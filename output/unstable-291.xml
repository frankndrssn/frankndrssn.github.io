<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1425</fr:anchor><fr:addr
type="machine">#291</fr:addr><fr:route>unstable-291.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>745</fr:anchor><fr:addr
type="machine">#289</fr:addr><fr:route>unstable-289.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a cartesian category with images that commute with pullbacks.
      Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be a morphism and <fr:tex
display="inline"><![CDATA[g\colon B'\twoheadrightarrow B]]></fr:tex> be a cover.
      Then note that <fr:tex
display="inline"><![CDATA[\mathsf {Img}(g)]]></fr:tex> is an isomorphism.
      Since images commute with pullbacks by hypothesis, we can form the following diagram.</fr:p>
    
      
      <fr:figure><fr:resource
hash="fe831617b13b46498327edb3e5b9e92b"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIxMC4zODc1MjdwdCcgaGVpZ2h0PSc5Ny45OTk5NXB0JyB2aWV3Qm94PSctNzIgLTcyIDE0MC4yNTgzNTEgNjUuMzMzMyc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJRQUFvQUFBQUFCT1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZRjFRR050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFHU0FBQUJ2R0UwYno5b1pXRmtBQUFDK0FBQUFDOEFBQUEyS0kvQ1NHaG9aV0VBQUFNb0FBQUFIZ0FBQUNRR0xRSlBhRzEwZUFBQUEwZ0FBQUFNQUFBQURBamRBT0JzYjJOaEFBQURWQUFBQUFnQUFBQUlBSElBM20xaGVIQUFBQU5jQUFBQUdBQUFBQ0FBQmdCS2JtRnRaUUFBQTNRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRVJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbStzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWTBoblp2Z1A1RE5EcEpIVS9BY0tBd0FHaEEyeGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOER5YlQvLy8vUEJ2TVpBRld4QnNONDJpV1BRVzdUUUJpRjU4MjQ0OFNKUFhac2o5MlFoR2JjMkUyVnhGSGMyaXBVTmxCVlJEUkliWGRJQ0tsQ3NDaXc3SW8xRzFoMHg1cGJ3QVY2QWc3QklaQmFZcXIvTFg3cGZZdjNFWkRQZDFONlEzK1RKU0ZnQWx5M29QTTRLWkhKd09PNmZJZ1NSVjRoTHlJZTcrL2xRVmIvLzA4R0ZxSTRpZk1pVHFGMExwRGwwdE81amo4SFp0UHBkcDVPMVV1R3NiL0xQRjlZYm45N3crbjBuTllyMC9YRUc0dHJZY09Nem5aZXJCRzV5OUFlMk1MdEJrWTcvR1I2RGFiaDIrM1BVaDJPdXhtRm1pbkZFbWRvNktBMDk2dkxINWVQd0UydmlkUGgxcDd0cEJxMkp6WENFNnRCRWRyVk5maG1pNEVRUXNtN3V3bjlpaHN5STBlMTVYbzFUMUU3THFSLzd5aExXbUZ0UGtOeUw3ZVFRVjRNNE90RlhxUHJ5b0kvUUZIV29WOCtldGNmMHYxV3BtRzBrSVpOMVRTb25vYzg3S3dXSis4cE8zWTZweGZxeWFhalhQZjdGTDRXSEk2WHN0K2pCMXM3eDMycmlhdmIxY21TTmxrNzdZKzZvdEVUR3hRdzV2UGVoVDJpZUgzK2R1V0taK3lCU2dEZit2dkxpTGpTTUkvU3ErSGpDWkQwaFNEL0FOZGZQUmdBQUhqYVkyQmtZR0FBNGthVEIrbngvRFpmR1poWkdFRGdzWkQ5TWdUOVg0YzVoT2t5a012QndBUVNCUUFXR2dtNkFIamFZMkJrWUdCbStNOEFKRU1ZVXY5L1p6cktBQlJCQWN3QWFTWUVnUUFBQTFRQUFBSzhBSHNDelFCbEFBQUFBQUJ5QU41NDJtTmdaR0JnWUdid1pHQmlBQUZHQmpRQUFBZndBRkY0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBL1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBtbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDOEFBQUEwRThPekgxb1pXRmtBQUFDSUFBQUFDMEFBQUEyS0kzQ1NXaG9aV0VBQUFKUUFBQUFIZ0FBQUNRRkxBSzRhRzEwZUFBQUFuQUFBQUFLQUFBQUNnWGZBSnBzYjJOaEFBQUNmQUFBQUFnQUFBQUlBRFlBYUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBZ2JtRnRaUUFBQXB3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBZElsRE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaSmoxbjRIeE9ETURneHdEQXlNZkl6dWJ1QmdZaXJBcHFlc3hxcXVwbTVuYk1acWJHWW1Kc2pFZUNXcGxaVmJpNE5LdDRHQmtrM0pVOUZLd1pXR3hWZkJTZEpSaVkyUjZidloxVDJ5bGhIaFZLZ3NYQzVlSmJKUnR3WW9WaGJhUnNpWmNMSndNUU1ESWtBeTBhd0xRTG1rZ2g0MGRaSnVhUHFNSjJBSWhOWFUxSUVOY2psRmNqSEVDMUZSbUpsYjFjRFZUeHJSaWRtWm1pSVdNREJBekdWazVPRmhrazhPYUdLVit4M0p6c3pLQ0xRUUFFYU1qajNqYVkyQmtZR0FBNHYyeWllM3gvRFpmR1poWkdFRGdzWkQ5TWdUOW40RTVpQm5FNVdCZ0FsRUFBUXdJZ2dBQUFIamFZMkJrWUdCbStNOEFKSU1Za2htU0dZOHpBRVZRQUJNQVJza0M2Z0FBQTFJQUFBSXFBSm9BWXdBQUFBQUFBQUEyQUdoNDJtTmdaR0JnWUdhUVp3RFJERkFTQ1FBQUE3OEFKZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBBQUFvQUFBQUFCRXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBtMk50WVhBQUFBRTRBQUFBTWdBQUFEd0FaQUJ5WjJ4NVpnQUFBV3dBQUFENEFBQUJHSkpCcDdWb1pXRmtBQUFDWkFBQUFDMEFBQUEyS0hQQ1NtaG9aV0VBQUFLVUFBQUFIZ0FBQUNRR2dnTFFhRzEwZUFBQUFyUUFBQUFRQUFBQUVBbm5BUVZzYjJOaEFBQUN4QUFBQUFvQUFBQUtBTHdBWUcxaGVIQUFBQUxRQUFBQUdBQUFBQ0FBQndBY2JtRnRaUUFBQXVnQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRHRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXFtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTU5neU0vd0g4cGtoMGtocS9nT0ZBYzJDRE00QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS2FqTFkvdjhQNUd1QTZQODMveDhEcXdJQ0FJeXpDTkFBQUhqYVkyQmtLUG5QeU5qQXpNQWd4Y0RBS0M0bXdzN0d6OGpHemlZR1pQSXpxcWtEb2JtYVBhTVpZdzR2Tzd1akZic2xNMk5ZR2hjN2I2c3BIN2NxRTVNdW54a3pBeU9UQUp0SmprRGhzZDZmc1p3Q1RJeEp0WW9LdGNsRnphcE5RQ01aUElEbWgwRE1Gd2FhS2k3R0xzTEd6c2VvWm01aXoyakhhSzdIcUs1bWFtWWUwMklHTWxCVHlTeFBtcEdaUHlTR2tiblFqWk9SalprQllsclVRb2ZFWkNZdVpoWkJuL2NManp5MTRtTGpaR0lBQWlZR1Q0WXlaZ3ZHYmdadUJuR2dkWXBzYWlabTRvcG1Za0JMa05qTVFuOWplU1VsZVppVzhnREp2OUZBa3BkcE1WQ0VNWUtSUTRXREVVUThnTE1ZR0FBTk1Dd1JlTnBqWUdSZ1lBQmlqZXpsN2ZIOE5sOFptRmtZUU9DeGtQMHlCUDJma2RtQ0djVGxZR0FDVVFEK1ZnaG1BQUFBZU5wallHUmdZR2I0endBa214ZzhHRHlaTFJpQUlpaUFCUUE4ZHdKYUFBQUMwd0FBQWNrQWRBSEpBRWdEZ2dCSkFBQUFBQUF3QUdBQWpBQUFlTnBqWUdSZ1lHQmhrR1pnWWdBQlJnWTBBQUFEalFBa2VObzlqREdyd2pBVWhiOWlGZTBiSEFTSE4wandCNFJLSDdpNE9UaTVPcnpObWlBZG1rcGFpeTdpVC9jMkJHL2c4TjF6emcyUThTSmhtSVI1MEdGU2VmUElZMzVZUko2SXY0cWM4Y3VhRVVrNkUyZkZMbkxLbFAvSVk1YVVrU2ZpUHlKbi9QSGVOL1h0M2xtdmpvMngzbDFxdnoxWjMxYU5VeHVkRCt2Qk91dlBuVFdxZkNyVFYyMS9yVldoYzEyd3A2SG14cDBPaTBkeEZNY0VkbHdrODJ3NWhiMmxrc3hKWjRNbS82WUhTVjFvbk1NdlJob2xUMUZETHpldDZGVzZpaUxjYVlvUFdLd3VTd0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQzBBQUFBMktZL0NKV2hvWldFQUFBSkFBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbUFBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDYUFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKd0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGkyb04zWDhiejIzeGxZR1poQUlISFF2YkxrR21XVU1ZN1FJcURnUW5FQXdBeGF3bWhBQUFBZU5wallHUmdZTmI2WThuQXdCTEswTWZRejVUTUFCUkJBVXdBVW9BRFFnQUVWUUFBQXZJQWpnQUFBQUFBVkFBQWVOcGpZR1JnWUdCaU1HVUEwUXhRRWdrQUFBWEtBRHNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXOTBuR050WVhBQUFBRTRBQUFBTXdBQUFFUUFld0VnWjJ4NVpnQUFBV3dBQUFGTUFBQUJqUE53SkpOb1pXRmtBQUFDdUFBQUFDOEFBQUEyS0VmQ1AyaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR053SjFhRzEwZUFBQUF3Z0FBQUFRQUFBQUVBajlBTlpzYjJOaEFBQURHQUFBQUFvQUFBQUtBTlFBaUcxaGVIQUFBQU1rQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQXp3QUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TXVReWMvOEg4cG01R2RIVS9BY0tBd0REN3d6N2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VROEdkSVpjdi8vUjdEKzcvZy8rLzgwc0Zvd0FBRHNod3VWQUhqYVZWRExUc0pRRUoyWlcxb2dXQVNsRmR0VWFXTUxpQkI1dE1CVkVoY1NJeXBxNGtJa1NHVGpqeGcrRFJNU0VxSWY0dGFGNE1XTm1rbE96bU5tY1FZUVJnQXdwUWt3Z0kyRWs1ZyswK1NySVRRSXgxcVdLSTd2VUFJT0hRRFVQVWRXZEMybG9pSjdzbUpoVVBGMVRZeUt0dXU1ZmxCRXp3L2NXZ3NEWDI4aDAxYU80NjQyZFhFcDZ4YVdSZTZKSVJhcmNsT1NUSHk2MkcrRUdCWGlqOFpSM3ExS05KNk5HUm81SllGUzJxSGhaYkZ4L0xDME9XRXQ3d2owZTZQbW1zcG84RElncVJCZkwrSzhMU0VMNXc1UGgwUzd0T01taUNKaHpicmkzUzdmNU5zUnoyb2FCM1dSTWx1TExqNnd5Q3ZWSDNobHBxbGtzdGxNVmcyUkxDb0R3cDBvSHNNMzJCTkMvTU12b2V1cHFLZiswVXJLRjExRXhjQkNGcjFucXBRODQyWDhKYmZ0M25sVFR0NmM5RG1XRm5QTXB1MlF6VmkvOXZtWHpqclh4T3BiaGs5c0NOL3JyRDNyZU5wallHUmdZQUJpWStkeTMzaCttNjhNekN3TUlQQll5SDRaZ3Y2dno4ekRkQnpJNVdCZ0Fva0NBUEJCQ0tjQWVOcGpZR1JnWU9iK3p3QWs0eG5rR0FTWmVSaUFJaWlBQlFBdXZ3RzBBQUFDVUFBQUFTNEFZd0lnQUI0RFh3QlZBQUFBQUFBT0FJZ0F4Z0FBZU5wallHUmdZR0JoOEdGZ1pnQUJSZ1kwQUFBSWJRQldlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVWUFBb0FBQUFBQmZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0TldOdFlYQUFBQUU4QUFBQU1nQUFBRHdIVGYxYVoyeDVaZ0FBQVhBQUFBSklBQUFDdVBPMnY1Tm9aV0ZrQUFBRHVBQUFBQzhBQUFBMktBSENSMmhvWldFQUFBUG9BQUFBSUFBQUFDUUZ2Z0diYUcxMGVBQUFCQWdBQUFBUUFBQUFFQW44QUtkc2IyTmhBQUFFR0FBQUFBb0FBQUFLQWNJQTFHMWhlSEFBQUFRa0FBQUFHQUFBQUNBQUJ3QllibUZ0WlFBQUJEd0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1WOWtadmdQNURNek1JS0VHUkVxL2dPRkFRSGZEaWtBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZelgvei9IOGhQQTlIL1ovOHhBcXNDQWdDbFV3bWxBQUI0MmtXUndXN1RRQlJGL1dhY21TUk9QSFpzajF2SGRaTTR0b09VSm0zaU9GSXdTWndBYWlpMFJVS3RDaWdWU04yd1FKVVFFdUlqUUVJczJQSVo3UHNEZkV3WGJGckdGUkx6ZG5QZmsrNjVWd0xwNExhUDNxSGYwbHlTQURNZ1ZBWGFDcU1wRExuTkNlWGJNSVVaOWttWTJNTXBqTVgvZ05zcStHRVVKdU93RHlwaU1FdzRpZURuUkpNMXA1VHRkU1lBYlN2RXdMWVpZKzBtM3VxeHB4NHkySE5tcVh6aDMwc0JmQzUweldPc1Z2UEtSZWM4bCtIN3pkVVRmUjZiU3h6NlhnTzFTYVNVRU1nSDFvL3JVOXlpY0hwV2o4S2cvVitDelhEbmk5d3FnaVFla3JxM095aUFLNmtuTFhNYVFVTHVTSVJqazFDYkQza2lBR1lDc2dkUk1zN0hBMXRRaVFVOGd5UVNVSVRtRVhCN2tLK2k1bVhwdzZmK1doWitkUTVxemRXYlp1cTduTnJqVlhhR2NNYjAxVmxuVk1WT3JXckJ0ejRHMDRxZFpjUFNkQWdqYitGV0tIeSt5Zm92TWJLNlcwM0RVTHh5QVlIaWJ1NDJYZzlsT0QyK09EVFlRd3h0cm5IUTlKcy92NWdTK0RKMFJtRTJQeHBEMEdEVk83YmQyMnYwVmZTMGtrNEVtODFOR3VWV1NZNll6SEF5aXNOSUFLdlFoeDdrM25NMGsyRmlrWDh3ZVZ0NUhHTlJyTTJwS0ZjRWNIY2tTdWJvcEdWWGgvWEpSdjNSU1hxT29Hd3dpcGpodFpRQ0xTc0VPS3RFWG5jR01xTjJBVFVTLzBIVGJWZW1hWEZTUUc4WGp6MWE0QUJrdllHaEhneWVJWG5QaWVHU29nMjVlUEVtOEk1bGlQZDkvK2orVmttMVhJQjV6MVFBSVczcDhnWkEzQzNyMmViYU1ad1JtdDRmZkl5MWdIUU9WKyt4bkZiVVJWcmFEMTY4R2h3aXZFNnpwdWFJT1A0QzByVmN1SGphWTJCa1lHQUFZczk5VnVMeC9EWmZHWmhaR0VEZ3NaRDlNZ1Q5WDVmcEdOTkZJSmVEZ1Fra0NnQUFDUW1HQUhqYVkyQmtZR0JtK00vQXdNQjBqRUhuL3dXbWZnYWdDQXBnQVFCbjJ3UmRBc1lBQUFJNkFFc0NPZ0FzQXNJQU1BQUFBQUFBWmdEVUFWd0FBSGphWTJCa1lHQmdZUWhuWUdJQUFVWUdOQUFBQ1drQVlIamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b0NDeGRXRmdZbVhxQXRoRkdXd2pKMFJDcWpyMmQvZGhQUFFOVitkKzJFRE5Ed1gzSzVnbHZWOUpKZTdCRlZQbW1TZmkzakxYTEhqbmlhSjhsdVNWajh5bE5KK1pLMTc0eWp5Ui9EdHp6WXJmVFhDWDYyQ2oyZ1Zqb3o4NTE2MzNOdlpkOEdxcG0rUzMxdHQ0R0t4Ung1c3lZOWVQWjZkYTNlaVdEUUhIaFNzRGxvaGlKNGxKN0RsSjUraFlzMDlKTHh3a1Z5elJOUC82cmZRK2JRN3BKeU9iSXpkUnd5aUxYdlFzVzBXYlhtcmFQOHVoTC9jQUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU4wQUFvQUFBQUFBK0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRTBBQUFCZ3FvWmlPV050WVhBQUFBRkVBQUFBTXdBQUFEeWVOV1NsWjJ4NVpnQUFBWGdBQUFDb0FBQUFzTkZjOEl0b1pXRmtBQUFDSUFBQUFDd0FBQUEyS012Q2hXaG9aV0VBQUFKTUFBQUFIZ0FBQUNRR2x2L2thRzEwZUFBQUFtd0FBQUFNQUFBQURBaHpBSUJzYjJOaEFBQUNlQUFBQUFnQUFBQUlBRGdBV0cxaGVIQUFBQUtBQUFBQUZ3QUFBQ0FBQlFBamJtRnRaUUFBQXBnQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBRGFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzZzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUFCQmdZSEdEdWx1Q3lkZ1UzSjVvRUJzK0lmSXdZR1prWG1jMEJoUm9UcS8vOFpHQUExM3crL0FBQUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVptUmdVcko1WVBEL1B3TURoTDU3VlA0U1dCVVFBQUNzQkFuWEFIamFZMkJrOEdjb1ozWm03R1JRWkdCZzVHTmsxMk5XQjVJaWJPeHNhdXAyak9aeXpPSkEwc1RNM0V3TXFDbzF3am94SU16Y3c1K1pqWWVabDVFeEpjSW1JU2pNMUNPQW1ZMmJtWTh4SWJLSGhjbmUzNXFSSmNtYVI1YVJrVmNHU1lCYkRpakF3TWhneUtET2FNSmt3OEFIdEkrWlRZOVIzVndZWkEranVCaWo1a0YyQVRrbTFuWVdDVmtKWlVZbXhzZi9Ja1NZZWJrRUdIZnpLVEl5eWtseU1BQUFZL0VZbUhqYVkyQmtZR0FBNGx1MlhySHgvRFpmR1poWkdFRGdzWkQ5TW1TYWVTS1REWkRpWUdBQzhRRDJRQWYzZU5wallHUmdZRmI4WXdRa0p6SVlNc2d5T3pNQVJWQUFNd0JDWUFLQUFBQURrUUFBQTVFQVR3RlJBREVBQUFBQUFEZ0FXSGphWTJCa1lHQmdabEJpQU5FTVVCSUpBQUFFQ2dBcEFIamFUWXc5YjhJd0VJYWZpQVNKZE9oU2RlZ0FIcGl0b0ZSaVkyRmdZbVhxQXRpZ0RIR1FIU0pGcWpyeXUzdTRIbnJENlhrLzdvQ1NIektlay9FYTkzTnlDbEYvWFBEQ1crS3BxRVhpa2crV1RNanltVGh6Tm9selNiNFNGN3h6U1R3Vi96dHh5U2VQYmRmZTdyMzFhdDhaNjkyNURlUDZZSDFvT3FkV3VvcDZaNTMxeDk0YWRScVZHWm93WEZ0VjYwclhiT2xvdVhHbngrSlI3TVV4a1IxbnlRSWphdzdSQ1RTU09tbXQwRlQvOHAza0xuYU84Wk9SemtrU0pUVElWWkI5bGJhaWpwZWEraGZ6ZVRCUEFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwNFdOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDVVoyeDVaZ0FBQVdRQUFBQ29BQUFBcUwvc0RlVm9aV0ZrQUFBQ0RBQUFBQzhBQUFBMktCekRKV2hvWldFQUFBSThBQUFBSFFBQUFDUUdCd0lpYUcxMGVBQUFBbHdBQUFBSUFBQUFDQVYyQUNSc2IyTmhBQUFDWkFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKc0FBQUFGZ0FBQUNBQUJRQTBibUZ0WlFBQUFvUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm0yczA0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmtadmdQNURORHBKSFUvQWNLQXdEbzl3MHRlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aU8vLzlEeVA4SHdId0dBRktYQnAwQUFBQUFBZ0FrLy84QzRRTGRBQzhBTWdBQU53RTJOeklXRnhNVUZqTTJGZ1l2QVFjbkppYzBOaGNXTmpjdkFTRUhCaFFXRnpZWERnRXZBUWNtSnpRMk16NEJOek1EdHdGbEJoUU5CZ0UrRmkwVkFRd0ZkSUFJQlFFTkN4TTBBd2tIL3Y5T0RSd1REUU1CRFFWbldBd0JEQWtpUHBucklYWUNWaEFCQ1EvOWdCWVBBeDBIQVFNREFRSUlEd2NCQVF3WFprV0VGQ1FRQVFJUERnWUJBd01CQ2c4R0FTUElBVklBQUFCNDJtTmdaR0JnQU9LR2h4TDE4ZncyWHhtWVdSaEE0TEdRL1RJRS9mOC8wME9tdTBBdUJ3TVRTQlFBS2VNTEh3QjQybU5nWkdCZ1p2alBBQ0laVkJqa21SNHlBRVZRQUJNQU5Zd0NNQUFBQUFKMkFBQURBQUFrQUFBQUFBQlVBQUI0Mm1OZ1pHQmdZR0l3Qm1JUVlHUkFBd0FGcndBNkFBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi41NzcwMTIsLTU5LjE3NTg3MilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjE1Mjc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTU5LjE3NTg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctNTkuMTc1ODcyJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01NS4xMDUwMTMnIHk9Jy02Mi43OTEyMzYnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzNi40ODgzLC00Mi43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC01OS4xNzU4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTU5LjE3NTg3Mic+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3NS4zMjM4LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTU5LjE3NTg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctNTkuMTc1ODcyJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01NS4xMDUwMTMnIHk9Jy02Mi43OTEyMzYnPu6AsDwvdGV4dD4KPHJlY3QgeD0nLTYyLjU3NzAxMicgeT0nLTU3Ljk4MDQxOScgaGVpZ2h0PScuMzk4NDg0JyB3aWR0aD0nMTAuMjY3MDcxJy8+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTE0LjQwOTMzLC00Mi43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC01OS4xNzU4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTU5LjE3NTg3Mic+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTUuMTA1MDEzJyB5PSctNjIuNzkxMjM2Jz7ugLDugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTYuNDA5NDItNi40MDk3M0wzMS42NDUzNi0zMS42NDE3NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE0LC0wLjcwNzAzLDAuNzA3MDMsMC43MDcxNCwzMS44MjIxNCwtMzEuODE4NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuMzI2ODcsLTI3LjM1ODQ0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC01OS4xNzU4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTU5LjE3NTg3Mic+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTcuOTEwNDI4JyB5PSctNjIuMTgyMzg5Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTUzLjc0NTQ1OScgeT0nLTU5LjE3NTg3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTAuNjMyMTE2JyB5PSctNTkuMTc1ODcyJz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy00Ni40OTUxNjUnIHk9Jy01OS4xNzU4NzInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg2Ni45OTYxNCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2Ni44NzExNCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyOC45Mjg3Nyw1LjQ0OTMxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC01OS4xNzU4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTU5LjE3NTg3Mic+z5E8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTU3Ljc2NjA3MScgeT0nLTU3Ljc5MzU1OSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTMuNzcwNjAxJyB5PSctNTkuMjYwMjg3Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTQ5LjYwNTYzMicgeT0nLTU3Ljc5MzU1OSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDYuOTA3Mzc3JyB5PSctNTcuNzkzNTU5Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy00My4yMzg4MicgeT0nLTU3Ljc5MzU1OSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNzAuNTExNjYtOS45NjUwN0w0OC44MzEyNS0zMS42NDE3NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE1LDAuNzA3MDMsLTAuNzA3MDMsMC43MDcxNSw3MC4zMzQ4NywtMTAuMTQxODMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjcwNzE1LC0wLjcwNzAzLDAuNzA3MDMsLTAuNzA3MTUsNDguNjU0NDYsLTMxLjgxODUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTTM4LjYxNjc0LTI2LjcwMjQySDgxLjkyODMyVi0xMy42MDgyN0gzOC42MTY3NFonIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQxLjYxNjc0LC0yMS45NTI0MiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNTkuMTc1ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02Mi41NzcwMTInIHk9Jy01OS4xNzU4NzInPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTAuODI2NjczJyB5PSctNTkuMTc1ODcyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny43MTMzMycgeT0nLTU5LjE3NTg3Mic+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDMuMDQ2NzQ2JyB5PSctNjIuMTgyMzg5Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM4Ljg4MTc3NicgeT0nLTU5LjE3NTg3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMzUuNzY4NDMzJyB5PSctNTkuMTc1ODcyJz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zMS42MzE0ODMnIHk9Jy01OS4xNzU4NzInPikpPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTg4Ljg4Njg0LTguNDA5NkwxMTEuNDM3NzMtMzAuOTU3MjMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNCwtMC43MDcwMywwLjcwNzAzLDAuNzA3MTQsMTExLjYxNDUyLC0zMS4xMzM5OSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNOTQuMjE0MDctMjUuMTEwMTdIMTA2LjQ2NDA3Vi0xNC4yMzMwN0g5NC4yMTQwN1onIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDk3LjIxNDA3LC0yMS42MTAxNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNTkuMTc1ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Mi41NzcwMTInIHk9Jy02MC44NTgxMTYnPuKIvDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNjIuNTIxNjYzJyB5PSctNTguNjc3NzQnPj08L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTA3LjY1MzgtNDAuMjM4M0g0OS4wNDM4NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDcuNDAzOCwtNDAuMjM4MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsNDguNzkzODQsLTQwLjIzODMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjU0MzAzLC00OC4zOTQyNiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNTkuMTc1ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy01OS4xNzU4NzInPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU3LjkxMDQyOCcgeT0nLTYyLjE4MjM4OSc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy01My43NDU0NTknIHk9Jy01OS4xNzU4NzInPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUwLjYzMjExNicgeT0nLTU5LjE3NTg3Mic+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zOC44ODE3NzYnIHk9Jy01OS4xNzU4NzInPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM1Ljc2ODQzMycgeT0nLTU5LjE3NTg3Mic+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzEuNjMxNDgzJyB5PSctNTkuMTc1ODcyJz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \node  (1) {$A'$};
        \node  [below right = of 1] (3) {$A$};
        \node  [above right = of 3] (2) {$\underline {A'}$};
        \node  [below right = of 2] (4) {$A''$};
        \draw  [->,morphism] (1) to node[swap] {$f^{*}(g)$} (3);
        \draw  [cover,morphism] (1) to node {$\vartheta _{f^{*}(g)}$} (2);
        \draw  [>->,morphism] (2) to node[desc] {$\mathsf {Img}(f^{*}(g))$} (3);
        \draw  [->,morphism] (2) to node[desc] {$\cong $} (4);
        \draw  [>->,morphism] (4) to node {$f^{*}(\mathsf {Img}(g))$} (3);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Since isomorphisms are stable under pullback, <fr:tex
display="inline"><![CDATA[f^{*}(\mathsf {Img}(g))]]></fr:tex> is also an isomorphism.
      Thus, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f^{*}(g))]]></fr:tex> is an isomorphism.
      Then since <fr:tex
display="inline"><![CDATA[f^{*}(g)]]></fr:tex> is the composite of two covers, it is itself a cover.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>746</fr:anchor><fr:addr
type="machine">#290</fr:addr><fr:route>unstable-290.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is regular, then by <fr:ref
addr="ct-000N"
href="ct-000N.xml"
taxon="Lemma" />, the unit <fr:tex
display="inline"><![CDATA[\vartheta \colon \mathsf {id}\to \mathsf {Img}]]></fr:tex> consists of <fr:link
type="local"
href="ct-000M.xml"
addr="ct-000M"
title="Extremal epimorphism">covers</fr:link>.
      Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be any morphism in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g\colon B'\to B]]></fr:tex> be an object in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>.
      By <fr:ref
addr="ct-000Q"
href="ct-000Q.xml"
taxon="Lemma" />, <fr:tex
display="inline"><![CDATA[g]]></fr:tex> can be factored as <fr:tex
display="inline"><![CDATA[\vartheta _{g}\mathsf {Img}(g)]]></fr:tex>.
      Form the following pullbacks.
      Note that since covers are stable under pullback by hypothesis, <fr:tex
display="inline"><![CDATA[\widehat {\vartheta _{g}}]]></fr:tex> is also a cover.
      Then by the <fr:link
type="local"
href="ct-0008.xml"
addr="ct-0008"
title="Pasting lemma of pullbacks">pasting lemma</fr:link>, the composite <fr:tex
display="inline"><![CDATA[f^{*}(\mathsf {Img}(g)) \circ  \widehat {\vartheta _{g}}]]></fr:tex> is isomorphic to <fr:tex
display="inline"><![CDATA[f^{*}(g)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="da7334f99682b52474eec73093f5ecbf"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMS4wMzI5OTZwdCcgaGVpZ2h0PScxMjUuMTE0MDkycHQnIHZpZXdCb3g9Jy03MiAtNzIgMTM0LjAyMTk5OCA4My40MDkzOTUnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtZXg3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFMb0FBb0FBQUFBQTB3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdjR0JhNkdOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DMloyeDVaZ0FBQVd3QUFBQW9BQUFBS0xUdGE1Wm9aV0ZrQUFBQmxBQUFBQ3dBQUFBMktiekRVV2hvWldFQUFBSEFBQUFBSHdBQUFDUUhvL2pOYUcxMGVBQUFBZUFBQUFBSUFBQUFDQWExQUF4c2IyTmhBQUFCNkFBQUFBWUFBQUFHQUJRQUFHMWhlSEFBQUFId0FBQUFGd0FBQUNBQUJBQUhibUZ0WlFBQUFnZ0FBQURQQUFBQk9CRjlLb053YjNOMEFBQUMyQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1qbUtjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UxQjhvTmtacEV2Umd3TXpDTGM1NERDakFnVi8vOHpNQUFBSHVJUUJ3QjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytRK1MvLytIa1BMendQSU1BR2loQjU4QUFBQUJBQXdDUmdTQ0F4UUFCUUFBQVFVSEpRVW5Ba2NDT3dyOXovM05DQU1VcmlDTGl5QUFBQUI0Mm1OZ1pHQmdBT0xqN1hXVzhmdzJYeG1ZV1JoQTRMR1EvUUprbXFXSldRUkljVEF3Z1hnQS8wY0gvWGphWTJCa1lHQVcrV0xFd01EU3k4RER3TTNTeEFBVVFRRk1BRCtHQW5BQUFpZ0FBQVNOQUF3QUFBQUFBQlFBQUhqYVkyQmtZR0JnWW1CakFORU1VQklKQUFBQk13QU1BSGphVFl3OWI4SXdFSWFmcUFsUzA2RkwxYUVEOWREWkNrb2xOaFlHSmxZbUZzQlhsQ0VPY2tJRUV1clkzOTNEOWRBYnpzLzdjUVpLdnNtNFQ4WnozUGZKS1ZUOWNjRVRMNGtucXQ0VGw3enh3UU5aL3FqT2xFWGlYSk50NG9KWHZoSlAxTDhsTHZua1o5bTFwL01nd2F3N0o4RWZXcm5NTnhMNnB2Tm1acXVvVitJbDdBWnhabjgxYm16NjhkaWEybGEyWmtsSHk0a3pBMExBc0ZiSFJmWWNOQk11ek5sRXA2ZlIxR3RyaHFYNmw2LzA5Ykd6aXo4NTdleTU2bmFNZXRYclBtcmJVTWRMUy8wTDJCTXdFd0I0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzODtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUVlBQW9BQUFBQUJNd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFc5MG5HTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWV3RWdaMng1WmdBQUFXd0FBQUZNQUFBQmpQTndKSk5vWldGa0FBQUN1QUFBQUM4QUFBQTJLRWZDTTJob1pXRUFBQUxvQUFBQUhnQUFBQ1FHTndKMWFHMTBlQUFBQXdnQUFBQVFBQUFBRUFqOUFOWnNiMk5oQUFBREdBQUFBQW9BQUFBS0FOUUFpRzFoZUhBQUFBTWtBQUFBR0FBQUFDQUFDQUJOYm1GdFpRQUFBendBQUFET0FBQUJPQWQxS3Ixd2IzTjBBQUFFREFBQUFBd0FBQUFnQUFNQUFIamFZMkJtc21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcDZNdVF5Yy84SDhwbTVHZEhVL0FjS0F3REQ3d3o3ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVE4R2RJWmN2Ly9SN0QrNy9nLysvODBzRm93QUFEc2h3dVZBSGphVlZETFRzSlFFSjJaVzFvZ1dBU2xGZHRVYVdNTGlCQjV0TUJWRWhjU0l5cHE0a0lrU0dUamp4ZytEUk1TRXFJZjR0YUY0TVdObWtsT3ptTm1jUVlRUmdBd3BRa3dnSTJFazVnKzArU3JJVFFJeDFxV0tJN3ZVQUlPSFFEVVBVZFdkQzJsb2lKN3NtSmhVUEYxVFl5S3R1dTVmbEJFencvY1dnc0RYMjhoMDFhTzQ2NDJkWEVwNnhhV1JlNkpJUmFyY2xPU1RIeTYyRytFR0JYaWo4WlIzcTFLTko2TkdSbzVKWUZTMnFIaFpiRngvTEMwT1dFdDd3ajBlNlBtbXNwbzhESWdxUkJmTCtLOExTRUw1dzVQaDBTN3RPTW1pQ0poemJyaTNTN2Y1TnNSejJvYUIzV1JNbHVMTGo2d3lDdlZIM2hscHFsa3N0bE1WZzJSTENvRHdwMG9Ic00zMkJOQy9NTXZvZXVwcUtmKzBVcktGMTFFeGNCQ0ZyMW5xcFE4NDJYOEpiZnQzbmxUVHQ2YzlEbVdGblBNcHUyUXpWaS85dm1YempyWHhPcGJoazlzQ04vcnJEM3JlTnBqWUdSZ1lBQmlZK2Z5MUhoK202OE16Q3dNSVBCWXlINEJndjZ2ejh6RGRCekk1V0JnQW9rQ0FQTTFDTE1BZU5wallHUmdZT2IrendBazR4bmtHQVNaZVJpQUlpaUFCUUF1dndHMEFBQUNVQUFBQVM0QVl3SWdBQjREWHdCVkFBQUFBQUFPQUlnQXhnQUFlTnBqWUdSZ1lHQmg4R0ZnWmdBQlJnWTBBQUFJYlFCV2VOcE5qRDF2d2pBUWhwK29DVkxEd0lJNk1MUWVPbHRCWVdCaVlXQmlaV0lCN0tJTWNaQWRJaUZWSGZuZFBZd0h6dExwZVQvT1FNa2ZHWS9KbU1UOW1KeEMxSk1MeGt3VGowUjlKUzZaOGMwYldmNHV6aWVyeExrays4UUZIL3drSG9uL203aGt3WDNkdFpkcmI3M2Fkc1o2ZDJwRFdPNnNEMDNuMUZ4WFVXK3NzLzdRVzZPT04yV0dKZ3puVnRXNjBqVnJPbG91WE9teGVCUmJjVXhreDBteUlHL0pManFCUmxJbnJUbWE2aVhmU081aTV4Qi9NdEk1Y3BOdEdPUXF5RDVMVzFISFMwMzlEK3B0TURzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVZQUFvQUFBQUFCZkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjROV050WVhBQUFBRThBQUFBTWdBQUFEd0hUZjFhWjJ4NVpnQUFBWEFBQUFKSUFBQUN1UE8ydjVOb1pXRmtBQUFEdUFBQUFDOEFBQUEyS0FIQ08yaG9aV0VBQUFQb0FBQUFJQUFBQUNRRnZnR2JhRzEwZUFBQUJBZ0FBQUFRQUFBQUVBbjhBS2RzYjJOaEFBQUVHQUFBQUFvQUFBQUtBY0lBMUcxaGVIQUFBQVFrQUFBQUdBQUFBQ0FBQndCWWJtRnRaUUFBQkR3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRkRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXFtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVY5a1p2Z1A1RE16TUlLRUdSRXEvZ09GQVFIZkRpa0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5cVl6WC96L0g4aFBBOUgvWi84eEFxc0NBZ0NsVXdtbEFBQjQya1dSd1c3VFFCUkYvV2FjbVNST1BIWnNqMXZIZFpNNHRvT1VKbTNpT0ZJd1Nad0FhaWkwUlVLdENpZ1ZTTjJ3UUpVUUV1SWpRRUlzMlBJWjdQc0RmRXdYYkZyR0ZSTHpkblBmays2NVZ3THA0TGFQM3FIZjBseVNBRE1nVkFYYUNxTXBETG5OQ2VYYk1JVVo5a21ZMk1NcGpNWC9nTnNxK0dFVUp1T3dEeXBpTUV3NGllRG5SSk0xcDVUdGRTWUFiU3ZFd0xZWlkrMG0zdXF4cHg0eTJITm1xWHpoMzBzQmZDNTB6V09zVnZQS1JlYzhsK0g3emRVVGZSNmJTeHo2WGdPMVNhU1VFTWdIMW8vclU5eWljSHBXajhLZy9WK0N6WERuaTl3cWdpUWVrcnEzT3lpQUs2a25MWE1hUVVMdVNJUmprMUNiRDNraUFHWUNzZ2RSTXM3SEExdFFpUVU4Z3lRU1VJVG1FWEI3a0sraTVtWHB3NmYrV2haK2RRNXF6ZFdiWnVxN25OcmpWWGFHY01iMDFWbG5WTVZPcldyQnR6NEcwNHFkWmNQU2RBZ2piK0ZXS0h5K3lmb3ZNYks2VzAzRFVMeHlBWUhpYnU0MlhnOWxPRDIrT0RUWVF3eHRybkhROUpzL3Y1Z1MrREowUm1FMlB4cEQwR0RWTzdiZDIydjBWZlMwa2s0RW04MU5HdVZXU1k2WXpIQXlpc05JQUt2UWh4N2szbk0wazJGaWtYOHdlVnQ1SEdOUnJNMnBLRmNFY0hja1N1Ym9wR1ZYaC9YSlJ2M1JTWHFPb0d3d2lwamh0WlFDTFNzRU9LdEVYbmNHTXFOMkFUVVMvMEhUYlZlbWFYRlNRRzhYanoxYTRBQmt2WUdoSGd5ZUlYblBpZUdTb2cyNWVQRW04STVsaVBkOS8raitWa20xWElCNXoxUUFJVzNwOGdaQTNDM3IyZWJhTVp3Um10NGZmSXkxZ0hRT1YrK3huRmJVUlZyYUQxNjhHaHdpdkU2enB1YUlPUDRDMHJWY3VIamFZMkJrWUdBQVlzOTlWdnJ4L0RaZkdaaFpHRURnc1pEOUFnVDlYNWZwR05ORklKZURnUWtrQ2dBQy9RbVNBSGphWTJCa1lHQm0rTS9Bd01CMGpFSG4vd1dtZmdhZ0NBcGdBUUJuMndSZEFzWUFBQUk2QUVzQ09nQXNBc0lBTUFBQUFBQUFaZ0RVQVZ3QUFIamFZMkJrWUdCZ1lRaG5ZR0lBQVVZR05BQUFDV2tBWUhqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLSS9CTG1ob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0o1Ui9PUHh2UGJmR1ZnWm1FQWdjZEM5Z3NROUg4ZDVoREdvMEF1QndNVFNCUUFMM0VLT2dCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQzBBQUFBMktZL0NHV2hvWldFQUFBSkFBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbUFBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDYUFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKd0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGkyb1AzR09QNWJiNHlNTE13Z01Caklmc0Z5RFJMS09NZElNWEJ3QVRpQVFBSml3aXVBQUFBZU5wallHUmdZTmI2WThuQXdCTEswTWZRejVUTUFCUkJBVXdBVW9BRFFnQUVWUUFBQXZJQWpnQUFBQUFBVkFBQWVOcGpZR1JnWUdCaU1HVUEwUXhRRWdrQUFBWEtBRHNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS012Q2VXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZHF6NGJ4dlBiZkdWZ1ptRUFnY2RDOWd1UWFlYUpURFpBaW9PQkNjUURBQmg2Q0xZQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzRBQUFBMktBN0NQbWhvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRoTXNDdWZqK1cyK01qQ3pNSURBWXlIN0JRajZQeVBUWldZUWw0T0JDVVFCQUFTckNPNEFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVrQUFvQUFBQUFCZlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDFGMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNYWjJ4NVpnQUFBV1FBQUFKWUFBQUN1SkhqY2Nsb1pXRmtBQUFEdkFBQUFDOEFBQUEyS0hMREEyaG9aV0VBQUFQc0FBQUFIZ0FBQUNRR1hnSWxhRzEwZUFBQUJBd0FBQUFVQUFBQUZBNm9BS3RzYjJOaEFBQUVJQUFBQUF3QUFBQU1BV0lDREcxaGVIQUFBQVFzQUFBQUdBQUFBQ0FBQ1FBNmJtRnRaUUFBQkVRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRkdBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaFp2Z1A1RE5EcEpIVS9BY0tBd0Q3MVExamVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZndS8vOERTY2YvLy84ZkFQTVpBRkxLQnFCNDJqWFJ2MDhUWVJ6SDhlZnpmTnZuYUdudktsZnVhcURYbEpZZVlGb0l2ZHdCaWNWUXFRaXgvS2hCZ28xRUV5U1NpRDlBWkdEb2dERWFHSXdKaVhGdzBNMDR1emc1TVRtNU9xaVQ4VTh3YlgyT2hPZFpubnh6dy92N09zWlp0dDNtUC9rUE5zeEdHZlBnZXFPR3FjZU5vbXVJWVNoMnpuWmMwM0M5WWFRVkVUZE0xMVFoNS82NFdJSlhwTTlZRi9Hb1FNbklkeU1TM0dsMEJCSHQxQjBLS2ExMk5kcXJSd25SNE1aS0JKRlFYK25OMy9RdVg0NGhwRFViaGtaSkJVVGdIWm9DUk15NzB3ZnhiQXhjVTRVL0Rtc0NtUk1zTVhtSVhXZzNTZkF2ekdKRGJFeVc2azdHRnJJdGJhRmJoV0xCRkJxRWtoYW52Ym9mNStic1RFNG9kUFltK1VIeHcxR1BuZFEwck5UdlVLTTJWd08vRXJ2MnBQVzZWMVVuckhmSGF6c2NoZkpCU2c5dUhkWjNPUitaK1ZvSkFPb0NIei9IcVZjQlg1eVkzZERDMWZHNUtiVVU4RGVBam1sNlhNbGU1dERPTnovUzAyci9BclYrZDRrd1kyREY5aC9xNU4vOVpwQ0tqQlNkaEpPelpiTWZiRnJ3Sks5Zm1JSWxGNUR6QW16WDg2OWhHcVluMTZId0pSTGhVQkFjeS9QVHowWXFQY0pBWVAvcXdKcnI1RVVncEFRcFh4bDhWTjU3UzFSelpyY1Bhb01EWWtaRmhKKzAvcW15V2RGeXE1dEFlV3hsTFZIUDc5N202QnNxMUJPZEFJL2NuK292Z280YkwzWm1uU1VLWlB2VmVaV1ROT2RzVUpwNzBqekI4cjY0ZXdadUNzVy9aOWFucnFhL3dpUmN1d0JGcXI4L1F0bUtTZWJ0ZmREODBOaG1vL1VwcVVuaVg0Yys1OHRiZStaRW9xTUwvRjUxSzZWTDNSaFJVdjcyVncrZVA3eVl2MDVrQ1FuTHk4MXYwaEdCaGRUaXpmUU5lMzBWMEdUYWYvUUJkMWQ0Mm1OZ1pHQmdBT0xqQWxhdDhmdzJYeG1ZV1JoQTRMR1EvUUlFL2Y4bHN6blRYU0NYZzRFSkpBb0FEZEFKOGdCNDJtTmdaR0JnWnZqUEFDVDlHVlQrWDJBMlp3Q0tvQUJXQUZVckE0a0FBQUoyQUFBREFBQWtBd2dBS3dMYkFETURUd0FwQUFBQUFBQlVBTEFCRGdGY2VOcGpZR1JnWUdCbHNHUmdaZ0FCUmdZMEFBQUdyUUJFZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbWV4Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNyB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy45MzEyNCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPkM8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuNDQ2MTgsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScyLjQ2NDgnIHk9Jy02MS4yMjYyNzMnPu6AsDwvdGV4dD4KPHJlY3QgeD0nLTUuNTkxODA4JyB5PSctNTYuNDE1NDU2JyBoZWlnaHQ9Jy4zOTg0ODQnIHdpZHRoPScxMC44NTE2NzEnLz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00Ny40Nzc5NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDcuNzI3OTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjI2Mzg5LC0yOC45NDM4MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1My4xNTU1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjY4Njc4IDBINDguMDk5OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTAuOTM2NzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4zNDk5NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDkuODg3NTcsNC41NjE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUuNTkxODA4JyB5PSctNTcuNjEwOTA5Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0uOTI1MjI0JyB5PSctNjAuNjE3NDI2Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nMy4yMzk3NDUnIHk9Jy01Ny42MTA5MDknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nNi4zNTMwODgnIHk9Jy01Ny42MTA5MDknPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PScxOC4xMDM0MjcnIHk9Jy01Ny42MTA5MDknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMjEuMjE2NzcnIHk9Jy01Ny42MTA5MDknPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nMjUuMzUzNzIxJyB5PSctNTcuNjEwOTA5Jz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTIuMjAxNzItNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMi40NTE3MiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMDU2NTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE4LjA1NTcxLC02NC45NjczMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUuNTkxODA4JyB5PSctNTcuNjEwOTA5Jz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nNi4xNTg1MzEnIHk9Jy01Ny42MTA5MDknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nOS4yNzE4NzQnIHk9Jy01Ny42MTA5MDknPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nMTMuNDA4ODI0JyB5PSctNTcuNjEwOTA5Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNTEuMjE1MDQtMTQuMjI2MzZILTQyLjY3OTE0Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02MS4xODM5OCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPkQ8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjM1MTY4LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMi40NjQ4JyB5PSctNjEuMjI2MjczJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00OC4wNzE0OSAwSC0xMi4yNTg5MScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTIuMzgzOTEsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMyLjc4NDc5LDQuNzg0MDMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01LjA3NDIxOCcgeT0nLTU5LjQ1MTIyMic+7oGjPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+z5E8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLS43ODA4NjcnIHk9Jy01Ni42MTQ2NDUnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS01Ni45MDU1LTYuNDA5NzNWLTQ3LjQ3Nzk1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsLTU2LjkwNTUsLTQ3LjcyNzk1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNLTQ2LjkwMzc4LTU2LjkwNTVILTEzLjc3Mzg1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMy44OTg4NSwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lam9pbj0nbWl0ZXInPgogPHBhdGggZD0nTTMuMzk3MTMgMEwuMjUgMS44NzQ5NFYwVi0xLjg3NDk0WicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMi45NTg0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUuNTkxODA4JyB5PSctNTcuNjEwOTA5Jz7PkTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctLjc4MDg2NycgeT0nLTU2LjYxNDY0NSc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \SpliceDiagramSquare {
          nw = C,
          ne = A,
          sw = \underline {B'},
          se = B,
          north = f^{*}(\mathsf {Img}(g)),
          east = f,
          south = \mathsf {Img}(g),
          north/style = {>->},
          south/style = {>->},
          nw/style = pullback,
        }
        \node  [left = of nw,pullback] (1) {$D$};
        \node  [left = of sw] (2) {$B'$};
        \draw  [cover,morphism] (1) to node {$\widehat {\vartheta _{g}}$} (nw);
        \draw  [->,morphism] (1) to (2);
        \draw  [cover,morphism] (2) to node[swap] {$\vartheta _{g}$} (sw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Thus, <fr:tex
display="inline"><![CDATA[f^{*}(g)]]></fr:tex> admits another cover-mono factorization.</fr:p>
    
      
      <fr:figure><fr:resource
hash="b9c08c521816bfce626332248a40053d"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIyNy4xODE0cHQnIGhlaWdodD0nMTUxLjY5NzQ4NHB0JyB2aWV3Qm94PSctNzIgLTcyIDE1MS40NTQyNjcgMTAxLjEzMTY1Nic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUEvUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMG1tTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM4QUFBQTBFOE96SDFvWldGa0FBQUNJQUFBQUMwQUFBQTJLSTNDYVdob1pXRUFBQUpRQUFBQUhnQUFBQ1FGTEFLNGFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dYZkFKcHNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEWUFhRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFnYm1GdFpRQUFBcHdBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNm1HY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFkSWxETTBBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pKajFuNEh4T0RNRGd4d0RBeU1mSXp1YnVCZ1lpckFwcWVzeHFxdXBtNW5iTVpxYkdZbUpzakVlQ1dwbFpWYmk0Tkt0NEdCa2szSlU5Rkt3WldHeFZmQlNkSlJpWTJSNmJ2WjFUMnlsaEhoVktnc1hDNWVKYkpSdHdZb1ZoYmFSc2laY0xKd01RTURJa0F5MGF3TFFMbWtnaDQwZFpKdWFQcU1KMkFJaE5YVTFJRU5jamxGY2pIRUMxRlJtSmxiMWNEVlR4clJpZG1abWlJV01EQkF6R1ZrNU9GaGtrOE9hR0tWK3gzSnpzektDTFFRQUVhTWpqM2phWTJCa1lHQUE0djJ5aWU3eC9EWmZHWmhaR0VEZ3NaRDlOZ1Q5bjRFNWlCbkU1V0JnQWxFQStSMElZZ0FBQUhqYVkyQmtZR0JtK004QUpJTVlraG1TR1k4ekFFVlFBQk1BUnNrQzZnQUFBMUlBQUFJcUFKb0FZd0FBQUFBQUFBQTJBR2g0Mm1OZ1pHQmdZR2FRWndEUkRGQVNDUUFBQTc4QUpnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVxZm01dURrNnZEMjZ3SjBxR3BwTFhvSXY1MGIwUHdCZzdmUGVmY0FCa3ZFb1pKbUFjZEpwVTNqenptaDBYa2lmaXJ5Qm0vckJtUnBETnhWdXdpcDB6NWp6eG1TUmw1SXY0amNzWWY3MzFUMys2ZDllcllHT3ZkcGZiYmsvVnQxVGkxMGZtd0hxeXovdHhabzhxbk1uM1Y5dGRhRlRyWEJYc2FhbTdjNmJCNEZFZHhUR0RIUlRMUGxsUFlXeXJKbkhRMmFQSnZlcERVaGNZNS9HS2tVZklVTmZSeTA0cGVwYXNvd3AybStBQlZNaTVEQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJRQUFvQUFBQUFCT1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZRjFRR050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFHU0FBQUJ2R0UwYno5b1pXRmtBQUFDK0FBQUFDOEFBQUEyS0kvQ2FHaG9aV0VBQUFNb0FBQUFIZ0FBQUNRR0xRSlBhRzEwZUFBQUEwZ0FBQUFNQUFBQURBamRBT0JzYjJOaEFBQURWQUFBQUFnQUFBQUlBSElBM20xaGVIQUFBQU5jQUFBQUdBQUFBQ0FBQmdCS2JtRnRaUUFBQTNRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRVJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbStzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWTBoblp2Z1A1RE5EcEpIVS9BY0tBd0FHaEEyeGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOER5YlQvLy8vUEJ2TVpBRld4QnNONDJpV1BRVzdUUUJpRjU4MjQ0OFNKUFhac2o5MlFoR2JjMkUyVnhGSGMyaXBVTmxCVlJEUkliWGRJQ0tsQ3NDaXc3SW8xRzFoMHg1cGJ3QVY2QWc3QklaQmFZcXIvTFg3cGZZdjNFWkRQZDFONlEzK1RKU0ZnQWx5M29QTTRLWkhKd09PNmZJZ1NSVjRoTHlJZTcrL2xRVmIvLzA4R0ZxSTRpZk1pVHFGMExwRGwwdE81amo4SFp0UHBkcDVPMVV1R3NiL0xQRjlZYm45N3crbjBuTllyMC9YRUc0dHJZY09Nem5aZXJCRzV5OUFlMk1MdEJrWTcvR1I2RGFiaDIrM1BVaDJPdXhtRm1pbkZFbWRvNktBMDk2dkxINWVQd0UydmlkUGgxcDd0cEJxMkp6WENFNnRCRWRyVk5maG1pNEVRUXNtN3V3bjlpaHN5STBlMTVYbzFUMUU3THFSLzd5aExXbUZ0UGtOeUw3ZVFRVjRNNE90RlhxUHJ5b0kvUUZIV29WOCtldGNmMHYxV3BtRzBrSVpOMVRTb25vYzg3S3dXSis4cE8zWTZweGZxeWFhalhQZjdGTDRXSEk2WHN0K2pCMXM3eDMycmlhdmIxY21TTmxrNzdZKzZvdEVUR3hRdzV2UGVoVDJpZUgzK2R1V0taK3lCU2dEZit2dkxpTGpTTUkvU3ErSGpDWkQwaFNEL0FOZGZQUmdBQUhqYVkyQmtZR0FBNGthVEIrcngvRFpmR1poWkdFRGdzWkQ5TmdUOVg0YzVoT2t5a012QndBUVNCUUFPT2dtYUFIamFZMkJrWUdCbStNOEFKRU1ZVXY5L1p6cktBQlJCQWN3QWFTWUVnUUFBQTFRQUFBSzhBSHNDelFCbEFBQUFBQUJ5QU41NDJtTmdaR0JnWUdid1pHQmlBQUZHQmpRQUFBZndBRkY0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktFZkNYMmhvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaVkrZHkzbmgrbTY4TXpDd01JUEJZeUg0Ymd2NnZ6OHpEZEJ6STVXQmdBb2tDQU9oaENJY0FlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWS9DUldob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMm9OM1Y4YnoyM3hsWUdaaEFJSEhRdmJia0dtV1VNWTdRSXFEZ1FuRUF3QXBpd21CQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVWUFBb0FBQUFBQmZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0TldOdFlYQUFBQUU4QUFBQU1nQUFBRHdIVGYxYVoyeDVaZ0FBQVhBQUFBSklBQUFDdVBPMnY1Tm9aV0ZrQUFBRHVBQUFBQzhBQUFBMktBSENaMmhvWldFQUFBUG9BQUFBSUFBQUFDUUZ2Z0diYUcxMGVBQUFCQWdBQUFBUUFBQUFFQW44QUtkc2IyTmhBQUFFR0FBQUFBb0FBQUFLQWNJQTFHMWhlSEFBQUFRa0FBQUFHQUFBQUNBQUJ3QllibUZ0WlFBQUJEd0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1WOWtadmdQNURNek1JS0VHUkVxL2dPRkFRSGZEaWtBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZelgvei9IOGhQQTlIL1ovOHhBcXNDQWdDbFV3bWxBQUI0MmtXUndXN1RRQlJGL1dhY21TUk9QSFpzajF2SGRaTTR0b09VSm0zaU9GSXdTWndBYWlpMFJVS3RDaWdWU04yd1FKVVFFdUlqUUVJczJQSVo3UHNEZkV3WGJGckdGUkx6ZG5QZmsrNjVWd0xwNExhUDNxSGYwbHlTQURNZ1ZBWGFDcU1wRExuTkNlWGJNSVVaOWttWTJNTXBqTVgvZ05zcStHRVVKdU93RHlwaU1FdzRpZURuUkpNMXA1VHRkU1lBYlN2RXdMWVpZKzBtM3VxeHB4NHkySE5tcVh6aDMwc0JmQzUweldPc1Z2UEtSZWM4bCtIN3pkVVRmUjZiU3h6NlhnTzFTYVNVRU1nSDFvL3JVOXlpY0hwV2o4S2cvVitDelhEbmk5d3FnaVFla3JxM095aUFLNmtuTFhNYVFVTHVTSVJqazFDYkQza2lBR1lDc2dkUk1zN0hBMXRRaVFVOGd5UVNVSVRtRVhCN2tLK2k1bVhwdzZmK1doWitkUTVxemRXYlp1cTduTnJqVlhhR2NNYjAxVmxuVk1WT3JXckJ0ejRHMDRxZFpjUFNkQWdqYitGV0tIeSt5Zm92TWJLNlcwM0RVTHh5QVlIaWJ1NDJYZzlsT0QyK09EVFlRd3h0cm5IUTlKcy92NWdTK0RKMFJtRTJQeHBEMEdEVk83YmQyMnYwVmZTMGtrNEVtODFOR3VWV1NZNll6SEF5aXNOSUFLdlFoeDdrM25NMGsyRmlrWDh3ZVZ0NUhHTlJyTTJwS0ZjRWNIY2tTdWJvcEdWWGgvWEpSdjNSU1hxT29Hd3dpcGpodFpRQ0xTc0VPS3RFWG5jR01xTjJBVFVTLzBIVGJWZW1hWEZTUUc4WGp6MWE0QUJrdllHaEhneWVJWG5QaWVHU29nMjVlUEVtOEk1bGlQZDkvK2orVmttMVhJQjV6MVFBSVczcDhnWkEzQzNyMmViYU1ad1JtdDRmZkl5MWdIUU9WKyt4bkZiVVJWcmFEMTY4R2h3aXZFNnpwdWFJT1A0QzByVmN1SGphWTJCa1lHQUFZczk5bHRmaitXMitNakN6TUlEQVl5SDdiUWo2dnk3VE1hYUxRQzRIQXhOSUZBQWkvUXBsQUhqYVkyQmtZR0JtK00vQXdNQjBqRUhuL3dXbWZnYWdDQXBnQVFCbjJ3UmRBc1lBQUFJNkFFc0NPZ0FzQXNJQU1BQUFBQUFBWmdEVUFWd0FBSGphWTJCa1lHQmdZUWhuWUdJQUFVWUdOQUFBQ1drQVlIamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b0NDeGRXRmdZbVhxQXRoRkdXd2pKMFJDcWpyMmQvZGhQUFFOVitkKzJFRE5Ed1gzSzVnbHZWOUpKZTdCRlZQbW1TZmkzakxYTEhqbmlhSjhsdVNWajh5bE5KK1pLMTc0eWp5Ui9EdHp6WXJmVFhDWDYyQ2oyZ1Zqb3o4NTE2MzNOdlpkOEdxcG0rUzMxdHQ0R0t4Ung1c3lZOWVQWjZkYTNlaVdEUUhIaFNzRGxvaGlKNGxKN0RsSjUraFlzMDlKTHh3a1Z5elJOUC82cmZRK2JRN3BKeU9iSXpkUnd5aUxYdlFzVzBXYlhtcmFQOHVoTC9jQUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUEFBQW9BQUFBQUJFd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMG0yTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QVpBQnlaMng1WmdBQUFXd0FBQUQ0QUFBQkdKSkJwN1ZvWldGa0FBQUNaQUFBQUMwQUFBQTJLSFBDYW1ob1pXRUFBQUtVQUFBQUhnQUFBQ1FHZ2dMUWFHMTBlQUFBQXJRQUFBQVFBQUFBRUFubkFRVnNiMk5oQUFBQ3hBQUFBQW9BQUFBS0FMd0FZRzFoZUhBQUFBTFFBQUFBR0FBQUFDQUFCd0FjYm1GdFpRQUFBdWdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEdEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNTmd5TS93SDhwa2gwa2hxL2dPRkFjMkNETTRBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLYWpMWS92OFA1R3VBNlA4My94OERxd0lDQUl5ekNOQUFBSGphWTJCa0tQblB5TmpBek1BZ3hjREFLQzRtd3M3R3o4akd6aVlHWlBJenFxa0RvYm1hUGFNWll3NHZPN3VqRmJzbE0yTllHaGM3YjZzcEg3Y3FFNU11bnhrekF5T1RBSnRKamtEaHNkNmZzWndDVEl4SnRZb0t0Y2xGemFwTlFDTVpQSURtaDBETUZ3YWFLaTdHTHNMR3pzZW9abTVpejJqSGFLN0hxSzVtYW1ZZTAySUdNbEJUeVN4UG1wR1pQeVNHa2JuUWpaT1JqWmtCWWxyVVFvZkVaQ1l1WmhaQm4vY0xqenkxNG1MalpHSUFBaVlHVDRZeVpndkdiZ1p1Qm5HZ2RZcHNhaVptNG9wbVlrQkxrTmpNUW45amVTVWxlWmlXOGdESnY5RkFrcGRwTVZDRU1ZS1JRNFdERVVROGdMTVlHQUFOTUN3UmVOcGpZR1JnWUFCaWplemw3dkg4Tmw4Wm1Ga1lRT0N4a1AwMkJQMmZrZG1DR2NUbFlHQUNVUUQyZGdoR0FBQUFlTnBqWUdSZ1lHYjR6d0FrbXhnOEdEeVpMUmlBSWlpQUJRQThkd0phQUFBQzB3QUFBY2tBZEFISkFFZ0RnZ0JKQUFBQUFBQXdBR0FBakFBQWVOcGpZR1JnWUdCaGtHWmdZZ0FCUmdZMEFBQURqUUFrZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktIN2k0T1RpNU9yek5taUFkbWtwYWl5N2lUL2MyQkcvZzhOMXp6ZzJROFNKaG1JUjUwR0ZTZWZQSVkzNVlSSjZJdjRxYzhjdWFFVWs2RTJmRkxuTEtsUC9JWTVhVWtTZmlQeUpuL1BIZU4vWHQzbG12am8yeDNsMXF2ejFaMzFhTlV4dWREK3ZCT3V2UG5UV3FmQ3JUVjIxL3JWV2hjMTJ3cDZIbXhwME9pMGR4Rk1jRWRsd2s4Mnc1aGIybGtzeEpaNE1tLzZZSFNWMW9uTU12UmhvbFQxRkRMemV0NkZXNmlpTGNhWW9QV0t3dVN3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU4wQUFvQUFBQUFBK0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRTBBQUFCZ3FvWmlPV050WVhBQUFBRkVBQUFBTXdBQUFEeWVOV1NsWjJ4NVpnQUFBWGdBQUFDb0FBQUFzTkZjOEl0b1pXRmtBQUFDSUFBQUFDd0FBQUEyS012Q3BXaG9aV0VBQUFKTUFBQUFIZ0FBQUNRR2x2L2thRzEwZUFBQUFtd0FBQUFNQUFBQURBaHpBSUJzYjJOaEFBQUNlQUFBQUFnQUFBQUlBRGdBV0cxaGVIQUFBQUtBQUFBQUZ3QUFBQ0FBQlFBamJtRnRaUUFBQXBnQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBRGFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzZzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUFCQmdZSEdEdWx1Q3lkZ1UzSjVvRUJzK0lmSXdZR1prWG1jMEJoUm9UcS8vOFpHQUExM3crL0FBQUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVptUmdVcko1WVBEL1B3TURoTDU3VlA0U1dCVVFBQUNzQkFuWEFIamFZMkJrOEdjb1ozWm03R1JRWkdCZzVHTmsxMk5XQjVJaWJPeHNhdXAyak9aeXpPSkEwc1RNM0V3TXFDbzF3am94SU16Y3c1K1pqWWVabDVFeEpjSW1JU2pNMUNPQW1ZMmJtWTh4SWJLSGhjbmUzNXFSSmNtYVI1YVJrVmNHU1lCYkRpakF3TWhneUtET2FNSmt3OEFIdEkrWlRZOVIzVndZWkEranVCaWo1a0YyQVRrbTFuWVdDVmtKWlVZbXhzZi9Ja1NZZWJrRUdIZnpLVEl5eWtseU1BQUFZL0VZbUhqYVkyQmtZR0FBNGx1MlhyTHgvRFpmR1poWkdFRGdzWkQ5Tm1TYWVTS1REWkRpWUdBQzhRRHVZQWZYZU5wallHUmdZRmI4WXdRa0p6SVlNc2d5T3pNQVJWQUFNd0JDWUFLQUFBQURrUUFBQTVFQVR3RlJBREVBQUFBQUFEZ0FXSGphWTJCa1lHQmdabEJpQU5FTVVCSUpBQUFFQ2dBcEFIamFUWXc5YjhJd0VJYWZpQVNKZE9oU2RlZ0FIcGl0b0ZSaVkyRmdZbVhxQXRpZ0RIR1FIU0pGcWpyeXUzdTRIbnJENlhrLzdvQ1NIektlay9FYTkzTnlDbEYvWFBEQ1crS3BxRVhpa2crV1RNanltVGh6Tm9selNiNFNGN3h6U1R3Vi96dHh5U2VQYmRmZTdyMzFhdDhaNjkyNURlUDZZSDFvT3FkV3VvcDZaNTMxeDk0YWRScVZHWm93WEZ0VjYwclhiT2xvdVhHbngrSlI3TVV4a1IxbnlRSWphdzdSQ1RTU09tbXQwRlQvOHAza0xuYU84Wk9SemtrU0pUVElWWkI5bGJhaWpwZWEraGZ6ZVRCUEFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU00QUFvQUFBQUFBNlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDA1bU50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNVWjJ4NVpnQUFBV1FBQUFDQUFBQUFnQUdRVnpOb1pXRmtBQUFCNUFBQUFDd0FBQUEyS0JqRFIyaG9aV0VBQUFJUUFBQUFIUUFBQUNRR0FRSWxhRzEwZUFBQUFqQUFBQUFJQUFBQUNBV0FBQ0ZzYjJOaEFBQUNPQUFBQUFZQUFBQUdBRUFBQUcxaGVIQUFBQUpBQUFBQUZnQUFBQ0FBQlFBb2JtRnRaUUFBQWxnQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBREtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbU9zQTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCa1p2Z1A1RE5EcEpIVS9BY0tBd0RxeUEweWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpTy8vOUR5UDhId0h3R0FGS1hCcDBBQUFBQUFnQWhBQUFDM2dMZUFDTUFKZ0FBQVJNZUFUY3pGU1lyQVFjMUZqWTNMd0VqQndZVkZCWVhGU2NITlRJMk54TTJGeklXQndNekFaamRCeU10RWtKRVMwZ1hPd01ETi8wdkFpY21kbWdxT2c3VUJSUUxDVE55NWdMSi9ZQVpFUUVnQXdNZ0FRa1dENXlHQndnVkhnRWdBd01nSFNjQ1pSVUJDbjMrc3dBQUFIamFZMkJrWUdBQVlpMUZXZU40ZnB1dkRNd3NEQ0R3V01oK0d6TE5kSS9wSHBEaVlHQUM4UURRbXdmaWVOcGpZR1JnWUdiNHp3QWlHUlFabEpqdU1RQkZVQUFUQURWTkFpMEFBQUFDZ0FBQUF3QUFJUUFBQUFBQVFBQUFlTnBqWUdSZ1lHQmlVQWRpRUdCa1FBTUFCSU1BTGdBQWVOcEZqREZ2d2pBUWhiK0lCSWwwNkZKMVlBQVB6RmFpTUhkaFlHSmxZZ0Zzb2d4eGtCTWlJYUdPL2QwOWpDVnVlUHJ1dlhjSDVQeVM4SnlFejZEUFNjbGtlM0hHQjErUnA3SXRJK2ZNV1RFaFNXZmlMUGlKbkVweWlKenh6U1h5VlB4SDVKdzFmNXV1dmQ0RzY5V3VNOWE3Yyt2TFltOTkzM1JPbGJvSSs5WTY2NCtETmVwMFYyWnMrckZ1VmFVTFhiR2hvK1hLalFHTFI3RVR4d1IybkNYemxCVHNnOVBUU09xa1ZhTEZmZWRieVYzb0hNTW5JNTBUZDFIREtGZTlhQzF0UlJVdU5kVS9ZejB2RHdBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU2tBQW9BQUFBQUJVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUVXTnRZWEFBQUFFNEFBQUFNd0FBQUR3QVdBQ2NaMng1WmdBQUFXd0FBQUhUQUFBQ0FCZzh6bnhvWldGa0FBQURRQUFBQUM4QUFBQTJLSExETDJob1pXRUFBQU53QUFBQUhnQUFBQ1FHWGdJa2FHMTBlQUFBQTVBQUFBQVFBQUFBRUF1Z0FJQnNiMk5oQUFBRG9BQUFBQW9BQUFBS0FWUUFzbTFoZUhBQUFBT3NBQUFBR0FBQUFDQUFCd0E2Ym1GdFpRQUFBOFFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFbUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtZXNFNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJoWnZnUDVETkRwSkhVL0FjS0F3RDVwdzFkZU5vZGlvRUpBQ0FRQXU4cm1xQWhXdU9wdldzemt3UTlSSUVDVkhzNDQ3TXh6VzZHMTJSTDdzbVNkSFgreTNxUVhRanVBSGphSFpBOWI5TlFHSVh2dVc5OGJ6NGNPNnFEYnlTSW96UnAzRlJ5Z21yTERwVklFVkVyNk5DVUZwV29WRlFNQlZHSkw3V3FPblRJVUlSQU1MQWdJVVptWmhaK1FDY21WZ2JZRUQ4QkplR0c5MHp2TXozbk1NN3Frd24veVgrd05sdGtMRUdjTExyS0ticGg3SW8ycE4vd28xaTVjZEpHVllxaXEySmxRZk1wRHJ0SVF2cUNmVkhNQzNUZDRBSk00MmlZTnBEUE9SRmw1SGl5bnIvazVBbDU0K0hBaEptWjdYNzRVejNtMndWazdOSFF0YWtzUVFTZXRpVmdxZ2NyWjhWNkFkeTJ4QlJuYllIYU9UYVpQckJ3OHB0eS9EdnI2SWNzMUxUWk1xS0diMEVLRzBKNVNMU21Wb29yOENDazVpMzRjVEtOcTF5VjZCcVV2VVlpbXpIQXNkMWZlWEY1OWFKd2tUcTlPYjhYUjRGSVphUkJ3V3J6ZWUva0k5Rld0SFo0dHRXY0Z6Y3NtUHg4L05lUzROSnU3QndBdmM1Z3I3UWJITi9ubUYxbzdaWnlBRGNmWDU4TFFlK0hyNDdXb2sxSzFlZXN2c1ZKdTNQV25Jd280VjlaaVFWNll5ZjJoUjYxNmtFSk9VMVYvTi9ZSWQwalZOTUt5NGo5Rm1TdElUNjlSYzhyMkJnY25vTDZDNTJENGZoejJiYVd2Rjl2VW9EMSt0NkpXaXFsWjhBZnJUK3BPQnY4U29Hb3JPZDc5L1RsczZ2QmJTSlBBQTd2amI3TmlDeFNHNVZiZDZ0My9QMGR3TlpxL3dDNnoxVmdBSGphWTJCa1lHQUE0djFmTzVQaitXMitNakN6TUlEQVl5SDdiUWo2LzB0bWM2YTdRQzRIQXhOSUZBQkFjd3NvQUhqYVkyQmtZR0JtK004QUpQMFpWUDVmWURabkFJcWdBQllBVlNvRGlBQUFBbllBQUFNQUFDUUMyd0F6QTA4QUtRQUFBQUFBVkFDeUFRQUFBSGphWTJCa1lHQmdZYkJrWUdJQUFVWUdOQUFBQm5zQVFuamFUWTZ4YXNNd0VJWS9VOGRRcDlDcEhUb1VUUm1GamZzQWdReVpzbVlzSkpFSURrZ0tzbVBJRXZvQWZlaGVGQTA5d2ZIZGQ3K0VnSm9iQmZjcWVFMzlYaVdWVEErZU1lY3RjeVZIWmE3NVlNRVRSZmtzNXBObDVwSVh2alBQZU9lVXVSTC9rN25taTk5VmNPZkxhS1BhQkdPalB6alh0ODNXeHFFUFhyVzZlWWkxOVRidVJtdlUvcXJNMUEvVDBhbE9ON3BqUmNCeDVzS0lKY3JQTm1KTVlzOUJkbzZlbG9adGNvTk1RVFpLbkJiN1A3R1doRStwWFhyTlNHclBWYnBoa3N3Zy9TaHBSWmZ1YXJvLzMvUXd1d0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNyB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mOCB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjE1Mjc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy0yMS41MTcxNSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTUuMTA1MDEzJyB5PSctMjUuMTMyNTE0Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjguNDUyNzQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4xNzQyNyw0MC4xNzkxMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTIxLjUxNzE1Jz5EPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDgxLjQyNyw0MC4xNzkxMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTIxLjUxNzE1Jz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDExMC4wNjEwMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNjIuNTc3MDEyJyB5PSctMjEuNTE3MTUnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTYuOTA1NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjc1MjcyLC00NS4xNzkxMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTIxLjUxNzE1Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01NS4xMDUwMTMnIHk9Jy0yNS4xMzI1MTQnPu6AsDwvdGV4dD4KPHJlY3QgeD0nLTYyLjU3NzAxMicgeT0nLTIwLjMyMTY5NycgaGVpZ2h0PScuMzk4NDg0JyB3aWR0aD0nMTAuMjY3MDcxJy8+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTUuOTQ5MDIgOC45Mjc1NUwyMy45MDM4NSAzNS44NTM0MicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjU1NDc2LDAuODMxOTUsLTAuODMxOTUsMC41NTQ3NiwyNC4wNDI1NCwzNi4wNjE0MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNOC45NDAxMiAxNy4zNDg0NkgyMS4xOTAxMlYyOC4yMjU1Nkg4Ljk0MDEyWicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTEuOTQwMTIsMjAuODQ4NDYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Mi41NzcwMTInIHk9Jy0yMy4xOTkzOTQnPuKIvDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNjIuNTIxNjYzJyB5PSctMjEuMDE5MDE4Jz49PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTM3LjI4Njc2IDQyLjY3OTEySDczLjA5OTMzJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDcyLjk3NDMzLDQyLjY3OTEyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPHBhdGggZD0nTTkwLjg1MTc2IDM0LjQzOTA0TDEwOC4wNDAzIDguNjU5MDMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNTU0NywwLjgzMTk5LC0wLjgzMTk5LC0wLjU1NDcsOTAuOTkwNDMsMzQuMjMxMDMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNTU0NywtMC44MzE5OSwwLjgzMTk5LDAuNTU0NywxMDguMTc4OTcsOC40NTEwMyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTAyLjIzODQyLDI2LjgxODA0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctMjEuNTE3MTUnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU3LjkxMDQyOCcgeT0nLTI0LjUyMzY2Nyc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy01My43NDU0NTknIHk9Jy0yMS41MTcxNSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTAuNjMyMTE2JyB5PSctMjEuNTE3MTUnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMzguODgxNzc2JyB5PSctMjEuNTE3MTUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM1Ljc2ODQzMycgeT0nLTIxLjUxNzE1Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0zMS42MzE0ODMnIHk9Jy0yMS41MTcxNSc+KSk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEgxMDUuMDA1NDgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA1LjI1NTQ4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNNDQuOTczMzMtNi41SDcwLjI0MDQ4VjYuNTk0MTVINDQuOTczMzNaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ny45NzMzMywtMS43NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTIxLjUxNzE1Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01Ny45MTA0MjgnIHk9Jy0yNC41MjM2NjcnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNTMuNzQ1NDU5JyB5PSctMjEuNTE3MTUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUwLjYzMjExNicgeT0nLTIxLjUxNzE1Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy00Ni40OTUxNjUnIHk9Jy0yMS41MTcxNSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjU0NDMxLTYuNDA5NzNMNDQuMTc5NjQtMzMuMTM4ODInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43OTk5NiwtMC42MDAwMiwwLjYwMDAyLDAuNzk5OTYsNDQuMDc5NjUsLTMzLjA2MzgzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMS45ODc4MSwtMjguNTc4ODYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy0yMS41MTcxNSc+z5E8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTU3Ljc2NjA3MScgeT0nLTIwLjEzNDgzNyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTMuNzcwNjAxJyB5PSctMjEuNjAxNTY2Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTQ5LjYwNTYzMicgeT0nLTIwLjEzNDgzNyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDYuOTA3Mzc3JyB5PSctMjAuMTM0ODM3Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjgnIHg9Jy00My4yMzg4MicgeT0nLTIwLjEzNDgzNyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNjguMzczNjYtMzQuMDc5NzFMMTA1LjEwNTUxLTYuNTI1NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC43OTk5MywtMC42MDAwNSwwLjYwMDA1LC0wLjc5OTkzLDY4LjU3MzY0LC0zMy45Mjk2OSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43OTk5MywwLjYwMDA1LC0wLjYwMDA1LDAuNzk5OTMsMTA1LjMwNTUsLTYuMzc1NDkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg5LjMyMzUzLC0yOC45Njg2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTYyLjU3NzAxMicgeT0nLTIxLjUxNzE1Jz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTUwLjgyNjY3MycgeT0nLTIxLjUxNzE1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny43MTMzMycgeT0nLTIxLjUxNzE1Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00My4wNDY3NDYnIHk9Jy0yNC41MjM2NjcnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMzguODgxNzc2JyB5PSctMjEuNTE3MTUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM1Ljc2ODQzMycgeT0nLTIxLjUxNzE1Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0zMS42MzE0ODMnIHk9Jy0yMS41MTcxNSc+KSk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram, node distance = 4cm,baseline = (2.base)]
        \node  (1) {$A'$};
        \node  [right = 1cm of 1] (ref1) {};
        \node  [above = 1.5cm of ref1] (2) {$D$};
        \node  [right = 2cm of 2] (3) {$C$};
        \node  [right = of 1] (4) {A};
        \node  [between = 1 and 4] (ref2) {};
        \node  [below = 1.5cm of ref2] (5) {$\underline {A'}$};
        \draw  [->,morphism] (1) to node[desc] {$\cong $} (2);
        \draw  [cover,morphism] (2) to (3);
        \draw  [>->,morphism] (3) to node {$f^{*}(\mathsf {Img}(g))$} (4);
        \draw  [->,morphism] (1) to node[desc] {$f^{*}(g)$} (4);
        \draw  [cover,morphism] (1) to node[swap] {$\vartheta _{f^{*}(g)}$} (5);
        \draw  [>->,morphism] (5) to node[swap] {$\mathsf {Img}(f^{*}(g))$} (4);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Then by uniqueness, <fr:tex
display="inline"><![CDATA[C \cong  \underline {A'}]]></fr:tex>.
      Thus, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f^{*}(g)) \cong  f^{*}(\mathsf {Img}(g))]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>  
</fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1426</fr:anchor><fr:addr
type="user">ct-000P</fr:addr><fr:route>ct-000P.xml</fr:route><fr:title
text="Equivalent condition for regular categories">Equivalent condition for <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular categories</fr:link></fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is regular iff it is cartesian and has <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">images</fr:link> that commute with pullbacks, i.e., the following diagram commutes up to isomorphism for any object <fr:tex
display="inline"><![CDATA[f \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="d7848f567449dd029989d612a2f5eab3"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzNy44Mjg0NzNwdCcgaGVpZ2h0PScxMTkuNjk2ODYycHQnIHZpZXdCb3g9Jy03MiAtNzIgOTEuODg1NjQ5IDc5Ljc5NzkwOCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktFSERGMmhvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRyYlhwMkxqK1cyK01qQ3pNSURBWXlIN0JRajYvMTltTnFhN1FDNEhBeE5JRkFBNVdBclhBSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMko3dkNQV2hvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaXp5c25YWTdudC9uS3dNekNBQUtQaGV3WElPai9ERXdOekNBdUJ3TVRpQUlBT1dRSjRBQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoWGQwZzJOdFlYQUFBQUU0QUFBQU13QUFBRVFBZGdFeVoyeDVaZ0FBQVd3QUFBRTZBQUFCVUNpQ2IyZG9aV0ZrQUFBQ3FBQUFBQzhBQUFBMkoyWERBbWhvWldFQUFBTFlBQUFBSHdBQUFDUUZOd0ZnYUcxMGVBQUFBdmdBQUFBT0FBQUFEZ2JFQUlGc2IyTmhBQUFEQ0FBQUFBb0FBQUFLQVBvQWhtMWhlSEFBQUFNVUFBQUFHQUFBQUNBQUJ3QXlibUZ0WlFBQUF5d0FBQURUQUFBQlBxa3JkZHR3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1VbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvR001UXljLzRIOHBrNUdkSFUvQWNLQXdDNmFnenFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1U0NHWklZU3YvL1I3RCtyL3UvNEg4ZldDMFlBQUR1aGd1aUFIamFQWTZ4VHNKUUFFWGZmVlVhSFFxdkRUVUlGZ3RDb1FZcUpmQ0NHZ2l4RVRFR0dqVEI2S0k0cUluT2F0VE53ZEZmY0RYeEU1ZzcrZ082T0RtNHVvTFBHRTN1Y3U0ZDdpRWdoZkVIeHZTTkxCRUN1UWhMZ1d4ZzVqOENRMW1MRytCMWNESC9KdnREcm83WGNLTFhhSFZBNDdKdUwzcWJLVFVOZW5Qc1huamh0U3R6dlFQTVJ0UkNvN0NSWEpGd2ZjYjM2Rk12bGdOdE95bDdVb3RNTXlPanRkemQyd2trODl1VmVVcjlpbGxTVkJhZU1zeG1zM3NweFFnaGxPeU12L0JKQXhJaENVSTBWdjh6RXliUk5OT2lPdGVyUWs1VzhPajBrKzE5S3AxM3k1N3ErOWFxZXlCSi9aTE5hVEI2V1loQnVqODZ2YU93VkVjVUQrOGVoVDhZQ00yYytBSHBpWjhoQXFJS1lPbUtnblFSbkpWWlNIZXJuR0c0WlIzYWRRYytuVHRwQWNHb1ZqTGphTmJRSHoybk1ud1orVytuZEVCU0FBQjQybU5nWkdCZ0FPTGVHWDZYNC9sdHZqSXdzekNBd0dNaCt3VUkrdjhMSmkybXUwQXVCd01UU0JRQUt4QUtrd0I0Mm1OZ1pHQmc1dnpQd01EQVpNR2d5NkRDK0o4QktJSUNtQUUvWUFLY0FBSXFBQUFDT0FBdEFoQUFWQUJTQUFBQUFBQUFBRklBaGdDb0FBQjQybU5nWkdCZ1lHRXdaR0JpQUFGR0JqUUFBQVd6QURwNDJrMk9zV3JETUJDR1AxUGJVTGZRcVIwNkZFMFpoWTM3QUlVTW1iSm1MQ1NSTUM1WURwSmo4Rkw2QUhub1hCUU52WU9mVC8vOWR3aW8rQ1hqVmhrdlVXK1ZVOHJyemdWUHZDWXVwVlhpaW5kV1BKRGxqK0o4OEpVNDU1bnZ4QVZ2L0NRdXhmOUxYUEhKWlQwT3AvTmt2ZHFPeG5wM0hFSm82cDMxb1IrZGFuUjlOemJXV2IrZnJGR0hSWm01RDNNM3FGYlh1bVhOeU1DSk14TVdMei9iaW1NaU80NHlDOUlOTmJ2b0JYcVpPOGsxYUhIL0p6YVNjREcxajllTXBBNHNvb1paOW9Kb0ozbEZHM2MxN1JYK0NERDdBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQzBBQUFBMktZL0NHV2hvWldFQUFBSkFBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbUFBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDYUFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKd0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGkyb1AzR09QNWJiNHlNTE13Z01Caklmc0Z5RFJMS09NZElNWEJ3QVRpQVFBSml3aXVBQUFBZU5wallHUmdZTmI2WThuQXdCTEswTWZRejVUTUFCUkJBVXdBVW9BRFFnQUVWUUFBQXZJQWpnQUFBQUFBVkFBQWVOcGpZR1JnWUdCaU1HVUEwUXhRRWdrQUFBWEtBRHNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXOTBuR050WVhBQUFBRTRBQUFBTXdBQUFFUUFld0VnWjJ4NVpnQUFBV3dBQUFGTUFBQUJqUE53SkpOb1pXRmtBQUFDdUFBQUFDOEFBQUEyS0VmQ00yaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR053SjFhRzEwZUFBQUF3Z0FBQUFRQUFBQUVBajlBTlpzYjJOaEFBQURHQUFBQUFvQUFBQUtBTlFBaUcxaGVIQUFBQU1rQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQXp3QUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TXVReWMvOEg4cG01R2RIVS9BY0tBd0REN3d6N2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VROEdkSVpjdi8vUjdEKzcvZy8rLzgwc0Zvd0FBRHNod3VWQUhqYVZWRExUc0pRRUoyWlcxb2dXQVNsRmR0VWFXTUxpQkI1dE1CVkVoY1NJeXBxNGtJa1NHVGpqeGcrRFJNU0VxSWY0dGFGNE1XTm1rbE96bU5tY1FZUVJnQXdwUWt3Z0kyRWs1ZyswK1NySVRRSXgxcVdLSTd2VUFJT0hRRFVQVWRXZEMybG9pSjdzbUpoVVBGMVRZeUt0dXU1ZmxCRXp3L2NXZ3NEWDI4aDAxYU80NjQyZFhFcDZ4YVdSZTZKSVJhcmNsT1NUSHk2MkcrRUdCWGlqOFpSM3ExS05KNk5HUm81SllGUzJxSGhaYkZ4L0xDME9XRXQ3d2owZTZQbW1zcG84RElncVJCZkwrSzhMU0VMNXc1UGgwUzd0T01taUNKaHpicmkzUzdmNU5zUnoyb2FCM1dSTWx1TExqNnd5Q3ZWSDNobHBxbGtzdGxNVmcyUkxDb0R3cDBvSHNNMzJCTkMvTU12b2V1cHFLZiswVXJLRjExRXhjQkNGcjFucXBRODQyWDhKYmZ0M25sVFR0NmM5RG1XRm5QTXB1MlF6VmkvOXZtWHpqclh4T3BiaGs5c0NOL3JyRDNyZU5wallHUmdZQUJpWStmeTFIaCttNjhNekN3TUlQQll5SDRCZ3Y2dno4ekRkQnpJNVdCZ0Fva0NBUE0xQ0xNQWVOcGpZR1JnWU9iK3p3QWs0eG5rR0FTWmVSaUFJaWlBQlFBdXZ3RzBBQUFDVUFBQUFTNEFZd0lnQUI0RFh3QlZBQUFBQUFBT0FJZ0F4Z0FBZU5wallHUmdZR0JoOEdGZ1pnQUJSZ1kwQUFBSWJRQldlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUOEFBb0FBQUFBQmJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVXAxSTJOdFlYQUFBQUU0QUFBQU5RQUFBRVFBVndEL1oyeDVaZ0FBQVhBQUFBSW5BQUFDZUlZdzdoaG9aV0ZrQUFBRG1BQUFBQzBBQUFBMktKVENQV2hvWldFQUFBUElBQUFBSGdBQUFDUUdsZ0pLYUcxMGVBQUFBK2dBQUFBVUFBQUFGQTQ3QVIxc2IyTmhBQUFEL0FBQUFBd0FBQUFNQVBRQnNtMWhlSEFBQUFRSUFBQUFHQUFBQUNBQUNRQkNibUZ0WlFBQUJDQUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUU4QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0U0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVowaGpadmdQNURORHBKSFUvQWNLQXdEMWd3MWRlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1VDBHWndZMHY3L0I3TWNRYXovbC80Zi9EOFByQllNQU9HNkMxQUFBQUI0MmtXU3pXc1RRUmpHNTVtWnptU1R1THZaSkxNbTJxU2JqYnRxUDZLSjNkall4cllXV2hKcmJYdW9GU0VYRVNvRkJSRUV2Nmg0MElzbkR4Njg5Q0FVYng2RjN2UWYwSjRVL3cxdmJlS3NJRjVtNW4wZmVQazl6N3dFNU5xQVVJTVJraWJFZ0pDVk1HaWlEVmRSOUYvdzR6a09pV2REbzV6U2c4TkZseFdaelQ3SEZ5R0VrdFpnd0dib1Q5SWdFU0ZOUk0yNmNyTTUxYWlyZkU3V0lDY3dxVWUxMFF3OUN5SmZRc05WcmdtdGlMQ05oaFk4ZG9CSHlZS1pvRGZWYU5yT3RXWmVKZ1ZzWTZ5SVF2L1hXbEpRUDVFU2dEVzBkU1BOWUNYR0x1MUNubnRNbHhUU21hUFhXWk9uOG1EZ1NMS01CREtKajgrZGxKRkxVV2JvbW5QWWxtUm45N0ZDQ0NPZHdTSGJwUHZFSStOa1NoTm5tMUZRZ3krQ3lQVkswR1JTbjBLalNpL3VxU2diTTBaQjZBZENzbjl2SnRTWFZ4eUdYVERMY0V3OHZIMFBiS2UzZGd0MDJWbC8wbjl3a21hT1RRM3Y3VzA5QloxY2ZsKzJoKzUvNk8wd3RKZCtkSkcrVGtlVUZHQzhJa0hYcHhmdU9NblZpOTA1czgyNHJ4MDRXR0RiODk0aWg2bU9QdEh0bFZxSDlyOUxIVGhJZDFDamQrazNNcXNMRm1OcTRrb1FSNmxjSmFRcTY1Kzd6UDc2aVdGMXZ4N243UWRoRURXMVU1TmFhRVJLaE5odDJkd3VHblBuVDdlQWFqN1EwWll0eTZwNmJIakN1bHFpV1d2VnlwdHEzajh6RGZoSzYzYkpzaHlubEV3VWU3R010LzJ2bmN6c2hkd1ZGdmlsRVZvVlljcWc0TjM4dTk4YlRGdmIyRHdSQnFlcS95VVVndkUzdkpLQVhwMC84UHhlZXdCNDJtTmdaR0JnQUdLdHpKdUg0L2x0dmpJd3N6Q0F3R01oK3dVSStqOERjeVF6aU12QndBU2lBQkdkQ09nQUFBQjQybU5nWkdCZ1p2alBBQ1JMR0t6K1gyQ09aQUNLb0FCV0FGMUlBK1lBQUFMR0FBQUNWd0JPQTNBQU9nTjBBRW9DT2dCTEFBQUFBQUFlQUhZQTFnRThlTnBqWUdSZ1lHQmxjR1JnWmdBQlJnWTBBQUFIZFFCTWVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVjQUFBQmdpRTl5Qm1OdFlYQUFBQUU4QUFBQUtRQUFBRFFBREFDV1oyeDVaZ0FBQVdnQUFBQ3lBQUFBdUxXMVQ1Vm9aV0ZrQUFBQ0hBQUFBQzhBQUFBMktGZkM5MmhvWldFQUFBSk1BQUFBSGdBQUFDUUZTUDlBYUcxMGVBQUFBbXdBQUFBSUFBQUFDQVUzQUFsc2IyTmhBQUFDZEFBQUFBWUFBQUFHQUZ3QUFHMWhlSEFBQUFKOEFBQUFGd0FBQUNBQUJBQTVibUZ0WlFBQUFwUUFBQURUQUFBQlBxODNkZUZ3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1tczA0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpuQm1sdnFqeWNEQUxNVjhIVlhOLy84TURBRDJmdzVFQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnVWdEUUxFSUw0enYvL1E4ai8rOEI4QmdCU3dRYWZBQUFBZU5wallHVGcvUCtjU1pucE1vTTVBNE1xR3pzSUtxbXBxOWt6bXBtYmdRa3hjVForUmo1R2RqWjFjenRHY3pWMklCT0k1QmlCUEtBOFdBbmpIMFlUQlgyditLZ01SbVp4RnNsUWxVRDI0SHc1WXlabWNSVXVIUUZ1Um5adVZTWW1PNzk0UlEwalJxWTBkMk5YQ1g1MmZuNWVmczZGd2lZS3NvYXNGWVZhOFh6SnVYb216RVlzakpLYTZnYXVmQktNVEp6OHdvR3k1a3lNTGtiMkN6eUtzeGdaZFZWRk9MZzQyQmdaR1JnQTVVd2JQQUFBZU5wallHUmdZQURpbEVrTFV1UDViYjR5TUxNd2dNQmpJZnNGQ1ByL2MyWVpwc3RBTGdjREUwZ1VBQjBkQ2pBQWVOcGpZR1JnWUpiNm93a2taUmc0Ly85Z1VtWUFpcUFBSmdCVzZRT0xBQUFESEFBQUFoc0FDUUFBQUFBQVhBQUFlTnBqWUdSZ1lHQmlzR0FBMFF4UUVna0FBQVlWQUQ0QWVOcE5qckZxd3pBUWhqOVR4MUFua0trZE9oUk5HWVdOOHdDRkRKbXlaaXdra1FnT1dBNlNZL0JTOGdCOTZGNFVEVDNCOGVtLzc0U0FraDh5SHBXeGpQMVJPWVhjbmp4anpsdmlRbzVLWFBMQmloZXkvRldTVDc0UzV5ejRUanpqblV2aVF2Sjc0cEkxdjV1K3U5NEc2OVd1TjlhN1V4ZW11dHBiSDlyZXFWcFh6MkJybmZXSHdScDFuSlFaMnpDZU85WG9TamRzNk9tNGNtUEE0dVZuTzBsTVpNZEpab0dKbW9wOXpBS3R6SjE0TlZyUy84WldEQmV0UTN6TmlIV1VtUklhWlM5SVA0dXZhT0t1cHZrRENWRXhFd0I0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3MxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5MTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTYuOTE0MTUxLC02MC40NDc1MDEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOC4xMjI3NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTYuOTE0MTUxLC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU2LjkxNDE1MScgeT0nLTYwLjQ0NzUwMSc+QzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNTEuNjY4NTI5JyB5PSctNTguNjQ4Njc0Jz4vQjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNy43MjI5MywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01Ni45MTQxNTEnIHk9Jy02MC40NDc1MDEnPkM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUxLjY2ODUyOScgeT0nLTU4LjY0ODY3NCc+Lzx0c3BhbiB4PSctNDguMDE1NTQxJz5BPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOS45NjUzVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMi4xMjg1NCwtMzEuMDYzODcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ni45MTQxNTEsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNTYuOTE0MTUxJyB5PSctNjAuNDQ3NTAxJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01Mi4yNDc1NjYnIHk9Jy02My40NTQwMTgnPuKIlzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MS4wMjg3NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTYuOTE0MTUxLC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU2LjkxNDE1MScgeT0nLTYwLjQ0NzUwMSc+U3ViPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy00MS4wODQ1OTUnIHk9Jy02MC40NDc1MDEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM3LjIxMDIyMicgeT0nLTYwLjQ0NzUwMSc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjkuMTUzNjEzJyB5PSctNjAuNDQ3NTAxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQxLjMyMjE0LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTYuOTE0MTUxLC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU2LjkxNDE1MScgeT0nLTYwLjQ0NzUwMSc+U3ViPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy00MS4wODQ1OTUnIHk9Jy02MC40NDc1MDEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM3LjIxMDIyMicgeT0nLTYwLjQ0NzUwMSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjkuNzM4MjIzJyB5PSctNjAuNDQ3NTAxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMi42NzgzIDBIMzUuOTczMicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzNi4yMjMyLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTguNjc4NTQsNC4xNzI5MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01Ni45MTQxNTEnIHk9Jy02MC40NDc1MDEnPkltZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS04LjkwOTczVi00Ny40OTU3NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ3Ljc0NTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMzAuMjAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ni45MTQxNTEsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNTYuOTE0MTUxJyB5PSctNjAuNDQ3NTAxJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01Mi4yNDc1NjYnIHk9Jy02My40NTQwMTgnPuKIlzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTIuMjc4NDctNTYuOTA1NUgzNi4yNjY2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM2LjUxNjYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE4LjYyNTM0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01Ni45MTQxNTEnIHk9Jy02MC40NDc1MDEnPkltZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = {{\mathcal {C}}_{/{B}}},
    sw = {{\mathcal {C}}_{/{A}}},
    ne = \mathsf {Sub}(B),
    se = \mathsf {Sub}(A),
    north = \mathsf {Img},
    south = \mathsf {Img},
    west = f^{*},
    east = f^{*},
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>744</fr:anchor><fr:addr
type="machine">#291</fr:addr><fr:route>unstable-291.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>745</fr:anchor><fr:addr
type="machine">#289</fr:addr><fr:route>unstable-289.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a cartesian category with images that commute with pullbacks.
      Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be a morphism and <fr:tex
display="inline"><![CDATA[g\colon B'\twoheadrightarrow B]]></fr:tex> be a cover.
      Then note that <fr:tex
display="inline"><![CDATA[\mathsf {Img}(g)]]></fr:tex> is an isomorphism.
      Since images commute with pullbacks by hypothesis, we can form the following diagram.</fr:p>
    
      
      <fr:figure><fr:resource
hash="fe831617b13b46498327edb3e5b9e92b"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIxMC4zODc1MjdwdCcgaGVpZ2h0PSc5Ny45OTk5NXB0JyB2aWV3Qm94PSctNzIgLTcyIDE0MC4yNTgzNTEgNjUuMzMzMyc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJRQUFvQUFBQUFCT1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZRjFRR050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFHU0FBQUJ2R0UwYno5b1pXRmtBQUFDK0FBQUFDOEFBQUEyS0kvQ1NHaG9aV0VBQUFNb0FBQUFIZ0FBQUNRR0xRSlBhRzEwZUFBQUEwZ0FBQUFNQUFBQURBamRBT0JzYjJOaEFBQURWQUFBQUFnQUFBQUlBSElBM20xaGVIQUFBQU5jQUFBQUdBQUFBQ0FBQmdCS2JtRnRaUUFBQTNRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRVJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbStzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWTBoblp2Z1A1RE5EcEpIVS9BY0tBd0FHaEEyeGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOER5YlQvLy8vUEJ2TVpBRld4QnNONDJpV1BRVzdUUUJpRjU4MjQ0OFNKUFhac2o5MlFoR2JjMkUyVnhGSGMyaXBVTmxCVlJEUkliWGRJQ0tsQ3NDaXc3SW8xRzFoMHg1cGJ3QVY2QWc3QklaQmFZcXIvTFg3cGZZdjNFWkRQZDFONlEzK1RKU0ZnQWx5M29QTTRLWkhKd09PNmZJZ1NSVjRoTHlJZTcrL2xRVmIvLzA4R0ZxSTRpZk1pVHFGMExwRGwwdE81amo4SFp0UHBkcDVPMVV1R3NiL0xQRjlZYm45N3crbjBuTllyMC9YRUc0dHJZY09Nem5aZXJCRzV5OUFlMk1MdEJrWTcvR1I2RGFiaDIrM1BVaDJPdXhtRm1pbkZFbWRvNktBMDk2dkxINWVQd0UydmlkUGgxcDd0cEJxMkp6WENFNnRCRWRyVk5maG1pNEVRUXNtN3V3bjlpaHN5STBlMTVYbzFUMUU3THFSLzd5aExXbUZ0UGtOeUw3ZVFRVjRNNE90RlhxUHJ5b0kvUUZIV29WOCtldGNmMHYxV3BtRzBrSVpOMVRTb25vYzg3S3dXSis4cE8zWTZweGZxeWFhalhQZjdGTDRXSEk2WHN0K2pCMXM3eDMycmlhdmIxY21TTmxrNzdZKzZvdEVUR3hRdzV2UGVoVDJpZUgzK2R1V0taK3lCU2dEZit2dkxpTGpTTUkvU3ErSGpDWkQwaFNEL0FOZGZQUmdBQUhqYVkyQmtZR0FBNGthVEIrbngvRFpmR1poWkdFRGdzWkQ5TWdUOVg0YzVoT2t5a012QndBUVNCUUFXR2dtNkFIamFZMkJrWUdCbStNOEFKRU1ZVXY5L1p6cktBQlJCQWN3QWFTWUVnUUFBQTFRQUFBSzhBSHNDelFCbEFBQUFBQUJ5QU41NDJtTmdaR0JnWUdid1pHQmlBQUZHQmpRQUFBZndBRkY0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBL1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBtbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDOEFBQUEwRThPekgxb1pXRmtBQUFDSUFBQUFDMEFBQUEyS0kzQ1NXaG9aV0VBQUFKUUFBQUFIZ0FBQUNRRkxBSzRhRzEwZUFBQUFuQUFBQUFLQUFBQUNnWGZBSnBzYjJOaEFBQUNmQUFBQUFnQUFBQUlBRFlBYUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBZ2JtRnRaUUFBQXB3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBZElsRE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaSmoxbjRIeE9ETURneHdEQXlNZkl6dWJ1QmdZaXJBcHFlc3hxcXVwbTVuYk1acWJHWW1Kc2pFZUNXcGxaVmJpNE5LdDRHQmtrM0pVOUZLd1pXR3hWZkJTZEpSaVkyUjZidloxVDJ5bGhIaFZLZ3NYQzVlSmJKUnR3WW9WaGJhUnNpWmNMSndNUU1ESWtBeTBhd0xRTG1rZ2g0MGRaSnVhUHFNSjJBSWhOWFUxSUVOY2psRmNqSEVDMUZSbUpsYjFjRFZUeHJSaWRtWm1pSVdNREJBekdWazVPRmhrazhPYUdLVit4M0p6c3pLQ0xRUUFFYU1qajNqYVkyQmtZR0FBNHYyeWllM3gvRFpmR1poWkdFRGdzWkQ5TWdUOW40RTVpQm5FNVdCZ0FsRUFBUXdJZ2dBQUFIamFZMkJrWUdCbStNOEFKSU1Za2htU0dZOHpBRVZRQUJNQVJza0M2Z0FBQTFJQUFBSXFBSm9BWXdBQUFBQUFBQUEyQUdoNDJtTmdaR0JnWUdhUVp3RFJERkFTQ1FBQUE3OEFKZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBBQUFvQUFBQUFCRXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBtMk50WVhBQUFBRTRBQUFBTWdBQUFEd0FaQUJ5WjJ4NVpnQUFBV3dBQUFENEFBQUJHSkpCcDdWb1pXRmtBQUFDWkFBQUFDMEFBQUEyS0hQQ1NtaG9aV0VBQUFLVUFBQUFIZ0FBQUNRR2dnTFFhRzEwZUFBQUFyUUFBQUFRQUFBQUVBbm5BUVZzYjJOaEFBQUN4QUFBQUFvQUFBQUtBTHdBWUcxaGVIQUFBQUxRQUFBQUdBQUFBQ0FBQndBY2JtRnRaUUFBQXVnQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRHRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXFtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTU5neU0vd0g4cGtoMGtocS9nT0ZBYzJDRE00QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS2FqTFkvdjhQNUd1QTZQODMveDhEcXdJQ0FJeXpDTkFBQUhqYVkyQmtLUG5QeU5qQXpNQWd4Y0RBS0M0bXdzN0d6OGpHemlZR1pQSXpxcWtEb2JtYVBhTVpZdzR2Tzd1akZic2xNMk5ZR2hjN2I2c3BIN2NxRTVNdW54a3pBeU9UQUp0SmprRGhzZDZmc1p3Q1RJeEp0WW9LdGNsRnphcE5RQ01aUElEbWgwRE1Gd2FhS2k3R0xzTEd6c2VvWm01aXoyakhhSzdIcUs1bWFtWWUwMklHTWxCVHlTeFBtcEdaUHlTR2tiblFqWk9SalprQllsclVRb2ZFWkNZdVpoWkJuL2NManp5MTRtTGpaR0lBQWlZR1Q0WXlaZ3ZHYmdadUJuR2dkWXBzYWlabTRvcG1Za0JMa05qTVFuOWplU1VsZVppVzhnREp2OUZBa3BkcE1WQ0VNWUtSUTRXREVVUThnTE1ZR0FBTk1Dd1JlTnBqWUdSZ1lBQmlqZXpsN2ZIOE5sOFptRmtZUU9DeGtQMHlCUDJma2RtQ0djVGxZR0FDVVFEK1ZnaG1BQUFBZU5wallHUmdZR2I0endBa214ZzhHRHlaTFJpQUlpaUFCUUE4ZHdKYUFBQUMwd0FBQWNrQWRBSEpBRWdEZ2dCSkFBQUFBQUF3QUdBQWpBQUFlTnBqWUdSZ1lHQmhrR1pnWWdBQlJnWTBBQUFEalFBa2VObzlqREdyd2pBVWhiOWlGZTBiSEFTSE4wandCNFJLSDdpNE9UaTVPcnpObWlBZG1rcGFpeTdpVC9jMkJHL2c4TjF6emcyUThTSmhtSVI1MEdGU2VmUElZMzVZUko2SXY0cWM4Y3VhRVVrNkUyZkZMbkxLbFAvSVk1YVVrU2ZpUHlKbi9QSGVOL1h0M2xtdmpvMngzbDFxdnoxWjMxYU5VeHVkRCt2Qk91dlBuVFdxZkNyVFYyMS9yVldoYzEyd3A2SG14cDBPaTBkeEZNY0VkbHdrODJ3NWhiMmxrc3hKWjRNbS82WUhTVjFvbk1NdlJob2xUMUZETHpldDZGVzZpaUxjYVlvUFdLd3VTd0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQzBBQUFBMktZL0NKV2hvWldFQUFBSkFBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbUFBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDYUFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKd0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGkyb04zWDhiejIzeGxZR1poQUlISFF2YkxrR21XVU1ZN1FJcURnUW5FQXdBeGF3bWhBQUFBZU5wallHUmdZTmI2WThuQXdCTEswTWZRejVUTUFCUkJBVXdBVW9BRFFnQUVWUUFBQXZJQWpnQUFBQUFBVkFBQWVOcGpZR1JnWUdCaU1HVUEwUXhRRWdrQUFBWEtBRHNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXOTBuR050WVhBQUFBRTRBQUFBTXdBQUFFUUFld0VnWjJ4NVpnQUFBV3dBQUFGTUFBQUJqUE53SkpOb1pXRmtBQUFDdUFBQUFDOEFBQUEyS0VmQ1AyaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR053SjFhRzEwZUFBQUF3Z0FBQUFRQUFBQUVBajlBTlpzYjJOaEFBQURHQUFBQUFvQUFBQUtBTlFBaUcxaGVIQUFBQU1rQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQXp3QUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TXVReWMvOEg4cG01R2RIVS9BY0tBd0REN3d6N2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VROEdkSVpjdi8vUjdEKzcvZy8rLzgwc0Zvd0FBRHNod3VWQUhqYVZWRExUc0pRRUoyWlcxb2dXQVNsRmR0VWFXTUxpQkI1dE1CVkVoY1NJeXBxNGtJa1NHVGpqeGcrRFJNU0VxSWY0dGFGNE1XTm1rbE96bU5tY1FZUVJnQXdwUWt3Z0kyRWs1ZyswK1NySVRRSXgxcVdLSTd2VUFJT0hRRFVQVWRXZEMybG9pSjdzbUpoVVBGMVRZeUt0dXU1ZmxCRXp3L2NXZ3NEWDI4aDAxYU80NjQyZFhFcDZ4YVdSZTZKSVJhcmNsT1NUSHk2MkcrRUdCWGlqOFpSM3ExS05KNk5HUm81SllGUzJxSGhaYkZ4L0xDME9XRXQ3d2owZTZQbW1zcG84RElncVJCZkwrSzhMU0VMNXc1UGgwUzd0T01taUNKaHpicmkzUzdmNU5zUnoyb2FCM1dSTWx1TExqNnd5Q3ZWSDNobHBxbGtzdGxNVmcyUkxDb0R3cDBvSHNNMzJCTkMvTU12b2V1cHFLZiswVXJLRjExRXhjQkNGcjFucXBRODQyWDhKYmZ0M25sVFR0NmM5RG1XRm5QTXB1MlF6VmkvOXZtWHpqclh4T3BiaGs5c0NOL3JyRDNyZU5wallHUmdZQUJpWStkeTMzaCttNjhNekN3TUlQQll5SDRaZ3Y2dno4ekRkQnpJNVdCZ0Fva0NBUEJCQ0tjQWVOcGpZR1JnWU9iK3p3QWs0eG5rR0FTWmVSaUFJaWlBQlFBdXZ3RzBBQUFDVUFBQUFTNEFZd0lnQUI0RFh3QlZBQUFBQUFBT0FJZ0F4Z0FBZU5wallHUmdZR0JoOEdGZ1pnQUJSZ1kwQUFBSWJRQldlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVWUFBb0FBQUFBQmZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0TldOdFlYQUFBQUU4QUFBQU1nQUFBRHdIVGYxYVoyeDVaZ0FBQVhBQUFBSklBQUFDdVBPMnY1Tm9aV0ZrQUFBRHVBQUFBQzhBQUFBMktBSENSMmhvWldFQUFBUG9BQUFBSUFBQUFDUUZ2Z0diYUcxMGVBQUFCQWdBQUFBUUFBQUFFQW44QUtkc2IyTmhBQUFFR0FBQUFBb0FBQUFLQWNJQTFHMWhlSEFBQUFRa0FBQUFHQUFBQUNBQUJ3QllibUZ0WlFBQUJEd0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1WOWtadmdQNURNek1JS0VHUkVxL2dPRkFRSGZEaWtBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZelgvei9IOGhQQTlIL1ovOHhBcXNDQWdDbFV3bWxBQUI0MmtXUndXN1RRQlJGL1dhY21TUk9QSFpzajF2SGRaTTR0b09VSm0zaU9GSXdTWndBYWlpMFJVS3RDaWdWU04yd1FKVVFFdUlqUUVJczJQSVo3UHNEZkV3WGJGckdGUkx6ZG5QZmsrNjVWd0xwNExhUDNxSGYwbHlTQURNZ1ZBWGFDcU1wRExuTkNlWGJNSVVaOWttWTJNTXBqTVgvZ05zcStHRVVKdU93RHlwaU1FdzRpZURuUkpNMXA1VHRkU1lBYlN2RXdMWVpZKzBtM3VxeHB4NHkySE5tcVh6aDMwc0JmQzUweldPc1Z2UEtSZWM4bCtIN3pkVVRmUjZiU3h6NlhnTzFTYVNVRU1nSDFvL3JVOXlpY0hwV2o4S2cvVitDelhEbmk5d3FnaVFla3JxM095aUFLNmtuTFhNYVFVTHVTSVJqazFDYkQza2lBR1lDc2dkUk1zN0hBMXRRaVFVOGd5UVNVSVRtRVhCN2tLK2k1bVhwdzZmK1doWitkUTVxemRXYlp1cTduTnJqVlhhR2NNYjAxVmxuVk1WT3JXckJ0ejRHMDRxZFpjUFNkQWdqYitGV0tIeSt5Zm92TWJLNlcwM0RVTHh5QVlIaWJ1NDJYZzlsT0QyK09EVFlRd3h0cm5IUTlKcy92NWdTK0RKMFJtRTJQeHBEMEdEVk83YmQyMnYwVmZTMGtrNEVtODFOR3VWV1NZNll6SEF5aXNOSUFLdlFoeDdrM25NMGsyRmlrWDh3ZVZ0NUhHTlJyTTJwS0ZjRWNIY2tTdWJvcEdWWGgvWEpSdjNSU1hxT29Hd3dpcGpodFpRQ0xTc0VPS3RFWG5jR01xTjJBVFVTLzBIVGJWZW1hWEZTUUc4WGp6MWE0QUJrdllHaEhneWVJWG5QaWVHU29nMjVlUEVtOEk1bGlQZDkvK2orVmttMVhJQjV6MVFBSVczcDhnWkEzQzNyMmViYU1ad1JtdDRmZkl5MWdIUU9WKyt4bkZiVVJWcmFEMTY4R2h3aXZFNnpwdWFJT1A0QzByVmN1SGphWTJCa1lHQUFZczk5VnVMeC9EWmZHWmhaR0VEZ3NaRDlNZ1Q5WDVmcEdOTkZJSmVEZ1Fra0NnQUFDUW1HQUhqYVkyQmtZR0JtK00vQXdNQjBqRUhuL3dXbWZnYWdDQXBnQVFCbjJ3UmRBc1lBQUFJNkFFc0NPZ0FzQXNJQU1BQUFBQUFBWmdEVUFWd0FBSGphWTJCa1lHQmdZUWhuWUdJQUFVWUdOQUFBQ1drQVlIamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b0NDeGRXRmdZbVhxQXRoRkdXd2pKMFJDcWpyMmQvZGhQUFFOVitkKzJFRE5Ed1gzSzVnbHZWOUpKZTdCRlZQbW1TZmkzakxYTEhqbmlhSjhsdVNWajh5bE5KK1pLMTc0eWp5Ui9EdHp6WXJmVFhDWDYyQ2oyZ1Zqb3o4NTE2MzNOdlpkOEdxcG0rUzMxdHQ0R0t4Ung1c3lZOWVQWjZkYTNlaVdEUUhIaFNzRGxvaGlKNGxKN0RsSjUraFlzMDlKTHh3a1Z5elJOUC82cmZRK2JRN3BKeU9iSXpkUnd5aUxYdlFzVzBXYlhtcmFQOHVoTC9jQUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU4wQUFvQUFBQUFBK0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRTBBQUFCZ3FvWmlPV050WVhBQUFBRkVBQUFBTXdBQUFEeWVOV1NsWjJ4NVpnQUFBWGdBQUFDb0FBQUFzTkZjOEl0b1pXRmtBQUFDSUFBQUFDd0FBQUEyS012Q2hXaG9aV0VBQUFKTUFBQUFIZ0FBQUNRR2x2L2thRzEwZUFBQUFtd0FBQUFNQUFBQURBaHpBSUJzYjJOaEFBQUNlQUFBQUFnQUFBQUlBRGdBV0cxaGVIQUFBQUtBQUFBQUZ3QUFBQ0FBQlFBamJtRnRaUUFBQXBnQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBRGFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzZzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUFCQmdZSEdEdWx1Q3lkZ1UzSjVvRUJzK0lmSXdZR1prWG1jMEJoUm9UcS8vOFpHQUExM3crL0FBQUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVptUmdVcko1WVBEL1B3TURoTDU3VlA0U1dCVVFBQUNzQkFuWEFIamFZMkJrOEdjb1ozWm03R1JRWkdCZzVHTmsxMk5XQjVJaWJPeHNhdXAyak9aeXpPSkEwc1RNM0V3TXFDbzF3am94SU16Y3c1K1pqWWVabDVFeEpjSW1JU2pNMUNPQW1ZMmJtWTh4SWJLSGhjbmUzNXFSSmNtYVI1YVJrVmNHU1lCYkRpakF3TWhneUtET2FNSmt3OEFIdEkrWlRZOVIzVndZWkEranVCaWo1a0YyQVRrbTFuWVdDVmtKWlVZbXhzZi9Ja1NZZWJrRUdIZnpLVEl5eWtseU1BQUFZL0VZbUhqYVkyQmtZR0FBNGx1MlhySHgvRFpmR1poWkdFRGdzWkQ5TW1TYWVTS1REWkRpWUdBQzhRRDJRQWYzZU5wallHUmdZRmI4WXdRa0p6SVlNc2d5T3pNQVJWQUFNd0JDWUFLQUFBQURrUUFBQTVFQVR3RlJBREVBQUFBQUFEZ0FXSGphWTJCa1lHQmdabEJpQU5FTVVCSUpBQUFFQ2dBcEFIamFUWXc5YjhJd0VJYWZpQVNKZE9oU2RlZ0FIcGl0b0ZSaVkyRmdZbVhxQXRpZ0RIR1FIU0pGcWpyeXUzdTRIbnJENlhrLzdvQ1NIektlay9FYTkzTnlDbEYvWFBEQ1crS3BxRVhpa2crV1RNanltVGh6Tm9selNiNFNGN3h6U1R3Vi96dHh5U2VQYmRmZTdyMzFhdDhaNjkyNURlUDZZSDFvT3FkV3VvcDZaNTMxeDk0YWRScVZHWm93WEZ0VjYwclhiT2xvdVhHbngrSlI3TVV4a1IxbnlRSWphdzdSQ1RTU09tbXQwRlQvOHAza0xuYU84Wk9SemtrU0pUVElWWkI5bGJhaWpwZWEraGZ6ZVRCUEFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwNFdOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDVVoyeDVaZ0FBQVdRQUFBQ29BQUFBcUwvc0RlVm9aV0ZrQUFBQ0RBQUFBQzhBQUFBMktCekRKV2hvWldFQUFBSThBQUFBSFFBQUFDUUdCd0lpYUcxMGVBQUFBbHdBQUFBSUFBQUFDQVYyQUNSc2IyTmhBQUFDWkFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKc0FBQUFGZ0FBQUNBQUJRQTBibUZ0WlFBQUFvUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm0yczA0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmtadmdQNURORHBKSFUvQWNLQXdEbzl3MHRlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aU8vLzlEeVA4SHdId0dBRktYQnAwQUFBQUFBZ0FrLy84QzRRTGRBQzhBTWdBQU53RTJOeklXRnhNVUZqTTJGZ1l2QVFjbkppYzBOaGNXTmpjdkFTRUhCaFFXRnpZWERnRXZBUWNtSnpRMk16NEJOek1EdHdGbEJoUU5CZ0UrRmkwVkFRd0ZkSUFJQlFFTkN4TTBBd2tIL3Y5T0RSd1REUU1CRFFWbldBd0JEQWtpUHBucklYWUNWaEFCQ1EvOWdCWVBBeDBIQVFNREFRSUlEd2NCQVF3WFprV0VGQ1FRQVFJUERnWUJBd01CQ2c4R0FTUElBVklBQUFCNDJtTmdaR0JnQU9LR2h4TDE4ZncyWHhtWVdSaEE0TEdRL1RJRS9mOC8wME9tdTBBdUJ3TVRTQlFBS2VNTEh3QjQybU5nWkdCZ1p2alBBQ0laVkJqa21SNHlBRVZRQUJNQU5Zd0NNQUFBQUFKMkFBQURBQUFrQUFBQUFBQlVBQUI0Mm1OZ1pHQmdZR0l3Qm1JUVlHUkFBd0FGcndBNkFBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi41NzcwMTIsLTU5LjE3NTg3MilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjE1Mjc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTU5LjE3NTg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctNTkuMTc1ODcyJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01NS4xMDUwMTMnIHk9Jy02Mi43OTEyMzYnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzNi40ODgzLC00Mi43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC01OS4xNzU4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTU5LjE3NTg3Mic+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3NS4zMjM4LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTU5LjE3NTg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctNTkuMTc1ODcyJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01NS4xMDUwMTMnIHk9Jy02Mi43OTEyMzYnPu6AsDwvdGV4dD4KPHJlY3QgeD0nLTYyLjU3NzAxMicgeT0nLTU3Ljk4MDQxOScgaGVpZ2h0PScuMzk4NDg0JyB3aWR0aD0nMTAuMjY3MDcxJy8+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTE0LjQwOTMzLC00Mi43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC01OS4xNzU4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTU5LjE3NTg3Mic+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTUuMTA1MDEzJyB5PSctNjIuNzkxMjM2Jz7ugLDugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTYuNDA5NDItNi40MDk3M0wzMS42NDUzNi0zMS42NDE3NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE0LC0wLjcwNzAzLDAuNzA3MDMsMC43MDcxNCwzMS44MjIxNCwtMzEuODE4NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuMzI2ODcsLTI3LjM1ODQ0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC01OS4xNzU4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTU5LjE3NTg3Mic+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTcuOTEwNDI4JyB5PSctNjIuMTgyMzg5Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTUzLjc0NTQ1OScgeT0nLTU5LjE3NTg3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTAuNjMyMTE2JyB5PSctNTkuMTc1ODcyJz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy00Ni40OTUxNjUnIHk9Jy01OS4xNzU4NzInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg2Ni45OTYxNCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2Ni44NzExNCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyOC45Mjg3Nyw1LjQ0OTMxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC01OS4xNzU4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTU5LjE3NTg3Mic+z5E8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTU3Ljc2NjA3MScgeT0nLTU3Ljc5MzU1OSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTMuNzcwNjAxJyB5PSctNTkuMjYwMjg3Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTQ5LjYwNTYzMicgeT0nLTU3Ljc5MzU1OSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDYuOTA3Mzc3JyB5PSctNTcuNzkzNTU5Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy00My4yMzg4MicgeT0nLTU3Ljc5MzU1OSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNzAuNTExNjYtOS45NjUwN0w0OC44MzEyNS0zMS42NDE3NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE1LDAuNzA3MDMsLTAuNzA3MDMsMC43MDcxNSw3MC4zMzQ4NywtMTAuMTQxODMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjcwNzE1LC0wLjcwNzAzLDAuNzA3MDMsLTAuNzA3MTUsNDguNjU0NDYsLTMxLjgxODUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTTM4LjYxNjc0LTI2LjcwMjQySDgxLjkyODMyVi0xMy42MDgyN0gzOC42MTY3NFonIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQxLjYxNjc0LC0yMS45NTI0MiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNTkuMTc1ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02Mi41NzcwMTInIHk9Jy01OS4xNzU4NzInPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTAuODI2NjczJyB5PSctNTkuMTc1ODcyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny43MTMzMycgeT0nLTU5LjE3NTg3Mic+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDMuMDQ2NzQ2JyB5PSctNjIuMTgyMzg5Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM4Ljg4MTc3NicgeT0nLTU5LjE3NTg3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMzUuNzY4NDMzJyB5PSctNTkuMTc1ODcyJz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zMS42MzE0ODMnIHk9Jy01OS4xNzU4NzInPikpPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTg4Ljg4Njg0LTguNDA5NkwxMTEuNDM3NzMtMzAuOTU3MjMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNCwtMC43MDcwMywwLjcwNzAzLDAuNzA3MTQsMTExLjYxNDUyLC0zMS4xMzM5OSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNOTQuMjE0MDctMjUuMTEwMTdIMTA2LjQ2NDA3Vi0xNC4yMzMwN0g5NC4yMTQwN1onIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDk3LjIxNDA3LC0yMS42MTAxNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNTkuMTc1ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Mi41NzcwMTInIHk9Jy02MC44NTgxMTYnPuKIvDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNjIuNTIxNjYzJyB5PSctNTguNjc3NzQnPj08L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTA3LjY1MzgtNDAuMjM4M0g0OS4wNDM4NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDcuNDAzOCwtNDAuMjM4MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsNDguNzkzODQsLTQwLjIzODMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjU0MzAzLC00OC4zOTQyNiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNTkuMTc1ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy01OS4xNzU4NzInPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU3LjkxMDQyOCcgeT0nLTYyLjE4MjM4OSc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy01My43NDU0NTknIHk9Jy01OS4xNzU4NzInPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUwLjYzMjExNicgeT0nLTU5LjE3NTg3Mic+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zOC44ODE3NzYnIHk9Jy01OS4xNzU4NzInPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM1Ljc2ODQzMycgeT0nLTU5LjE3NTg3Mic+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzEuNjMxNDgzJyB5PSctNTkuMTc1ODcyJz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \node  (1) {$A'$};
        \node  [below right = of 1] (3) {$A$};
        \node  [above right = of 3] (2) {$\underline {A'}$};
        \node  [below right = of 2] (4) {$A''$};
        \draw  [->,morphism] (1) to node[swap] {$f^{*}(g)$} (3);
        \draw  [cover,morphism] (1) to node {$\vartheta _{f^{*}(g)}$} (2);
        \draw  [>->,morphism] (2) to node[desc] {$\mathsf {Img}(f^{*}(g))$} (3);
        \draw  [->,morphism] (2) to node[desc] {$\cong $} (4);
        \draw  [>->,morphism] (4) to node {$f^{*}(\mathsf {Img}(g))$} (3);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Since isomorphisms are stable under pullback, <fr:tex
display="inline"><![CDATA[f^{*}(\mathsf {Img}(g))]]></fr:tex> is also an isomorphism.
      Thus, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f^{*}(g))]]></fr:tex> is an isomorphism.
      Then since <fr:tex
display="inline"><![CDATA[f^{*}(g)]]></fr:tex> is the composite of two covers, it is itself a cover.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>746</fr:anchor><fr:addr
type="machine">#290</fr:addr><fr:route>unstable-290.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is regular, then by <fr:ref
addr="ct-000N"
href="ct-000N.xml"
taxon="Lemma" />, the unit <fr:tex
display="inline"><![CDATA[\vartheta \colon \mathsf {id}\to \mathsf {Img}]]></fr:tex> consists of <fr:link
type="local"
href="ct-000M.xml"
addr="ct-000M"
title="Extremal epimorphism">covers</fr:link>.
      Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be any morphism in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g\colon B'\to B]]></fr:tex> be an object in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>.
      By <fr:ref
addr="ct-000Q"
href="ct-000Q.xml"
taxon="Lemma" />, <fr:tex
display="inline"><![CDATA[g]]></fr:tex> can be factored as <fr:tex
display="inline"><![CDATA[\vartheta _{g}\mathsf {Img}(g)]]></fr:tex>.
      Form the following pullbacks.
      Note that since covers are stable under pullback by hypothesis, <fr:tex
display="inline"><![CDATA[\widehat {\vartheta _{g}}]]></fr:tex> is also a cover.
      Then by the <fr:link
type="local"
href="ct-0008.xml"
addr="ct-0008"
title="Pasting lemma of pullbacks">pasting lemma</fr:link>, the composite <fr:tex
display="inline"><![CDATA[f^{*}(\mathsf {Img}(g)) \circ  \widehat {\vartheta _{g}}]]></fr:tex> is isomorphic to <fr:tex
display="inline"><![CDATA[f^{*}(g)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="da7334f99682b52474eec73093f5ecbf"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMS4wMzI5OTZwdCcgaGVpZ2h0PScxMjUuMTE0MDkycHQnIHZpZXdCb3g9Jy03MiAtNzIgMTM0LjAyMTk5OCA4My40MDkzOTUnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtZXg3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFMb0FBb0FBQUFBQTB3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdjR0JhNkdOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DMloyeDVaZ0FBQVd3QUFBQW9BQUFBS0xUdGE1Wm9aV0ZrQUFBQmxBQUFBQ3dBQUFBMktiekRVV2hvWldFQUFBSEFBQUFBSHdBQUFDUUhvL2pOYUcxMGVBQUFBZUFBQUFBSUFBQUFDQWExQUF4c2IyTmhBQUFCNkFBQUFBWUFBQUFHQUJRQUFHMWhlSEFBQUFId0FBQUFGd0FBQUNBQUJBQUhibUZ0WlFBQUFnZ0FBQURQQUFBQk9CRjlLb053YjNOMEFBQUMyQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1qbUtjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UxQjhvTmtacEV2Umd3TXpDTGM1NERDakFnVi8vOHpNQUFBSHVJUUJ3QjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytRK1MvLytIa1BMendQSU1BR2loQjU4QUFBQUJBQXdDUmdTQ0F4UUFCUUFBQVFVSEpRVW5Ba2NDT3dyOXovM05DQU1VcmlDTGl5QUFBQUI0Mm1OZ1pHQmdBT0xqN1hXVzhmdzJYeG1ZV1JoQTRMR1EvUUprbXFXSldRUkljVEF3Z1hnQS8wY0gvWGphWTJCa1lHQVcrV0xFd01EU3k4RER3TTNTeEFBVVFRRk1BRCtHQW5BQUFpZ0FBQVNOQUF3QUFBQUFBQlFBQUhqYVkyQmtZR0JnWW1CakFORU1VQklKQUFBQk13QU1BSGphVFl3OWI4SXdFSWFmcUFsUzA2RkwxYUVEOWREWkNrb2xOaFlHSmxZbUZzQlhsQ0VPY2tJRUV1clkzOTNEOWRBYnpzLzdjUVpLdnNtNFQ4WnozUGZKS1ZUOWNjRVRMNGtucXQ0VGw3enh3UU5aL3FqT2xFWGlYSk50NG9KWHZoSlAxTDhsTHZua1o5bTFwL01nd2F3N0o4RWZXcm5NTnhMNnB2Tm1acXVvVitJbDdBWnhabjgxYm16NjhkaWEybGEyWmtsSHk0a3pBMExBc0ZiSFJmWWNOQk11ek5sRXA2ZlIxR3RyaHFYNmw2LzA5Ykd6aXo4NTdleTU2bmFNZXRYclBtcmJVTWRMUy8wTDJCTXdFd0I0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzODtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUVlBQW9BQUFBQUJNd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFc5MG5HTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWV3RWdaMng1WmdBQUFXd0FBQUZNQUFBQmpQTndKSk5vWldGa0FBQUN1QUFBQUM4QUFBQTJLRWZDTTJob1pXRUFBQUxvQUFBQUhnQUFBQ1FHTndKMWFHMTBlQUFBQXdnQUFBQVFBQUFBRUFqOUFOWnNiMk5oQUFBREdBQUFBQW9BQUFBS0FOUUFpRzFoZUhBQUFBTWtBQUFBR0FBQUFDQUFDQUJOYm1GdFpRQUFBendBQUFET0FBQUJPQWQxS3Ixd2IzTjBBQUFFREFBQUFBd0FBQUFnQUFNQUFIamFZMkJtc21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcDZNdVF5Yy84SDhwbTVHZEhVL0FjS0F3REQ3d3o3ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVE4R2RJWmN2Ly9SN0QrNy9nLysvODBzRm93QUFEc2h3dVZBSGphVlZETFRzSlFFSjJaVzFvZ1dBU2xGZHRVYVdNTGlCQjV0TUJWRWhjU0l5cHE0a0lrU0dUamp4ZytEUk1TRXFJZjR0YUY0TVdObWtsT3ptTm1jUVlRUmdBd3BRa3dnSTJFazVnKzArU3JJVFFJeDFxV0tJN3ZVQUlPSFFEVVBVZFdkQzJsb2lKN3NtSmhVUEYxVFl5S3R1dTVmbEJFencvY1dnc0RYMjhoMDFhTzQ2NDJkWEVwNnhhV1JlNkpJUmFyY2xPU1RIeTYyRytFR0JYaWo4WlIzcTFLTko2TkdSbzVKWUZTMnFIaFpiRngvTEMwT1dFdDd3ajBlNlBtbXNwbzhESWdxUkJmTCtLOExTRUw1dzVQaDBTN3RPTW1pQ0poemJyaTNTN2Y1TnNSejJvYUIzV1JNbHVMTGo2d3lDdlZIM2hscHFsa3N0bE1WZzJSTENvRHdwMG9Ic00zMkJOQy9NTXZvZXVwcUtmKzBVcktGMTFFeGNCQ0ZyMW5xcFE4NDJYOEpiZnQzbmxUVHQ2YzlEbVdGblBNcHUyUXpWaS85dm1YempyWHhPcGJoazlzQ04vcnJEM3JlTnBqWUdSZ1lBQmlZK2Z5MUhoK202OE16Q3dNSVBCWXlINEJndjZ2ejh6RGRCekk1V0JnQW9rQ0FQTTFDTE1BZU5wallHUmdZT2IrendBazR4bmtHQVNaZVJpQUlpaUFCUUF1dndHMEFBQUNVQUFBQVM0QVl3SWdBQjREWHdCVkFBQUFBQUFPQUlnQXhnQUFlTnBqWUdSZ1lHQmg4R0ZnWmdBQlJnWTBBQUFJYlFCV2VOcE5qRDF2d2pBUWhwK29DVkxEd0lJNk1MUWVPbHRCWVdCaVlXQmlaV0lCN0tJTWNaQWRJaUZWSGZuZFBZd0h6dExwZVQvT1FNa2ZHWS9KbU1UOW1KeEMxSk1MeGt3VGowUjlKUzZaOGMwYldmNHV6aWVyeExrays4UUZIL3drSG9uL203aGt3WDNkdFpkcmI3M2Fkc1o2ZDJwRFdPNnNEMDNuMUZ4WFVXK3NzLzdRVzZPT04yV0dKZ3puVnRXNjBqVnJPbG91WE9teGVCUmJjVXhreDBteUlHL0pManFCUmxJbnJUbWE2aVhmU081aTV4Qi9NdEk1Y3BOdEdPUXF5RDVMVzFISFMwMzlEK3B0TURzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVZQUFvQUFBQUFCZkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjROV050WVhBQUFBRThBQUFBTWdBQUFEd0hUZjFhWjJ4NVpnQUFBWEFBQUFKSUFBQUN1UE8ydjVOb1pXRmtBQUFEdUFBQUFDOEFBQUEyS0FIQ08yaG9aV0VBQUFQb0FBQUFJQUFBQUNRRnZnR2JhRzEwZUFBQUJBZ0FBQUFRQUFBQUVBbjhBS2RzYjJOaEFBQUVHQUFBQUFvQUFBQUtBY0lBMUcxaGVIQUFBQVFrQUFBQUdBQUFBQ0FBQndCWWJtRnRaUUFBQkR3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRkRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXFtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVY5a1p2Z1A1RE16TUlLRUdSRXEvZ09GQVFIZkRpa0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5cVl6WC96L0g4aFBBOUgvWi84eEFxc0NBZ0NsVXdtbEFBQjQya1dSd1c3VFFCUkYvV2FjbVNST1BIWnNqMXZIZFpNNHRvT1VKbTNpT0ZJd1Nad0FhaWkwUlVLdENpZ1ZTTjJ3UUpVUUV1SWpRRUlzMlBJWjdQc0RmRXdYYkZyR0ZSTHpkblBmays2NVZ3THA0TGFQM3FIZjBseVNBRE1nVkFYYUNxTXBETG5OQ2VYYk1JVVo5a21ZMk1NcGpNWC9nTnNxK0dFVUp1T3dEeXBpTUV3NGllRG5SSk0xcDVUdGRTWUFiU3ZFd0xZWlkrMG0zdXF4cHg0eTJITm1xWHpoMzBzQmZDNTB6V09zVnZQS1JlYzhsK0g3emRVVGZSNmJTeHo2WGdPMVNhU1VFTWdIMW8vclU5eWljSHBXajhLZy9WK0N6WERuaTl3cWdpUWVrcnEzT3lpQUs2a25MWE1hUVVMdVNJUmprMUNiRDNraUFHWUNzZ2RSTXM3SEExdFFpUVU4Z3lRU1VJVG1FWEI3a0sraTVtWHB3NmYrV2haK2RRNXF6ZFdiWnVxN25OcmpWWGFHY01iMDFWbG5WTVZPcldyQnR6NEcwNHFkWmNQU2RBZ2piK0ZXS0h5K3lmb3ZNYks2VzAzRFVMeHlBWUhpYnU0MlhnOWxPRDIrT0RUWVF3eHRybkhROUpzL3Y1Z1MrREowUm1FMlB4cEQwR0RWTzdiZDIydjBWZlMwa2s0RW04MU5HdVZXU1k2WXpIQXlpc05JQUt2UWh4N2szbk0wazJGaWtYOHdlVnQ1SEdOUnJNMnBLRmNFY0hja1N1Ym9wR1ZYaC9YSlJ2M1JTWHFPb0d3d2lwamh0WlFDTFNzRU9LdEVYbmNHTXFOMkFUVVMvMEhUYlZlbWFYRlNRRzhYanoxYTRBQmt2WUdoSGd5ZUlYblBpZUdTb2cyNWVQRW04STVsaVBkOS8raitWa20xWElCNXoxUUFJVzNwOGdaQTNDM3IyZWJhTVp3Um10NGZmSXkxZ0hRT1YrK3huRmJVUlZyYUQxNjhHaHdpdkU2enB1YUlPUDRDMHJWY3VIamFZMkJrWUdBQVlzOTlWdnJ4L0RaZkdaaFpHRURnc1pEOUFnVDlYNWZwR05ORklKZURnUWtrQ2dBQy9RbVNBSGphWTJCa1lHQm0rTS9Bd01CMGpFSG4vd1dtZmdhZ0NBcGdBUUJuMndSZEFzWUFBQUk2QUVzQ09nQXNBc0lBTUFBQUFBQUFaZ0RVQVZ3QUFIamFZMkJrWUdCZ1lRaG5ZR0lBQVVZR05BQUFDV2tBWUhqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLSS9CTG1ob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0o1Ui9PUHh2UGJmR1ZnWm1FQWdjZEM5Z3NROUg4ZDVoREdvMEF1QndNVFNCUUFMM0VLT2dCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQzBBQUFBMktZL0NHV2hvWldFQUFBSkFBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbUFBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDYUFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKd0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGkyb1AzR09QNWJiNHlNTE13Z01Caklmc0Z5RFJMS09NZElNWEJ3QVRpQVFBSml3aXVBQUFBZU5wallHUmdZTmI2WThuQXdCTEswTWZRejVUTUFCUkJBVXdBVW9BRFFnQUVWUUFBQXZJQWpnQUFBQUFBVkFBQWVOcGpZR1JnWUdCaU1HVUEwUXhRRWdrQUFBWEtBRHNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS012Q2VXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZHF6NGJ4dlBiZkdWZ1ptRUFnY2RDOWd1UWFlYUpURFpBaW9PQkNjUURBQmg2Q0xZQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzRBQUFBMktBN0NQbWhvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRoTXNDdWZqK1cyK01qQ3pNSURBWXlIN0JRajZQeVBUWldZUWw0T0JDVVFCQUFTckNPNEFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVrQUFvQUFBQUFCZlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDFGMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNYWjJ4NVpnQUFBV1FBQUFKWUFBQUN1SkhqY2Nsb1pXRmtBQUFEdkFBQUFDOEFBQUEyS0hMREEyaG9aV0VBQUFQc0FBQUFIZ0FBQUNRR1hnSWxhRzEwZUFBQUJBd0FBQUFVQUFBQUZBNm9BS3RzYjJOaEFBQUVJQUFBQUF3QUFBQU1BV0lDREcxaGVIQUFBQVFzQUFBQUdBQUFBQ0FBQ1FBNmJtRnRaUUFBQkVRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRkdBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaFp2Z1A1RE5EcEpIVS9BY0tBd0Q3MVExamVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZndS8vOERTY2YvLy84ZkFQTVpBRkxLQnFCNDJqWFJ2MDhUWVJ6SDhlZnpmTnZuYUdudktsZnVhcURYbEpZZVlGb0l2ZHdCaWNWUXFRaXgvS2hCZ28xRUV5U1NpRDlBWkdEb2dERWFHSXdKaVhGdzBNMDR1emc1TVRtNU9xaVQ4VTh3YlgyT2hPZFpubnh6dy92N09zWlp0dDNtUC9rUE5zeEdHZlBnZXFPR3FjZU5vbXVJWVNoMnpuWmMwM0M5WWFRVkVUZE0xMVFoNS82NFdJSlhwTTlZRi9Hb1FNbklkeU1TM0dsMEJCSHQxQjBLS2ExMk5kcXJSd25SNE1aS0JKRlFYK25OMy9RdVg0NGhwRFViaGtaSkJVVGdIWm9DUk15NzB3ZnhiQXhjVTRVL0Rtc0NtUk1zTVhtSVhXZzNTZkF2ekdKRGJFeVc2azdHRnJJdGJhRmJoV0xCRkJxRWtoYW52Ym9mNStic1RFNG9kUFltK1VIeHcxR1BuZFEwck5UdlVLTTJWd08vRXJ2MnBQVzZWMVVuckhmSGF6c2NoZkpCU2c5dUhkWjNPUitaK1ZvSkFPb0NIei9IcVZjQlg1eVkzZERDMWZHNUtiVVU4RGVBam1sNlhNbGU1dERPTnovUzAyci9BclYrZDRrd1kyREY5aC9xNU4vOVpwQ0tqQlNkaEpPelpiTWZiRnJ3Sks5Zm1JSWxGNUR6QW16WDg2OWhHcVluMTZId0pSTGhVQkFjeS9QVHowWXFQY0pBWVAvcXdKcnI1RVVncEFRcFh4bDhWTjU3UzFSelpyY1Bhb01EWWtaRmhKKzAvcW15V2RGeXE1dEFlV3hsTFZIUDc5N202QnNxMUJPZEFJL2NuK292Z280YkwzWm1uU1VLWlB2VmVaV1ROT2RzVUpwNzBqekI4cjY0ZXdadUNzVy9aOWFucnFhL3dpUmN1d0JGcXI4L1F0bUtTZWJ0ZmREODBOaG1vL1VwcVVuaVg0Yys1OHRiZStaRW9xTUwvRjUxSzZWTDNSaFJVdjcyVncrZVA3eVl2MDVrQ1FuTHk4MXYwaEdCaGRUaXpmUU5lMzBWMEdUYWYvUUJkMWQ0Mm1OZ1pHQmdBT0xqQWxhdDhmdzJYeG1ZV1JoQTRMR1EvUUlFL2Y4bHN6blRYU0NYZzRFSkpBb0FEZEFKOGdCNDJtTmdaR0JnWnZqUEFDVDlHVlQrWDJBMlp3Q0tvQUJXQUZVckE0a0FBQUoyQUFBREFBQWtBd2dBS3dMYkFETURUd0FwQUFBQUFBQlVBTEFCRGdGY2VOcGpZR1JnWUdCbHNHUmdaZ0FCUmdZMEFBQUdyUUJFZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbWV4Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNyB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy45MzEyNCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPkM8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuNDQ2MTgsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScyLjQ2NDgnIHk9Jy02MS4yMjYyNzMnPu6AsDwvdGV4dD4KPHJlY3QgeD0nLTUuNTkxODA4JyB5PSctNTYuNDE1NDU2JyBoZWlnaHQ9Jy4zOTg0ODQnIHdpZHRoPScxMC44NTE2NzEnLz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00Ny40Nzc5NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDcuNzI3OTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjI2Mzg5LC0yOC45NDM4MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1My4xNTU1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjY4Njc4IDBINDguMDk5OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTAuOTM2NzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4zNDk5NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDkuODg3NTcsNC41NjE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUuNTkxODA4JyB5PSctNTcuNjEwOTA5Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0uOTI1MjI0JyB5PSctNjAuNjE3NDI2Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nMy4yMzk3NDUnIHk9Jy01Ny42MTA5MDknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nNi4zNTMwODgnIHk9Jy01Ny42MTA5MDknPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PScxOC4xMDM0MjcnIHk9Jy01Ny42MTA5MDknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMjEuMjE2NzcnIHk9Jy01Ny42MTA5MDknPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nMjUuMzUzNzIxJyB5PSctNTcuNjEwOTA5Jz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTIuMjAxNzItNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMi40NTE3MiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMDU2NTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE4LjA1NTcxLC02NC45NjczMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUuNTkxODA4JyB5PSctNTcuNjEwOTA5Jz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nNi4xNTg1MzEnIHk9Jy01Ny42MTA5MDknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nOS4yNzE4NzQnIHk9Jy01Ny42MTA5MDknPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nMTMuNDA4ODI0JyB5PSctNTcuNjEwOTA5Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNTEuMjE1MDQtMTQuMjI2MzZILTQyLjY3OTE0Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02MS4xODM5OCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPkQ8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjM1MTY4LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMi40NjQ4JyB5PSctNjEuMjI2MjczJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00OC4wNzE0OSAwSC0xMi4yNTg5MScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTIuMzgzOTEsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMyLjc4NDc5LDQuNzg0MDMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01LjA3NDIxOCcgeT0nLTU5LjQ1MTIyMic+7oGjPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+z5E8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLS43ODA4NjcnIHk9Jy01Ni42MTQ2NDUnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS01Ni45MDU1LTYuNDA5NzNWLTQ3LjQ3Nzk1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsLTU2LjkwNTUsLTQ3LjcyNzk1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNLTQ2LjkwMzc4LTU2LjkwNTVILTEzLjc3Mzg1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMy44OTg4NSwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lam9pbj0nbWl0ZXInPgogPHBhdGggZD0nTTMuMzk3MTMgMEwuMjUgMS44NzQ5NFYwVi0xLjg3NDk0WicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMi45NTg0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUuNTkxODA4JyB5PSctNTcuNjEwOTA5Jz7PkTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctLjc4MDg2NycgeT0nLTU2LjYxNDY0NSc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \SpliceDiagramSquare {
          nw = C,
          ne = A,
          sw = \underline {B'},
          se = B,
          north = f^{*}(\mathsf {Img}(g)),
          east = f,
          south = \mathsf {Img}(g),
          north/style = {>->},
          south/style = {>->},
          nw/style = pullback,
        }
        \node  [left = of nw,pullback] (1) {$D$};
        \node  [left = of sw] (2) {$B'$};
        \draw  [cover,morphism] (1) to node {$\widehat {\vartheta _{g}}$} (nw);
        \draw  [->,morphism] (1) to (2);
        \draw  [cover,morphism] (2) to node[swap] {$\vartheta _{g}$} (sw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Thus, <fr:tex
display="inline"><![CDATA[f^{*}(g)]]></fr:tex> admits another cover-mono factorization.</fr:p>
    
      
      <fr:figure><fr:resource
hash="b9c08c521816bfce626332248a40053d"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIyNy4xODE0cHQnIGhlaWdodD0nMTUxLjY5NzQ4NHB0JyB2aWV3Qm94PSctNzIgLTcyIDE1MS40NTQyNjcgMTAxLjEzMTY1Nic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUEvUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMG1tTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM4QUFBQTBFOE96SDFvWldGa0FBQUNJQUFBQUMwQUFBQTJLSTNDYVdob1pXRUFBQUpRQUFBQUhnQUFBQ1FGTEFLNGFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dYZkFKcHNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEWUFhRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFnYm1GdFpRQUFBcHdBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNm1HY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFkSWxETTBBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pKajFuNEh4T0RNRGd4d0RBeU1mSXp1YnVCZ1lpckFwcWVzeHFxdXBtNW5iTVpxYkdZbUpzakVlQ1dwbFpWYmk0Tkt0NEdCa2szSlU5Rkt3WldHeFZmQlNkSlJpWTJSNmJ2WjFUMnlsaEhoVktnc1hDNWVKYkpSdHdZb1ZoYmFSc2laY0xKd01RTURJa0F5MGF3TFFMbWtnaDQwZFpKdWFQcU1KMkFJaE5YVTFJRU5jamxGY2pIRUMxRlJtSmxiMWNEVlR4clJpZG1abWlJV01EQkF6R1ZrNU9GaGtrOE9hR0tWK3gzSnpzektDTFFRQUVhTWpqM2phWTJCa1lHQUE0djJ5aWU3eC9EWmZHWmhaR0VEZ3NaRDlOZ1Q5bjRFNWlCbkU1V0JnQWxFQStSMElZZ0FBQUhqYVkyQmtZR0JtK004QUpJTVlraG1TR1k4ekFFVlFBQk1BUnNrQzZnQUFBMUlBQUFJcUFKb0FZd0FBQUFBQUFBQTJBR2g0Mm1OZ1pHQmdZR2FRWndEUkRGQVNDUUFBQTc4QUpnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVxZm01dURrNnZEMjZ3SjBxR3BwTFhvSXY1MGIwUHdCZzdmUGVmY0FCa3ZFb1pKbUFjZEpwVTNqenptaDBYa2lmaXJ5Qm0vckJtUnBETnhWdXdpcDB6NWp6eG1TUmw1SXY0amNzWWY3MzFUMys2ZDllcllHT3ZkcGZiYmsvVnQxVGkxMGZtd0hxeXovdHhabzhxbk1uM1Y5dGRhRlRyWEJYc2FhbTdjNmJCNEZFZHhUR0RIUlRMUGxsUFlXeXJKbkhRMmFQSnZlcERVaGNZNS9HS2tVZklVTmZSeTA0cGVwYXNvd3AybStBQlZNaTVEQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJRQUFvQUFBQUFCT1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZRjFRR050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFHU0FBQUJ2R0UwYno5b1pXRmtBQUFDK0FBQUFDOEFBQUEyS0kvQ2FHaG9aV0VBQUFNb0FBQUFIZ0FBQUNRR0xRSlBhRzEwZUFBQUEwZ0FBQUFNQUFBQURBamRBT0JzYjJOaEFBQURWQUFBQUFnQUFBQUlBSElBM20xaGVIQUFBQU5jQUFBQUdBQUFBQ0FBQmdCS2JtRnRaUUFBQTNRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRVJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbStzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWTBoblp2Z1A1RE5EcEpIVS9BY0tBd0FHaEEyeGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOER5YlQvLy8vUEJ2TVpBRld4QnNONDJpV1BRVzdUUUJpRjU4MjQ0OFNKUFhac2o5MlFoR2JjMkUyVnhGSGMyaXBVTmxCVlJEUkliWGRJQ0tsQ3NDaXc3SW8xRzFoMHg1cGJ3QVY2QWc3QklaQmFZcXIvTFg3cGZZdjNFWkRQZDFONlEzK1RKU0ZnQWx5M29QTTRLWkhKd09PNmZJZ1NSVjRoTHlJZTcrL2xRVmIvLzA4R0ZxSTRpZk1pVHFGMExwRGwwdE81amo4SFp0UHBkcDVPMVV1R3NiL0xQRjlZYm45N3crbjBuTllyMC9YRUc0dHJZY09Nem5aZXJCRzV5OUFlMk1MdEJrWTcvR1I2RGFiaDIrM1BVaDJPdXhtRm1pbkZFbWRvNktBMDk2dkxINWVQd0UydmlkUGgxcDd0cEJxMkp6WENFNnRCRWRyVk5maG1pNEVRUXNtN3V3bjlpaHN5STBlMTVYbzFUMUU3THFSLzd5aExXbUZ0UGtOeUw3ZVFRVjRNNE90RlhxUHJ5b0kvUUZIV29WOCtldGNmMHYxV3BtRzBrSVpOMVRTb25vYzg3S3dXSis4cE8zWTZweGZxeWFhalhQZjdGTDRXSEk2WHN0K2pCMXM3eDMycmlhdmIxY21TTmxrNzdZKzZvdEVUR3hRdzV2UGVoVDJpZUgzK2R1V0taK3lCU2dEZit2dkxpTGpTTUkvU3ErSGpDWkQwaFNEL0FOZGZQUmdBQUhqYVkyQmtZR0FBNGthVEIrcngvRFpmR1poWkdFRGdzWkQ5TmdUOVg0YzVoT2t5a012QndBUVNCUUFPT2dtYUFIamFZMkJrWUdCbStNOEFKRU1ZVXY5L1p6cktBQlJCQWN3QWFTWUVnUUFBQTFRQUFBSzhBSHNDelFCbEFBQUFBQUJ5QU41NDJtTmdaR0JnWUdid1pHQmlBQUZHQmpRQUFBZndBRkY0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktFZkNYMmhvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaVkrZHkzbmgrbTY4TXpDd01JUEJZeUg0Ymd2NnZ6OHpEZEJ6STVXQmdBb2tDQU9oaENJY0FlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWS9DUldob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMm9OM1Y4YnoyM3hsWUdaaEFJSEhRdmJia0dtV1VNWTdRSXFEZ1FuRUF3QXBpd21CQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVWUFBb0FBQUFBQmZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0TldOdFlYQUFBQUU4QUFBQU1nQUFBRHdIVGYxYVoyeDVaZ0FBQVhBQUFBSklBQUFDdVBPMnY1Tm9aV0ZrQUFBRHVBQUFBQzhBQUFBMktBSENaMmhvWldFQUFBUG9BQUFBSUFBQUFDUUZ2Z0diYUcxMGVBQUFCQWdBQUFBUUFBQUFFQW44QUtkc2IyTmhBQUFFR0FBQUFBb0FBQUFLQWNJQTFHMWhlSEFBQUFRa0FBQUFHQUFBQUNBQUJ3QllibUZ0WlFBQUJEd0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1WOWtadmdQNURNek1JS0VHUkVxL2dPRkFRSGZEaWtBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZelgvei9IOGhQQTlIL1ovOHhBcXNDQWdDbFV3bWxBQUI0MmtXUndXN1RRQlJGL1dhY21TUk9QSFpzajF2SGRaTTR0b09VSm0zaU9GSXdTWndBYWlpMFJVS3RDaWdWU04yd1FKVVFFdUlqUUVJczJQSVo3UHNEZkV3WGJGckdGUkx6ZG5QZmsrNjVWd0xwNExhUDNxSGYwbHlTQURNZ1ZBWGFDcU1wRExuTkNlWGJNSVVaOWttWTJNTXBqTVgvZ05zcStHRVVKdU93RHlwaU1FdzRpZURuUkpNMXA1VHRkU1lBYlN2RXdMWVpZKzBtM3VxeHB4NHkySE5tcVh6aDMwc0JmQzUweldPc1Z2UEtSZWM4bCtIN3pkVVRmUjZiU3h6NlhnTzFTYVNVRU1nSDFvL3JVOXlpY0hwV2o4S2cvVitDelhEbmk5d3FnaVFla3JxM095aUFLNmtuTFhNYVFVTHVTSVJqazFDYkQza2lBR1lDc2dkUk1zN0hBMXRRaVFVOGd5UVNVSVRtRVhCN2tLK2k1bVhwdzZmK1doWitkUTVxemRXYlp1cTduTnJqVlhhR2NNYjAxVmxuVk1WT3JXckJ0ejRHMDRxZFpjUFNkQWdqYitGV0tIeSt5Zm92TWJLNlcwM0RVTHh5QVlIaWJ1NDJYZzlsT0QyK09EVFlRd3h0cm5IUTlKcy92NWdTK0RKMFJtRTJQeHBEMEdEVk83YmQyMnYwVmZTMGtrNEVtODFOR3VWV1NZNll6SEF5aXNOSUFLdlFoeDdrM25NMGsyRmlrWDh3ZVZ0NUhHTlJyTTJwS0ZjRWNIY2tTdWJvcEdWWGgvWEpSdjNSU1hxT29Hd3dpcGpodFpRQ0xTc0VPS3RFWG5jR01xTjJBVFVTLzBIVGJWZW1hWEZTUUc4WGp6MWE0QUJrdllHaEhneWVJWG5QaWVHU29nMjVlUEVtOEk1bGlQZDkvK2orVmttMVhJQjV6MVFBSVczcDhnWkEzQzNyMmViYU1ad1JtdDRmZkl5MWdIUU9WKyt4bkZiVVJWcmFEMTY4R2h3aXZFNnpwdWFJT1A0QzByVmN1SGphWTJCa1lHQUFZczk5bHRmaitXMitNakN6TUlEQVl5SDdiUWo2dnk3VE1hYUxRQzRIQXhOSUZBQWkvUXBsQUhqYVkyQmtZR0JtK00vQXdNQjBqRUhuL3dXbWZnYWdDQXBnQVFCbjJ3UmRBc1lBQUFJNkFFc0NPZ0FzQXNJQU1BQUFBQUFBWmdEVUFWd0FBSGphWTJCa1lHQmdZUWhuWUdJQUFVWUdOQUFBQ1drQVlIamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b0NDeGRXRmdZbVhxQXRoRkdXd2pKMFJDcWpyMmQvZGhQUFFOVitkKzJFRE5Ed1gzSzVnbHZWOUpKZTdCRlZQbW1TZmkzakxYTEhqbmlhSjhsdVNWajh5bE5KK1pLMTc0eWp5Ui9EdHp6WXJmVFhDWDYyQ2oyZ1Zqb3o4NTE2MzNOdlpkOEdxcG0rUzMxdHQ0R0t4Ung1c3lZOWVQWjZkYTNlaVdEUUhIaFNzRGxvaGlKNGxKN0RsSjUraFlzMDlKTHh3a1Z5elJOUC82cmZRK2JRN3BKeU9iSXpkUnd5aUxYdlFzVzBXYlhtcmFQOHVoTC9jQUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUEFBQW9BQUFBQUJFd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMG0yTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QVpBQnlaMng1WmdBQUFXd0FBQUQ0QUFBQkdKSkJwN1ZvWldGa0FBQUNaQUFBQUMwQUFBQTJLSFBDYW1ob1pXRUFBQUtVQUFBQUhnQUFBQ1FHZ2dMUWFHMTBlQUFBQXJRQUFBQVFBQUFBRUFubkFRVnNiMk5oQUFBQ3hBQUFBQW9BQUFBS0FMd0FZRzFoZUhBQUFBTFFBQUFBR0FBQUFDQUFCd0FjYm1GdFpRQUFBdWdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEdEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNTmd5TS93SDhwa2gwa2hxL2dPRkFjMkNETTRBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLYWpMWS92OFA1R3VBNlA4My94OERxd0lDQUl5ekNOQUFBSGphWTJCa0tQblB5TmpBek1BZ3hjREFLQzRtd3M3R3o4akd6aVlHWlBJenFxa0RvYm1hUGFNWll3NHZPN3VqRmJzbE0yTllHaGM3YjZzcEg3Y3FFNU11bnhrekF5T1RBSnRKamtEaHNkNmZzWndDVEl4SnRZb0t0Y2xGemFwTlFDTVpQSURtaDBETUZ3YWFLaTdHTHNMR3pzZW9abTVpejJqSGFLN0hxSzVtYW1ZZTAySUdNbEJUeVN4UG1wR1pQeVNHa2JuUWpaT1JqWmtCWWxyVVFvZkVaQ1l1WmhaQm4vY0xqenkxNG1MalpHSUFBaVlHVDRZeVpndkdiZ1p1Qm5HZ2RZcHNhaVptNG9wbVlrQkxrTmpNUW45amVTVWxlWmlXOGdESnY5RkFrcGRwTVZDRU1ZS1JRNFdERVVROGdMTVlHQUFOTUN3UmVOcGpZR1JnWUFCaWplemw3dkg4Tmw4Wm1Ga1lRT0N4a1AwMkJQMmZrZG1DR2NUbFlHQUNVUUQyZGdoR0FBQUFlTnBqWUdSZ1lHYjR6d0FrbXhnOEdEeVpMUmlBSWlpQUJRQThkd0phQUFBQzB3QUFBY2tBZEFISkFFZ0RnZ0JKQUFBQUFBQXdBR0FBakFBQWVOcGpZR1JnWUdCaGtHWmdZZ0FCUmdZMEFBQURqUUFrZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktIN2k0T1RpNU9yek5taUFkbWtwYWl5N2lUL2MyQkcvZzhOMXp6ZzJROFNKaG1JUjUwR0ZTZWZQSVkzNVlSSjZJdjRxYzhjdWFFVWs2RTJmRkxuTEtsUC9JWTVhVWtTZmlQeUpuL1BIZU4vWHQzbG12am8yeDNsMXF2ejFaMzFhTlV4dWREK3ZCT3V2UG5UV3FmQ3JUVjIxL3JWV2hjMTJ3cDZIbXhwME9pMGR4Rk1jRWRsd2s4Mnc1aGIybGtzeEpaNE1tLzZZSFNWMW9uTU12UmhvbFQxRkRMemV0NkZXNmlpTGNhWW9QV0t3dVN3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU4wQUFvQUFBQUFBK0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRTBBQUFCZ3FvWmlPV050WVhBQUFBRkVBQUFBTXdBQUFEeWVOV1NsWjJ4NVpnQUFBWGdBQUFDb0FBQUFzTkZjOEl0b1pXRmtBQUFDSUFBQUFDd0FBQUEyS012Q3BXaG9aV0VBQUFKTUFBQUFIZ0FBQUNRR2x2L2thRzEwZUFBQUFtd0FBQUFNQUFBQURBaHpBSUJzYjJOaEFBQUNlQUFBQUFnQUFBQUlBRGdBV0cxaGVIQUFBQUtBQUFBQUZ3QUFBQ0FBQlFBamJtRnRaUUFBQXBnQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBRGFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzZzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUFCQmdZSEdEdWx1Q3lkZ1UzSjVvRUJzK0lmSXdZR1prWG1jMEJoUm9UcS8vOFpHQUExM3crL0FBQUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVptUmdVcko1WVBEL1B3TURoTDU3VlA0U1dCVVFBQUNzQkFuWEFIamFZMkJrOEdjb1ozWm03R1JRWkdCZzVHTmsxMk5XQjVJaWJPeHNhdXAyak9aeXpPSkEwc1RNM0V3TXFDbzF3am94SU16Y3c1K1pqWWVabDVFeEpjSW1JU2pNMUNPQW1ZMmJtWTh4SWJLSGhjbmUzNXFSSmNtYVI1YVJrVmNHU1lCYkRpakF3TWhneUtET2FNSmt3OEFIdEkrWlRZOVIzVndZWkEranVCaWo1a0YyQVRrbTFuWVdDVmtKWlVZbXhzZi9Ja1NZZWJrRUdIZnpLVEl5eWtseU1BQUFZL0VZbUhqYVkyQmtZR0FBNGx1MlhyTHgvRFpmR1poWkdFRGdzWkQ5Tm1TYWVTS1REWkRpWUdBQzhRRHVZQWZYZU5wallHUmdZRmI4WXdRa0p6SVlNc2d5T3pNQVJWQUFNd0JDWUFLQUFBQURrUUFBQTVFQVR3RlJBREVBQUFBQUFEZ0FXSGphWTJCa1lHQmdabEJpQU5FTVVCSUpBQUFFQ2dBcEFIamFUWXc5YjhJd0VJYWZpQVNKZE9oU2RlZ0FIcGl0b0ZSaVkyRmdZbVhxQXRpZ0RIR1FIU0pGcWpyeXUzdTRIbnJENlhrLzdvQ1NIektlay9FYTkzTnlDbEYvWFBEQ1crS3BxRVhpa2crV1RNanltVGh6Tm9selNiNFNGN3h6U1R3Vi96dHh5U2VQYmRmZTdyMzFhdDhaNjkyNURlUDZZSDFvT3FkV3VvcDZaNTMxeDk0YWRScVZHWm93WEZ0VjYwclhiT2xvdVhHbngrSlI3TVV4a1IxbnlRSWphdzdSQ1RTU09tbXQwRlQvOHAza0xuYU84Wk9SemtrU0pUVElWWkI5bGJhaWpwZWEraGZ6ZVRCUEFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU00QUFvQUFBQUFBNlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDA1bU50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNVWjJ4NVpnQUFBV1FBQUFDQUFBQUFnQUdRVnpOb1pXRmtBQUFCNUFBQUFDd0FBQUEyS0JqRFIyaG9aV0VBQUFJUUFBQUFIUUFBQUNRR0FRSWxhRzEwZUFBQUFqQUFBQUFJQUFBQUNBV0FBQ0ZzYjJOaEFBQUNPQUFBQUFZQUFBQUdBRUFBQUcxaGVIQUFBQUpBQUFBQUZnQUFBQ0FBQlFBb2JtRnRaUUFBQWxnQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBREtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbU9zQTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCa1p2Z1A1RE5EcEpIVS9BY0tBd0RxeUEweWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpTy8vOUR5UDhId0h3R0FGS1hCcDBBQUFBQUFnQWhBQUFDM2dMZUFDTUFKZ0FBQVJNZUFUY3pGU1lyQVFjMUZqWTNMd0VqQndZVkZCWVhGU2NITlRJMk54TTJGeklXQndNekFaamRCeU10RWtKRVMwZ1hPd01ETi8wdkFpY21kbWdxT2c3VUJSUUxDVE55NWdMSi9ZQVpFUUVnQXdNZ0FRa1dENXlHQndnVkhnRWdBd01nSFNjQ1pSVUJDbjMrc3dBQUFIamFZMkJrWUdBQVlpMUZXZU40ZnB1dkRNd3NEQ0R3V01oK0d6TE5kSS9wSHBEaVlHQUM4UURRbXdmaWVOcGpZR1JnWUdiNHp3QWlHUlFabEpqdU1RQkZVQUFUQURWTkFpMEFBQUFDZ0FBQUF3QUFJUUFBQUFBQVFBQUFlTnBqWUdSZ1lHQmlVQWRpRUdCa1FBTUFCSU1BTGdBQWVOcEZqREZ2d2pBUWhiK0lCSWwwNkZKMVlBQVB6RmFpTUhkaFlHSmxZZ0Zzb2d4eGtCTWlJYUdPL2QwOWpDVnVlUHJ1dlhjSDVQeVM4SnlFejZEUFNjbGtlM0hHQjErUnA3SXRJK2ZNV1RFaFNXZmlMUGlKbkVweWlKenh6U1h5VlB4SDVKdzFmNXV1dmQ0RzY5V3VNOWE3Yyt2TFltOTkzM1JPbGJvSSs5WTY2NCtETmVwMFYyWnMrckZ1VmFVTFhiR2hvK1hLalFHTFI3RVR4d1IybkNYemxCVHNnOVBUU09xa1ZhTEZmZWRieVYzb0hNTW5JNTBUZDFIREtGZTlhQzF0UlJVdU5kVS9ZejB2RHdBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU2tBQW9BQUFBQUJVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUVXTnRZWEFBQUFFNEFBQUFNd0FBQUR3QVdBQ2NaMng1WmdBQUFXd0FBQUhUQUFBQ0FCZzh6bnhvWldGa0FBQURRQUFBQUM4QUFBQTJLSExETDJob1pXRUFBQU53QUFBQUhnQUFBQ1FHWGdJa2FHMTBlQUFBQTVBQUFBQVFBQUFBRUF1Z0FJQnNiMk5oQUFBRG9BQUFBQW9BQUFBS0FWUUFzbTFoZUhBQUFBT3NBQUFBR0FBQUFDQUFCd0E2Ym1GdFpRQUFBOFFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFbUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtZXNFNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJoWnZnUDVETkRwSkhVL0FjS0F3RDVwdzFkZU5vZGlvRUpBQ0FRQXU4cm1xQWhXdU9wdldzemt3UTlSSUVDVkhzNDQ3TXh6VzZHMTJSTDdzbVNkSFgreTNxUVhRanVBSGphSFpBOWI5TlFHSVh2dVc5OGJ6NGNPNnFEYnlTSW96UnAzRlJ5Z21yTERwVklFVkVyNk5DVUZwV29WRlFNQlZHSkw3V3FPblRJVUlSQU1MQWdJVVptWmhaK1FDY21WZ2JZRUQ4QkplR0c5MHp2TXozbk1NN3Frd24veVgrd05sdGtMRUdjTExyS0ticGg3SW8ycE4vd28xaTVjZEpHVllxaXEySmxRZk1wRHJ0SVF2cUNmVkhNQzNUZDRBSk00MmlZTnBEUE9SRmw1SGl5bnIvazVBbDU0K0hBaEptWjdYNzRVejNtMndWazdOSFF0YWtzUVFTZXRpVmdxZ2NyWjhWNkFkeTJ4QlJuYllIYU9UYVpQckJ3OHB0eS9EdnI2SWNzMUxUWk1xS0diMEVLRzBKNVNMU21Wb29yOENDazVpMzRjVEtOcTF5VjZCcVV2VVlpbXpIQXNkMWZlWEY1OWFKd2tUcTlPYjhYUjRGSVphUkJ3V3J6ZWUva0k5Rld0SFo0dHRXY0Z6Y3NtUHg4L05lUzROSnU3QndBdmM1Z3I3UWJITi9ubUYxbzdaWnlBRGNmWDU4TFFlK0hyNDdXb2sxSzFlZXN2c1ZKdTNQV25Jd280VjlaaVFWNll5ZjJoUjYxNmtFSk9VMVYvTi9ZSWQwalZOTUt5NGo5Rm1TdElUNjlSYzhyMkJnY25vTDZDNTJENGZoejJiYVd2Rjl2VW9EMSt0NkpXaXFsWjhBZnJUK3BPQnY4U29Hb3JPZDc5L1RsczZ2QmJTSlBBQTd2amI3TmlDeFNHNVZiZDZ0My9QMGR3TlpxL3dDNnoxVmdBSGphWTJCa1lHQUE0djFmTzVQaitXMitNakN6TUlEQVl5SDdiUWo2LzB0bWM2YTdRQzRIQXhOSUZBQkFjd3NvQUhqYVkyQmtZR0JtK004QUpQMFpWUDVmWURabkFJcWdBQllBVlNvRGlBQUFBbllBQUFNQUFDUUMyd0F6QTA4QUtRQUFBQUFBVkFDeUFRQUFBSGphWTJCa1lHQmdZYkJrWUdJQUFVWUdOQUFBQm5zQVFuamFUWTZ4YXNNd0VJWS9VOGRRcDlDcEhUb1VUUm1GamZzQWdReVpzbVlzSkpFSURrZ0tzbVBJRXZvQWZlaGVGQTA5d2ZIZGQ3K0VnSm9iQmZjcWVFMzlYaVdWVEErZU1lY3RjeVZIWmE3NVlNRVRSZmtzNXBObDVwSVh2alBQZU9lVXVSTC9rN25taTk5VmNPZkxhS1BhQkdPalB6alh0ODNXeHFFUFhyVzZlWWkxOVRidVJtdlUvcXJNMUEvVDBhbE9ON3BqUmNCeDVzS0lKY3JQTm1KTVlzOUJkbzZlbG9adGNvTk1RVFpLbkJiN1A3R1doRStwWFhyTlNHclBWYnBoa3N3Zy9TaHBSWmZ1YXJvLzMvUXd1d0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNyB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mOCB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjE1Mjc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy0yMS41MTcxNSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTUuMTA1MDEzJyB5PSctMjUuMTMyNTE0Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjguNDUyNzQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4xNzQyNyw0MC4xNzkxMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTIxLjUxNzE1Jz5EPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDgxLjQyNyw0MC4xNzkxMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTIxLjUxNzE1Jz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDExMC4wNjEwMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNjIuNTc3MDEyJyB5PSctMjEuNTE3MTUnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTYuOTA1NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjc1MjcyLC00NS4xNzkxMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTIxLjUxNzE1Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01NS4xMDUwMTMnIHk9Jy0yNS4xMzI1MTQnPu6AsDwvdGV4dD4KPHJlY3QgeD0nLTYyLjU3NzAxMicgeT0nLTIwLjMyMTY5NycgaGVpZ2h0PScuMzk4NDg0JyB3aWR0aD0nMTAuMjY3MDcxJy8+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTUuOTQ5MDIgOC45Mjc1NUwyMy45MDM4NSAzNS44NTM0MicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjU1NDc2LDAuODMxOTUsLTAuODMxOTUsMC41NTQ3NiwyNC4wNDI1NCwzNi4wNjE0MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNOC45NDAxMiAxNy4zNDg0NkgyMS4xOTAxMlYyOC4yMjU1Nkg4Ljk0MDEyWicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTEuOTQwMTIsMjAuODQ4NDYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Mi41NzcwMTInIHk9Jy0yMy4xOTkzOTQnPuKIvDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNjIuNTIxNjYzJyB5PSctMjEuMDE5MDE4Jz49PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTM3LjI4Njc2IDQyLjY3OTEySDczLjA5OTMzJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDcyLjk3NDMzLDQyLjY3OTEyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPHBhdGggZD0nTTkwLjg1MTc2IDM0LjQzOTA0TDEwOC4wNDAzIDguNjU5MDMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNTU0NywwLjgzMTk5LC0wLjgzMTk5LC0wLjU1NDcsOTAuOTkwNDMsMzQuMjMxMDMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNTU0NywtMC44MzE5OSwwLjgzMTk5LDAuNTU0NywxMDguMTc4OTcsOC40NTEwMyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTAyLjIzODQyLDI2LjgxODA0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctMjEuNTE3MTUnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU3LjkxMDQyOCcgeT0nLTI0LjUyMzY2Nyc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy01My43NDU0NTknIHk9Jy0yMS41MTcxNSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTAuNjMyMTE2JyB5PSctMjEuNTE3MTUnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMzguODgxNzc2JyB5PSctMjEuNTE3MTUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM1Ljc2ODQzMycgeT0nLTIxLjUxNzE1Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0zMS42MzE0ODMnIHk9Jy0yMS41MTcxNSc+KSk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEgxMDUuMDA1NDgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA1LjI1NTQ4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNNDQuOTczMzMtNi41SDcwLjI0MDQ4VjYuNTk0MTVINDQuOTczMzNaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ny45NzMzMywtMS43NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTIxLjUxNzE1Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01Ny45MTA0MjgnIHk9Jy0yNC41MjM2NjcnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNTMuNzQ1NDU5JyB5PSctMjEuNTE3MTUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUwLjYzMjExNicgeT0nLTIxLjUxNzE1Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy00Ni40OTUxNjUnIHk9Jy0yMS41MTcxNSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjU0NDMxLTYuNDA5NzNMNDQuMTc5NjQtMzMuMTM4ODInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43OTk5NiwtMC42MDAwMiwwLjYwMDAyLDAuNzk5OTYsNDQuMDc5NjUsLTMzLjA2MzgzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMS45ODc4MSwtMjguNTc4ODYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy0yMS41MTcxNSc+z5E8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTU3Ljc2NjA3MScgeT0nLTIwLjEzNDgzNyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTMuNzcwNjAxJyB5PSctMjEuNjAxNTY2Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTQ5LjYwNTYzMicgeT0nLTIwLjEzNDgzNyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDYuOTA3Mzc3JyB5PSctMjAuMTM0ODM3Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjgnIHg9Jy00My4yMzg4MicgeT0nLTIwLjEzNDgzNyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNjguMzczNjYtMzQuMDc5NzFMMTA1LjEwNTUxLTYuNTI1NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC43OTk5MywtMC42MDAwNSwwLjYwMDA1LC0wLjc5OTkzLDY4LjU3MzY0LC0zMy45Mjk2OSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43OTk5MywwLjYwMDA1LC0wLjYwMDA1LDAuNzk5OTMsMTA1LjMwNTUsLTYuMzc1NDkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg5LjMyMzUzLC0yOC45Njg2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTYyLjU3NzAxMicgeT0nLTIxLjUxNzE1Jz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTUwLjgyNjY3MycgeT0nLTIxLjUxNzE1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny43MTMzMycgeT0nLTIxLjUxNzE1Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00My4wNDY3NDYnIHk9Jy0yNC41MjM2NjcnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMzguODgxNzc2JyB5PSctMjEuNTE3MTUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM1Ljc2ODQzMycgeT0nLTIxLjUxNzE1Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0zMS42MzE0ODMnIHk9Jy0yMS41MTcxNSc+KSk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram, node distance = 4cm,baseline = (2.base)]
        \node  (1) {$A'$};
        \node  [right = 1cm of 1] (ref1) {};
        \node  [above = 1.5cm of ref1] (2) {$D$};
        \node  [right = 2cm of 2] (3) {$C$};
        \node  [right = of 1] (4) {A};
        \node  [between = 1 and 4] (ref2) {};
        \node  [below = 1.5cm of ref2] (5) {$\underline {A'}$};
        \draw  [->,morphism] (1) to node[desc] {$\cong $} (2);
        \draw  [cover,morphism] (2) to (3);
        \draw  [>->,morphism] (3) to node {$f^{*}(\mathsf {Img}(g))$} (4);
        \draw  [->,morphism] (1) to node[desc] {$f^{*}(g)$} (4);
        \draw  [cover,morphism] (1) to node[swap] {$\vartheta _{f^{*}(g)}$} (5);
        \draw  [>->,morphism] (5) to node[swap] {$\mathsf {Img}(f^{*}(g))$} (4);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Then by uniqueness, <fr:tex
display="inline"><![CDATA[C \cong  \underline {A'}]]></fr:tex>.
      Thus, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f^{*}(g)) \cong  f^{*}(\mathsf {Img}(g))]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>  
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>