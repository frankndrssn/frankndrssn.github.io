<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>572</fr:anchor><fr:addr
type="user">log-000W</fr:addr><fr:route>log-000W.xml</fr:route><fr:title
text="Covers in the internal language of a category"><fr:link
type="local"
href="ct-000M.xml"
addr="ct-000M"
title="Extremal epimorphism">Covers</fr:link> in the <fr:link
type="local"
href="log-000P.xml"
addr="log-000P"
title="Internal language of a category">internal language</fr:link> of a category</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>.
  <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> is a cover iff <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> satisfies <fr:tex
display="inline"><![CDATA[y\colon B|\top  \vdash  \exists x\colon A.\mkern 5muf(x) = y]]></fr:tex> in its internal language.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>573</fr:anchor><fr:addr
type="machine">#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Suppose that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is a cover.
    Let <fr:tex
display="inline"><![CDATA[e = (b,a)\colon E\to B \times  A]]></fr:tex> be the interpretation of <fr:tex
display="inline"><![CDATA[f(x) = y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
    Note that <fr:tex
display="inline"><![CDATA[a]]></fr:tex> is an isomorphism since the following is also an equalizer diagram.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="9927b7cfeb51e0dda956286a03f34140"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5NC41OTM0OTRwdCcgaGVpZ2h0PSc0Mi4xNjY3NDVwdCcgdmlld0JveD0nLTcyIC03MiAxMjkuNzI4OTk2IDI4LjExMTE2Myc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJrQUFvQUFBQUFCUlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hjZDM1bU50WVhBQUFBRThBQUFBTXdBQUFFUUFlZ1JXWjJ4NVpnQUFBWEFBQUFHVEFBQUIxT2gvVGJGb1pXRmtBQUFEQkFBQUFDOEFBQUEyS0FIQ1BXaG9aV0VBQUFNMEFBQUFJQUFBQUNRRnhBR2JhRzEwZUFBQUExUUFBQUFRQUFBQUVBa0hBT3hzYjJOaEFBQURaQUFBQUFvQUFBQUtBUlFBa0cxaGVIQUFBQU53QUFBQUZ3QUFBQ0FBQmdCQ2JtRnRaUUFBQTRnQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRVdBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWNtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHJxTUI5Z1p2Z1A1RE16TUlLRUdSRXEvZ09GQWVKWERhQUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtkQmpTbUEvOC80OWcvYi82Zjg0Zlo3QmFNQUFBOUN3THpRQjQya1dRc1c3VFVCU0c3My90M2hzbmpxL3J4TmNrTkhZY085ZXRLbUlTTjdhVUlydEF1MUFreEJSMTZzNEtZa1NJQjJDQm9TTzhSbWRlZ0kwSElTdmhXZ3ljN2Rjbm5mUDloNEM4M1cvSWpyd25rcENLTTc3QVdWbUY4SmtBNHlvcnF4cS83TjdnS0pxTzA5U2NXM1BSTThDS3lPMXdJRjdGUUwzY3J2c3IwRDQvV040U1BTRFgrNXkrb1QvSmhRNUd1OGdCbjZtc1JpRUR5YmlNVUtNeEVxYktvS2loVHhRckdUaElWS2JLU3VWd3FFQlJTcGJoKzhZMTNiSDFkSG04QVZKZkdSQ1JFQ0tOamNsQ3ZBenBRTHdXdmlPZkpTZFBnRVJxN29aQ2VGN1k3WXh2VzR5dmYzNjhPTHc0R3o0M1ZCSk9hY3F5bmtWaFh2dDN1NjB4NDlqZVBNelVQUDJQTUZLUFBwdXpEdjUxV2V4MzlBdnVTYWtEYngzWGpiYXZFc1U0eTlHVzB2NUJYTXBBMHl6UmZ3c1J5TFl4MDNWYWpMbzVETVBVR0Q2NEhEZmVxNU1EcDh0QVQyVzhEdkZKSE1Fd2c5SEhMcVh3WFF1WWVIM2Y3bWtMRys5K1gxMlpFNUU5L3JhbFFXR0R3ckxPaDFNZnNIeGhlYlNLOHVabVluZUhJMkF3bjU0M0gzS3QvQmRjbkRzN0FIamFZMkJrWUdBQTRzSlc4ZW54L0RaZkdaaFpHRURnc1pEOUFnVDlYNS9wR05ORklKZURnUWtrQ2dBTHVnbklBSGphWTJCa1lHQm0rTS9Bd01CMGpFSHYvd1dteVF4QUVSVEFBZ0JvVlFSakFzWUFBQUZiQUhNQ09nQkxBcXdBTGdBQUFBQUFLZ0NRQU9vQUFIamFZMkJrWUdCZ1lYQmtBTkVNVUJJSkFBQUhMQUJKQUhqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzODtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTlFBQW9BQUFBQUE3d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFlwMEwyTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWdBQzhaMng1WmdBQUFXd0FBQUNNQUFBQWpDd1Z1S2RvWldGa0FBQUIrQUFBQUM4QUFBQTJKNHZDK21ob1pXRUFBQUlvQUFBQUh3QUFBQ1FGREFHamFHMTBlQUFBQWtnQUFBQU1BQUFBREFXRUFISnNiMk5oQUFBQ1ZBQUFBQWdBQUFBSUFESUFSbTFoZUhBQUFBSmNBQUFBR0FBQUFDQUFCZ0FkYm1GdFpRQUFBblFBQUFET0FBQUJPQWQxS3Ixd2IzTjBBQUFEUkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdk1ZNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUk1ZY2hrNXY0UDVETnpNNktwK1E4VUJnRDlQUTJvZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpCay92OFA1SVBwLzNQL3p3U3JBZ0lBbU5FSk5nQUFBQUFDQUNYLzlnSGFBc2NBRUFBYkFBQUJFU00xRGdFSExnRW5QZ0UzTmhZWEVRTTFKaU1tQmdjZUFUYzJBZHBaSGxRd1VXY0NBbWxTR0ZneUF5ZytPR0lEQWxjNFN3TEgvVGsxR2lRQkE0WmtaWVlEQVJVaUFTejl1Tm8wQVUxZldGSUJBd0FBQWdCTkFBQUF0QUsrQUFNQUJ3QUFFeFVqTlJjUkl4RzBaMTlXQXI1blovZitPUUhIQUFBQWVOcGpZR1JnWUFEaXN3ZWl1ZVA1YmI0eU1MTXdnTUJqSWZzRkNQci9ONllBcHVOQUxnY0RFMGdVQUNBS0NsNEFlTnBqWUdSZ1lPYit6OERBd0JUQW9Ncmd6M2lMQVNpQ0FwZ0JRZ1lDdEFBQ1VBQUFBakVBSlFFREFFMEFBQUFBQURJQVJuamFZMkJrWUdCZ1pwQmhZR0lBQVVZR05BQUFBNHNBSkhqYVRZdzliOEl3RUlhZnFBbFN3OENDT2pDMEhqcGJRV0ZnWW1GZ1ltVmlBZXlpREhHUUhTSWhWUjM1M1QyTUI4N1M2WGsvemtESkh4bVB5WmpFL1ppY1F0U1RDOFpNRTQ5RWZTVXVtZkhORzFuK0xzNG5xOFM1SlB2RUJSLzhKQjZKLzV1NFpNRjkzYldYYTIrOTJuYkdlbmRxUTFqdXJBOU41OVJjVjFGdnJMUCswRnVqampkbGhpWU01MWJWdXRJMWF6cGFMbHpwc1hnVVczRk1aTWRKc2lCdnlTNDZnVVpTSjYwNW11b2wzMGp1WXVjUWZ6TFNPWEtUYlJqa0tzZytTMXRSeDB0Ti9RL3FiVEE3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPd0FBb0FBQUFBQkJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVXgxQW1OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDRloyeDVaZ0FBQVdRQUFBRDBBQUFBOU51KytaSm9aV0ZrQUFBQ1dBQUFBQzBBQUFBMktJekM2R2hvWldFQUFBS0lBQUFBSGdBQUFDUUZ1Z0t5YUcxMGVBQUFBcWdBQUFBS0FBQUFDZ1puQUpKc2IyTmhBQUFDdEFBQUFBZ0FBQUFJQURJQWVtMWhlSEFBQUFLOEFBQUFGd0FBQUNBQUJRQXRibUZ0WlFBQUF0UUFBQURLQUFBQk11c0lrZVp3YjNOMEFBQURvQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1lczA0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBRMFpEQmladmdQNURORHBKSFUvQWNLQXdEMnhBMCtlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aEcvLzhEU2NQLy8vOWZBUE1aQUZGWUJvNEFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FBQUVBWFFBQUFsc0NxZ0FyQUFBbEJ5RTFORDhDUGdFM0xnRW5JZ1lISGdFWERnRWpCaVluUGdFM01oWVhEZ0VIQmc4QkpUWTNQZ0UzQWxzaS9pUURDZm85VFFFQ2FFMDBVaFlZSVFFQkpoVU9MQUlDaEdwd213TUNhRWd2TldrQkFpb0tEUThDeHNZZkJRSUoxREZxUDB4VEFTb2pBaDhiSUIwQkdTZE5aUUpwWTFCcExpQW5UZ0VCQkF0QkVnQUFlTnBqWUdSZ1lBRGl4WjNNditQNWJiNHlNTE13Z01Caklmc0Z5RFJ6RU5OcUlNWEJ3QVRpQVFBSW5RaUhBQUFBZU5wallHUmdZR2I0endBa2d4aGlHV0tab2htQUlpaUFDUUE5MFFKekFBQURVZ0FBQXJnQWtnQmRBQUFBQUFBQUFESUFlbmphWTJCa1lHQmdadEJoQU5FTVVCSUpBQUFGQkFBekFIamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU3ArYm00T1RxOFBickFuU29hbWt0ZWdpL25SdlEvQUdEdDg5NTl3QUdTOFNoa21ZQngwbWxUZVBQT2FIUmVTSitLdklHYitzR1pHa00zRlc3Q0tuVFBtUFBHWkpHWGtpL2lOeXhoL3ZmVlBmN3AzMTZ0Z1k2OTJsOXR1VDlXM1ZPTFhSK2JBZXJMUCszRm1qeXFjeWZkWDIxMW9WT3RjRmV4cHFidHpwc0hnVVIzRk1ZTWRGTXMrV1U5aGJLc21jZERabzhtOTZrTlNGeGpuOFlxUlI4aFExOUhMVGlsNmxxeWpDbmFiNEFGVXlMa01BQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9JQUFvQUFBQUFBL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDE0bU50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNVWjJ4NVpnQUFBV1FBQUFESkFBQUF6RFZtV2Zob1pXRmtBQUFDTUFBQUFDOEFBQUEyS1FMREdXaG9aV0VBQUFKZ0FBQUFId0FBQUNRSE1nT0dhRzEwZUFBQUFvQUFBQUFJQUFBQUNBZDVBR2xzYjJOaEFBQUNpQUFBQUFZQUFBQUdBR1lBQUcxaGVIQUFBQUtRQUFBQUZnQUFBQ0FBQlFBK2JtRnRaUUFBQXFnQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTNzTTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCa1p2Z1A1RE5EcEpIVS9BY0tBd0Rwc2cwdmVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpTy8vOUR5UDhId0h3R0FGS1hCcDBBQUFCNDJoWEpRV3JDUUJRRzRQZS9HZWFwTTBaajZrUmJDS2dRZDJxckpGUWtpQlJCdklFMzZLSWJCUS9oc21mcENib1JlZ2QzTG5xSnFuWDdmY1QwZnIycUk1L29sV1pFaUJLTU14OTdHYUtHdEY4ZzlsaytSRWRNalkwa3lHTWZCN2huTisybldWNGdSNEVYTDZyRHYzdTBSallDSHVlTDFWc0RpRnhwcXF2aDVTZlNhdTBNT0MxWkFVS3ptd3kwWlVqd3ZFandLZld1MjV6UjQrKy9RMWlGY1Urc0FJVjZzd3hJdU55QTljZURMVGNxWU9YK1VVTkpoZHVNM29DWDFybnQ1WXVJYnRGM0c5a0FBQUI0Mm1OZ1pHQmdBT0tidkFMTzhmdzJYeG1ZV1JoQTRMR1EvUUlFL2Y4LzgzR211MEF1QndNVFNCUUFCdEVLT3dCNDJtTmdaR0JnWnZqUHdNREFvc3FReVJESGZKd0JLSUlDbUFCQ3h3TEJBQU5VQUFBRUpRQnBBQUFBQUFCbUFBQjQybU5nWkdCZ1lHS3dCV0lRWUdSQUF3QUdxUUJFQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTkFBQW9BQUFBQUE2UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJnaU9SekcyTnRZWEFBQUFGQUFBQUFLUUFBQURRQURBRXFaMng1WmdBQUFXd0FBQUI0QUFBQWVKTVNQSkZvWldGa0FBQUI1QUFBQUMwQUFBQTJLRmJDTldob1pXRUFBQUlVQUFBQUhnQUFBQ1FHTmYvZGFHMTBlQUFBQWpRQUFBQUdBQUFBQmdPd0FBQnNiMk5oQUFBQ1BBQUFBQVlBQUFBR0FEd0FBRzFoZUhBQUFBSkVBQUFBRndBQUFDQUFCQUFrYm1GdFpRQUFBbHdBQUFEVEFBQUJQcTgzZGVGd2IzTjBBQUFETUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtbG1HY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRVRBeEpJS1M1TEIwcGVaN2pPTFBWSGs0R0JXWXI1T2xDWUVhSGkvMzhHQmdEcm5RN3ZBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4Q0MrTmYvLzRlUS83WEFmQVlBWHVVSE13QUFBQUFCQUpRQUNRS0dBZmdBSWdBQUFUYzJGeFlYQmc4Q0h3RVdCd1lISmk4QkJ3NEJJeVluSmo4Qkp5WTNOamN5RndHT3l3NEtFd0VDQXhxN3BUSUVBUUVUQ3dYVXl3a0lCaEVEQXhETnpSQURBeEVHQkFFZHloRUJBaE1LQXhxN3BUSUlBeE1DQWdUVXl3b0ZBaE1IRGM3T0RRY1RBZ0lBQUhqYVkyQmtZR0FBNGxVcVJ4Zkg4OXQ4WldCbVlRQ0J4MEwyQzVCcFpobkdIMENLZzRFSnhBTUFDek1JcVFBQUFIamFZMkJrWUdDVytxTUpKR1VZcGpCTVkycGpBSXFnQUVZQVRNb0RGd0FBQXh3QUFBQ1VBQUFBQUFBQUFEd0FBSGphWTJCa1lHQmdZbEJtQU5FTVVCSUpBQUFFQ0FBcEFIamFUWTZ4YXNNd0VJWS9VOGRRSjVDcEhUb1VUUm1GamZNQWhReVpzbVlzSkpFSURsZ09rbVB3VXZJQWZlaGVGQTA5d2ZIcHYrK0VnSklmTWg2VnNZejlVVG1GM0o0OFk4NWI0a0tPU2x6eXdZb1hzdnhWa2srK0V1Y3MrRTQ4NDUxTDRrTHllK0tTTmIrYnZydmVCdXZWcmpmV3UxTVhwcnJhV3gvYTNxbGFWODlnYTUzMWg4RWFkWnlVR2Rzd25qdlY2RW8zYk9qcHVISmp3T0xsWnp0SlRHVEhTV2FCaVpxS2Zjd0NyY3lkZURWYTB2L0dWZ3dYclVOOHpZaDFsSmtTR21VdlNEK0xyMmppcnFiNUF3bFJNUk1BZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUM0QUFBQTJLQTdDUG1ob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0aE1zQ3VmaitXMitNakN6TUlEQVl5SDdCUWo2UHlQVFpXWVFsNE9CQ1VRQkFBU3JDTzRBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktFSERGMmhvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRyYlhwMkxqK1cyK01qQ3pNSURBWXlIN0JRajYvMTltTnFhN1FDNEhBeE5JRkFBNVdBclhBSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjMuOTc0NTU4LC01Ni44NDQzOSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTU2Ljg0NDM5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My45NzQ1NTgnIHk9Jy01Ni44NDQzOSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0My4wMDEwMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC01Ni44NDQzOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjMuOTc0NTU4JyB5PSctNTYuODQ0MzknPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUzLjcwNDA4MycgeT0nLTU2Ljg0NDM5Jz7DlzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDMuNzQxNDcnIHk9Jy01Ni44NDQzOSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDkuNzY3NjEsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjk3NDU1OCcgeT0nLTU2Ljg0NDM5Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMC41MDU1NCAwSDM3Ljk0NTQ4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDEwLjc1NTU0LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguMTk1NDgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMC42MDU3Myw0LjU2MTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC01Ni44NDQzOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNjMuOTc0NTU4JyB5PSctNTYuODQ0MzknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYwLjg2MTIxNScgeT0nLTU2Ljg0NDM5Jz5mPHRzcGFuIHg9Jy01Ni42MjM1NzknPiw8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTIuODk2ODAyJyB5PSctNTYuODQ0MzknPmlkPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny4zMDMxMzknIHk9Jy01NS44NDI1NzcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQxLjY0MzcyOCcgeT0nLTU2Ljg0NDM5Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J003NS4zNjU1MiAzLjYxNjYySDEwNC43MTIwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDQuOTYyMDcsMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODMuNjU3MTgsNy43ODk1NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYzLjk3NDU1OCcgeT0nLTU2Ljg0NDM5Jz5mPHRzcGFuIHg9Jy01OS4zMDc5NzMnPs+APC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTU0LjY0OTEyOScgeT0nLTU1Ljg0ODEyNic+MjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNzUuMzY1NTItMy42MTY2MkgxMDQuNzEyMDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA0Ljk2MjA3LC0zLjYxNjYyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4NS45OTkyMiwtOS40NDIzMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYzLjk3NDU1OCcgeT0nLTU2Ljg0NDM5Jz7PgDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTkuMzE1NzEzJyB5PSctNTUuODQ4MTI2Jz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$A$};
      \node  (2) [right = of 1] {$B \times  A$};
      \node  (3) [right = of 2] {$B$};
      \draw  [>->,morphism] (1) to node {$(f,\mathsf {id}_{A})$} (2);
      \draw  [->,morphism,offset=-1.5] (2) to node {$f\pi _{2}$} (3);
      \draw  [->,morphism,offset=1.5] (2) to node [swap] {$\pi _{1}$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By <fr:ref
addr="log-0008"
href="log-0008.xml"
taxon="Definition" />, <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket y\colon B.\exists x\colon A.\mkern 5muf(x) = y\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> is the <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">image</fr:link> of the following composite.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="91178b569ec537fc20ab4245e0e7042d"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5NC45MzU5NXB0JyBoZWlnaHQ9JzEwOC4yNzMwODZwdCcgdmlld0JveD0nLTcyIC03MiAxMjkuOTU3MyA3Mi4xODIwNTcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0E3Q1hHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhNc0NwUGorVzIrTWpDek1JREFZeUg3OVFqNlB5UFRaV1lRbDRPQkNVUUJBUDA2Q05BQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1jQUFvQUFBQUFBNFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVeDFHMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNFWjJ4NVpnQUFBV1FBQUFCa0FBQUFaREZ1QXJKb1pXRmtBQUFCeUFBQUFDMEFBQUEyS0l6REJtaG9aV0VBQUFINEFBQUFIZ0FBQUNRRnl3TFdhRzEwZUFBQUFoZ0FBQUFJQUFBQUNBWUtBSkpzYjJOaEFBQUNJQUFBQUFZQUFBQUdBRElBQUcxaGVIQUFBQUlvQUFBQUZ3QUFBQ0FBQkFBZ2JtRnRaUUFBQWtBQUFBREtBQUFCTXVzSWtlWndiM04wQUFBRERBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVptV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9hTWhneU0vd0g4cGtoMGtocS9nT0ZBYU4zREZnQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpRy8vOUR5UDhYd0h3R0FGRkhCbzBBQUFBQUFRQ1NBQUFDTndLckFCNEFBQUVSQmhZN0FSVW1KeU1HQnpVek1qWW5FUTRCSnlNMU14WS9BVFkzTmhZQm1BUWlUak1zT3RFNkxETk9JUU11VkJNU0VoSStCejg1R0E0Q2kvM05GeFF0QXdFQkF5MFVGd0lBRWd3QkxRSUtBZ291QVFrQWVOcGpZR1JnWUFEaUgwZStyWXpudC9uS3dNekNBQUtQaGV6WEk5UE1RVXlyZ1JRSEF4T0lCd0JBOGduV0FBQUFlTnBqWUdSZ1lHYjR6d0FrZ3hnbU1UUXltVE1BUlZBQUV3QkMzQUtvQUFBRFVnQUFBcmdBa2dBQUFBQUFNZ0FBZU5wallHUmdZR0Jpa0djQTBReFFFZ2tBQUFPa0FDVUFlTm85akRHcndqQVVoYjlpRmUwYkhBU0hOMGp3QjRSS241dWJnNU9ydzl1c0NkS2hxYVMxNkNMK2RHOUQ4QVlPM3ozbjNBQVpMeEtHU1pnSEhTYVZONDg4NW9kRjVJbjRxOGdadjZ3WmthUXpjVmJzSXFkTStZODhaa2taZVNMK0kzTEdIKzk5VTkvdW5mWHEyQmpyM2FYMjI1UDFiZFU0dGRINXNCNnNzLzdjV2FQS3B6SjkxZmJYV2hVNjF3VjdHbXB1M09td2VCUkhjVXhneDBVeXo1WlQyRnNxeVp4ME5tanliM3FRMUlYR09meGlwRkh5RkRYMGN0T0tYcVdyS01LZHB2Z0FWVEl1UXdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktFZkNVV2hvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaVkrZHl6WGgrbTY4TXpDd01JUEJZeUg0OWd2NnZ6OHpEZEJ6STVXQmdBb2tDQU92VENKVUFlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU2dBQW9BQUFBQUJWQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGYxNERHTnRZWEFBQUFFOEFBQUFNd0FBQUVRQWVRU01aMng1WmdBQUFYQUFBQUhQQUFBQ0VONUQ5cTlvWldGa0FBQURRQUFBQUM4QUFBQTJLQUhERjJob1pXRUFBQU53QUFBQUlBQUFBQ1FGd3dIa2FHMTBlQUFBQTVBQUFBQVFBQUFBRUFtZkFMWnNiMk5oQUFBRG9BQUFBQW9BQUFBS0FXQUFybTFoZUhBQUFBT3NBQUFBR0FBQUFDQUFCd0E0Ym1GdFpRQUFBOFFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFbEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtU21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwb21NUjlnWnZnUDVETXpNSUtFR1JFcS9nT0ZBZmF2RGZ3QUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUlMa2toaFNtUS84LzQ5Zy9aLy9mKzRmWjdCYU1BQUEvS3NNQWdCNDJpV1F2MjdUVUJURzczZnRYTWVPWTZlcC84UVZNWW1kMmc0cGNSUmp1eUtwblJZSFVKZFdhcVVxSGJxek1LQnVsUkR3Q3J3QUl5L0FBRE1TN3dGaVlBY1dCT1dtM2M1M3ZqUDh6bzlROHVqNk43N1NMOFFqR1NFUUN1U1paVE1kVEJvakRFcStDSHd2Q0Fza3ZKRFdmWUYwRE4rVE5QQXIwN0NnUGJZUG90MExRZGp2SDY3MlR3RjJmNnd3cWcva0RVQ1hxcDBCOG1pNTJlbGk1TTRMclM2NjlTRjkvKytiNVFFbnEyZkhmaVZnZGRUeVBuNjRaemNWVWRIcmtpaW9mODh4RHlkWC9vTzQwblh0S25MR0R3bWhaTWw1LytBekNkYTh1YzlKWFNSV2lTelBYSmpHTFhqS1U1NGxVOHUybU1Ta01MSFdPZWZZQVkvcyswSUdSUmEzOXRxTG1kSnNUTGVLeS9NTDhhblpPVG5ObndEKzdzN2s5YlE3My9aU0ViRnZKVm96L1JHWmJsRlF0ZFphTktBeWJkaUtSUHI4K0VWbDZPbGsxTmt6TmRFQnEybEc3dllFUTFKNkJHUjgvWXUreGFjYnMxeVhINlFsdUVBLzRBd3gxbEs1VEx2UGhmTTJ2UDNGdHZnc3NTQzhxVkdVRzY0N0VJeE90VlcyajRZMVRXR2dJNnVmdW5pajM0RWcyczRyaFZLWUxSbm90cHVtMmdBY0ZaYy9sMHV4cTRlVGQyZlVUbFQrcml6UGpKNEp5S1l1dDJsK055NVhYVlV4SEdCenV6Y3JYOGFFa1A5alEweU9BSGphWTJCa1lHQUE0dWFUQnhuaitXMitNakN6TUlEQVl5SDc5UWo2LzFlbVkwekhnVndPQmlhUUtBQXN6Z3NNQUhqYVkyQmtZR0JtK00vQXdNQjBqRUdQUVpKcE1nTlFCQVd3QUFCRGFBS3RBc1lBQUFJQ0FFTUNLd0JGQXF3QUxnQUFBQUFBV0FDdUFRZ0FBSGphWTJCa1lHQmdZVEJuWUdJQUFVWUdOQUFBQmtrQVFIamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b0NDeGRXRmdZbVhxQXRoRkdXd2pKMFJDcWpyMmQvZGhQUFFOVitkKzJFRE5Ed1gzSzVnbHZWOUpKZTdCRlZQbW1TZmkzakxYTEhqbmlhSjhsdVNWajh5bE5KK1pLMTc0eWp5Ui9EdHp6WXJmVFhDWDYyQ2oyZ1Zqb3o4NTE2MzNOdlpkOEdxcG0rUzMxdHQ0R0t4Ung1c3lZOWVQWjZkYTNlaVdEUUhIaFNzRGxvaGlKNGxKN0RsSjUraFlzMDlKTHh3a1Z5elJOUC82cmZRK2JRN3BKeU9iSXpkUnd5aUxYdlFzVzBXYlhtcmFQOHVoTC9jQUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOQUFBb0FBQUFBQTZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdpT1J6RzJOdFlYQUFBQUZBQUFBQUtRQUFBRFFBREFFcVoyeDVaZ0FBQVd3QUFBQjRBQUFBZUpNU1BKRm9aV0ZrQUFBQjVBQUFBQzBBQUFBMktGYkNVMmhvWldFQUFBSVVBQUFBSGdBQUFDUUdOZi9kYUcxMGVBQUFBalFBQUFBR0FBQUFCZ093QUFCc2IyTmhBQUFDUEFBQUFBWUFBQUFHQUR3QUFHMWhlSEFBQUFKRUFBQUFGd0FBQUNBQUJBQWtibUZ0WlFBQUFsd0FBQURUQUFBQlBxODNkZUZ3YjNOMEFBQURNQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1sbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFVEF4SklLUzVMQjBwZVo3ak9MUFZIazRHQldZcjVPbENZRWFIaS8zOEdCZ0RyblE3dkFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hDQytOZi8vNGVRLzdYQWZBWUFYdVVITXdBQUFBQUJBSlFBQ1FLR0FmZ0FJZ0FBQVRjMkZ4WVhCZzhDSHdFV0J3WUhKaThCQnc0Qkl5WW5KajhCSnlZM05qY3lGd0dPeXc0S0V3RUNBeHE3cFRJRUFRRVRDd1hVeXdrSUJoRURBeEROelJBREF4RUdCQUVkeWhFQkFoTUtBeHE3cFRJSUF4TUNBZ1RVeXdvRkFoTUhEYzdPRFFjVEFnSUFBSGphWTJCa1lHQUE0bFVxUjlQaitXMitNakN6TUlEQVl5SDc5Y2cwc3d6akR5REZ3Y0FFNGdFQUE5RUlpd0FBQUhqYVkyQmtZR0NXK3FNSkpHVVlwakJNWTJwakFJcWdBRVlBVE1vREZ3QUFBeHdBQUFDVUFBQUFBQUFBQUR3QUFIamFZMkJrWUdCZ1lsQm1BTkVNVUJJSkFBQUVDQUFwQUhqYVRZNnhhc013RUlZL1U4ZFFKNUNwSFRvVVRSbUZqZk1BaFF5WnNtWXNKSkVJRGxnT2ttUHdVdklBZmVoZUZBMDl3ZkhwdisrRWdKSWZNaDZWc1l6OVVUbUYzSjQ4WTg1YjRrS09TbHp5d1lvWHN2eFZraysrRXVjcytFNDg0NTFMNGtMeWUrS1NOYitidnJ2ZUJ1dlZyamZXdTFNWHBycmFXeC9hM3FsYVY4OWdhNTMxaDhFYWRaeVVHZHN3bmp2VjZFbzNiT2pwdUhKandPTGxaenRKVEdUSFNXYUJpWnFLZmN3Q3JjeWRlRFZhMHYvR1Znd1hyVU44elloMWxKa1NHbVV2U0QrTHIyamlycWI1QXdsUk1STUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVUwQUFvQUFBQUFCaHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDAwbU50WVhBQUFBRTRBQUFBTlFBQUFFUUFXZ0QyWjJ4NVpnQUFBWEFBQUFKWkFBQUMwS3lRZGhob1pXRmtBQUFEekFBQUFDOEFBQUEyS0V2RE5XaG9aV0VBQUFQOEFBQUFIZ0FBQUNRR05nSFRhRzEwZUFBQUJCd0FBQUFVQUFBQUZBMDBBSmxzYjJOaEFBQUVNQUFBQUF3QUFBQU1BWFlDR0cxaGVIQUFBQVE4QUFBQUdBQUFBQ0FBQ1FCTWJtRnRaUUFBQkZRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRktBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVdzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWlBCa1p2Z1A1RE5EcEpIVS9BY0tBd0RoaEEwZWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VTY0dGd1pQUC8vQjdJY0lhei9CLzd2Kzc4YnJCWU1BT0VXQzBvQUFBQjQyajJTejBzVVVRREgzL2U5bWZmYzNabDVxN003b3puT3NxM09pS2JHL25qYmJyUlNxWVdTV0VKNGtJb2doYUFPWVhyTWc1UkpIU0lJT25YcFZwZE9FWFRxMUQvUU1TRTZSWVJIVDd2Ykd5bmY2ZkY5Ny9ENThQMFNTb2E3WGZxRGZpZFRwRXhJSGFwZTludzM1MVdVeDZjZzRpaXVLdDlUOVNrVUJjOTV2dklkNkR5Skt5M1VLK3dqN3ZDY3pkSHlKdkt3ekkzdEhoTjJ4cTJ5bE9oMEYrM0F0UmxzYzMzRmdwVTYyWHI5dTdoSnIyZVJrdTF0VDdJaEFjWkFlNlFBTEg5dGRpYzNuQVdWRGsvaXRPUW9mY1Uxb2c4ajQ5MDI0L1F6Q2NrWU9hTkozV29wNXBxdEdDTHZRSVR3dVFRWFJYN0U2eVp3S29wTEVSZnMvNTNwRDVXM3p3ZmpJU214c25xYmJTOHZMSU5leWw1NTJIa1pPRTR6ZlBQcTVnYkY1TVdkZ212ZWY3YTZTZW5weTEvbURNQlpvbzFleWdJQmVyVTV2eTdUaTQyRkMwN0xTQXpnWXBZOW1CdWVvWkFEN1hkc2EzRmtpWFYrOXZFMElTQ3g1czdTVDJTZWtCSGhvUFFQc081T1l4SkhBc3FUeUVYVHRLWWlvWGtsS3ZwWmViN2dVYTFhVi9FeHVsK2UxdjJvY2dIMDJ3M0R5cmIvREVrTmJUN1JnQ01ObWFWbW44VnlBV0RRODZzdnRNSzVXek0xbS9rNGEvU3psS1p2cmMwbUx1KzNsQ3lQSVU5eHNHK1pMT1JhSWFSaHI3Q0ZvUTJSY2o4RVJ0b05UclJxUUhiZ0VCTU5GNWtEajZVTk1TN2NRWFIrYVRsTU91cHV4dURhc2RUdG9xMjdHZFhDVFBBQzFORklqc2ZqcXJnYUNkNUNBWFhmODNNOGpqZ2VQVFZZY0twSWJiSDNPR1ZDOWpVTHhoNURWQXhnODkxZEhUbHVzMER2dGZmN0phVUo1ZkZVOGdFZHpaaDZIa2toU1pyU2kwR2VrTDgxbEc5NUFBQUFlTnBqWUdSZ1lBRGlLUlVHM2ZIOE5sOFptRmtZUU9DeGtQMTZCUDMvTDdNQTAxMGdsNE9CQ1NRS0FCZ2JDaTRBZU5wallHUmdZR2I0endBa09SaVUveDlsRm1BQWlxQUFWZ0JLV1FNUEFBQUNkZ0FBQXdBQUpBTUlBQ3NDOUFBbkFjSUFJd0FBQUFBQVZBQ3dBU0lCYUhqYVkyQmtZR0JnWmZCbVlHWUFBVVlHTkFBQUNHOEFWbmphVFk2eGFzTXdFSVkvVThkUXA5Q3BIVG9VVFJtRmpmc0FnUXlac21Zc0pKRUlEa2dLc21QSUV2b0FmZWhlRkEwOXdmSGRkNytFZ0pvYkJmY3FlRTM5WGlXVlRBK2VNZWN0Y3lWSFphNzVZTUVUUmZrczVwTmw1cElYdmpQUGVPZVV1UkwvazdubWk5OVZjT2ZMYUtQYUJHT2pQempYdDgzV3hxRVBYclc2ZVlpMTlUYnVSbXZVL3FyTTFBL1QwYWxPTjdwalJjQng1c0tJSmNyUE5tSk1ZczlCZG82ZWxvWnRjb05NUVRaS25CYjdQN0dXaEUrcFhYck5TR3JQVmJwaGtzd2cvU2hwUlpmdWFyby8zL1F3dXdBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuOTc5MTYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkU8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDMuMDAxMDIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUzLjQ3NTc4MycgeT0nLTYyLjY0NzU2NCc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQzLjUxMzE3JyB5PSctNjIuNjQ3NTY0Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwOS43Njc2MSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjc0NjI1NycgeT0nLTYyLjY0NzU2NCc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1NC4zMTUyMywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjczNDcgMEgzNy45NDU0OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMC45ODQ3LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguMTk1NDgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMS41OTMwMywyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYzLjc0NjI1NycgeT0nLTYyLjY0NzU2NCc+ZTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNzUuMzY1NTIgMEgxMDQuNzEyMDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA0Ljk2MjA3LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODUuOTk5MjIsMy44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPs+APC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01OS4wODc0MTMnIHk9Jy02MS42NTEzJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002LjQwNDU0LTYuNDA5NzNMNDcuMDkyMzktNDcuMDk2NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzEsLTAuNzA3MDksMC43MDcwOSwwLjcwNzEsNDcuMDA0MDEsLTQ3LjAwODIyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPHBhdGggZD0nTTY1LjYwNjktNDguMjA4NzZMMTA3LjA1MTQ1LTYuNzYzMjgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNzA3MDksLTAuNzA3MSwwLjcwNzEsLTAuNzA3MDksNjUuNzgzNjgsLTQ4LjAzMTk4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzA5LDAuNzA3MSwtMC43MDcxLDAuNzA3MDksMTA3LjIyODIzLC02LjU4NjUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4Ljk5MjAzLC0zNi4xNDg4OCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTEuOTk1OTE4JyB5PSctNjIuNjQ3NTY0Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00OC44ODI1NzUnIHk9Jy02Mi42NDc1NjQnPmI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ1LjM3OTAzNycgeT0nLTYyLjY0NzU2NCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$E$};
      \node  (2) [right = of 1] {$B \times  A$};
      \node  (3) [right = of 2] {$B$};
      \node  (4) [below = of 2] {$I$};
      \draw  [>->,morphism] (1) to node {$e$} (2);
      \draw  [->,morphism] (2) to node {$\pi _{1}$} (3);
      \draw  [cover,morphism] (1) to (4);
      \draw  [>->,morphism] (4) to node[swap] {$\mathsf {Img}(b)$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By assumption, <fr:tex
display="inline"><![CDATA[fa = b]]></fr:tex>.
    Thus, the image of <fr:tex
display="inline"><![CDATA[b]]></fr:tex> coincides with that of <fr:tex
display="inline"><![CDATA[fa]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="ac18ba5c17d57f35668c8be429afad85"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5NC45MzU5NXB0JyBoZWlnaHQ9JzExMS41NzMxOTFwdCcgdmlld0JveD0nLTcyIC03MiAxMjkuOTU3MyA3NC4zODIxMjcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0E3Q1BtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhNc0N1ZmorVzIrTWpDek1JREFZeUg3QlFqNlB5UFRaV1lRbDRPQkNVUUJBQVNyQ080QUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUTUFBb0FBQUFBQllnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWHgwcW1OdFlYQUFBQUU0QUFBQU1nQUFBRHdBZlFDN1oyeDVaZ0FBQVd3QUFBSCtBQUFDVUVwT2pMQm9aV0ZrQUFBRGJBQUFBQzhBQUFBMktBSENQV2hvWldFQUFBT2NBQUFBSUFBQUFDUUZxd0diYUcxMGVBQUFBN3dBQUFBUUFBQUFFQWw4QU14c2IyTmhBQUFEekFBQUFBb0FBQUFLQVpJQXdtMWhlSEFBQUFQWUFBQUFHQUFBQUNBQUJ3QkNibUZ0WlFBQUEvQUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUV3QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1pbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvbU1xUXhNL3dIOHBraDBraHEvZ09GQWMrY0RSWUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtKakdrL2Y4UDVDZUM2UDhML3M4RnF3SUNBSmcvQ1RJQUFIamFSWkUvYjlOUUZNVjkzbk50eHhTL0pJNmZhZE02cVovN25KYkdwVGpZcUZST2s3YVIrayswQXFsS3haK0pBYjVDRnpZMkpnWldOa1lXQnZaS2JFaDhBaVQ0REdVajRia00zTHZkYzRmZk9VY2pXakc5SXZ1NDFMcmF0cWFod0YzdU0rTEFhM0MvUUI5WkM5eHZHS1phR1Rzd0U4UlpYbTRBbW1leGpLVmhxbk9BdkVDZTRkUE1Zck9CdXNmTkNuUGJ3ckowMnpiZzFwcVpQNndGKzZzN1o5RDd6RDA0WCs1dHBHaDRxVDhTYmdpc0JXSFBrbmpEM1dydDVQaUpsemg4QVdRdmJob2d4SjRadEZPS1pqZm9BRStQWHB5NjlSRkZPUG54YlhZNTBrbm5nWGpkelJPUWxyV2dxU0hhenZRM2ZwS3ZXcWhseWhNdHliaHZNQmdsdnV5cmd4U2hqQXVrU2pCTHZjQzlCQ0pVVnRTWDhnNW41QTg3OTU5Uk9sZzZHQThlQTBZM3NRM0Nva29OWU9idVdvUzhzK2ZlV3NUdFlLdHdMRDJ3VnNqSHlTK3V6RHdhdnp3UnV4VGpoOVh3eStkVi82YXQyOHd5ZFRyNzV4eGI4WjBMMFZ2ZlpjeTU2TXdsbXdwUU81eXVrMWZrKzNVRHRNUlVpZjdqNHo0M1RONVN2ZlNwTUdUbXA5ZXdxV3JKZ1ZEcFo3bGNoME1ZMG93Yk1UNXNWdlhxZkdXdzBka0VJazlTc0JaakxGcWlpd2s3Q29qTFRwbm44S0ZZMlFJRVYzbzFZS3hlRDJ4ci9ua3A0OTNrOHFDMjNXdnNVQ21DTm9tTStFYUZRRC8wM2wrZDBkREUyYmdaeStYb3Y0UTUyWDJyaHhaVTlIOEJsbmRUbUFBQWVOcGpZR1JnWUFEaU5RY1dkOGZ6MjN4bFlHWmhBSUhIUXZZTEVQUi9mYVpqVEJlQlhBNEdKcEFvQURhL0NyNEFlTnBqWUdSZ1lHYjR6OERBd0hTTXdlNy9CYVlzQnFBSUNtQUJBR2E2QkVvQ3hnQUFBbm9BUGdJQ0FFTUNPZ0JMQUFBQUFBQnFBTUlCS0FBQWVOcGpZR1JnWUdCaGNHUmdZZ0FCUmdZMEFBQUhRd0JLZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzODtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUVlBQW9BQUFBQUJNd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFc5MG5HTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWV3RWdaMng1WmdBQUFXd0FBQUZNQUFBQmpQTndKSk5vWldGa0FBQUN1QUFBQUM4QUFBQTJLRWZDTTJob1pXRUFBQUxvQUFBQUhnQUFBQ1FHTndKMWFHMTBlQUFBQXdnQUFBQVFBQUFBRUFqOUFOWnNiMk5oQUFBREdBQUFBQW9BQUFBS0FOUUFpRzFoZUhBQUFBTWtBQUFBR0FBQUFDQUFDQUJOYm1GdFpRQUFBendBQUFET0FBQUJPQWQxS3Ixd2IzTjBBQUFFREFBQUFBd0FBQUFnQUFNQUFIamFZMkJtc21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcDZNdVF5Yy84SDhwbTVHZEhVL0FjS0F3REQ3d3o3ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVE4R2RJWmN2Ly9SN0QrNy9nLysvODBzRm93QUFEc2h3dVZBSGphVlZETFRzSlFFSjJaVzFvZ1dBU2xGZHRVYVdNTGlCQjV0TUJWRWhjU0l5cHE0a0lrU0dUamp4ZytEUk1TRXFJZjR0YUY0TVdObWtsT3ptTm1jUVlRUmdBd3BRa3dnSTJFazVnKzArU3JJVFFJeDFxV0tJN3ZVQUlPSFFEVVBVZFdkQzJsb2lKN3NtSmhVUEYxVFl5S3R1dTVmbEJFencvY1dnc0RYMjhoMDFhTzQ2NDJkWEVwNnhhV1JlNkpJUmFyY2xPU1RIeTYyRytFR0JYaWo4WlIzcTFLTko2TkdSbzVKWUZTMnFIaFpiRngvTEMwT1dFdDd3ajBlNlBtbXNwbzhESWdxUkJmTCtLOExTRUw1dzVQaDBTN3RPTW1pQ0poemJyaTNTN2Y1TnNSejJvYUIzV1JNbHVMTGo2d3lDdlZIM2hscHFsa3N0bE1WZzJSTENvRHdwMG9Ic00zMkJOQy9NTXZvZXVwcUtmKzBVcktGMTFFeGNCQ0ZyMW5xcFE4NDJYOEpiZnQzbmxUVHQ2YzlEbVdGblBNcHUyUXpWaS85dm1YempyWHhPcGJoazlzQ04vcnJEM3JlTnBqWUdSZ1lBQmlZK2Z5MUhoK202OE16Q3dNSVBCWXlINEJndjZ2ejh6RGRCekk1V0JnQW9rQ0FQTTFDTE1BZU5wallHUmdZT2IrendBazR4bmtHQVNaZVJpQUlpaUFCUUF1dndHMEFBQUNVQUFBQVM0QVl3SWdBQjREWHdCVkFBQUFBQUFPQUlnQXhnQUFlTnBqWUdSZ1lHQmg4R0ZnWmdBQlJnWTBBQUFJYlFCV2VOcE5qRDF2d2pBUWhwK29DVkxEd0lJNk1MUWVPbHRCWVdCaVlXQmlaV0lCN0tJTWNaQWRJaUZWSGZuZFBZd0h6dExwZVQvT1FNa2ZHWS9KbU1UOW1KeEMxSk1MeGt3VGowUjlKUzZaOGMwYldmNHV6aWVyeExrays4UUZIL3drSG9uL203aGt3WDNkdFpkcmI3M2Fkc1o2ZDJwRFdPNnNEMDNuMUZ4WFVXK3NzLzdRVzZPT04yV0dKZ3puVnRXNjBqVnJPbG91WE9teGVCUmJjVXhreDBteUlHL0pManFCUmxJbnJUbWE2aVhmU081aTV4Qi9NdEk1Y3BOdEdPUXF5RDVMVzFISFMwMzlEK3B0TURzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVMEFBb0FBQUFBQmh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwMG1OdFlYQUFBQUU0QUFBQU5RQUFBRVFBV2dEMloyeDVaZ0FBQVhBQUFBSlpBQUFDMEt5UWRoaG9aV0ZrQUFBRHpBQUFBQzhBQUFBMktFdkRGMmhvWldFQUFBUDhBQUFBSGdBQUFDUUdOZ0hUYUcxMGVBQUFCQndBQUFBVUFBQUFGQTAwQUpsc2IyTmhBQUFFTUFBQUFBd0FBQUFNQVhZQ0dHMWhlSEFBQUFROEFBQUFHQUFBQUNBQUNRQk1ibUZ0WlFBQUJGUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZLQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1Xc0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpQQmtadmdQNURORHBKSFUvQWNLQXdEaGhBMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1U2NHRndaUFAvL0I3SWNJYXovQi83dis3OGJyQllNQU9FV0Mwb0FBQUI0MmoyU3owc1VVUURIMy9lOW1mZmMzWmw1cTdNN296bk9zcTNPaUtiRy9uamJiclJTcVlXU1dFSjRrSW9naGFBT1lYck1nNVJKSFNJSU9uWHBWcGRPRVhUcTFEL1FNU0U2UllSSFQ3dmJHeW5mNmZGOTcvRDU4UDBTU29hN1hmcURmaWRUcEV4SUhhcGU5bnczNTFXVXg2Y2c0aWl1S3Q5VDlTa1VCYzk1dnZJZDZEeUpLeTNVSyt3ajd2Q2N6ZEh5SnZLd3pJM3RIaE4yeHEyeWxPaDBGKzNBdFJsc2MzM0ZncFU2MlhyOXU3aEpyMmVSa3UxdFQ3SWhBY1pBZTZRQUxIOXRkaWMzbkFXVkRrL2l0T1FvZmNVMW9nOGo0OTAyNC9RekNja1lPYU5KM1dvcDVwcXRHQ0x2UUlUd3VRUVhSWDdFNnlad0tvcExFUmZzLzUzcEQ1VzN6d2ZqSVNteHNucWJiUzh2TElOZXlsNTUySGtaT0U0emZQUHE1Z2JGNU1XZGdtdmVmN2E2U2VucHkxL21ETUJab28xZXlnSUJlclU1dnk3VGk0MkZDMDdMU0F6Z1lwWTltQnVlb1pBRDdYZHNhM0ZraVhWKzl2RTBJU0N4NXM3U1QyU2VrQkhob1BRUHNPNU9ZeEpIQXNxVHlFWFR0S1lpb1hrbEt2cFplYjdnVWExYVYvRXh1bCtlMXYyb2NnSDAydzNEeXJiL0RFa05iVDdSZ0NNTm1hVm1uOFZ5QVdEUTg2c3Z0TUs1V3pNMW0vazRhL1N6bEtadnJjMG1MdSszbEN5UElVOXhzRytaTE9SYUlhUmhyN0NGb1EyUmNqOEVSdG9OVHJScVFIYmdFQk1ORjVrRGo2VU5NUzdjUVhSK2FUbE1PdXB1eHVEYXNkVHRvcTI3R2RYQ1RQQUMxTkZJanNmanFyZ2FDZDVDQVhYZjgzTThqamdlUFRWWWNLcEliYkgzT0dWQzlqVUx4aDVEVkF4Zzg5MWRIVGx1czBEdnRmZjdKYVVKNWZGVThnRWR6Wmg2SGtraFNaclNpMEdla0w4MWxHOTVBQUFBZU5wallHUmdZQURpS1JVR3grUDViYjR5TUxNd2dNQmpJZnNGQ1ByL1gyWUJwcnRBTGdjREUwZ1VBQjk5Q2t3QWVOcGpZR1JnWUdiNHp3QWtPUmlVL3g5bEZtQUFpcUFBVmdCS1dRTVBBQUFDZGdBQUF3QUFKQU1JQUNzQzlBQW5BY0lBSXdBQUFBQUFWQUN3QVNJQmFIamFZMkJrWUdCZ1pmQm1ZR1lBQVVZR05BQUFDRzhBVm5qYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjk3OTE2LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5FPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUzLjE1NTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02My43NDYyNTcnIHk9Jy02MC40NDc1MDEnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA5Ljc2NzYxLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU0LjMxNTIzLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYzLjc0NjI1NycgeT0nLTYwLjQ0NzUwMSc+STwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC41MzQ3IDBINDguMDk5OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMzQ5OTYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNi4zOTg1LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5hPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002NS4yMTEwNCAwSDEwMS40Mzk5NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDEuMzE0OTQsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODIuODY5NSw0LjE3MjkxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjc0NjI1NycgeT0nLTYwLjQ0NzUwMSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNi40MDQ1NC02LjQwOTczTDQ3LjA5MjM5LTQ3LjA5NjYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxLC0wLjcwNzA5LDAuNzA3MDksMC43MDcxLDQ3LjAwNDAxLC00Ny4wMDgyMiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lam9pbj0nbWl0ZXInPgogPHBhdGggZD0nTTMuMzk3MTMgMEwuMjUgMS44NzQ5NFYwVi0xLjg3NDk0WicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J002NS42MDY5LTQ4LjIwODc2TDEwNy4wNTE0NS02Ljc2MzI4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjcwNzA5LC0wLjcwNzEsMC43MDcxLC0wLjcwNzA5LDY1Ljc4MzY4LC00OC4wMzE5OCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcwOSwwLjcwNzEsLTAuNzA3MSwwLjcwNzA5LDEwNy4yMjgyMywtNi41ODY1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OC45OTIwMywtMzYuMTQ4ODgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUxLjk5NTkxOCcgeT0nLTYwLjQ0NzUwMSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDguODgyNTc1JyB5PSctNjAuNDQ3NTAxJz5iPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00NS4zNzkwMzcnIHk9Jy02MC40NDc1MDEnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$E$};
      \node  (2) [right = of 1] {$A$};
      \node  (3) [right = of 2] {$B$};
      \node  (4) [below = of 2] {$I$};
      \draw  [->,morphism] (1) to node {$a$} (2);
      \draw  [cover,morphism] (2) to node {$f$} (3);
      \draw  [cover,morphism] (1) to (4);
      \draw  [>->,morphism] (4) to node[swap] {$\mathsf {Img}(b)$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Since <fr:tex
display="inline"><![CDATA[a]]></fr:tex> is an isomorphism, it follows that the image of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is isomorphic to <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex>.
    Thus, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex> is an isomorphism.</fr:p>
  <fr:p>Assume the converse.
    Then the identity morphism factors through <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex>, i.e., <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex> is an isomorphism.
    Thus, it follows that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is a cover.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Related">Related</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>574</fr:anchor><fr:addr
type="user">log-000P</fr:addr><fr:route>log-000P.xml</fr:route><fr:title
text="Internal language of a category">Internal language of a category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category.
  The <fr:em><fr:strong>internal language</fr:strong></fr:em> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> consists of the signature <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> whose sorts are the objects of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, function symbols are the morphisms of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, and relation symbols are the subobjects in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p><fr:p>We write <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> for the canonical <fr:link
type="local"
href="log-0006.xml"
addr="log-0006"
title="Sigma structure"><fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structure</fr:link> that maps each variable to the appropriate product projection, each function symbol <fr:tex
display="inline"><![CDATA[f\colon A_{1},\ldots ,A_{n}\to B]]></fr:tex> to its underlying morphism <fr:tex
display="inline"><![CDATA[f\colon A_{1} \times  \cdots  \times  A_{n}\to B]]></fr:tex>, and each relation symbol <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1},\ldots ,A_{n}]]></fr:tex> to its underlying subobject <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1} \times  \cdots  \times  A_{n}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>575</fr:anchor><fr:addr
type="user">log-0008</fr:addr><fr:route>log-0008.xml</fr:route><fr:title
text="Interpretation of formulas">Interpretation of <fr:link
type="local"
href="log-0003.xml"
addr="log-0003"
title="Formulas">formulas</fr:link></fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>18</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with sufficient structure and <fr:tex
display="inline"><![CDATA[\Gamma  = x_{1}\colon B_{1},\ldots ,x_{m}\colon B_{m}]]></fr:tex> be a context over a signature <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>.
  Given a <fr:link
type="local"
href="log-0006.xml"
addr="log-0006"
title="Sigma structure"><fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structure</fr:link> <fr:tex
display="inline"><![CDATA[M]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the interpretation of a formula-in-context <fr:tex
display="inline"><![CDATA[\Gamma .\varphi ]]></fr:tex> in <fr:tex
display="inline"><![CDATA[M]]></fr:tex> is a subobject <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi \rrbracket \mathclose {}}_{M} \rightarrowtail  M(B_{1},\ldots ,B_{m})]]></fr:tex> defined recursively on the structure of <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> as follow:</fr:p><fr:ul><fr:li>If <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1},\ldots ,A_{n}]]></fr:tex> is a relation symbol and <fr:tex
display="inline"><![CDATA[t_{1},\ldots ,t_{n}]]></fr:tex> are terms of appropriate sorts, then <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .R(t_{1},\ldots ,t_{n})\rrbracket \mathclose {}}_{M}]]></fr:tex> is the following pullback:
    
    
      
      <fr:figure><fr:resource
hash="6ed2369964bbc52730b95a3062c9c119"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzM3Ny40NTI4MTJwdCcgaGVpZ2h0PScxMTcuMjE4NzJwdCcgdmlld0JveD0nLTcyIC03MiAyNTEuNjM1MjA4IDc4LjE0NTgxMyc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVNFQUFvQUFBQUFCVEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXaDJVV050WVhBQUFBRTRBQUFBTVFBQUFEd0FvUUNKWjJ4NVpnQUFBV3dBQUFHL0FBQUNBQTlIemVob1pXRmtBQUFETEFBQUFDOEFBQUEyS21YRENHaG9aV0VBQUFOY0FBQUFJQUFBQUNRSWlRUWdhRzEwZUFBQUEzd0FBQUFNQUFBQURBdjhBTnBzYjJOaEFBQURpQUFBQUFnQUFBQUlBSUlCQUcxaGVIQUFBQU9RQUFBQUZ3QUFBQ0FBQlFCVWJtRnRaUUFBQTZnQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRWVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbS9zYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFQwWmNoalp2Z1A1RE5EcEpIVS9BY0tBd0FJU0EycWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUSytqTGsvZjhQNUlQcC8xditUd0dyQWdJQWxwa0pKQUFBQUhqYUZaRE5idE5RRUlYdm1YdDdIVHYrLzdsT1NOSTBwTFZKYU9zMmJXeGFpYVNnQ21pRmtHREJpZzFTTnp3QVcwQkNxb0JGSG9BdEcrQVpZQTFQMGpkZ2hVeTUxb3cwYytZYmFYU0dnYjI1cnRlbTlJTTlaUXpja0dxSVVpVXVDaGhaZmxpbXM3S0tJUE9iV2Q2R0lkTlNwYklnalJaSUY2aWlhcDRWa05sY2J4NW9Ga0hQZFJNYjBoaG5Vbnk5NURERGJUOUVLRmVmQXFqNHpvQ3YvczBUMzdWb2RTbjR1ZW1EMVBIZDF4NGhhSjNlNG05NUVQZmpNUGEvSko1NGoyOTJFbngySTVOa3R4clFSWDNsU1FHQ3RCTVRRbkJYRnorbDQvcGpqL3N1dmFxdk9sc05IUktISUMrMndHK24rR3M3QW9CMFloTXdvL29ubmJ1RzFsMkhnSUNCdmJqK3c2ZjR4WjR4dHVUbHZNeHlGNGFMY1o3bFdWVTJvUnEzTTVWSUQwMG1zdEVMSEtRcWJieEtZeGQ1cVFkVm1UZEtldHlGL2xuMWUrUllFc0dOamN3bTAzWmErcDRWclI5dFBEZDZMeCtjUGFGRXBLNGxhSlF0UGRGcStNRDJKNmZGa3NpTWRvak9Iczg2d1ZiTG1KaG12NmNnTHo3czdTZ24yQVE5M0xWTUltdXQ2UGNMUWRQRjVnbmRPOW8rYVM5Ry9iWS81cmhmZUpxMzQvMDRMQVQySnQyd2VGYzhJckd2T29keCtuMFllV0c0enY0RDNJeEQyd0I0Mm1OZ1pHQmdBR0xSTU1uNmVINmJyd3pNTEF3ZzhGaklmaTJDL3YrVlZZdHBENURMd2NBRUVnVUE5SGNKV1FCNDJtTmdaR0JnWnZqUHdNREFxc3dROC84bnF4WURVQVFGTUFNQVdLY0Rzd05VQUFBRkl3QitBNFVBWEFBQUFBQUFnZ0VBZU5wallHUmdZR0JtQ0dZQTBReFFFZ2tBQUFqVEFGb0FlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ3dOcUZnWW1WcVF0Z0YyV3dqWndRQ2FucTJOL2RoL0hRTjF5ZCsyRUROVDhVM0s5Z2x2UitKWlc0QjFkTW1XZWVpSHZMWExQZ25TZUs4bG1TVno0eWw5SjhacTU0NFN2elJQTHZ6RFVyZmpmQlhhNkRqV29YakkzKzVGeTMzdHZZZDhHcnBXNlMzMXB2NDJHd1JoMXZ5b3hkUDU2ZGFuV2pXellFSEJldURGZ2lpcDBrSnJIbkpKMmpZODArSmIxd2tGeXhSTlA4NjdmUys3UTVwSitNYkk3Y1JBMmpMSHJSczJ3VmJYcXBhZjhBeUJFdjd3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFQVUFBb0FBQUFBQkVRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY04zZm1OdFlYQUFBQUU4QUFBQU1nQUFBRHdIRC8wY1oyeDVaZ0FBQVhBQUFBRDlBQUFCREtLbE81bG9aV0ZrQUFBQ2NBQUFBQzBBQUFBMko3dkNWMmhvWldFQUFBS2dBQUFBSGdBQUFDUUZlQUdGYUcxMGVBQUFBc0FBQUFBUUFBQUFFQWZ1QUw5c2IyTmhBQUFDMEFBQUFBb0FBQUFLQUxJQVZtMWhlSEFBQUFMY0FBQUFGd0FBQUNBQUJnQWZibUZ0WlFBQUF2UUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQUR4QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1ZbU9jd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBwcU1FOW1admdQNURNek1JS0VHUkVxL2dPRkFjZFREVFFBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeW1veVQvNy9IOGpYQU5IL2IvNHBBS3NDQWdDV3l3a3BBQUI0MmkzTlQwckRRQmlINGU4M1V4T1IycHJReklTWW1wckF4Q0pVR2sxQ0VGMklpb2hkcFlJYkxmMmpJcDdBQTRqbjZFcndCTDJPRzlldVhObHFpTDRIZUY0Q1RYNElmVTRraVpZYXZnbzdTRldTSGlLcW93YXBtUjRFY2pIdXRsM0FWZDA3Z2VyTkdkanhvTTYvVmthRHE3ZURvK25sK0xhNk52eCtlVm9zSmthRmlrQlo0YmIvWEFoTnI4R1BDelhjVXp0UWFSSUp1UUZzbGFLMWVuM084Z3VUQTFiNW9YOXhOSCtlZnZiTUNpcy9oZWtUc1Q2YlViTXdaZENCSGloTkdwclloeFVHZXJ3YkphR1JxRzNFTEcwNnl5ZVBENEVCN3AxdTVxODlPM01ZY3pLYnpUN3VoNEJwejkvWFJZdnpWc05sdG10NVJMLzV4Qy82QUFBQWVOcGpZR1JnWUFEaXE5cEJFK1A1YmI0eU1MTXdnTUJqSWZ1MUNQby9BMU1ETTRqTHdjQUVvZ0FLR2dqY0FBQUFlTnBqWUdSZ1lHYjR6OERBd05UQW9BUWtReGlBSWlpQUJRQTB4QUlEQUFBQ2dBQUFBWTBBWkFHTkFEa0NWQUFpQUFBQUFBQXNBRllBaGdBQWVOcGpZR1JnWUdCaGtHTUEwUXhRRWdrQUFBUEJBQ1lBZU5wRmpERnZ3akFRaGIrSUJJbDA2RkoxWUFBUHpGYWlNSGRoWUdKbFlnRnNvZ3h4a0JNaUlhR08vZDA5akNWdWVQcnV2WGNINVB5UzhKeUV6NkRQU2Nsa2UzSEdCMStScDdJdEkrZk1XVEVoU1dmaUxQaUpuRXB5aUp6eHpTWHlWUHhINUp3MWY1dXV2ZDRHNjlXdU05YTdjK3ZMWW05OTMzUk9sYm9JKzlZNjY0K0ROZXAwVjJacytyRnVWYVVMWGJHaG8rWEtqUUdMUjdFVHh3UjJuQ1h6bEJUc2c5UFRTT3FrVmFMRmZlZGJ5VjNvSE1Nbkk1MFRkMUhES0ZlOWFDMXRSUlV1TmRVL1l6MHZEd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVlFQUFvQUFBQUFCN0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVZDArMk50WVhBQUFBRTRBQUFBUWdBQUFGUUF1d0Z2WjJ4NVpnQUFBWHdBQUFNWEFBQUVVT0U5eitOb1pXRmtBQUFFbEFBQUFDOEFBQUEyS2NyQ1VHaG9aV0VBQUFURUFBQUFJQUFBQUNRSHZRTXZhRzEwZUFBQUJPUUFBQUFjQUFBQUhCSndBYjVzYjJOaEFBQUZBQUFBQUJBQUFBQVFBczREMEcxaGVIQUFBQVVRQUFBQUZ3QUFBQ0FBQ1FCdmJtRnRaUUFBQlNnQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRitBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVdzUTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWVNoaFp2Z1A1RE5EcEpIVS9BY0tBd0RqSGcweWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCeUFOQThEQjFDT2hVR0hRWS9CbHlHUG9lVC9mNkFvaEpjTDR2Mi8rdi9LLzIzL3AvK2ZCTllIQndDK3VCQWhBQUI0Mm4yVFM0OGJSUkRIdTZwbnV1MFplOGFlUi9maUhiL0czdkd1SGV6MVkyZklybVB2NGtBQ1JFb0NFdUVXNVJBVUNjaUZoOFFCQ1lnaVJRSUpSZUVUY09DRXhCZEF5bzNQRUNtUmNrTEtGeUNuYkV4NU56a1FLVHN6M1pydXFpN1YvMWZWRE5pWHkxMzJML3VHS2NZeUtXUWZKbWxXZzFDNElHVFNTYk1aUENqWWZsUnZWTnB0WXlPLzRkb2N4TGhleWttQTVxZ0pNQnRlMlNtT0FJdlNIRjVsOUFEN2l1WW5GTk9pbUE3SU9LR1lJL1VFR3BXdzNhaW8xcTZPb1RHbVFiNFhsa3ZqRjd6UEx0RkJMb1dxUXhxSUFiaVFEQ2dWcmRMTXAwemlqZzFDcjZ4S096QUFTZFlaNkJsa2ZwYlNmMHNrcVI2blN2dXI3WEdxQTlGSmhLSHVHQ0M5VHQwMWZ6eVkyeHhMem02VjMzMSsyUW9DdUhuSEJBd0dUZzdBTlQvL3pPSUlSVG50bWo4WWtDc0ZmaE04OTE1WTROZmhKOHNKZnE2Q1Y4b2l2SEg0ajVZUzBHaEpNSUJJeURKeDhDcDQ5dkJXd0NPOGVmZzROQW9SUjU0bmcyR1FReWtIdkxlT3FLUUFic1RrbnZjUDcrTjVoK3krUzh2Z2lObjI4aWwvQkgrekx4amJtSk9JcE9Od0Z4MmVkT1k4M1puUUV1UktlUitvSnFoVzB0T2pXZWtheUtOeU9WUTJQVXF6ZEh5MFJXK2NkQ1p6cEowWHg0OERUakw0cStkeURIcW5QK2c1c2hxWStUQUt3T29WYk9INnRkZzJwV1VMQ01yNXp1S3MxRmYydHo2MDFqNTU1OXhhWkJNeDlHM0g0dFhHcm9kZVhvQXFsRnRuTms4REwyNkVpT0hXOU9JYmppMmowTXlwOVJETWovNlkrcTB4eCttc1dmMzZVdUE2VUNwMy85enU2MUlZQWV6M0F3cUo3a0hOYjJOM3A3bUgyTjF2TGREVWE1TmlmeXIyMXB2TmNvenpNeDZpM3RhcWJ3eTJDbmJqMDhVd0hDSXVOc05LN1dWUTAyY3ZPZUp2eFBFaVl5ZUJPd2tZT1I0amUxR0E3MTRMNXRUSGZBV2tVTFI0MU5qenNHd0owSGE1TmR0OEMzakJWUXBmaFh4d2t2YitlNi9YM0g1N01mUmVBYm5TMjFzK2hkdjRQVHZGbU0rbG92dEszLy8wWlA3eDdWanBVbHFPUnlxazIvSHNmWUZ4Nzd3eWMzbXFZczNWdmNXYisyQ2V1MVpGejcxUnoxbEpFN2V1T1dYUGhWK2ZQK3p1SUw0N0trcHE0KzAxU21uY3R6V3NjK3JtYitNdVl2MTN3NkkrWi84QjZmNk1hQUI0Mm1OZ1pHQmdBT0trcmY5ODQvbHR2akl3c3pDQXdHTWgrN1VJK3I4VlN6L1RmaUNYZzRFSkpBb0FMRVFLWkFCNDJtTmdaR0JnWnZqUHdNREFFczJnL2Y4TVN6OERVQVFGc0FNQVhWd0Q5QUxHQUFBQld3QnpBVnNBZEFSYkFFd0VEUUF3QXRNQU1BRzVBQ3NBQUFBQUFDb0FRQURFQVdnQjRBSW9lTnBqWUdSZ1lHQm55R01BMFF4UUVna0FBQXZpQUhrQWVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6c3RtYXJ5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTkFBQW9BQUFBQUE4UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnY0t4WmxtTnRZWEFBQUFGQUFBQUFMZ0FBQURRQURPQ2VaMng1WmdBQUFYQUFBQUNPQUFBQXFNRGJrM0ZvWldGa0FBQUNBQUFBQUM0QUFBQTJKdmpDVjJob1pXRUFBQUl3QUFBQUlBQUFBQ1FGWlBaTWFHMTBlQUFBQWxBQUFBQUtBQUFBQ2dOcEFKQnNiMk5oQUFBQ1hBQUFBQWdBQUFBSUFDb0FWRzFoZUhBQUFBSmtBQUFBR0FBQUFDQUFCZ0FaYm1GdFpRQUFBbndBQUFDeUFBQUJMRU52Wll4d2IzTjBBQUFETUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtM000NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBQUJKSFpLY1ZrNkE5c0Ryd2Zlek5WZlRCZ1ltS3U1endDRkdSRXEvdjluWUFBQVRZd1Evd0I0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUSs4Ly84SGtsNy8vOHR2QjhzekFBQm1wUWVIQUFCNDJtTmdZcGp3bjRGeEx6TURnekNET0FPRHVLQ1p1YUtZdUNnYnU3S2dNWmhXVkJNR01pY3c4VElLOERBeDhjVEhnOGgvSDNoN29xTS9NVC9oWldUa0ZlTmwvSk1DcGhpWnovNUpZV0JnWXRBR21oa0dOSk1aYktheG9MSXd5Q0IxVXpOeklCdE1BeTA1R1IzZEN6VHFJOGlNdURnUXljalB3M1NPZWM0ZkI2aXh6SE1neHZJeUFBQ1RzaDJOQUFCNDJtTmdaR0JnQU9Mb09YdXk0L2x0dmpJd3N6Q0F3R01oKzdVSStqOEQ0MTVtRUplRGdRbEVBUUFXN0FsVEFBQjQybU5nWkdCZ3J2NWl3c0RBK0pKQm0wR0hjUzhEVUFRRk1BRUFYb29EcWdGVkFBQUI2UUNRQUNzQUFBQUFBQUFBS2dCVWVOcGpZR1JnWUdCbWtHQmdZZ0FCUmdZMEFBQURKd0FnZU5wZGpzRUtna0FRaGo5Sml3dzZCblhhSjFnVWc2QVhzQ2Z3cnJpRWtBcXVDSGJvMlJ0bFRzNWg1dHQvdm9FRlluNEVMQlZ3V1B0U29mQkJPZUxFV1hrdjZWVTU1b1poUnhBZUpUbnpWQTZGWDhvUkZ3cmx2ZVFmNVpnN1h6KzI1VEEvZEJSdThFM2ZtZFFtbXVTdWMwTTV1dHBVczZtbnhrL3YxbVEyc1JtZWtaYVNnWm5INWxYZ2hEd05QWjM4TU1XU2JKeGNuRzcxU3NrZHRYaVZiSXpRSkpkZStsdDhRN1plVzdJL1FhUXRmUUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6c3RtYXJ5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU04QUFvQUFBQUFBOUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2NIQlpGbU50WVhBQUFBRkFBQUFBTGdBQUFEUUFET0NlWjJ4NVpnQUFBWEFBQUFDSUFBQUFxSU9QTy8xb1pXRmtBQUFCK0FBQUFDNEFBQUEySnNEQ1YyaG9aV0VBQUFJb0FBQUFId0FBQUNRRTFmWGphRzEwZUFBQUFrZ0FBQUFLQUFBQUNnTUxBSGRzYjJOaEFBQUNWQUFBQUFnQUFBQUlBQ29BVkcxaGVIQUFBQUpjQUFBQUdBQUFBQ0FBQmdBWmJtRnRaUUFBQW5RQUFBQzJBQUFCTlNDU1NNdHdiM04wQUFBRExBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWJHV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCMXdOdlpyTXYyZ3dNekdiY1Y0SENqQWdWLy84ek1BQUFMandRUXdCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1ErOC8vOEhrbDcvLzh0dkI4c3pBQUJtcFFlSEFBQjQybU5nWWlqL3o4RFl5c3pBSU13Z3pzQWdMbWhtYml3bUxzckdyaXdJcGRXRWdjeHlScTd2M0l5TTNGRlJJUEk3VjExWTJGZm1WMXlNakZ6Q1hJeC9nc0FVSS9PMVAwRU1RTURFSUFrMFV3Vm9KalBZVEdOQlpXR1FRZXFtUU1NRm9iU1krSkx3OEFaR3JxOGdROExEUVNTUWVaMTUzUjhUcUxITTZ5REdjZ0dOQkFBdWd4dzRlTnBqWUdSZ1lBQml1WTNManNUejIzeGxZR1poQUlISFF2WnJFZlIvQnNaV1poQ1hnNEVKUkFFQUYvb0pOZ0FBZU5wallHUmdZRGI3b3MzQXdEaVhRWkpCZ3JHVkFTaUNBcGdBUmxRQ3NnQUJWUUFBQVowQWR3QVpBQUFBQUFBQUFDb0FWSGphWTJCa1lHQmdacEJnWUdJQUFVWUdOQUFBQXljQUlIamFiWXd4RDRJd0VJVWZFUWppd3VTZ1N4UDNCbEpYWnlaWE5vY1NHc0pBU1NnaFlYSHhqL3NnMVVWdnVQdnUzWHNISU1VVEFkWUtrR3g5clpDY2VJNXdRT1k1cG5yMm5PS0VDM1lJd2oyVkREZlBJZm51T2NJUkQ4OHhkZWM1eFJVdk4vVjZYSXI4TXlzenVtNndvcEJmcVRUV2pIb3lqYWdYMGN5ZG05dGVLSmxMeFZjVGVtaU1XRkFnLzlrckdMSkRod0VXZ3ByODR5cnBzcHRUODJMUTBGbnpKa2d6czQ2OVpVSkFiWGtKOVFiQnVTNnBBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRc0FBb0FBQUFBQkx3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY04zeEdOdFlYQUFBQUU4QUFBQU5RQUFBRVFBUmdRbloyeDVaZ0FBQVhRQUFBRlhBQUFCZlA2UDF0NW9aV0ZrQUFBQ3pBQUFBQzBBQUFBMktBN0NXR2hvWldFQUFBTDhBQUFBSGdBQUFDUUYxZ0haYUcxMGVBQUFBeHdBQUFBVUFBQUFGQXRIQVdWc2IyTmhBQUFETUFBQUFBd0FBQUFNQUx3QkhtMWhlSEFBQUFNOEFBQUFGd0FBQUNBQUJ3QWdibUZ0WlFBQUExUUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQUVJQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm04bUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBwcU1FOW1admdQNURNek1JS0VHUkVxL2dPRkFlREJEWG9BQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnTWdEUUhFSUxrTkJrTW1TZi8vdzlrYVVCWS8yLyt2L1NuRUt3V0RBRGxMUXRxQUFBQWVOcGQwTTFLQWxFVUIvQjd6bzE3bVJGbkZHZkdkTUQ4YUdhSXlpQ2RPMnFRdFVnU0NscElSVmxRZ2hGSWFMaFVpRDVXMFJPMGN0a1QrQUlSOUI2MXFVWHJGbElqMGlZT25ITld2Ly9oRUNEZEg0QXJTa2ljRUlnYUdtY3FNTTRNZjFYQmR2enk3RElJYUFVNVh5L3hJb1hkcHN5RGQ2NFNzQkFYRlVFSllJamxXNkhPeThQM2tSUkNPTzJua3YzRzVZMTE3Wk5rMC9kckV6L2lxMUdEYTR3cllIdjVNcXlDbHdYSGRvVlh2eFZqY0M0dExreWdhcTBPdEZPUmdGRXkwUTRHYXljTmxPbFVlT3RyOFB4ZWtwbUVoSXo5dHQvZThJbkUvQmxteGdyb1M2Q0NtMXNXVGxnQnh6V0VKd3pZbzhtcWM3YlRyampWSkYyb2FhbHVUZy9nL2VnMXJsc1VFQzA5anJJbXdTd2FXWkRIYnBFUWZNUWhTWXova3NrQ3o2Ulo5SCtBc09mQnhkNU1SdHJ1OURJcTBNVEc3T0YrVThRS0pxSlppT0h3OC93WVF0T2pqNzhjTFk1aE0yTDVwLzhDNmhvOUZ3QjQybU5nWkdCZ0FHSy9YUFBPZUg2YnJ3ek1MQXdnOEZqSWZpMkMvcy9JZEprWnhPVmdZQUpSQVB1dENNZ0FBQUI0Mm1OZ1pHQmdadmpQd01EQWRKbkJFa2pPWmdDS29BQldBRVEyQXJVQUFBTFRBQUFCeVFCMEFja0FTQUpIQUhBQ213QTVBQUFBQUFBd0FHQUFqQUMrZU5wallHUmdZR0Jsa0djQTBReFFFZ2tBQUFQMUFDZ0FlTm85akRHcndqQVVoYjlpRmUwYkhBU0hOMGp3QjRSS0g3aTRPVGk1T3J6Tm1pQWRta3BhaXk3aVQvYzJCRy9nOE4xenpnMlE4U0pobUlSNTBHRlNlZlBJWTM1WVJKNkl2NHFjOGN1YUVVazZFMmZGTG5MS2xQL0lZNWFVa1NmaVB5Sm4vUEhlTi9YdDNsbXZqbzJ4M2wxcXZ6MVozMWFOVXh1ZEQrdkJPdXZQblRXcWZDclRWMjEvclZXaGMxMndwNkhteHAwT2kwZHhGTWNFZGx3azgydzVoYjJsa3N4Slo0TW0vNllIU1Yxb25NTXZSaG9sVDFGREx6ZXQ2Rlc2aWlMY2FZb1BXS3d1U3dBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNY0FBb0FBQUFBQTRRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVXgxRzJOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDRVoyeDVaZ0FBQVdRQUFBQmtBQUFBWkRGdUFySm9aV0ZrQUFBQnlBQUFBQzBBQUFBMktJekRBbWhvWldFQUFBSDRBQUFBSGdBQUFDUUZ5d0xXYUcxMGVBQUFBaGdBQUFBSUFBQUFDQVlLQUpKc2IyTmhBQUFDSUFBQUFBWUFBQUFHQURJQUFHMWhlSEFBQUFJb0FBQUFGd0FBQUNBQUJBQWdibUZ0WlFBQUFrQUFBQURLQUFBQk11c0lrZVp3YjNOMEFBQUREQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1abVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvYU1oZ3lNL3dIOHBraDBraHEvZ09GQWFOM0RGZ0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aUcvLzlEeVA4WHdId0dBRkZIQm8wQUFBQUFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FlTnBqWUdSZ1lBRGlIMGUrYll6bnQvbkt3TXpDQUFLUGhlelhJdFBNUVV5cmdSUUhBeE9JQndCQjdnbmFBQUFBZU5wallHUmdZR2I0endBa2d4Z21NVFF5bVRNQVJWQUFFd0JDM0FLb0FBQURVZ0FBQXJnQWtnQUFBQUFBTWdBQWVOcGpZR1JnWUdCaWtHY0EwUXhRRWdrQUFBT2tBQ1VBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktuNXViZzVPcnc5dXNDZEtocWFTMTZDTCtkRzlEOEFZTzN6M24zQUFaTHhLR1NaZ0hIU2FWTjQ4ODVvZEY1SW40cThnWnY2d1prYVF6Y1Zic0lxZE0rWTg4WmtrWmVTTCtJM0xHSCs5OVU5L3VuZlhxMkJqcjNhWDIyNVAxYmRVNHRkSDVzQjZzcy83Y1dhUEtweko5MWZiWFdoVTYxd1Y3R21wdTNPbXdlQlJIY1V4Z3gwVXl6NVpUMkZzcXlaeDBObWp5YjNxUTFJWEdPZnhpcEZIeUZEWDBjdE9LWHFXcktNS2RwdmdBVlRJdVF3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQWFRQUFvQUFBQUFCK3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVZDB1Mk50WVhBQUFBRTRBQUFBUndBQUFGd0JSQUVpWjJ4NVpnQUFBWUFBQUFPVUFBQUVkTEtnSHFCb1pXRmtBQUFGRkFBQUFDOEFBQUEyS1dqQ2JtaG9aV0VBQUFWRUFBQUFIZ0FBQUNRSFJ3S2VhRzEwZUFBQUJXUUFBQUFnQUFBQUlCTVNBVzFzYjJOaEFBQUZoQUFBQUJJQUFBQVNCRlFER0cxaGVIQUFBQVdZQUFBQUdBQUFBQ0FBREFCZGJtRnRaUUFBQmJBQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBR2hBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVNtS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHJxTUpRd00vd0g4cGtoMGtocS9nT0ZBY3ZlRFBJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEeUFOQjhEQjFDT2pVR0hRWS9CaWNHWElZaWg1UDkvb0RpSTd3amovNy82LzhyL1EvOTMvTi95ZnpKWU54SUFBRDFYRWxvQWVOcFZrMDlzMjFRY3g5L3Z2ZWYzNGpUMmMrM0VKbitjTkUxclE5WW1yRW50SldpWklLUWRsRlpsVTZFYmt4Q1RvRUppSEdEZHBGNEkwd1JJMjRRRUVoSmNPTUNONnlRdUV3ZWtTUnluSVk1TW1qaHc0SVFFeHlUOGJHMElMUHZwK2ZsbisvdjlmbjZQQU5tZjljazljb2tVQ0ltRkFoUENJQjVBM0pXaTBZSnVGTHYzZUVNc3VjQlVxUW5jeVJkOXYzZ0tYdTFtajBPT21xWDluczBWTEt6VWdCTThnSnpENnk1NWgyVHdleVlzQnQxb3piMEx0ZFVhbnBHYmpEV3NvMlJwTnFNUDZhK2tUZGF3RXFKNHpmV2N2TnVKWE5FR0dRWmhOL0xjS0c1RFhZcTg2MFdlQ2JpZUxIZFFYb2Q5RDIrS3ZDRmc0SzRXSUtkZEhtYzBNT2FjTHRQbGRMWmpWQnlEZ2FFZDdPY2dweThPdnZ5amZvVytZb0d1Sm1OWE1WOENZMEF6U2dMa3ZMZEcxL05MRmxCbGltUTVxd1EwZm9JemlSOUdqczBtVE5BN3BFcWE1QVFxZGJxTlVLQzJlaFVLSnNncWVKaWFrSFdSNm5VU2NWRVFOZ0loMmVNNXc0TE90N2ZLb2E4VTdGKzR5TVpudDg0QzNiUzJENmVmVjB5elgvMzZpOWN2VTJnTnI5Y2M3ZDJiRjY1USt2VHBIemM0Z0xsTGUvT1VWU1RRbC9zdkhxanNUbS9yT1hQQUV3Zmd3SWk5dDdIMFBBVlZuSHpIcnU0czc3THBiN2JJSmh4V1pqTytTbjhnbTNpREFxb1FwUUgrRzZ5RG9vUDFPUkFGNGRiQUxhUlBFeE1vMm9sU2k4akNjMkFBeVVTRWdXQzNQMEZKeXozTWRmeEJWZ1BMNkZlMXo2WVh4Ync2ZDRORCtSamlNUG5iQjRiQlQ2NklqMkJZdGRSTkp3ZTdjSmd4N1kvTG9PellwNWNtRDJ4cENKNHlvRWhFb0pNcTNacGNOVGtyMEtQSmZWTjNpZ0JVTjFOS1pSeWJDN1JpTWVaanFaeWYzS0duRTFJWUNoVFNYbXJPZm1jYU1yTElhNG5iSlBjQnJBZHRDSktHZHBCUlhxVkdPMmc4aWowM3ZaZm9LWW5qRkZwY1R6a2h6U2ovdi9iN0QyMFBYNER4OFAzUm5sTXQ4MjZodHo1UTJVK0xJOFlsQi9zSko4STJGQnE0cHQvUE5SMzdLYTdOQ1oydWpvNkdERE16TXRjK3hBNU5ZR3UzS29Gdld0QTRPS0o4WTVNZVR2K0NaWGRocnpLMFpZNEN0YWUveVBnWnI5aGZMUHAxQ09NY28xUTNtdmFUR3MxcWMrNnpWckhsaElZL29OTS83Y2M1UHVwbHpQRlJ1OERlY0x2YndUN3dabi9ER1hxTnJCRGlNQ2tLK1RqSkFQZFRYcUloMlVyMnU5TVFDV1VNRGFOUjBNRVF3cDlmNG5TaDlNS2lsdFY1eWZUQ2s4ME8vbVR6dkE5S3ZSSHFGVjZoc25IZVZ4WjhOYjN2WnUzamxKN1l0b0NaZXJ0WWFuSG9OR1VONmdteWIwbzVnSEw5UmlJTGNmMEQ1dTZtbFhqYVkyQmtZR0FBNG9JclozWGorVzIrTWpDek1JREFZeUg3dFFqNnZ4V0xMdE5kSUplRGdRa2tDZ0FpdnduOEFIamFZMkJrWUdCbStNOEFKQjh5aVAvZndxTExBQlJCQVJ3QVgwOEQ3QUFBQW5ZQUFBRWNBRmdCSEFCWkF3QUFKQU1JQUNzRDRRQXNBd2tBS2dGeUFCY0FBQUFBQUNnQVBBQ1FBT3dCWWdId0Fqb0FBSGphWTJCa1lHRGdZSWhoWUdZQUFVWUdOQUFBQ21rQWFuamFUWTZ4YXNNd0VJWS9VOGRRcDlDcEhUb1VUUm1GamZzQWdReVpzbVlzSkpFSURrZ0tzbVBJRXZvQWZlaGVGQTA5d2ZIZGQ3K0VnSm9iQmZjcWVFMzlYaVdWVEErZU1lY3RjeVZIWmE3NVlNRVRSZmtzNXBObDVwSVh2alBQZU9lVXVSTC9rN25taTk5VmNPZkxhS1BhQkdPalB6alh0ODNXeHFFUFhyVzZlWWkxOVRidVJtdlUvcXJNMUEvVDBhbE9ON3BqUmNCeDVzS0lKY3JQTm1KTVlzOUJkbzZlbG9adGNvTk1RVFpLbkJiN1A3R1doRStwWFhyTlNHclBWYnBoa3N3Zy9TaHBSWmZ1YXJvLzMvUXd1d0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpzdG1hcnk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpzdG1hcnkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjcge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTI3LjQ3MDcxNSwtNjMuMzcyNjI4KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQwLjM5MDczLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yNy40NzA3MTUsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMjcuNDcwNzE1JyB5PSctNjMuMzcyNjI4Jz7ugYo8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTIzLjQ1Nzk3NycgeT0nLTYzLjM3MjYyOCc+zpM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTE3LjIzMTMwOCcgeT0nLTYzLjM3MjYyOCc+LlI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTYuODIyNDAyJyB5PSctNjMuMzcyNjI4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yLjk0ODAyOCcgeT0nLTYzLjM3MjYyOCc+dDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PScuNjQ5NjA2JyB5PSctNjEuODc4MjQ3Jz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzUuMTE4OTc2JyB5PSctNjMuMzcyNjI4Jz4sPHRzcGFuIHg9JzkuNTQ2Nzg0Jz4uPC90c3Bhbj48dHNwYW4geD0nMTMuOTc0NTkyJz4uPC90c3Bhbj48dHNwYW4geD0nMTguNDAyNCc+LjwvdHNwYW4+PHRzcGFuIHg9JzIyLjgzMDIwOCc+LDwvdHNwYW4+PHRzcGFuIHg9JzI3LjI1ODAxNic+dDwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzMwLjg1NTY1MScgeT0nLTYxLjg3ODI0Nyc+bjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSczNi4yNzg2NDMnIHk9Jy02My4zNzI2MjgnPik8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNDAuMTUzMDE3JyB5PSctNjMuMzcyNjI4Jz7ugYs8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNDQuMTY1NzIzJyB5PSctNjAuMzgzODUxJz5NPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zNC4wMjE5NiwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTI3LjQ3MDcxNSwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yNy40NzA3MTUnIHk9Jy02My4zNzI2MjgnPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTE2LjcxOTM3MycgeT0nLTYzLjM3MjYyOCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTIuODQ0OTk5JyB5PSctNjMuMzcyNjI4Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy01LjI4ODI0JyB5PSctNjEuODc4MjQ3Jz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0uODE4ODcxJyB5PSctNjMuMzcyNjI4Jz4sPHRzcGFuIHg9JzMuNjA4OTM3Jz4uPC90c3Bhbj48dHNwYW4geD0nOC4wMzY3NDUnPi48L3RzcGFuPjx0c3BhbiB4PScxMi40NjQ1NTMnPi48L3RzcGFuPjx0c3BhbiB4PScxNi44OTIzNjEnPiw8L3RzcGFuPjx0c3BhbiB4PScyMS4zMjAxNjknPkI8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScyOC44NzY5MjgnIHk9Jy02MS44NzgyNDcnPm08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMzYuNDQ0NjY0JyB5PSctNjMuMzcyNjI4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTExLjYwOTdWLTQ3LjQ5NTc3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsMC4wLC0xMS44NTk3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDcuNzQ1NzcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjI2Mzg5LC0zMC40NTI3MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTI3LjQ3MDcxNSwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTYxLjQ4NTYzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yNy40NzA3MTUsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjcuNDcwNzE1JyB5PSctNjMuMzcyNjI4Jz5NPHRzcGFuIHg9Jy0xNi43MTkzNzMnPlI8L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMzcuODU2MDIsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yNy40NzA3MTUsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjcuNDcwNzE1JyB5PSctNjMuMzcyNjI4Jz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xNi43MTkzNzMnIHk9Jy02My4zNzI2MjgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTEyLjg0NDk5OScgeT0nLTYzLjM3MjYyOCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNS4zNzMnIHk9Jy02MS44NzgyNDcnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLS45MDM2MycgeT0nLTYzLjM3MjYyOCc+LDx0c3BhbiB4PSczLjUyNDE3OCc+LjwvdHNwYW4+PHRzcGFuIHg9JzcuOTUxOTg2Jz4uPC90c3Bhbj48dHNwYW4geD0nMTIuMzc5Nzk0Jz4uPC90c3Bhbj48dHNwYW4geD0nMTYuODA3NjAyJz4sPC90c3Bhbj48dHNwYW4geD0nMjEuMjM1NDEnPkE8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScyOC43MDc0MDknIHk9Jy02MS44NzgyNDcnPm48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMzQuMTMwNDAxJyB5PSctNjMuMzcyNjI4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J000NC45NDYyNyAwSDE1Ni40MzAwOCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNTYuNjgwMDgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDAuOTM4MTcsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTI3LjQ3MDcxNSwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTE3MC43MTY1Mi04LjYwOTczVi00Ny40OTU3NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDE3MC43MTY1MiwtOC44NTk3MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwxNzAuNzE2NTIsLTQ3Ljc0NTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNzMuOTgwNDEsLTI4Ljk1Mjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjcuNDcwNzE1LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMzguNTc3NS01Ni45MDU1SDEzMi44MDA0OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMzMuMDUwNDgsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ0LjU2NTU1LC02NC45NjczMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTI3LjQ3MDcxNSwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNy40NzA3MTUnIHk9Jy02My4zNzI2MjgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTI0LjM1NzM3MicgeT0nLTYzLjM3MjYyOCc+7oGKPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yMS4wMjYwOTYnIHk9Jy02My4zNzI2MjgnPs6TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xNi4xMDAwOTcnIHk9Jy02My4zNzI2MjgnPi50PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0xMC43MjQzODQnIHk9Jy02Mi4zNzYzNjQnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTYuODM2MTMzJyB5PSctNjMuMzcyNjI4Jz7ugYs8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTMuNTA0OTA1JyB5PSctNjEuMTMxMDM0Jz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzMuOTMyNTM3JyB5PSctNjMuMzcyNjI4Jz4sPHRzcGFuIHg9JzcuNjU5MzE0Jz4uPC90c3Bhbj48dHNwYW4geD0nMTEuMzg2MDknPi48L3RzcGFuPjx0c3BhbiB4PScxNS4xMTI4NjcnPi48L3RzcGFuPjx0c3BhbiB4PScxOC44Mzk2MDEnPiw8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PScyMi41NjYzNzgnIHk9Jy02My4zNzI2MjgnPu6BijwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PScyNS44OTc2NTQnIHk9Jy02My4zNzI2MjgnPs6TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzMwLjgyMzY1NCcgeT0nLTYzLjM3MjYyOCc+LnQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMzYuMTk5MzY2JyB5PSctNjIuMzc2MzY0Jz5uPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzQxLjA4NTAzNicgeT0nLTYzLjM3MjYyOCc+7oGLPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzQ0LjQxNjI2NScgeT0nLTYxLjEzMTAzNCc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSc1MS44NTM3MDYnIHk9Jy02My4zNzI2MjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \DiagramSquare {
        width = 6cm,
        nw = {{\mathopen {}\llbracket \Gamma .R(t_{1},\ldots ,t_{n})\rrbracket \mathclose {}}_{M}},
        nw/style = {pullback},
        ne = MR,
        sw = {M(B_{1},\ldots ,B_{m})},
        se = {M(A_{1},\ldots ,A_{n})},
        west/style = {>->},
        east/style = {>->},
        south = {({\mathopen {}\llbracket \Gamma .t_{1}\rrbracket \mathclose {}}_{M},\ldots ,{\mathopen {}\llbracket \Gamma .t_{n}\rrbracket \mathclose {}}_{M})},
      }
    ]]></fr:resource-source></fr:resource></fr:figure></fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[s]]></fr:tex> and <fr:tex
display="inline"><![CDATA[t]]></fr:tex> are terms of the same sort <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .s=t\rrbracket \mathclose {}}_{M}]]></fr:tex> is the following equalizer:
    
    
      
      <fr:figure><fr:resource
hash="ed5b657b8e31b55f3106c22aefbf15bd"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMxNy4yMTQzMDZwdCcgaGVpZ2h0PSc0OS4yODU5MjhwdCcgdmlld0JveD0nLTcyIC03MiAyMTEuNDc2MjA0IDMyLjg1NzI4NSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU93QUFvQUFBQUFCQ2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXaDJiV050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNnWjJ4NVpnQUFBV1FBQUFEeUFBQUJCSkRUM1NCb1pXRmtBQUFDV0FBQUFDOEFBQUEyS21YRENtaG9aV0VBQUFLSUFBQUFJQUFBQUNRSXF3UWZhRzEwZUFBQUFxZ0FBQUFJQUFBQUNBaDNBSDVzYjJOaEFBQUNzQUFBQUFZQUFBQUdBSUlBQUcxaGVIQUFBQUs0QUFBQUZ3QUFBQ0FBQkFCVGJtRnRaUUFBQXRBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRG9BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXNXYWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHI2TXZneU0vd0g4cGtoMGtocS9nT0ZBYjRERE1jQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpKy8vOUR5UDlid0h3R0FGT1RCcWtBQUFCNDJoV0tNVTdEUUJSRVBYK1h2empZNjdXOTloSkJGSWtJR3dHU0pjQTJpa1FxcW5UY2dZWUQwRUtCRkFtS0hJQ1dCdTRBMThrbGtJR2xtcG4zSmtEdzhEdHNIZE5uY0JNRUVJckxLYnF5MEdpZ3F2cWljMmRkbjRQcmc2cmVnV0xYbFk0Yjhtb0J0MENmOTIzVmdLdldQOCs5eStHNUwxYXhtbFVzMzFjQ1lYWnFNbVM4ZmtsUjJzdUpXUCswaGRFaldxK2tXSVlHVk02djdoTkN1bjE5SkI1RmF2ZHRaczFia2NnbmZFUkYrcXJ6a0hqY1QraDIyQ1FzUWVDb0NDR2wwRDZNby9ud3ZDZU1wcnRoczN2NGI2Y2tJQ214STRnVGgrOG9sZ0E0dGlFUTVzTVhMYlh5ZXh3VGtQNEJWb2tsUndBQWVOcGpZR1JnWUFCaUtRUFd1Zkg4Tmw4Wm1Ga1lRT0N4a1AwcUJQMy9MNnNXMHg0Z2w0T0JDU1FLQVBBM0NVUUFlTnBqWUdSZ1lHYjR6OERBd0tyTVVQZi9KNnNXQTFBRUJUQUJBRnUwQTlRRFZBQUFCU01BZmdBQUFBQUFnZ0FBZU5wallHUmdZR0JpQ0dJQTBReFFFZ2tBQUFpZkFGZ0FlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ3dOcUZnWW1WcVF0Z0YyV3dqWndRQ2FucTJOL2RoL0hRTjF5ZCsyRUROVDhVM0s5Z2x2UitKWlc0QjFkTW1XZWVpSHZMWExQZ25TZUs4bG1TVno0eWw5SjhacTU0NFN2elJQTHZ6RFVyZmpmQlhhNkRqV29YakkzKzVGeTMzdHZZZDhHcnBXNlMzMXB2NDJHd1JoMXZ5b3hkUDU2ZGFuV2pXellFSEJldURGZ2lpcDBrSnJIbkpKMmpZODArSmIxd2tGeXhSTlA4NjdmUys3UTVwSitNYkk3Y1JBMmpMSHJSczJ3VmJYcXBhZjhBeUJFdjd3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVpjQUFvQUFBQUFCNUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVZDBsbU50WVhBQUFBRTRBQUFBUmdBQUFGUUFtZ0ZsWjJ4NVpnQUFBWUFBQUFOZUFBQUVJTXk5OW5wb1pXRmtBQUFFNEFBQUFDOEFBQUEyS1dqQ2FHaG9aV0VBQUFVUUFBQUFIZ0FBQUNRSFJ3S2VhRzEwZUFBQUJUQUFBQUFnQUFBQUlCSG9BWGhzYjJOaEFBQUZVQUFBQUJJQUFBQVNCQ29DN20xaGVIQUFBQVZrQUFBQUdBQUFBQ0FBREFCSmJtRnRaUUFBQlh3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBR1VBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHJxTUpRd00vd0g4cGtoMGtocS9nT0ZBYjV0RE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCeUFOQThEQjFDT2hVR0hRWS9CaWNHWG9lVC9mNkFvaU9jSTVCWC8vLy8vNnY4ci93LzkzL0YvTWxnZkhBQUF0VE1QOWdBQWVObzlVMStJRzBVWW45L01aUGFTWm5lU2JIYVhKSnZkU3piZDFUU1gzRjIydTAya09lalpYdlhhODlxaVhzdUJXTkJUc0Q1SS80QXZQYVNvMEFxaUlPaUxEL29tK0NUNFVud1FEbndzOVZtaDlORm5INU00R3pobnZoMW12djBZZm4rK0lTQjc4ekY1UW00Umk1QlVTQmlJd25TQ05OWkUwRWVjcFBZVEhvaU9EU2JyWFhDeldtczJheHQ0TXk2c29VaU4rdDZvd2lXV2V6NDRVUVBrdXZxT3lBZGtTZDFub0IzR3licDlCSC9GVjVIWTJlcXJPa282OHpsOVJ2OGlBN0t1S3BHazY3WmpWdTFoWW9zQnRDaU00c1N4azNTQWxpYXF0cE00QmxRK1N3OFZ2Q0g3RmUrSXFpNHdzVmNzRkhPM0Q1ZHkwRStZTWN0cnMvbU83cG82ZzU0NzJDdWltRzlQdnYybmRaZStVVUplVGc5dHlab2FHQU5ka2hwUWRONDkvNkRhS1lGS1EyVHBnaFFJL3NEVmpBOGpwK1pUSnVoajRwRXVPYU9RbW5FUUNZV3Q1Y0V5b0hsd2xHcENhNGtGWGpNRGw0UlJFQXFOSGUrWktoaisrRVVqYWtxSnZmMmI3UERhOWpYUXJkTGxPN092WGNNWWU5OS84OVp0aXY3bUE5L01mZmhvL3k2bHF4ZC92OEFCWTVlT3lwUzVHdWlWOGFzSHNyQXoyajVuVEhqR0FDYk9zNDh1ZEY2bWtMWHBUK3plenNsZE5udGVFWVhNaDk1OHpsZm9iMlJMSFJRQUQ4bEN3UCtGTlJYbzhQUUpDRXZZUG14cjhUY2pvVUNieVlLaThzSXhNVUcyRVZFbzJDK2ZLMGduUjByWHcvdUZIRXI2Mk10OU5ic3B5dkw2UTQ3R0tXV0h3ZDgvMEhWK3RpYyt4YVpYa28vTUluWnhaOG1vZk5hQXJLUk5lbXY2ZDBYVEJWOTRRSlVqUWpIeDZQYjBuc0daUlQrZVBqWHlaZzJnZVdQaFVrT3QzV1hxbGhocnFsS3RQSDFNTDJaT0tWRmdMWHJ1OVB4Zi9Jd2pNbEdIUGpRRGpuY2N0aWJVN0NPYVlManVWRVhrS1UreUdhbWNpbkJEdGQ3Q3lpQk00d1JmNmlQNzNCcXc2clpYclVLVlVyOVE3ciszK1JvUTJHM1c5cXdyOG5VdngycVVUcnIxU3h4K01kcC9hUVBOY2dzdTdqZE5zSTE2MnhhaVpPWERSanN1eTFXT3BCZTBPazdBb3dybEljOUZ6b3UrWUMrTWd6VTU0SWdEeitYMXNwdnhjQlNQcS9RVDBpUEVaSnF3cXFreUtsRzlYejFtRWFabUlESkgxQnQxYkVkaW1DaE9mMTdpZExuK1NqdFh5UE82NFVSbnUwUFYzRnMzbXBEeTdTanZjcGRxd1kybUxPRzcyVk83VUZtajlNemxFcGlSSDlUcWZZNWhWL1BSeXVUOW9WNEVHcTJIbWJoSzJ2OEFnSXFZaWdBQWVOcGpZR1JnWUFCaWg2a0swK1A1YmI0eU1MTXdnTUJqSWZ0VkNQcS9GWXN1MDEwZ2w0T0JDU1FLQUFLVUNVUUFlTnBqWUdSZ1lHYjR6d0FrSHpLSS85L0Nvc3NBRkVFQkhBQmZUd1BzQUFBQ2RnQUFBUndBV0FFY0FGa0RBQUFrQXdnQUt3UGhBQ3dCM3dBMUFYSUFGd0FBQUFBQUtBQThBSkFBN0FGaUFjWUNFQUFBZU5wallHUmdZT0JnOEdCZ1pnQUJSZ1kwQUFBSWRRQldlTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpzdG1hcnkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTThBQW9BQUFBQUE5QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnY0hCWkZtTnRZWEFBQUFGQUFBQUFMZ0FBQURRQURPQ2VaMng1WmdBQUFYQUFBQUNJQUFBQXFJT1BPLzFvWldGa0FBQUIrQUFBQUM0QUFBQTJKc0RDVVdob1pXRUFBQUlvQUFBQUh3QUFBQ1FFMWZYamFHMTBlQUFBQWtnQUFBQUtBQUFBQ2dNTEFIZHNiMk5oQUFBQ1ZBQUFBQWdBQUFBSUFDb0FWRzFoZUhBQUFBSmNBQUFBR0FBQUFDQUFCZ0FaYm1GdFpRQUFBblFBQUFDMkFBQUJOU0NTU010d2IzTjBBQUFETEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtYkdXY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkIxd052WnJNdjJnd016R2JjVjRIQ2pBZ1YvLzh6TUFBQUxqd1FRd0I0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUSs4Ly84SGtsNy8vOHR2QjhzekFBQm1wUWVIQUFCNDJtTmdZaWovejhEWXlzekFJTXdnenNBZ0xtaG1iaXdtTHNyR3Jpd0lwZFdFZ2N4eVJxN3YzSXlNM0ZGUklQSTdWMTFZMkZmbVYxeU1qRnpDWEl4L2dzQVVJL08xUDBFTVFNREVJQWswVXdWb0pqUFlUR05CWldHUVFlcW1RTU1Gb2JTWStKTHc4QVpHcnE4Z1E4TERRU1NRZVoxNTNSOFRxTEhNNnlER2NnR05CQUF1Z3h3NGVOcGpZR1JnWUFCaXVZM0xMc1R6MjN4bFlHWmhBSUhIUXZhckVQUi9Cc1pXWmhDWGc0RUpSQUVBR1hRSlBBQUFlTnBqWUdSZ1lEYjdvczNBd0RpWFFaSkJnckdWQVNpQ0FwZ0FSbFFDc2dBQlZRQUFBWjBBZHdBWkFBQUFBQUFBQUNvQVZIamFZMkJrWUdCZ1pwQmdZR0lBQVVZR05BQUFBeWNBSUhqYWJZd3hENEl3RUlVZkVRaml3dVNnU3hQM0JsSlhaeVpYTm9jU0dzSkFTU2doWVhIeGovc2cxVVZ2dVB2dTNYc0hJTVVUQWRZS2tHeDlyWkNjZUk1d1FPWTVwbnIybk9LRUMzWUl3ajJWRERmUElmbnVPY0lSRDg4eGRlYzV4UlV2Ti9WNlhJcjhNeXN6dW02d29wQmZxVFRXakhveWphZ1gwY3lkbTl0ZUtKbEx4VmNUZW1pTVdGQWcvOWtyR0xKRGh3RVdncHI4NHlycHNwdFQ4MkxRMEZuekprZ3pzNDY5WlVKQWJYa0o5UWJCdVM2cEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFZTUFBb0FBQUFBQnpRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVWwxRldOdFlYQUFBQUU0QUFBQVB3QUFBRXdCQUFEc1oyeDVaZ0FBQVhnQUFBTW5BQUFENE9YQnJHSm9aV0ZrQUFBRW9BQUFBQzhBQUFBMktjckRCbWhvWldFQUFBVFFBQUFBSUFBQUFDUUh2UU11YUcxMGVBQUFCUEFBQUFBWUFBQUFHQkJxQVdSc2IyTmhBQUFGQ0FBQUFBNEFBQUFPQTBRQ1FtMWhlSEFBQUFVWUFBQUFGd0FBQUNBQUNBQnZibUZ0WlFBQUJUQUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUdBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0yc000Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVl5aGhadmdQNURORHBKSFUvQWNLQXdEc3pnMU9lTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQ3lBTkJjREIxQ09pVUdQd1pjaGw2SGsvMytnR0lSZC9QLy8vOHYvdC82ZjluOGlXQWNVQUFCTzl3M2pBSGphVlpQZnF4dEZGTWZubk5uZFNYYVQyZXl2bVRTL3MwazJOOWwyazV2TjNlWGU1aVlwcWQ2cWhiWmFhRitMS0FXMUlLamdtMVdFZ29LSS9nMCtDVDRMUXAvMG4xQVFINFQrQlgzeTlqcDc2MzJRK2NHZWMyYlB6UG5PWndpUWp3Z2h6OGdueENRazU4RENhSm5sQy9FTWVvMWcyR3VJd1pFTW9aZXFRWURjUER2VHZzR241RFloUUpraHVwRDV4Z3hzaUdhd3pLVEljZzhNRm80dE1HUVJGWkxEREppS3JrR3VJZmZ5VEgwUGpDaVRhU2FrVjdqVFRQckdPREkwOFVRRDVvNjd0djc1dFkxRnNjYVAydlRiRjNkTTM0ZEhUM1JBZjhaTEFMYisvbnNtUmFpeTFWUi9yRUdwNW50OWNPM3ZnZ3A5Qjc0eXVmOTFHOXhhM3NLSHAzOUx4Z0MxQVFNTnFEcVp3d0RjQmw0Ly9jS25MWHgwK21lZ1ZWb1VhVmtGTkUwdHFKV0F4azFFd1F5Z1dxaVdsNzNUcDNpRHE3aG5LOU5YYWdHWm56Mm5mOEJ2NUFOQ1JodFZSRFRtMUVaT28vR0daZ2RMWlFJcktrOGd5OWNvaXRLejgxbklEakREVmp0eENBeTV5UElzUFhlcEZrYmo1UWFWNTcvZlh5WmM1dkJMYkZQMDQ4TTNZczdhdmw0T1dqNlljY1V5Yks4VFdqb3pMUU44cHp6ZVhXZnkzbmJ5cGxtLy84cEp2V1VweGRDenVFbmJ2U01YM2JJQm91SU1qdmNPZ1ZaSEFXSXdXZDI2eEMzV0N2U1NhQWFndi9YanlodWtGRmZyZnZ2ajI3N05vZVpNZjVvbnNoYTBBTGFKcjFLaWZhM2pEWEY2MEwrS09OME9kcWpMK3JLYXJJeXJ6WDdmQ1hGejdDTEt1UlNKTnB0VXJONjd1LzFnSDNHM0Z6UTZGMGwxajV6citOclpjL2dMZmlVN1pTU0t2WE5aZk1WTmdZNjRVR1VONlVJeHdqcVFLc0xXTUU0dWVwUm5SU3N3U3pDRG45MWpsMThSVHYxd3J6TnpMbXZZcXNyNWh6ZnZBd3prVU90ZThrNzY1cXJYazBDM2ZwcTRGUWxZTjUyOXQvZnZVaHdGQWlROGJsU0JWYTJoTytJbHpTczMxdTJGY0JQdElBa0hrZXpxZGEvQWJjNmpKcFk1TjRmdCtxeG14enBNRmlNQmR0Z3Nhb3BWVFYvaVorUXlJUjVsUXAxWDlmOWRjdTY5ZkFFYlJZZVFMRjJJUUwyQWYxNDNNSXh2Q0wxVVZqZlZzV1c4dTdJRi9lUkJHMTM3WWJka1JuMmNQT0NPYThQM0wzNmZIaUMrdXFneWhlcThycVJPRTB0Q2t5cGlQdzJuaU4wZk5GT3hUUDRGUGxkK1ZnQjQybU5nWkdCZ0FPSVlKNS9VZUg2YnJ3ek1MQXdnOEZqSWZoV0MvditOcFo5cFA1REx3Y0FFRWdVQUJ1TUtCd0I0Mm1OZ1pHQmdadmpQd01EQUVzMmcvZjhNU3o4RFVBUUZzQUVBWFZzRDh3TEdBQUFCV3dCMEJGc0FUQVFOQURBQ0tBQkpBYmtBS3dBQUFBQUFGZ0NhQVQ0QnFBSHdBQUI0Mm1OZ1pHQmdZR1BJWXdEUkRGQVNDUUFBQzhjQWVBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6c3RtYXJ5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTkFBQW9BQUFBQUE4UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnY0t4WmxtTnRZWEFBQUFGQUFBQUFMZ0FBQURRQURPQ2VaMng1WmdBQUFYQUFBQUNPQUFBQXFNRGJrM0ZvWldGa0FBQUNBQUFBQUM0QUFBQTJKdmpDVVdob1pXRUFBQUl3QUFBQUlBQUFBQ1FGWlBaTWFHMTBlQUFBQWxBQUFBQUtBQUFBQ2dOcEFKQnNiMk5oQUFBQ1hBQUFBQWdBQUFBSUFDb0FWRzFoZUhBQUFBSmtBQUFBR0FBQUFDQUFCZ0FaYm1GdFpRQUFBbndBQUFDeUFBQUJMRU52Wll4d2IzTjBBQUFETUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtM000NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBQUJKSFpLY1ZrNkE5c0Ryd2Zlek5WZlRCZ1ltS3U1endDRkdSRXEvdjluWUFBQVRZd1Evd0I0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUSs4Ly84SGtsNy8vOHR2QjhzekFBQm1wUWVIQUFCNDJtTmdZcGp3bjRGeEx6TURnekNET0FPRHVLQ1p1YUtZdUNnYnU3S2dNWmhXVkJNR01pY3c4VElLOERBeDhjVEhnOGgvSDNoN29xTS9NVC9oWldUa0ZlTmwvSk1DcGhpWnovNUpZV0JnWXRBR21oa0dOSk1aYktheG9MSXd5Q0IxVXpOeklCdE1BeTA1R1IzZEN6VHFJOGlNdURnUXljalB3M1NPZWM0ZkI2aXh6SE1neHZJeUFBQ1RzaDJOQUFCNDJtTmdaR0JnQU9Mb09Ydks0L2x0dmpJd3N6Q0F3R01oKzFVSStqOEQ0MTVtRUplRGdRbEVBUUFZWmdsWkFBQjQybU5nWkdCZ3J2NWl3c0RBK0pKQm0wR0hjUzhEVUFRRk1BRUFYb29EcWdGVkFBQUI2UUNRQUNzQUFBQUFBQUFBS2dCVWVOcGpZR1JnWUdCbWtHQmdZZ0FCUmdZMEFBQURKd0FnZU5wZGpzRUtna0FRaGo5Sml3dzZCblhhSjFnVWc2QVhzQ2Z3cnJpRWtBcXVDSGJvMlJ0bFRzNWg1dHQvdm9FRlluNEVMQlZ3V1B0U29mQkJPZUxFV1hrdjZWVTU1b1poUnhBZUpUbnpWQTZGWDhvUkZ3cmx2ZVFmNVpnN1h6KzI1VEEvZEJSdThFM2ZtZFFtbXVTdWMwTTV1dHBVczZtbnhrL3YxbVEyc1JtZWtaYVNnWm5INWxYZ2hEd05QWjM4TU1XU2JKeGNuRzcxU3NrZHRYaVZiSXpRSkpkZStsdDhRN1plVzdJL1FhUXRmUUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaGN4NEhHTnRZWEFBQUFFOEFBQUFNUUFBQUR3SEJ2MHNaMng1WmdBQUFYQUFBQUN1QUFBQXZMUVVhSWhvWldGa0FBQUNJQUFBQUMwQUFBQTJLQTNEQ0dob1pXRUFBQUpRQUFBQUhnQUFBQ1FGMWdIWGFHMTBlQUFBQW5BQUFBQU1BQUFBREFlMUFLbHNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFDd0FYbTFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFnYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtV3NJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdJTkdCaVNRVWx5V0RwUTBaSjdNelBBZnlHZG1ZQVFKTXlKVS9BY0tBd0FCM3czYkFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlob3lULzcvSDhnSDAvOHYvTWtIcXdJQ0FKZkFDVEFBQUFCNDJtTmdaQ2hnWUdCOHdyU1NRUkpJQzdLSldUT0s2alB5TTVvYUc1bXBDL0l4cXB1S21abWJpVEdHTXl0NHFxY0hGTGlwZXlvdzY0U0lLSllZaTNJemRmODlLU1dxeXN6SXhLUXFLc1hFSmNMSnFNSWtwc2ZJQlRTS3daS0JnV2syMDNZR09TQkhYRm1Qa1YxWmlVMGMzUUl6TlcxR1U2WWFlV1ZPMzhJYVpYNUdaamxYbGVpSU5ETkpDMmttSm1rTFNhYnRyelBqR0FVay9yNkMyU01peFNRb0xhekt3TUFBQURWMkhLUUFBSGphWTJCa1lHQUE0bnRTbWxQaitXMitNakN6TUlEQVl5SDdWY2cwMDJXbTdVQ0tnNEVKeEFNQS9kb0lzd0FBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0VTU001bUFJcWdBR1lBUkRRQ3N3QUFBdE1BQUFKSEFIQUNtd0E1QUFBQUFBQXNBRjU0Mm1OZ1pHQmdZR2FRWndEUkRGQVNDUUFBQTc4QUpnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFVQUFvQUFBQUFCS2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hjTjN0bU50WVhBQUFBRThBQUFBTlFBQUFFUUFVZ1FuWjJ4NVpnQUFBWFFBQUFFN0FBQUJaTHlJVy81b1pXRmtBQUFDc0FBQUFDNEFBQUEyS0J6Q1VXaG9aV0VBQUFMZ0FBQUFIZ0FBQUNRR0JRSWlhRzEwZUFBQUF3QUFBQUFVQUFBQUZBc0tBUGxzYjJOaEFBQURGQUFBQUF3QUFBQU1BSzRCQ0cxaGVIQUFBQU1nQUFBQUdBQUFBQ0FBQ0FBZmJtRnRaUUFBQXpnQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRUNBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtT2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHBxTUU5bVp2Z1A1RE16TUlLRUdSRXEvZ09GQWR1ckRXd0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtOQmxzbVNmLy93OWthVUJZLzIvK1AvYW5FS3dXREFEbkFRdDJBQUFBZU5wTnpyOU93bEFVQnZCelRyRTF0b0J0dUxjTkZ2blQ1RlppZ2dHaERSb2RqQnBqSkE1ZzRxSUVpaGpqRS9BQWhuY3djV0F5OFFuWTNId1BGbWNuSjR2V2FveG5PUG5POHZzT0lBdytBVHNTZ0Ftd2tDa0p0NEsrOFB4ZHJLVXhoYVpzNUpGam13ZlZzbzFvaStxUW8zWjVoTFRmVFV2dlMvM3UrZFBPM3VRc3VOS1dleC9qMFh3KzBCTVFEVUl6Y3NzL0xuSlpTV0dwRWFsdVhXeWc4TDBhTjFjUjEyS1JKUytPcVgxaVNJZ3M3b0Zmc1IvZVRkNWFSb0xpSGlEWWdqSE5jQVJxckJabFVmZk1vc2N6c3ZJdjAzUDRvSEd1MGxCbFRBM3ZWYzQxQ3BLTTRTa3FPUVcvMTh0ZmluOHRBVkNIcHBDTER0T3BvT0lJMmRSbHZvM01kWlRHWnMxemRVK3NZNFA4WEhieDRQYkcwVkhLSHhiYmp5MnJtU1hLTmkyYXZsNzNFQTBybkszd2dpUVZNalpaTnNzRGZBRnFYRHh5QUhqYVkyQmtZR0FBNG1VWC9zckg4OXQ4WldCbVlRQ0J4MEwycXhEMGZ3YW1oOHdnTGdjREU0Z0NBQzFLQ2VZQUFIamFZMkJrWUdCbStNOEFKR1VZbEJnWW1CNHlBRVZRQUNzQU5aSUNMZ0FBQW9BQUFBR05BR1FCalFBNUF4d0FPZ0pVQUNJQUFBQUFBQ3dBVmdDQ0FMSjQybU5nWkdCZ1lHV1FZMkJpQUFGR0JqUUFBQVB6QUNoNDJrV01NVy9DTUJDRnY0Z0VpWFRvVW5WZ0FBL01WcUl3ZDJGZ1ltVmlBV3lpREhHUUV5SWhvWTc5M1QyTUpXNTQrdTY5ZHdmay9KTHduSVRQb005SnlXUjdjY1lIWDVHbnNpMGo1OHhaTVNGSlorSXMrSW1jU25LSW5QSE5KZkpVL0Vma25EVi9tNjY5M2dicjFhNHoxcnR6Njh0aWIzM2ZkRTZWdWdqNzFqcnJqNE0xNm5SWFptejZzVzVWcFF0ZHNhR2o1Y3FOQVl0SHNSUEhCSGFjSmZPVUZPeUQwOU5JNnFSVm9zVjk1MXZKWGVnY3d5Y2puUk4zVWNNb1Y3MW9MVzFGRlM0MTFUOWpQUzhQQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6c3RtYXJ5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6c3RtYXJ5MTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MS4wMzU3MjIsLTU1LjU3MTM2MilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zNC4wMjE5NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg0MS4wMzU3MjIsLTU1LjU3MTM2MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSc0MS4wMzU3MjInIHk9Jy01NS41NzEzNjInPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nNTEuNzg3MDY1JyB5PSctNTUuNTcxMzYyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzU1LjY2MTQzOCcgeT0nLTU1LjU3MTM2Mic+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSc2My4yMTgxOTcnIHk9Jy01NC4wNzY5ODEnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNjcuNjg3NTY2JyB5PSctNTUuNTcxMzYyJz4sPHRzcGFuIHg9JzcyLjExNTM3NCc+LjwvdHNwYW4+PHRzcGFuIHg9Jzc2LjU0MzE4Mic+LjwvdHNwYW4+PHRzcGFuIHg9JzgwLjk3MDk5Jz4uPC90c3Bhbj48dHNwYW4geD0nODUuMzk4Nzk4Jz4sPC90c3Bhbj48dHNwYW4geD0nODkuODI2NjA2Jz5CPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nOTcuMzgzMzY1JyB5PSctNTQuMDc2OTgxJz5tPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzEwNC45NTExMDEnIHk9Jy01NS41NzEzNjInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzYuMjEyNDMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNDEuMDM1NzIyLC01NS41NzEzNjIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNDEuMDM1NzIyJyB5PSctNTUuNTcxMzYyJz5NPHRzcGFuIHg9JzUxLjc4NzA2NSc+QTwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMDkuMTU0MDcsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNDEuMDM1NzIyLC01NS41NzEzNjIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNDEuMDM1NzIyJyB5PSctNTUuNTcxMzYyJz7ugYo8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nNDUuMDQ4NDYnIHk9Jy01NS41NzEzNjInPs6TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzUxLjI3NTEyOScgeT0nLTU1LjU3MTM2Mic+LnM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nNjEuNDc5ODU4JyB5PSctNTUuNTcxMzYyJz49PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzcxLjk5NTkzOCcgeT0nLTU1LjU3MTM2Mic+dDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc3NS41OTM1NzMnIHk9Jy01NS41NzEzNjInPu6BizwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc3OS42MDYyOTInIHk9Jy01Mi41ODI1ODUnPk08L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS01NC44MDY5MiAwSC0zOS4wNzc1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLC01NC41NTY5MiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zOC44Mjc1LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPHBhdGggZD0nTTM4LjU3NzUgMy42MTY2Mkg3MS4xNTY4OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3MS40MDY4OSwzLjYxNjYyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Mi40OTM4Nyw4LjY3ODQ0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg0MS4wMzU3MjIsLTU1LjU3MTM2MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSc0MS4wMzU3MjInIHk9Jy01NS41NzEzNjInPu6BijwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSc0NC4zNjY5OTgnIHk9Jy01NS41NzEzNjInPs6TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzQ5LjI5Mjk5NycgeT0nLTU1LjU3MTM2Mic+LnM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nNTUuNDE5MzYzJyB5PSctNTUuNTcxMzYyJz7ugYs8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNTguNzUwNjAyJyB5PSctNTMuMzI5NzY4Jz5NPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00zOC41Nzc1LTMuNjE2NjJINzEuMTU2ODknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzEuNDA2ODksLTMuNjE2NjIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQyLjg3MDYsLTExLjY3ODQ0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg0MS4wMzU3MjIsLTU1LjU3MTM2MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSc0MS4wMzU3MjInIHk9Jy01NS41NzEzNjInPu6BijwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSc0NC4zNjY5OTgnIHk9Jy01NS41NzEzNjInPs6TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzQ5LjI5Mjk5NycgeT0nLTU1LjU3MTM2Mic+LnQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nNTQuNjY4NzEnIHk9Jy01NS41NzEzNjInPu6BizwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSc1Ny45OTk5MzgnIHk9Jy01My4zMjk3NjgnPk08L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram,node distance=3cm]
        \node  (1) {$M(B_{1},\ldots ,B_{m})$};
        \node  [right = of 1] (2) {$MA$};
        \node  [left = of 1] (e) {${\mathopen {}\llbracket \Gamma .s=t\rrbracket \mathclose {}}_{M}$};
        \draw  [>->,morphism] (e) to (1);
        \draw  [->,morphism,offset=-1.5] (1) to node {${\mathopen {}\llbracket \Gamma .s\rrbracket \mathclose {}}_{M}$} (2);
        \draw  [->,morphism,offset=1.5] (1) to node[swap] {${\mathopen {}\llbracket \Gamma .t\rrbracket \mathclose {}}_{M}$} (2);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure></fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\top \rrbracket \mathclose {}}_{M}]]></fr:tex> is the terminal object of <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(M(B_{1},\ldots ,B_{m}))]]></fr:tex>.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi  \wedge  \psi \rrbracket \mathclose {}}_{M}]]></fr:tex> is the intersection of <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi \rrbracket \mathclose {}}_{M}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\psi \rrbracket \mathclose {}}_{M}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(M(B_{1},\ldots ,B_{m}))]]></fr:tex>.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi  \vee  \psi \rrbracket \mathclose {}}_{M}]]></fr:tex> is the union of <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi \rrbracket \mathclose {}}_{M}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\psi \rrbracket \mathclose {}}_{M}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(M(B_{1},\ldots ,B_{m}))]]></fr:tex>.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi  \Rightarrow  \psi \rrbracket \mathclose {}}_{M}]]></fr:tex> is the <fr:link
type="local"
href="ct-001C.xml"
addr="ct-001C"
title="Heyting implication">Heyting implication</fr:link> <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi \rrbracket \mathclose {}}_{M} \Rightarrow  {\mathopen {}\llbracket \Gamma .\psi \rrbracket \mathclose {}}_{M}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(M(B_{1},\ldots ,B_{m}))]]></fr:tex>.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\lnot \varphi \rrbracket \mathclose {}}_{M}]]></fr:tex> is the Heyting negation of <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi \rrbracket \mathclose {}}_{M}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(M(B_{1},\ldots ,B_{m}))]]></fr:tex>.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\exists x\colon A.\mkern 5mu\varphi \rrbracket \mathclose {}}_{M}]]></fr:tex> is the <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">image</fr:link> of the following composite:
    <fr:tex
display="block"><![CDATA[       {\mathopen {}\llbracket \Gamma ,x\colon A.\varphi \rrbracket \mathclose {}}_{M} \rightarrowtail  M(B_{1},\ldots ,B_{m},A) \xrightarrow {\pi } M(B_{1},\ldots ,B_{m})     ]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex> is the projection of the first <fr:tex
display="inline"><![CDATA[m]]></fr:tex> factors.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\forall x\colon A.\mkern 5mu\varphi \rrbracket \mathclose {}}_{M}]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\forall _{\pi }({\mathopen {}\llbracket \Gamma ,x\colon A.\varphi \rrbracket \mathclose {}}_{M})]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\forall _{\pi }]]></fr:tex> is the right adjoint associated with a <fr:link
type="local"
href="ct-0019.xml"
addr="ct-0019"
title="Heyting category">Heyting category</fr:link> and <fr:tex
display="inline"><![CDATA[\pi \colon M(B_{1},\ldots ,B_{m},A)\to M(B_{1},\ldots ,B_{m})]]></fr:tex> is the projection of the first <fr:tex
display="inline"><![CDATA[m]]></fr:tex> factors.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\bigvee _{i \in  I}\varphi _{i}\rrbracket \mathclose {}}_{M}]]></fr:tex> is the arbitrary union of each <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi _{i}\rrbracket \mathclose {}}_{M}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(M(B_{1},\ldots ,B_{m}))]]></fr:tex>.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\bigwedge _{i \in  I}\varphi _{i}\rrbracket \mathclose {}}_{M}]]></fr:tex> is the arbitrary intersection of each <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi _{i}\rrbracket \mathclose {}}_{M}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(M(B_{1},\ldots ,B_{m}))]]></fr:tex>.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>576</fr:anchor><fr:addr
type="user">ct-000M</fr:addr><fr:route>ct-000M.xml</fr:route><fr:title
text="Extremal epimorphism">Extremal epimorphism</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>An epimorphism <fr:tex
display="inline"><![CDATA[f\colon A\twoheadrightarrow B]]></fr:tex> is said to be <fr:em><fr:strong>extremal</fr:strong></fr:em> (also called a <fr:em><fr:strong>cover</fr:strong></fr:em>) if for any monomorphism <fr:tex
display="inline"><![CDATA[m\colon C\rightarrowtail B]]></fr:tex> and any morphism <fr:tex
display="inline"><![CDATA[g\colon A\to C]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[f = mg]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[m]]></fr:tex> is an isomorphism.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>577</fr:anchor><fr:addr
type="user">ct-000O</fr:addr><fr:route>ct-000O.xml</fr:route><fr:title
text="Regular category">Regular category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is said to be <fr:em><fr:strong>regular</fr:strong></fr:em> if it is cartesian, has <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">images</fr:link>, and <fr:link
type="local"
href="ct-000M.xml"
addr="ct-000M"
title="Extremal epimorphism">covers</fr:link> are stable under pullback.
  A functor <fr:tex
display="inline"><![CDATA[F\colon \mathcal {C}\to \mathcal {D}]]></fr:tex> between regular categories is said to be <fr:em><fr:strong>regular</fr:strong></fr:em> if it is cartesian and preserves covers.
  Note that since cartesian functors preserve monomorphisms, every regular functor automatically preserves images.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>578</fr:anchor><fr:addr
type="machine">#292</fr:addr><fr:route>unstable-292.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[F\colon \mathcal {C}\to \mathcal {D}]]></fr:tex> be a regular functor and <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be a morphism in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
    By <fr:ref
addr="ct-000Q"
href="ct-000Q.xml"
taxon="Lemma" />, <fr:tex
display="inline"><![CDATA[f]]></fr:tex> admits a cover-mono factorization <fr:tex
display="inline"><![CDATA[f = \mathsf {Img}(f)\vartheta _{f}]]></fr:tex>.
    Then since <fr:tex
display="inline"><![CDATA[F]]></fr:tex> preserves monomorphisms and covers, <fr:tex
display="inline"><![CDATA[F(\mathsf {Img}(f))F(\vartheta _{f})]]></fr:tex> forms a cover-mono factorization of <fr:tex
display="inline"><![CDATA[F(f)]]></fr:tex>.
    Then by uniqueness, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(Ff) \cong  F(\mathsf {Img}(f))]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>579</fr:anchor><fr:addr
type="user">ct-000K</fr:addr><fr:route>ct-000K.xml</fr:route><fr:title
text="Image">Image</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is said to have <fr:em><fr:strong>images</fr:strong></fr:em> if the inclusion functor <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A) \hookrightarrow  {{\mathcal {C}}_{/{A}}}]]></fr:tex> admits a left adjoint <fr:tex
display="inline"><![CDATA[\mathsf {Img}\colon {{\mathcal {C}}_{/{A}}}\to \mathsf {Sub}(A)]]></fr:tex> for all objects <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>