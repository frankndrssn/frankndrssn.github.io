<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>745</fr:anchor><fr:addr
type="user">ct-001I</fr:addr><fr:route>ct-001I.xml</fr:route><fr:title
text="Grothendieck construction">Grothendieck construction</fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>25</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:link
type="local"
href="todo.xml"
addr="todo"
title="TODO">TODO</fr:link><fr:p>Fix notation and layout.</fr:p><fr:p>Given a <fr:link
type="local"
href="ct-001J.xml"
addr="ct-001J"
title="Lax functor">lax functor</fr:link> <fr:tex
display="inline"><![CDATA[(F,F^{2},F^{0})]]></fr:tex>, its <fr:em><fr:strong>Grothendieck construction</fr:strong></fr:em> <fr:tex
display="inline"><![CDATA[\mathsf {Elts}(F)]]></fr:tex> is the category defined as follows.</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
  
  <html:tr>
    
  <html:th>Objects</html:th>

    
  <html:th>Morphisms</html:th>

  </html:tr>

  
  <html:tr>
    
  <html:td>
      An object is a pair <fr:tex
display="inline"><![CDATA[(A,X)]]></fr:tex> where <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is an object in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is an object in <fr:tex
display="inline"><![CDATA[FA]]></fr:tex>.
    </html:td>

    
  <html:td>
      A morphism <fr:tex
display="inline"><![CDATA[(A,X) \to  (B,Y)]]></fr:tex> consists of a morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> and a morphism <fr:tex
display="inline"><![CDATA[p\colon X\to F(f)Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[FA]]></fr:tex>.
    </html:td>

  </html:tr>

  
  <html:tr>
    
  <html:th>Identities</html:th>

    
  <html:th>Composition</html:th>

  </html:tr>

  
  <html:tr>
    
  <html:td>
      The identity on each object <fr:tex
display="inline"><![CDATA[(A,X)]]></fr:tex> consists of the identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A}\colon A\to A]]></fr:tex> and the morphism <fr:tex
display="inline"><![CDATA[(F^{0}_{A})_{X}\colon X\to F(\mathsf {id}_{A})X]]></fr:tex>.
    </html:td>

    
  <html:td>
      Given a pair of composable morphisms <fr:tex
display="inline"><![CDATA[(f,p)\colon (A,X)\to (B,Y)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(g,q)\colon (B,Y)\to (C,Z)]]></fr:tex>, the composite <fr:tex
display="inline"><![CDATA[(g,q)(f,p)\colon (A,X)\to (C,Z)]]></fr:tex> consists of the composite <fr:tex
display="inline"><![CDATA[gf\colon A\to C]]></fr:tex> and the composite
      <fr:tex
display="block"><![CDATA[         X \xrightarrow {p} F(f)Y \xrightarrow {F(f)q} F(f)F(g)Z \xrightarrow {(F^{2}_{f,g})_{Z}} F(gf)Z       ]]></fr:tex>
    </html:td>

  </html:tr>

</html:table>
</fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Related">Related</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>759</fr:anchor><fr:addr
type="user">ct-001J</fr:addr><fr:route>ct-001J.xml</fr:route><fr:title
text="Lax functor">Lax functor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>25</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> be <fr:link
type="local"
href="ct-001M.xml"
addr="ct-001M"
title="Bicategory">bicategories</fr:link>.
  We write <fr:tex
display="inline"><![CDATA[a]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\ell ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[r]]></fr:tex> for the associator, left unitor, and right unitor of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> respectively and we use the primed version of these symbols for the corresponding structures in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>.</fr:p><fr:p>A <fr:em><fr:strong>lax functor</fr:strong></fr:em> <fr:tex
display="inline"><![CDATA[F\colon \mathcal {C}\to \mathcal {D}]]></fr:tex> consists of the following data:</fr:p><fr:ul><fr:li><fr:em><fr:strong>Action on <fr:tex
display="inline"><![CDATA[0]]></fr:tex>-cells</fr:strong></fr:em>: Each <fr:tex
display="inline"><![CDATA[0]]></fr:tex>-cell <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is mapped to a specified <fr:tex
display="inline"><![CDATA[0]]></fr:tex>-cell <fr:tex
display="inline"><![CDATA[FA]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>.</fr:li>
  <fr:li><fr:em><fr:strong>Action on <fr:tex
display="inline"><![CDATA[1]]></fr:tex>-cells</fr:strong></fr:em>: Each <fr:tex
display="inline"><![CDATA[1]]></fr:tex>-cell <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is mapped to a specified <fr:tex
display="inline"><![CDATA[1]]></fr:tex>-cell <fr:tex
display="inline"><![CDATA[Ff\colon FA\to FB]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>.</fr:li>
  <fr:li><fr:em><fr:strong>Action on <fr:tex
display="inline"><![CDATA[2]]></fr:tex>-cells</fr:strong></fr:em>: Each <fr:tex
display="inline"><![CDATA[2]]></fr:tex>-cell <fr:tex
display="inline"><![CDATA[\alpha \colon f\to g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is mapped to a specified <fr:tex
display="inline"><![CDATA[2]]></fr:tex>-cell <fr:tex
display="inline"><![CDATA[F\alpha \colon Ff\to Fg]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>.</fr:li>
  <fr:li><fr:em><fr:strong>Lax functoriality constraint</fr:strong></fr:em>: For any pair of composable <fr:tex
display="inline"><![CDATA[1]]></fr:tex>-cells <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, <fr:tex
display="inline"><![CDATA[f]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, a specified <fr:tex
display="inline"><![CDATA[2]]></fr:tex>-cell <fr:tex
display="inline"><![CDATA[F^{2}_{g,f}\colon FgFf\to F(gf)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>.</fr:li>
  <fr:li><fr:em><fr:strong>Lax unity constraint</fr:strong></fr:em>: For any <fr:tex
display="inline"><![CDATA[0]]></fr:tex>-cell <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, a specified <fr:tex
display="inline"><![CDATA[2]]></fr:tex>-cell <fr:tex
display="inline"><![CDATA[F^{0}_{A}\colon \mathsf {id}_{FA}\to F(\mathsf {id}_{A})]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>.</fr:li></fr:ul><fr:p>These data are subject to the following conditions:</fr:p><fr:ul><fr:li>For any <fr:tex
display="inline"><![CDATA[1]]></fr:tex>-cell <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the equation <fr:tex
display="inline"><![CDATA[F(\mathsf {id}_{f}) = \mathsf {id}_{Ff}]]></fr:tex> holds.</fr:li>
  <fr:li>For any vertically composable <fr:tex
display="inline"><![CDATA[2]]></fr:tex>-cells <fr:tex
display="inline"><![CDATA[\alpha ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\beta ]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the equation <fr:tex
display="inline"><![CDATA[F(\beta \alpha ) = F\beta  F\alpha ]]></fr:tex> holds.</fr:li></fr:ul><fr:p>The laxity constraints are subject to the following additional conditions:</fr:p><fr:ul><fr:li><fr:em><fr:strong>Naturality of functoriality constraint</fr:strong></fr:em>: For any pair of <fr:tex
display="inline"><![CDATA[2]]></fr:tex>-cells <fr:tex
display="inline"><![CDATA[\alpha \colon f\to f']]></fr:tex>, <fr:tex
display="inline"><![CDATA[\beta \colon g\to g']]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> such that every component of the following diagram is defined, the diagram commutes.
    
    
      
      <fr:figure><fr:embedded-tex
hash="fc7813c32092b7a88138eb0c8db24041"><fr:embedded-tex-preamble><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \DiagramSquare {
        width = 3cm,
        nw = FgFf,
        ne = F(gf),
        sw = {Fg'Ff'},
        se = {F(g'f')},
        north = {F^{2}_{g,f}},
        south = {F^{2}_{g',f'}},
        west = {F\beta  * F\alpha },
        east = {F(\beta  * \alpha )},
      }
    ]]></fr:embedded-tex-body></fr:embedded-tex></fr:figure></fr:li>
  <fr:li><fr:em><fr:strong>Lax associativity</fr:strong></fr:em>: For any composable triple of <fr:tex
display="inline"><![CDATA[1]]></fr:tex>-cells <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, <fr:tex
display="inline"><![CDATA[h]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the following diagram commutes.
    
    
      
      <fr:figure><fr:embedded-tex
hash="1a9c768136e906f8454230821e9df1b0"><fr:embedded-tex-preamble><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \begin {tikzpicture}[diagram,node distance = 3cm and 4cm]
        \node  (1) {$(FhFg)Ff$};
        \node  [right = of 1] (2) {$F(hg)Ff$};
        \node  [right = of 2] (3) {$F((hg)f)$};
        \node  [below = of 1] (4) {$Fh(FgFf)$};
        \node  [right = of 4] (5) {$FhF(gf)$};
        \node  [right = of 5] (6) {$F(h(gf))$};
        \draw  [->,morphism] (1) to node {$F^{2}_{h,g} * \mathsf {id}_{Ff}$} (2);
        \draw  [->,morphism] (2) to node {$F^{2}_{hg,f}$} (3);
        \draw  [->,morphism] (3) to node {$Fa$} (6);
        \draw  [->,morphism] (1) to node[swap] {$a'$} (4);
        \draw  [->,morphism] (4) to node[swap] {$\mathsf {id}_{Fh} * F^{2}_{g,f}$} (5);
        \draw  [->,morphism] (5) to node[swap] {$F^{2}_{h,gf}$} (6);
      \end {tikzpicture}
    ]]></fr:embedded-tex-body></fr:embedded-tex></fr:figure></fr:li>
  <fr:li><fr:em><fr:strong>Lax left and right unity</fr:strong></fr:em>: For any <fr:tex
display="inline"><![CDATA[1]]></fr:tex>-cell <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the following diagrams commute.
    
    
      
      <fr:figure><fr:embedded-tex
hash="02d1c0a5bd8905f1a0f64bdb4ae6f267"><fr:embedded-tex-preamble><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:embedded-tex-preamble><fr:embedded-tex-body><![CDATA[
      \DiagramSquare {
        width = 3cm,
        nw = {\mathsf {id}_{FB}Ff},
        ne = {Ff},
        sw = {F(\mathsf {id}_{B})Ff},
        se = {F(\mathsf {id}_{B}f)},
        east/style = {<-},
        north = {\ell '_{Ff}},
        west = {F^{0}_{B} * \mathsf {id}_{Ff}},
        south = {F^{2}_{\mathsf {id}_{B},f}},
        east = {F(\ell _{f})},
      }
      \qquad 
      \DiagramSquare {
        width = 3cm,
        nw = {Ff\mathsf {id}_{FA}},
        ne = {Ff},
        sw = {FfF(\mathsf {id}_{A})},
        se = {F(f\mathsf {id}_{A})},
        east/style = {<-},
        north = {r'_{Ff}},
        west = {\mathsf {id}_{Ff} * F^{0}_{A}},
        south = {F^{2}_{f,\mathsf {id}_{A}}},
        east = {F(r_{f})},
      }
    ]]></fr:embedded-tex-body></fr:embedded-tex></fr:figure></fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>760</fr:anchor><fr:addr
type="user">todo</fr:addr><fr:route>todo.xml</fr:route><fr:title
text="TODO">TODO</fr:title><fr:authors><fr:author><fr:link
type="local"
href="frankndrssn.xml"
addr="frankndrssn"
title="Frank Tsai">Frank Tsai</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>