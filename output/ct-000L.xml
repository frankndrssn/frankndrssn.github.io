<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1561</fr:anchor><fr:addr
type="user">ct-000L</fr:addr><fr:route>ct-000L.xml</fr:route><fr:title
text="Equivalent condition for the existence of images">Equivalent condition for the existence of <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">images</fr:link></fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with pullbacks. Then <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has images iff for each morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex>, the pullback functor <fr:tex
display="inline"><![CDATA[f^{*}\colon \mathsf {Sub}(B)\to \mathsf {Sub}(A)]]></fr:tex> admits a left adjoint <fr:tex
display="inline"><![CDATA[\exists _{f}\colon \mathsf {Sub}(A)\to \mathsf {Sub}(B)]]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>820</fr:anchor><fr:addr
type="machine">#304</fr:addr><fr:route>unstable-304.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By <fr:ref
addr="ct-000J"
href="ct-000J.xml"
taxon="Lemma" />, the pullback functor <fr:tex
display="inline"><![CDATA[f^{*}\colon {{\mathcal {C}}_{/{B}}}\to {{\mathcal {C}}_{/{A}}}]]></fr:tex> admits <fr:tex
display="inline"><![CDATA[\Sigma _{f}\colon {{\mathcal {C}}_{/{A}}}\to {{\mathcal {C}}_{/{B}}}]]></fr:tex> as a left adjoint.</fr:p>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>821</fr:anchor><fr:addr
type="machine">#302</fr:addr><fr:route>unstable-302.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[g\colon B'\rightarrowtail B]]></fr:tex> be an arbitrary object in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. We need to construct a functor <fr:tex
display="inline"><![CDATA[\mathsf {Img}\colon {{\mathcal {C}}_{/{B}}}\to \mathsf {Sub}(B)]]></fr:tex> so that each morphism <fr:tex
display="inline"><![CDATA[f \to  g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f) \to  g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[f \to  g]]></fr:tex> be an arbitrary morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. Then this corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A} \to  f^{*}(g)]]></fr:tex> as follows:</fr:p>
    
      
      <fr:figure><fr:resource
hash="42bf1abc475a99195f5c5cbd701c9668"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3Mi43OTYzMzlwdCcgaGVpZ2h0PScxNzQuNDQ0ODM3cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE1LjE5NzU1OSAxMTYuMjk2NTU4Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLT0xSOUdob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0o1OG42VzhmdzJYeG1ZV1JoQTRMSDFDV1lFL1YrSE9ZVHhLSkRMd2NBRUVnVUErb0FKRVFCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDMEFBQUEyS0dIVEJHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHVPeC81M2orVzIrTWpDek1JREFZK3NUekFqNlB5UFRaVENYZzRFSlJBRUFLRzRKd3dBQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOa0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQ3dBQUFBMktlTFMzMmhvWldFQUFBSThBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbHdBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDWkFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKc0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvUUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURWQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGlXdWs5cGZIOE5sOFptRmtZUU9DeDlRbG1aSm9sbFBFT2tPSmdZQUx4QVA5dUNJUjQybU5nWkdCZzF2cGp5Y0RBRXNyUXg5RFBsTXdBRkVFQlRBQlNnQU5DQUFSVkFBQUM4Z0NPQUFBQUFBQlVBQUI0Mm1OZ1pHQmdZR0l3WlFEUkRGQVNDUUFBQmNvQU93QjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFDVWxZV0JpWldwQzJDRE1zUkJkb2dVcWVySTcrN2hldWdOcCtmOXVBTktmc2g0VHNacjNNL0pLVVQ5Y2NFTGI0bW5vaGFKU3o1WU1pSExaK0xNMlNUT0pmbEtYUERPSmZGVS9PL0VKWjg4dGwxN3UvZldxMzFuckhmbk5venJnL1doNlp4YTZTcnFuWFhXSDN0cjFHbFVabWpDY0cxVnJTdGRzNldqNWNhZEhvdEhzUmZIUkhhY0pRdU1yRGxFSjlCSTZxUzFRbFA5eTNlU3U5ZzV4azlHT2lkSmxOQWdWMEgyVmRxS09sNXE2bC92NlRCSEFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVHdBQW9BQUFBQUJid0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGMzhtTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SEZmMTJaMng1WmdBQUFYQUFBQUllQUFBQ2hCTEZ2RVpvWldGa0FBQURrQUFBQUM4QUFBQTJLRlRUQVdob1pXRUFBQVBBQUFBQUlBQUFBQ1FGbVFHYmFHMTBlQUFBQStBQUFBQVFBQUFBRUFsaUFLZHNiMk5oQUFBRDhBQUFBQW9BQUFBS0FhZ0ExRzFoZUhBQUFBUDhBQUFBR0FBQUFDQUFCd0JGYm1GdFpRQUFCQlFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFNUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtaW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZkI1RGVZQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlxWXpiLzMvSDhoUEE5SC9aLy94QTZzQ0FnQ2lKd21KQUFCNDJrWFJQVy9UUUJ3R2NEOTM3amx2OXRteGZXNlQxSGx4YklmU3htbmNPaWl0OHRKV1FtMFJwVUtpS2tJZ2hpNmRrQmhBZkFnRzFJR1ZsVy9BM2gzeEhSaVJtQmhZVXM3dHdKMTB3ejAzL0gvM0tGQ09ieEp5U1g0b00wVUI1V0NhQWEwVHhST2t3aE5NRTAxTU1LVUJpekl2bldBazc0ZkNNeEJFY1pTTm9nUUc0VWd6d1dKOEdadXFXU3ZPTjN0am9PdEdGTHpKT2UrMjZXcWZQL0tKelUrNWE0aTk0TjR1RUFpWm16N24xYXBmS3RSZTVUR3VGdGRIMW16TDJhZFI0TGRJbDhYbElvRjY3SDcrYzBZN0dzN082M0VVZHY5SFdJazJQcXFkQWhTNWlMSitzMEZDWEN0OVpUL1hTQW03bGNpSkhhWjVJaFdaQkV3bHNvODRHK1hiaHlkVjhnR2RJb3NsaW1uNUZ3aHZtRDhsN1RmRnQrK1RsNnFjMXhJd3FnMnI3ZXdHRGFGNW84UDVPYUZ6YmgyZTk3WjFXcXZxTGo0bEZJNjdWZHR2dWFhRktQYjNHaFVOSHhiejVEa2w3dnBxMjdiTGZtbUpvTnhZR2JSZXBDck9ubHc4dHZrQlJWZVlBcWExK1B1Tmw4TkFSVzg3bXM5T1JnaGJYTCsxRFc1KzRUZStLenU1YldUQVk1N3NabmhuNEhja0tiazdNK0ZKbUNGSDZNczJaWXNTNldWNWJ6R0x4WlFrWUYvVEVOaFpiYVluRDZ0cVFTYzljL1B5MlFYSWd5WU5pSHIxdWpKc1cxM0FGYVZnckorK295U01kaXJ0QWVpa2NiL3NMNGZPOG5MeXN6NjExK29sUXVxK0J0VGpTcVRpYUR6WXF5SnN6cDRDekdDdXFkdEVjMHJZWE92WVJnSFFuVVlaYXJna1V4VkUwdjRCLzFCVW5BQUFlTnBqWUdSZ1lBQmlYaG5Gd0hoK202OE16Q3dNSVBEWStnUXpndjZ2eTNTTTZTS1F5OEhBQkJJRkFPS1NDT2NBZU5wallHUmdZR2I0ejhEQXdIU01RZWYvQmFZc0JxQUlDbUFCQUdVY0JEZ0N4Z0FBQWpvQVN3STZBQ3dDS0FBd0FBQUFBQUJtQU5RQlFnQUFlTnBqWUdSZ1lHQmhjR0ZnWWdBQlJnWTBBQUFIamdCTmVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS1I3VFAyaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZExCZVh4dlBiZkdWZ1ptRUFnY2ZXSjVpUmFlYUpURFpBaW9PQkNjUURBQTVzQ0l3QUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDArMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNWWjJ4NVpnQUFBV1FBQUFGTEFBQUJZRG1Tc1RKb1pXRmtBQUFDc0FBQUFDOEFBQUEyS0pUVDNXaG9aV0VBQUFMZ0FBQUFIZ0FBQUNRR0xBSU9hRzEwZUFBQUF3QUFBQUFNQUFBQURBaCtBRTlzYjJOaEFBQUREQUFBQUFnQUFBQUlBRlFBc0cxaGVIQUFBQU1VQUFBQUZnQUFBQ0FBQndBNmJtRnRaUUFBQXl3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaVp2Z1A1RE5EcEpIVS9BY0tBd0R5S1ExSGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoTy8vOERTY2YvLy84ZkFQTVpBRktvQnA1NDJqV1BNVS9DUUFDRjc5M0JIV0RiUTF2YUdBRlRRWnBvRkVOSkt3d01LbWcwRXBURU1KQ1ltQ2liZzBGY0dSaDFNakZ4Y25IekI3ZzRPZmtuSEl5anZ3R3dOZkZOTDEvZThEMUNTWDQ2cFYvMGt4UkppUkFmbmw4eUxkMHdYYy9rUlFpbjRKUTl5L1Q4SW16QkRkUHlMQTBCRDdGYmcrK3lWNXh6UStXb21Xc3BLTkgrTUJhRk9xT1hXVnhNcGswMXJhc01hclRYVWFERWwycVBQL2FBbmlRUmwrT2hLVmxHZ0RIUW1CU0FZbDNVUjBZK0NTbzFIdUtFNU1oOTRKZ0VZV1IxT21hY3ZwRXNXU0diZ2FsZXpqazhjTE96U0drUVdWaGNnZ3ViLy9ucW9aeFhjSElGTHRoL1o4SEFmYjViY0RKU290TTlZOFAyUVJ0ME4zbDRQYmxQYTFvMSsvUncycWRZM3g0dDZ0SEwyKzZBMG8yOTkwWUUwRnEwTWt0WldvQWVWZmQ3TXRHc0hHeHB0VWo0QURycTdLcVIzNkdROCtNWGR0TmNickhKOXh4UGtGK3p2VHVEQUhqYVkyQmtZR0FBNGpiWEZSZmorVzIrTWpDek1JREFZK3NUekFqNi8xOW1OcWE3UUM0SEF4TklGQUF2U2dxdEFIamFZMkJrWUdCbStNOEFKRGtZVkJpWW1Oa1lnQ0lvZ0JrQUk4Y0JRZ0FBQW5ZQUFBTUFBQ1FEQ0FBckFBQUFBQUJVQUxCNDJtTmdaR0JnWUdhd0JHSVFZR1JBQXdBR2R3QkNBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjE1Mjc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0xNi40MTQ1OTInIHk9Jy0yNy41NjQyMjEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOC42MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwwLjAsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIyLjUzMTA0LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE5LjIyMDAwNycgeT0nLTI2Ljk1NTM3NSc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xNS4wNTUwMzgnIHk9Jy0yMy45NDg4NTgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTExLjk0MTY5NScgeT0nLTIzLjk0ODg1OCc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNy44MDQ3NDQnIHk9Jy0yMy45NDg4NTgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTEuNDU5MzIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTE1LjgyOTk4MycgeT0nLTI3LjU2NDIyMSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjg2MjEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINDYuNDAzNzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNjUzNzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4zMjU4Miw0Ljc4NDAxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjMuODg2NTkxLC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIzLjg4NjU5MScgeT0nLTIzLjk0ODg1OCc+zrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTIwLjEyMjU2OScgeT0nLTIyLjk1MjU5NCc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS04LjYwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQzLjk4ODMsMzcuNzM4MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS0zMS45MzI3NSA0MS4zMzA0N0MyLjA3NjExIDQ2LjM3NDUzIDI4LjY4NzkgMzUuODU4MDIgNDkuNzQ5ODggOS4zMTkxOCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjYyMTYxLC0wLjc4MzI2LDAuNzgzMjYsMC42MjE2MSw0OS45MDUyNyw5LjEyMzM3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNy4wNjYzNiwzOS45MzEyMyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScxLjYnPgo8cGF0aCBkPSdNLTQxLjA4MTE4IDMzLjgyODU3Qy00Ni40NzQ0OS0xLjEzNDM1LTM1Ljg4NzYtMjguMzg1My04LjMwNTU0LTUwLjUzNzU4JyBmaWxsPSdub25lJy8+CjxnIHN0cm9rZS13aWR0aD0nMC42Jz4KPGcgc3Ryb2tlPScjZmZmJz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC4zMDU1NC01MC41Mzc1OCcgZmlsbD0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzMuNzk1MjMsLTEwLjM0NjY2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjMuODg2NTkxLC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2UtZGFzaGFycmF5PSczLjAsMi4wJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KPHBhdGggZD0nTS0zMy44MjgwOCAzMy44Mjg1N0wtOS4yNzcxNiA5LjI4MTA3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTQsLTAuNzA3MDUsMC43MDcwNSwwLjcwNzE0LC05LjEwMDM3LDkuMTA0MzEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xOC4xMTE5NSwyNC4xODk4OCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \SpliceDiagramSquare {
          ne = B',
          se = B,
          nw = A',
          nw/style = pullback,
          sw = A,
          east = g,
          east/style = {>->},
          west = f^{*}(g),
          west/style = {>->},
          south = f,
          north = \varepsilon _{g},
        }
        \node  [above left of = nw] (a) {$A$};
        \draw  [->,morphism,bend left] (a) to node {} (ne);
        \draw  [double,morphism,bend right] (a) to node {} (sw);
        \draw  [->,morphism,exists] (a) to node {} (nw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>This then corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\exists _{f}(\mathsf {id}_{A}) \to  g]]></fr:tex> under the adjunction <fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex>. Thus, we define <fr:tex
display="inline"><![CDATA[\mathsf {Img}]]></fr:tex> by the assignment <fr:tex
display="inline"><![CDATA[f \mapsto  \exists _{f}(\mathsf {id}_{A})]]></fr:tex>. This assignment can be trivially extended to a functor: since the category <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex> is a preorder, every morphism <fr:tex
display="inline"><![CDATA[f \to  f']]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex> has to be mapped to the unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f) \to  \mathsf {Img}(f')]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. This morphism must exist. Indeed, it is the lifting of <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)]]></fr:tex> against <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f')}]]></fr:tex> depicted in the following diagram.</fr:p>
    
      
      <fr:figure><fr:resource
hash="447c19ca1a6fbe2ea6dcb411e3c0becc"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0Ni41NjI4NTlwdCcgaGVpZ2h0PScxMjAuNjgwNzU3cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTcuNzA4NTczIDgwLjQ1MzgzOCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUM0QUFBQTJLR0hTOEdob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0dU94LzdQaitXMitNakN6TUlEQVkrdmpQeEgwZjBhbXk4d2dMZ2NERTRnQ0FGc3FDOVVBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1JQUFvQUFBQUFBMmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEeGloR050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCRUFBQUFSQjVhakhkb1pXRmtBQUFCc0FBQUFDMEFBQUEyS2VMVEsyaG9aV0VBQUFIZ0FBQUFId0FBQUNRRkJnRFphRzEwZUFBQUFnQUFBQUFJQUFBQUNBWVlBRjlzYjJOaEFBQUNDQUFBQUFZQUFBQUdBQ0lBQUcxaGVIQUFBQUlRQUFBQUZ3QUFBQ0FBQkFBU2JtRnRaUUFBQWlnQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBQytBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpxMC9sZ3dNekZyTXg0SENqQWdWLy84ek1BQUErd01QZndCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFGOEFKd0Y3QWp3QUVBQUFBUU1HSXljbUp6Y1RQZ0UzTWhZWEJnY0JjZFFHREJZVEF3U2VBeGtlR1NZQkFRUUIzUDVjRVFjSERSQUJ1dzRnQVNBY0RBd0FlTnBqWUdSZ1lBQmlkcmJmVitQNWJiNHlNTE13Z01CajYrTS9rV21XVUNZYklNWEJ3QVRpQVFBbXZBbmpBQUFBZU5wallHUmdZTmI2WThuQXdCTEtFTS9nd1ZqTkFCUkJBVXdBU2lnQzR3QUVWUUFBQWNNQVh3QUFBQUFBSWdBQWVOcGpZR1JnWUdCaUVHUUEwUXhRRWdrQUFBSkdBQmNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9nQUFvQUFBQUFCQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjFVMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM1WjJ4NVpnQUFBV1FBQUFEaUFBQUE1SXZLUWdSb1pXRmtBQUFDU0FBQUFDOEFBQUEyS09MUzcyaG9aV0VBQUFKNEFBQUFIZ0FBQUNRR1F3Sk9hRzEwZUFBQUFwZ0FBQUFJQUFBQUNBWVFBSHRzYjJOaEFBQUNvQUFBQUFZQUFBQUdBSElBQUcxaGVIQUFBQUtvQUFBQUZ3QUFBQ0FBQkFCS2JtRnRaUUFBQXNBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTWFReE0vd0g4cGtoMGtocS9nT0ZBYkQ2RE1VQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZocC8vOUR5UCt6d1h3R0FGV2dCc0lBQUFCNDJoM0t5VTNEUUJpRzRmbG16RC9PNGhrN0hpOVliQmxITm9rSU9UaU1CVUsydUNFa0pEaHlvWUJJVkVBSkhHaUJMcWlBQ2lpQ0xsaUMzc3Q3ZUJqWTg4K1NmL0JQZHMwWWhBWkpCVWxWM2FGSk0wTXlQVVNIMXZWd2JVblYyZHBsemZiL1N6T0ZzcW9yMTFZcldFa2FqVXVOSkltdjgyQVFGWk9ycGIwVm1DY0xZUkt0NHYzWlRqVFppMFlQUVd6MG95SXY5NFB5L3ZqbWo2UUxnZkZCcU9NaUc0N3pwOEQ0d3NQTDkzdG5MK2RGdzJGUHJSVjFOQjFLY082U2Z2TzJ1UUFGWm9DNzZkRTZqRlllWmlkYlFyWHlPZkt3ZndYdGpnUVkrd1hVZVIySEFBQjQybU5nWkdCZ0FHS0RxMHJINC9sdHZqSXdzekNBd0dQcjR6OFI5SDlkNWhDbXkwQXVCd01UU0JRQVE4d0x0UUI0Mm1OZ1pHQmdadmpQQUNSREdLci9mMmM2eWdBVVFRRk1BR3NmQkpZQUFBTlVBQUFDdkFCN0FBQUFBQUJ5QUFCNDJtTmdaR0JnWUdMd1pBRFJERkFTQ1FBQUI3NEFUd0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktKVFR5V2hvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRqYlhGVC9qK1cyK01qQ3pNSURBWSt2alB4SDAvNy9NYkV4M2dWd09CaWFRS0FCaUJneS9BSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBL1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBtbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDOEFBQUEwRThPekgxb1pXRmtBQUFDSUFBQUFDMEFBQUEyS09EUzcyaG9aV0VBQUFKUUFBQUFIZ0FBQUNRRkxBSzRhRzEwZUFBQUFuQUFBQUFLQUFBQUNnWGZBSnBzYjJOaEFBQUNmQUFBQUFnQUFBQUlBRFlBYUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBZ2JtRnRaUUFBQXB3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBZElsRE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaSmoxbjRIeE9ETURneHdEQXlNZkl6dWJ1QmdZaXJBcHFlc3hxcXVwbTVuYk1acWJHWW1Kc2pFZUNXcGxaVmJpNE5LdDRHQmtrM0pVOUZLd1pXR3hWZkJTZEpSaVkyUjZidloxVDJ5bGhIaFZLZ3NYQzVlSmJKUnR3WW9WaGJhUnNpWmNMSndNUU1ESWtBeTBhd0xRTG1rZ2g0MGRaSnVhUHFNSjJBSWhOWFUxSUVOY2psRmNqSEVDMUZSbUpsYjFjRFZUeHJSaWRtWm1pSVdNREJBekdWazVPRmhrazhPYUdLVit4M0p6c3pLQ0xRUUFFYU1qajNqYVkyQmtZR0FBNG4zbER0YngvRFpmR1poWkdFRGdzZlh4bndqNlB3TnpFRE9JeThIQUJLSUFMcXdLZGdBQUFIamFZMkJrWUdCbStNOEFKSU1Za2htU0dZOHpBRVZRQUJNQVJza0M2Z0FBQTFJQUFBSXFBSm9BWXdBQUFBQUFBQUEyQUdoNDJtTmdaR0JnWUdhUVp3RFJERkFTQ1FBQUE3OEFKZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktKclM1V2hvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaW83bGhqUEg4Tmw4Wm1Ga1lRT0N4OWZHZkNQcS9Qak1QMDNFZ2w0T0JDU1FLQUIzd0Nwc0FlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUkFBQW9BQUFBQUJOZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGMy9HTnRZWEFBQUFFOEFBQUFNUUFBQUR3SEZmMTBaMng1WmdBQUFYQUFBQUYzQUFBQnFKVjJCMnRvWldGa0FBQUM2QUFBQUM4QUFBQTJLRlRTNzJob1pXRUFBQU1ZQUFBQUlBQUFBQ1FGblFHYWFHMTBlQUFBQXpnQUFBQU1BQUFBREFjb0FIdHNiMk5oQUFBRFJBQUFBQWdBQUFBSUFHWUExRzFoZUhBQUFBTk1BQUFBR0FBQUFDQUFCZ0JGYm1GdFpRQUFBMlFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFTkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtU21LY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZlFiRGZBQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlxWXhiLzMvSDhnSDAvOW4vL0VGcXdJQ0FLSUZDWWNBQUFCNDJrWFB1MDdjUUJURzhmbG16SGpaaThkNzhYakJZR2ZYOWd3WFpXOUdOdHBGM29VdGtDQlNoQ0tCcUtJVU5Qc0N2QVVWQlczYVBBYzk0aDFTUnFKS0d6S3JGRG5GS2M2L09UOENjdmsrcEN2NlNoYUVnQWx3MjRIZFY3cEVKbjNKYlJtaHhKekZYT1YrVnFJdzk0bjBIY1JLcTd4UVF6aFVJTXNsMS9nK2RTMTNlL04wdkRjRkVrOHhpRWdJa2ZUWTdrQjhDbWxiWEFuUGtXZngvZ2tRUzlQZFVJaFdLNnhXdHIrdU14Ny9QRjgwRjBlZEpWTngrSUVtWE5jMktheEw3K24zRGV2YnVMa050RXFUL3dsYjZ1T0QxYStBbUtGazlQNExiM2doTTdJa3BIRGdjOS84UDhtTHZBaXh0ZzFnWU1XL25Vcy9oSkVvUFRCaUkvVkwrUG5hcHJtV2N6b0UvNUdsd0d3M3lqNmZ0NnhLZys2NTQ5WDFIZWh4eEdKcVBYNnJUM3JOQlBCa05aNDJydTRaVGRXczNodUJsVHVIdGJDYmRycmQ0YzlnM2o0SXFwUUdvUTBFdXE0c1hFeEhaeTJrMGVJTHdCM3V1WTAydFR0VmpBLzZiYWNDTkRvN05WanBocWtXcUtIOUJZNnROVmdBZU5wallHUmdZQUJpdnJXVHl1UDViYjR5TUxNd2dNQmo2K00vRWZSL2ZhWmpUQmVCWEE0R0pwQW9BRUk4Qy93QWVOcGpZR1JnWUdiNHo4REF3SFNNd2VEL0JhWXNCcUFJQ21BR0FHVjNCRHNDeGdBQUFqb0FTd0lvQURBQUFBQUFBR1lBMUhqYVkyQmtZR0JnWm5CaFlHSUFBVVlHTkFBQUIzTUFUSGphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9DQ3hkV0ZnWW1YcUF0aEZHV3dqSjBSQ3FqcjJkL2RoUFBRTlYrZCsyRURORHdYM0s1Z2x2VjlKSmU3QkZWUG1tU2ZpM2pMWExIam5pYUo4bHVTVmo4eWxOSitaSzE3NHlqeVIvRHR6ellyZlRYQ1g2MkNqMmdWam96ODUxNjMzTnZaZDhHcXBtK1MzMXR0NEdLeFJ4NXN5WTllUFo2ZGEzZWlXRFFISGhTc0Rsb2hpSjRsSjdEbEo1K2hZczA5Skx4d2tWeXpSTlAvNnJmUStiUTdwSnlPYkl6ZFJ3eWlMWHZRc1cwV2JYbXJhUDh1aEwvY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQzBBQUFBMktSN1RLMmhvWldFQUFBSGNBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZndBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPTGRMQmZQeHZQYmZHVmdabUVBZ2NmV3gzOGkwOHdUbVd5QUZBY0RFNGdIQUVFb0NwNEFBQUI0Mm1OZ1pHQmdWdnhqQkNRbk1oZ3l5REthTUFCRlVBQVRBRUVhQW00QUFBT1JBQUFCVVFBeEFBQUFBQUFnQUFCNDJtTmdaR0JnWUdMZ1p3RFJERkFTQ1FBQUFoUUFGUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY4IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi41NzcwMTIsLTYwLjU2NjQ3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01NS4xMDUwMTMnIHk9Jy02NC4xODE4MzQnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MC41NjY0NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjQ1OTMyLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYwLjU2NjQ3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy02MC41NjY0Nyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTQuNTIwNDA0JyB5PSctNjQuMTgxODM0Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINDYuNDAzNzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNjUzNzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNS44ODg2Nyw1LjkwMDcxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MC41NjY0NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNjIuNTc3MDEyJyB5PSctNjAuNTY2NDcnPs61PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01OC44MTI5OScgeT0nLTU4LjczNDQyNyc+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjgnIHg9Jy01MC40MTk5MDQnIHk9Jy01OC43MzQ0MjcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTQ3LjcyMTY0OScgeT0nLTU4LjczNDQyNyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDMuNzI2MTc5JyB5PSctNjAuMjAxMTU2Jz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTQxLjAzMTQwNCcgeT0nLTU4LjczNDQyNyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS04LjYwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTUwLjgyNjY3MycgeT0nLTYwLjU2NjQ3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny43MTMzMycgeT0nLTYwLjU2NjQ3Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00My4wNDY3NDYnIHk9Jy02My41NzI5ODcnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNDAuMzUxOTcxJyB5PSctNjAuNTY2NDcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjUwNTU0LTU2LjkwNTVINDcuODA2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTAuNzU1NTQsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNi45NDE3OSwtNjQuOTY3MzIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYwLjU2NjQ3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Mi41NzcwMTInIHk9Jy02MC41NjY0Nyc+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy01MC44MjY2NzMnIHk9Jy02MC41NjY0Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuNzEzMzMnIHk9Jy02MC41NjY0Nyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNDMuMDQ2NzQ2JyB5PSctNjAuNTY2NDcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J004LjIzODEzLTQ4LjY2MjQ2TDUwLjE0NTkyLTYuNzYzMjMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNywwLjcwNzAyLC0wLjcwNzAyLDAuNzA3MTcsNTAuMzIyNzEsLTYuNTg2NDkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \SpliceDiagramSquare {
          nw = A',
          nw/style = pullback,
          sw = A,
          ne = B',
          se = B,
          north = \varepsilon _{\mathsf {Img}(f')},
          east = \mathsf {Img}(f'),
          east/style = {>->},
          south = \mathsf {Img}(f),
          south/style = {>->},
        }
        \draw  [->,morphism,exists] (sw) to (ne);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>We can now extract the components of the unit and the counit from this correspondence.</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
      
  <html:tr>
        
  <html:th>Unit (<fr:tex
display="inline"><![CDATA[\vartheta ]]></fr:tex>)</html:th>

        
  <html:th>Counit (<fr:tex
display="inline"><![CDATA[\zeta ]]></fr:tex>)</html:th>

      </html:tr>

      
  <html:tr>
        
  <html:td>
          <fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be an object in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. The identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}\colon \mathsf {Img}(f)\to \mathsf {Img}(f)]]></fr:tex> is, by definition, the identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}\colon \exists _{f}(\mathsf {id}_{A})\to \mathsf {Img}(f)]]></fr:tex>, which corresponds to the unit <fr:tex
display="inline"><![CDATA[\eta _{\mathsf {id}_{A}}\colon \mathsf {id}_{A}\to f^{*}(\mathsf {Img}(f))]]></fr:tex> of the adjunction <html:span
style="white-space: nowrap"><fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex></html:span>.</fr:p>
          <fr:p>Then since <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)]]></fr:tex> is monic, <fr:tex
display="inline"><![CDATA[\eta _{\mathsf {id}_{A}}]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f)}\eta _{\mathsf {id}_{A}}\colon f\to \mathsf {Img}(f)]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> is the counit of the adjunction <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex>. This defines the component of <fr:tex
display="inline"><![CDATA[\vartheta ]]></fr:tex> at <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. This is precisely the lifting of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> against <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f)}]]></fr:tex>.</fr:p>
          
    
      
      <fr:figure><fr:resource
hash="9412b64af3fb67acab4f1f858195b591"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0Mi41MjA3MjdwdCcgaGVpZ2h0PScxMTguNzcxMjE4cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTUuMDEzODE4IDc5LjE4MDgxMic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUMwQUFBQTJLR0hUQkdob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0dU94LzUzaitXMitNakN6TUlEQVkrc1R6QWo2UHlQVFpUQ1hnNEVKUkFFQUtHNEp3d0FBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9nQUFvQUFBQUFCQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjFVMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM1WjJ4NVpnQUFBV1FBQUFEaUFBQUE1SXZLUWdSb1pXRmtBQUFDU0FBQUFDOEFBQUEyS09MVEEyaG9aV0VBQUFKNEFBQUFIZ0FBQUNRR1F3Sk9hRzEwZUFBQUFwZ0FBQUFJQUFBQUNBWVFBSHRzYjJOaEFBQUNvQUFBQUFZQUFBQUdBSElBQUcxaGVIQUFBQUtvQUFBQUZ3QUFBQ0FBQkFCS2JtRnRaUUFBQXNBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTWFReE0vd0g4cGtoMGtocS9nT0ZBYkQ2RE1VQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZocC8vOUR5UCt6d1h3R0FGV2dCc0lBQUFCNDJoM0t5VTNEUUJpRzRmbG16RC9PNGhrN0hpOVliQmxITm9rSU9UaU1CVUsydUNFa0pEaHlvWUJJVkVBSkhHaUJMcWlBQ2lpQ0xsaUMzc3Q3ZUJqWTg4K1NmL0JQZHMwWWhBWkpCVWxWM2FGSk0wTXlQVVNIMXZWd2JVblYyZHBsemZiL1N6T0ZzcW9yMTFZcldFa2FqVXVOSkltdjgyQVFGWk9ycGIwVm1DY0xZUkt0NHYzWlRqVFppMFlQUVd6MG95SXY5NFB5L3ZqbWo2UUxnZkZCcU9NaUc0N3pwOEQ0d3NQTDkzdG5MK2RGdzJGUHJSVjFOQjFLY082U2Z2TzJ1UUFGWm9DNzZkRTZqRlllWmlkYlFyWHlPZkt3ZndYdGpnUVkrd1hVZVIySEFBQjQybU5nWkdCZ0FHS0RxMHJ6NC9sdHZqSXdzekNBd0dQckU4d0krcjh1Y3dqVFpTQ1hnNEVKSkFvQUVSQUpvd0I0Mm1OZ1pHQmdadmpQQUNSREdLci9mMmM2eWdBVVFRRk1BR3NmQkpZQUFBTlVBQUFDdkFCN0FBQUFBQUJ5QUFCNDJtTmdaR0JnWUdMd1pBRFJERkFTQ1FBQUI3NEFUd0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktKVFQzV2hvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRqYlhGUmZqK1cyK01qQ3pNSURBWStzVHpBajYvMTltTnFhN1FDNEhBeE5JRkFBdlNncXRBSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU4wQUFvQUFBQUFBL1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBtbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDOEFBQUEwRThPekgxb1pXRmtBQUFDSUFBQUFDd0FBQUEyS09EVEEyaG9aV0VBQUFKTUFBQUFIZ0FBQUNRRkxBSzRhRzEwZUFBQUFtd0FBQUFLQUFBQUNnWGZBSnBzYjJOaEFBQUNlQUFBQUFnQUFBQUlBRFlBYUcxaGVIQUFBQUtBQUFBQUZ3QUFBQ0FBQlFBZ2JtRnRaUUFBQXBnQUFBREtBQUFCTXVzSWtlWndiM04wQUFBRFpBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBZElsRE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaSmoxbjRIeE9ETURneHdEQXlNZkl6dWJ1QmdZaXJBcHFlc3hxcXVwbTVuYk1acWJHWW1Kc2pFZUNXcGxaVmJpNE5LdDRHQmtrM0pVOUZLd1pXR3hWZkJTZEpSaVkyUjZidloxVDJ5bGhIaFZLZ3NYQzVlSmJKUnR3WW9WaGJhUnNpWmNMSndNUU1ESWtBeTBhd0xRTG1rZ2g0MGRaSnVhUHFNSjJBSWhOWFUxSUVOY2psRmNqSEVDMUZSbUpsYjFjRFZUeHJSaWRtWm1pSVdNREJBekdWazVPRmhrazhPYUdLVit4M0p6c3pLQ0xRUUFFYU1qajNqYVkyQmtZR0FBNG4zbERzTHgvRFpmR1poWkdFRGdzZlVKWmdUOW40RTVDTXpsWUdBQ1VRRDc0UWhrZU5wallHUmdZR2I0endBa2d4aVNHWklaanpNQVJWQUFFd0JHeVFMcUFBQURVZ0FBQWlvQW1nQmpBQUFBQUFBQUFEWUFhSGphWTJCa1lHQmdacEJuQU5FTVVCSUpBQUFEdndBbUFIamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU3ArYm00T1RxOFBickFuU29hbWt0ZWdpL25SdlEvQUdEdDg5NTl3QUdTOFNoa21ZQngwbWxUZVBQT2FIUmVTSitLdklHYitzR1pHa00zRlc3Q0tuVFBtUFBHWkpHWGtpL2lOeXhoL3ZmVlBmN3AzMTZ0Z1k2OTJsOXR1VDlXM1ZPTFhSK2JBZXJMUCszRm1qeXFjeWZkWDIxMW9WT3RjRmV4cHFidHpwc0hnVVIzRk1ZTWRGTXMrV1U5aGJLc21jZERabzhtOTZrTlNGeGpuOFlxUlI4aFExOUhMVGlsNmxxeWpDbmFiNEFGVXlMa01BQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXOTBuR050WVhBQUFBRTRBQUFBTXdBQUFFUUFld0VnWjJ4NVpnQUFBV3dBQUFGTUFBQUJqUE53SkpOb1pXRmtBQUFDdUFBQUFDOEFBQUEyS0pyUytXaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR053SjFhRzEwZUFBQUF3Z0FBQUFRQUFBQUVBajlBTlpzYjJOaEFBQURHQUFBQUFvQUFBQUtBTlFBaUcxaGVIQUFBQU1rQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQXp3QUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TXVReWMvOEg4cG01R2RIVS9BY0tBd0REN3d6N2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VROEdkSVpjdi8vUjdEKzcvZy8rLzgwc0Zvd0FBRHNod3VWQUhqYVZWRExUc0pRRUoyWlcxb2dXQVNsRmR0VWFXTUxpQkI1dE1CVkVoY1NJeXBxNGtJa1NHVGpqeGcrRFJNU0VxSWY0dGFGNE1XTm1rbE96bU5tY1FZUVJnQXdwUWt3Z0kyRWs1ZyswK1NySVRRSXgxcVdLSTd2VUFJT0hRRFVQVWRXZEMybG9pSjdzbUpoVVBGMVRZeUt0dXU1ZmxCRXp3L2NXZ3NEWDI4aDAxYU80NjQyZFhFcDZ4YVdSZTZKSVJhcmNsT1NUSHk2MkcrRUdCWGlqOFpSM3ExS05KNk5HUm81SllGUzJxSGhaYkZ4L0xDME9XRXQ3d2owZTZQbW1zcG84RElncVJCZkwrSzhMU0VMNXc1UGgwUzd0T01taUNKaHpicmkzUzdmNU5zUnoyb2FCM1dSTWx1TExqNnd5Q3ZWSDNobHBxbGtzdGxNVmcyUkxDb0R3cDBvSHNNMzJCTkMvTU12b2V1cHFLZiswVXJLRjExRXhjQkNGcjFucXBRODQyWDhKYmZ0M25sVFR0NmM5RG1XRm5QTXB1MlF6VmkvOXZtWHpqclh4T3BiaGs5c0NOL3JyRDNyZU5wallHUmdZQUJpbzdtaE4rUDViYjR5TUxNd2dNQmo2eFBNQ1BxL1BqTVAwM0VnbDRPQkNTUUtBQllJQ1lnQWVOcGpZR1JnWU9iK3p3QWs0eG5rR0FTWmVSaUFJaWlBQlFBdXZ3RzBBQUFDVUFBQUFTNEFZd0lnQUI0RFh3QlZBQUFBQUFBT0FJZ0F4Z0FBZU5wallHUmdZR0JoOEdGZ1pnQUJSZ1kwQUFBSWJRQldlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQzBBQUFBMktSN1RQMmhvWldFQUFBSGNBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZndBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPTGRMQmVYeHZQYmZHVmdabUVBZ2NmV0o1aVJhZWFKVERaQWlvT0JDY1FEQUE1c0NJd0FBQUI0Mm1OZ1pHQmdWdnhqQkNRbk1oZ3l5REthTUFCRlVBQVRBRUVhQW00QUFBT1JBQUFCVVFBeEFBQUFBQUFnQUFCNDJtTmdaR0JnWUdMZ1p3RFJERkFTQ1FBQUFoUUFGUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVjQUFvQUFBQUFCZmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjRNR050WVhBQUFBRThBQUFBTXdBQUFFUUR5UVNoWjJ4NVpnQUFBWEFBQUFKSkFBQUN1SE55R29ab1pXRmtBQUFEdkFBQUFDOEFBQUEyS0ZUVEEyaG9aV0VBQUFQc0FBQUFJQUFBQUNRRndnR2JhRzEwZUFBQUJBd0FBQUFRQUFBQUVBbnFBS3RzYjJOaEFBQUVIQUFBQUFvQUFBQUtBY0lBMUcxaGVIQUFBQVFvQUFBQUdBQUFBQ0FBQndCWWJtRnRaUUFBQkVBQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRkVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXFtS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVY5a1p2Z1A1RE16TUlLRUdSRXEvZ09GQVFBT0RpUUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGswcGkzTWwvOC94L0Irai83ais4Zkk3QmFNQUFBREhzTWFnQjQya1dSUDIvVFFCakcvWnlkYytJa1BqZTJ6Mm1jT2swYzI2V1VwSEZTR3lYQlNWTUIvUU10RlNnVlFtcFZwQzRkRUF2aVc4RFNnWldWejhHTytBNk1TRXhkS1pjaXhKMTB3L3ZvcFBmMy9DUklCemRkY2ttK1MxTkpnc3hBVlIxcUs0d3k5TG5EcWNvYnlEQ1JmUm9tVGo5REt1WXhkM1Q0WVJRbWFkaUZUaGo2Q2FjUlBnOE54YWdWdG50clE2QnRoekpZZ3pIV2Jzb3JIZmJFSXlZN1pyYk9aLzZkTWVCemtSc2VZNVdLcCtWclo0c1lWNysvN2k5TkI5YU9IUHJlS21uVHFGZ2dVQTdzVDljbmNrdkZ5VXMzQ29QMi93akw0YjBQU2lzUFNSd2liZDc4eEM5OGswYlNqaVNsT2h6cWlQM2pKRTFTRHd1MkRnUlkrdmROdU9OQmtJUlJSeEFMVWllRGt5ellJaHJ4Q2VtQ2Z1a0h3R2lsMFQ5NlhGSHlaYkptOUM3bkZ5RDNHN0pQbEt2elV0eGNhZ00yMS94aCtmaTlUSUp3VkdwdVFzN3FkNHRlTmJDcTFlNFBkMkt1dXhvaHJxY0NibFFLRmV3UE4yY1ZCSTNwYzREcTFEYktKbEV0RGIzMWxxbm5nYkpWTDBJSmNpSlZRUDZ4WFpPUHd0T2VOQmVtSEc2cEVWVnZieGdsRXpuWkdvU1JVS2VqaXc0UzRVa2dPeGFUcVUyNUU5OE9oSzJGMkZTSWRiZ3E1SXBpYmorSmtqaVp0NXh5M3gxVzNZZno4Um1CWmpLVk1OTnJGWE9xVnFUZ3JCUjVHeE1vVEhWeVpEWHhIelRyN1ZJMnpnOXo1UFhza2FmbXVGajN0Q3JERGVLblJPblZCbmlya3FxU3Z6Z1B2R2NLQnJ1K2Z6UmFLZWgySFpoMnJDSUlNWGJxZkJVWWJHaEwyOHVuTmJPMlJiSlIvRzVnQkhUdGNPK05ySXhMK214YzJBMWV2SW9QaVh3NjNtNGFOVkhISDZMT1dFWUFBQUI0Mm1OZ1pHQmdBT0tBNDhGUDQvbHR2akl3c3pDQXdHUHJFOHdJK3I4KzB6R21pMEF1QndNVFNCUUFMa3dLblFCNDJtTmdaR0JnWnZqUHdNREFkSXpCNFA4RnBuNEdvQWdLWUFFQWFEY0VZUUxHQUFBQ09nQkxBaWdBTUFMQ0FEQUFBQUFBQUdZQTFBRmNBQUI0Mm1OZ1pHQmdZR0VJWjJCaUFBRkdCalFBQUFscEFHQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjE1Mjc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuMDY0NjAyJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01NS4xMDUwMTMnIHk9Jy02NC42Nzk5NjYnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy4yNjM4OSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjQ1OTMyLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuMDY0NjAyJz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01NC41MjA0MDQnIHk9Jy02NC42Nzk5NjYnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjA2NDYwMic+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOS43MDgzMyAwSDQ2LjQwMzc4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjY1Mzc4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTcuMjQxMTIsNS40MDA3MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPs61PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01OC44MTI5OScgeT0nLTU5LjczMDcwNyc+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy01MC40MTk5MDQnIHk9Jy01OS43MzA3MDcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQ3LjcyMTY0OScgeT0nLTU5LjczMDcwNyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNDMuNzI2MTc5JyB5PSctNTkuNzMwNzA3Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTguNjA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwtOC44NTk3MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjA2NDYwMic+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy01MC44MjY2NzMnIHk9Jy02MS4wNjQ2MDInPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ3LjcxMzMzJyB5PSctNjEuMDY0NjAyJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy00My4wNDY3NDYnIHk9Jy02MS4wNjQ2MDInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J004LjIzODEzLTQ4LjY2MjQ2TDUwLjE0NTkyLTYuNzYzMjMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNywwLjcwNzAyLC0wLjcwNzAyLDAuNzA3MTcsNTAuMzIyNzEsLTYuNTg2NDkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTTIxLjY5OTEtMzQuMzE5NDNIMzcuMDM4NTJWLTIxLjQyNTAySDIxLjY5OTFaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC42OTkxLC0yOS4yODYxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjA2NDYwMic+z5E8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTU3Ljc2NjA3MScgeT0nLTYwLjAwNzQ1NSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                nw = A',
                nw/style = pullback,
                sw = A,
                ne = B',
                se = B,
                north = \varepsilon _{\mathsf {Img}(f)},
                east = \mathsf {Img}(f),
                east/style = {>->},
                south = f,
              }
              \draw  [->,morphism,exists] (sw) to node[desc] {$\vartheta _{f}$} (ne);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
        </html:td>

        
  <html:td>
          <fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A\rightarrowtail B]]></fr:tex> be an object in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. Then the identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}_{f}\colon f\to f]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[s\colon \mathsf {id}_{A}\to f^{*}(f)]]></fr:tex> by the universal property of pullbacks.</fr:p>
          <fr:p>This morphism corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\exists _{f}(\mathsf {id}_{A}) \to  f]]></fr:tex> under the adjunction <fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex>, which we take as the component of <fr:tex
display="inline"><![CDATA[\zeta ]]></fr:tex> at <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p>
        </html:td>

      </html:tr>

    </html:table>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>822</fr:anchor><fr:addr
type="machine">#303</fr:addr><fr:route>unstable-303.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has images, then we may define <fr:tex
display="inline"><![CDATA[\exists _{f}\colon \mathsf {Sub}(A)\to \mathsf {Sub}(B)]]></fr:tex> as the following composite:</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Sub}(A) \hookrightarrow  {{\mathcal {C}}_{/{A}}} \xrightarrow {\Sigma _{f}} {{\mathcal {C}}_{/{B}}} \xrightarrow {\mathsf {Img}} \mathsf {Sub}(B)     ]]></fr:tex><fr:p>Let <fr:tex
display="inline"><![CDATA[i_{A}\colon \mathsf {Sub}(A)\hookrightarrow {{\mathcal {C}}_{/{A}}}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[i_{B}\colon \mathsf {Sub}(B)\hookrightarrow {{\mathcal {C}}_{/{B}}}]]></fr:tex> be the inclusion functors. Note that</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Img}\Sigma _{f} \dashv  f^{*}i_{B}     ]]></fr:tex><fr:p>Since <fr:tex
display="inline"><![CDATA[f^{*}i_{B} \cong  i_{A}f^{*}]]></fr:tex> by construction, we have</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Img}\Sigma _{f} \dashv  i_{A}f^{*}     ]]></fr:tex><fr:p>Let <fr:tex
display="inline"><![CDATA[\eta ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> be the unit and counit of this adjunction respectively. Since <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> is a full subcategory of <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>, there is a natural isomorphism <fr:tex
display="inline"><![CDATA[\iota \colon \mathsf {id}_{{{\mathcal {C}}_{/{A}}}}\stackrel {\sim }{\smash {\longrightarrow }\rule {0pt}{0.4ex}}i_{A}]]></fr:tex>. Then we can define <fr:tex
display="inline"><![CDATA[\eta ']]></fr:tex> as follows:</fr:p><fr:tex
display="block"><![CDATA[       \eta ' := \mathsf {id}_{{{\mathcal {C}}_{/{A}}}} \xrightarrow {\eta } i_{A}f^{*}\mathsf {Img}\Sigma _{f}       \xrightarrow {\iota _{f^{*}\mathsf {Img}\Sigma _{f}}} f^{*}\mathsf {Img}\Sigma _{f}       \xrightarrow {f^{*}\mathsf {Img}\Sigma _{f}(\iota )} f^{*}\mathsf {Img}\Sigma _{f}i_{A}     ]]></fr:tex><fr:p>Then <fr:tex
display="inline"><![CDATA[\eta ']]></fr:tex> and <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> form the unit and counit of the adjunction <fr:tex
display="inline"><![CDATA[\mathsf {Img}\Sigma _{f}i_{A} \dashv  f^{*}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1562</fr:anchor><fr:addr
type="user">fnd-0008</fr:addr><fr:route>fnd-0008.xml</fr:route><fr:title
text="Regular category">Regular category</fr:title><fr:taxon>Section</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="frankndrssn.xml"
addr="frankndrssn"
title="Frank Tsai">Frank Tsai</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>817</fr:anchor><fr:addr
type="user">ct-000K</fr:addr><fr:route>ct-000K.xml</fr:route><fr:title
text="Image">Image</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is said to have <fr:em><fr:strong>images</fr:strong></fr:em> if the inclusion functor <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A) \hookrightarrow  {{\mathcal {C}}_{/{A}}}]]></fr:tex> admits a left adjoint <fr:tex
display="inline"><![CDATA[\mathsf {Img}\colon {{\mathcal {C}}_{/{A}}}\to \mathsf {Sub}(A)]]></fr:tex> for all objects <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>818</fr:anchor><fr:addr
type="user">ct-000O</fr:addr><fr:route>ct-000O.xml</fr:route><fr:title
text="Regular category">Regular category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is said to be <fr:em><fr:strong>regular</fr:strong></fr:em> if it is cartesian, has <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">images</fr:link>, and <fr:link
type="local"
href="ct-000M.xml"
addr="ct-000M"
title="Extremal epimorphism">covers</fr:link> are stable under pullback.
  A functor <fr:tex
display="inline"><![CDATA[F\colon \mathcal {C}\to \mathcal {D}]]></fr:tex> between regular categories is said to be <fr:em><fr:strong>regular</fr:strong></fr:em> if it is cartesian and preserves covers.
  Note that since cartesian functors preserve monomorphisms, every regular functor automatically preserves images.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>657</fr:anchor><fr:addr
type="machine">#300</fr:addr><fr:route>unstable-300.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[F\colon \mathcal {C}\to \mathcal {D}]]></fr:tex> be a regular functor and <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be a morphism in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
    By <fr:ref
addr="ct-000Q"
href="ct-000Q.xml"
taxon="Lemma" />, <fr:tex
display="inline"><![CDATA[f]]></fr:tex> admits a cover-mono factorization <fr:tex
display="inline"><![CDATA[f = \mathsf {Img}(f)\vartheta _{f}]]></fr:tex>.
    Then since <fr:tex
display="inline"><![CDATA[F]]></fr:tex> preserves monomorphisms and covers, <fr:tex
display="inline"><![CDATA[F(\mathsf {Img}(f))F(\vartheta _{f})]]></fr:tex> forms a cover-mono factorization of <fr:tex
display="inline"><![CDATA[F(f)]]></fr:tex>.
    Then by uniqueness, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(Ff) \cong  F(\mathsf {Img}(f))]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>819</fr:anchor><fr:addr
type="user">ct-000L</fr:addr><fr:route>ct-000L.xml</fr:route><fr:title
text="Equivalent condition for the existence of images">Equivalent condition for the existence of <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">images</fr:link></fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with pullbacks. Then <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has images iff for each morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex>, the pullback functor <fr:tex
display="inline"><![CDATA[f^{*}\colon \mathsf {Sub}(B)\to \mathsf {Sub}(A)]]></fr:tex> admits a left adjoint <fr:tex
display="inline"><![CDATA[\exists _{f}\colon \mathsf {Sub}(A)\to \mathsf {Sub}(B)]]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>820</fr:anchor><fr:addr
type="machine">#304</fr:addr><fr:route>unstable-304.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By <fr:ref
addr="ct-000J"
href="ct-000J.xml"
taxon="Lemma" />, the pullback functor <fr:tex
display="inline"><![CDATA[f^{*}\colon {{\mathcal {C}}_{/{B}}}\to {{\mathcal {C}}_{/{A}}}]]></fr:tex> admits <fr:tex
display="inline"><![CDATA[\Sigma _{f}\colon {{\mathcal {C}}_{/{A}}}\to {{\mathcal {C}}_{/{B}}}]]></fr:tex> as a left adjoint.</fr:p>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>821</fr:anchor><fr:addr
type="machine">#302</fr:addr><fr:route>unstable-302.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[g\colon B'\rightarrowtail B]]></fr:tex> be an arbitrary object in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. We need to construct a functor <fr:tex
display="inline"><![CDATA[\mathsf {Img}\colon {{\mathcal {C}}_{/{B}}}\to \mathsf {Sub}(B)]]></fr:tex> so that each morphism <fr:tex
display="inline"><![CDATA[f \to  g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f) \to  g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[f \to  g]]></fr:tex> be an arbitrary morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. Then this corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A} \to  f^{*}(g)]]></fr:tex> as follows:</fr:p>
    
      
      <fr:figure><fr:resource
hash="42bf1abc475a99195f5c5cbd701c9668"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3Mi43OTYzMzlwdCcgaGVpZ2h0PScxNzQuNDQ0ODM3cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE1LjE5NzU1OSAxMTYuMjk2NTU4Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLT0xSOUdob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0o1OG42VzhmdzJYeG1ZV1JoQTRMSDFDV1lFL1YrSE9ZVHhLSkRMd2NBRUVnVUErb0FKRVFCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDMEFBQUEyS0dIVEJHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHVPeC81M2orVzIrTWpDek1JREFZK3NUekFqNlB5UFRaVENYZzRFSlJBRUFLRzRKd3dBQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOa0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQ3dBQUFBMktlTFMzMmhvWldFQUFBSThBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbHdBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDWkFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKc0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvUUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURWQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGlXdWs5cGZIOE5sOFptRmtZUU9DeDlRbG1aSm9sbFBFT2tPSmdZQUx4QVA5dUNJUjQybU5nWkdCZzF2cGp5Y0RBRXNyUXg5RFBsTXdBRkVFQlRBQlNnQU5DQUFSVkFBQUM4Z0NPQUFBQUFBQlVBQUI0Mm1OZ1pHQmdZR0l3WlFEUkRGQVNDUUFBQmNvQU93QjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFDVWxZV0JpWldwQzJDRE1zUkJkb2dVcWVySTcrN2hldWdOcCtmOXVBTktmc2g0VHNacjNNL0pLVVQ5Y2NFTGI0bW5vaGFKU3o1WU1pSExaK0xNMlNUT0pmbEtYUERPSmZGVS9PL0VKWjg4dGwxN3UvZldxMzFuckhmbk5venJnL1doNlp4YTZTcnFuWFhXSDN0cjFHbFVabWpDY0cxVnJTdGRzNldqNWNhZEhvdEhzUmZIUkhhY0pRdU1yRGxFSjlCSTZxUzFRbFA5eTNlU3U5ZzV4azlHT2lkSmxOQWdWMEgyVmRxS09sNXE2bC92NlRCSEFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVHdBQW9BQUFBQUJid0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGMzhtTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SEZmMTJaMng1WmdBQUFYQUFBQUllQUFBQ2hCTEZ2RVpvWldGa0FBQURrQUFBQUM4QUFBQTJLRlRUQVdob1pXRUFBQVBBQUFBQUlBQUFBQ1FGbVFHYmFHMTBlQUFBQStBQUFBQVFBQUFBRUFsaUFLZHNiMk5oQUFBRDhBQUFBQW9BQUFBS0FhZ0ExRzFoZUhBQUFBUDhBQUFBR0FBQUFDQUFCd0JGYm1GdFpRQUFCQlFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFNUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtaW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZkI1RGVZQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlxWXpiLzMvSDhoUEE5SC9aLy94QTZzQ0FnQ2lKd21KQUFCNDJrWFJQVy9UUUJ3R2NEOTM3amx2OXRteGZXNlQxSGx4YklmU3htbmNPaWl0OHRKV1FtMFJwVUtpS2tJZ2hpNmRrQmhBZkFnRzFJR1ZsVy9BM2gzeEhSaVJtQmhZVXM3dHdKMTB3ejAzL0gvM0tGQ09ieEp5U1g0b00wVUI1V0NhQWEwVHhST2t3aE5NRTAxTU1LVUJpekl2bldBazc0ZkNNeEJFY1pTTm9nUUc0VWd6d1dKOEdadXFXU3ZPTjN0am9PdEdGTHpKT2UrMjZXcWZQL0tKelUrNWE0aTk0TjR1RUFpWm16N24xYXBmS3RSZTVUR3VGdGRIMW16TDJhZFI0TGRJbDhYbElvRjY3SDcrYzBZN0dzN082M0VVZHY5SFdJazJQcXFkQWhTNWlMSitzMEZDWEN0OVpUL1hTQW03bGNpSkhhWjVJaFdaQkV3bHNvODRHK1hiaHlkVjhnR2RJb3NsaW1uNUZ3aHZtRDhsN1RmRnQrK1RsNnFjMXhJd3FnMnI3ZXdHRGFGNW84UDVPYUZ6YmgyZTk3WjFXcXZxTGo0bEZJNjdWZHR2dWFhRktQYjNHaFVOSHhiejVEa2w3dnBxMjdiTGZtbUpvTnhZR2JSZXBDck9ubHc4dHZrQlJWZVlBcWExK1B1Tmw4TkFSVzg3bXM5T1JnaGJYTCsxRFc1KzRUZStLenU1YldUQVk1N3NabmhuNEhja0tiazdNK0ZKbUNGSDZNczJaWXNTNldWNWJ6R0x4WlFrWUYvVEVOaFpiYVluRDZ0cVFTYzljL1B5MlFYSWd5WU5pSHIxdWpKc1cxM0FGYVZnckorK295U01kaXJ0QWVpa2NiL3NMNGZPOG5MeXN6NjExK29sUXVxK0J0VGpTcVRpYUR6WXF5SnN6cDRDekdDdXFkdEVjMHJZWE92WVJnSFFuVVlaYXJna1V4VkUwdjRCLzFCVW5BQUFlTnBqWUdSZ1lBQmlYaG5Gd0hoK202OE16Q3dNSVBEWStnUXpndjZ2eTNTTTZTS1F5OEhBQkJJRkFPS1NDT2NBZU5wallHUmdZR2I0ejhEQXdIU01RZWYvQmFZc0JxQUlDbUFCQUdVY0JEZ0N4Z0FBQWpvQVN3STZBQ3dDS0FBd0FBQUFBQUJtQU5RQlFnQUFlTnBqWUdSZ1lHQmhjR0ZnWWdBQlJnWTBBQUFIamdCTmVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS1I3VFAyaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZExCZVh4dlBiZkdWZ1ptRUFnY2ZXSjVpUmFlYUpURFpBaW9PQkNjUURBQTVzQ0l3QUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDArMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNWWjJ4NVpnQUFBV1FBQUFGTEFBQUJZRG1Tc1RKb1pXRmtBQUFDc0FBQUFDOEFBQUEyS0pUVDNXaG9aV0VBQUFMZ0FBQUFIZ0FBQUNRR0xBSU9hRzEwZUFBQUF3QUFBQUFNQUFBQURBaCtBRTlzYjJOaEFBQUREQUFBQUFnQUFBQUlBRlFBc0cxaGVIQUFBQU1VQUFBQUZnQUFBQ0FBQndBNmJtRnRaUUFBQXl3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaVp2Z1A1RE5EcEpIVS9BY0tBd0R5S1ExSGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoTy8vOERTY2YvLy84ZkFQTVpBRktvQnA1NDJqV1BNVS9DUUFDRjc5M0JIV0RiUTF2YUdBRlRRWnBvRkVOSkt3d01LbWcwRXBURU1KQ1ltQ2liZzBGY0dSaDFNakZ4Y25IekI3ZzRPZmtuSEl5anZ3R3dOZkZOTDEvZThEMUNTWDQ2cFYvMGt4UkppUkFmbmw4eUxkMHdYYy9rUlFpbjRKUTl5L1Q4SW16QkRkUHlMQTBCRDdGYmcrK3lWNXh6UStXb21Xc3BLTkgrTUJhRk9xT1hXVnhNcGswMXJhc01hclRYVWFERWwycVBQL2FBbmlRUmwrT2hLVmxHZ0RIUW1CU0FZbDNVUjBZK0NTbzFIdUtFNU1oOTRKZ0VZV1IxT21hY3ZwRXNXU0diZ2FsZXpqazhjTE96U0drUVdWaGNnZ3ViLy9ucW9aeFhjSElGTHRoL1o4SEFmYjViY0RKU290TTlZOFAyUVJ0ME4zbDRQYmxQYTFvMSsvUncycWRZM3g0dDZ0SEwyKzZBMG8yOTkwWUUwRnEwTWt0WldvQWVWZmQ3TXRHc0hHeHB0VWo0QURycTdLcVIzNkdROCtNWGR0TmNickhKOXh4UGtGK3p2VHVEQUhqYVkyQmtZR0FBNGpiWEZSZmorVzIrTWpDek1JREFZK3NUekFqNi8xOW1OcWE3UUM0SEF4TklGQUF2U2dxdEFIamFZMkJrWUdCbStNOEFKRGtZVkJpWW1Oa1lnQ0lvZ0JrQUk4Y0JRZ0FBQW5ZQUFBTUFBQ1FEQ0FBckFBQUFBQUJVQUxCNDJtTmdaR0JnWUdhd0JHSVFZR1JBQXdBR2R3QkNBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjE1Mjc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0xNi40MTQ1OTInIHk9Jy0yNy41NjQyMjEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOC42MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwwLjAsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIyLjUzMTA0LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE5LjIyMDAwNycgeT0nLTI2Ljk1NTM3NSc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xNS4wNTUwMzgnIHk9Jy0yMy45NDg4NTgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTExLjk0MTY5NScgeT0nLTIzLjk0ODg1OCc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNy44MDQ3NDQnIHk9Jy0yMy45NDg4NTgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTEuNDU5MzIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTE1LjgyOTk4MycgeT0nLTI3LjU2NDIyMSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjg2MjEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINDYuNDAzNzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNjUzNzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4zMjU4Miw0Ljc4NDAxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjMuODg2NTkxLC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIzLjg4NjU5MScgeT0nLTIzLjk0ODg1OCc+zrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTIwLjEyMjU2OScgeT0nLTIyLjk1MjU5NCc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS04LjYwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQzLjk4ODMsMzcuNzM4MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS0zMS45MzI3NSA0MS4zMzA0N0MyLjA3NjExIDQ2LjM3NDUzIDI4LjY4NzkgMzUuODU4MDIgNDkuNzQ5ODggOS4zMTkxOCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjYyMTYxLC0wLjc4MzI2LDAuNzgzMjYsMC42MjE2MSw0OS45MDUyNyw5LjEyMzM3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNy4wNjYzNiwzOS45MzEyMyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScxLjYnPgo8cGF0aCBkPSdNLTQxLjA4MTE4IDMzLjgyODU3Qy00Ni40NzQ0OS0xLjEzNDM1LTM1Ljg4NzYtMjguMzg1My04LjMwNTU0LTUwLjUzNzU4JyBmaWxsPSdub25lJy8+CjxnIHN0cm9rZS13aWR0aD0nMC42Jz4KPGcgc3Ryb2tlPScjZmZmJz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC4zMDU1NC01MC41Mzc1OCcgZmlsbD0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzMuNzk1MjMsLTEwLjM0NjY2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjMuODg2NTkxLC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2UtZGFzaGFycmF5PSczLjAsMi4wJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KPHBhdGggZD0nTS0zMy44MjgwOCAzMy44Mjg1N0wtOS4yNzcxNiA5LjI4MTA3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTQsLTAuNzA3MDUsMC43MDcwNSwwLjcwNzE0LC05LjEwMDM3LDkuMTA0MzEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xOC4xMTE5NSwyNC4xODk4OCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \SpliceDiagramSquare {
          ne = B',
          se = B,
          nw = A',
          nw/style = pullback,
          sw = A,
          east = g,
          east/style = {>->},
          west = f^{*}(g),
          west/style = {>->},
          south = f,
          north = \varepsilon _{g},
        }
        \node  [above left of = nw] (a) {$A$};
        \draw  [->,morphism,bend left] (a) to node {} (ne);
        \draw  [double,morphism,bend right] (a) to node {} (sw);
        \draw  [->,morphism,exists] (a) to node {} (nw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>This then corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\exists _{f}(\mathsf {id}_{A}) \to  g]]></fr:tex> under the adjunction <fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex>. Thus, we define <fr:tex
display="inline"><![CDATA[\mathsf {Img}]]></fr:tex> by the assignment <fr:tex
display="inline"><![CDATA[f \mapsto  \exists _{f}(\mathsf {id}_{A})]]></fr:tex>. This assignment can be trivially extended to a functor: since the category <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex> is a preorder, every morphism <fr:tex
display="inline"><![CDATA[f \to  f']]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex> has to be mapped to the unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f) \to  \mathsf {Img}(f')]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. This morphism must exist. Indeed, it is the lifting of <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)]]></fr:tex> against <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f')}]]></fr:tex> depicted in the following diagram.</fr:p>
    
      
      <fr:figure><fr:resource
hash="447c19ca1a6fbe2ea6dcb411e3c0becc"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0Ni41NjI4NTlwdCcgaGVpZ2h0PScxMjAuNjgwNzU3cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTcuNzA4NTczIDgwLjQ1MzgzOCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUM0QUFBQTJLR0hTOEdob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0dU94LzdQaitXMitNakN6TUlEQVkrdmpQeEgwZjBhbXk4d2dMZ2NERTRnQ0FGc3FDOVVBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1JQUFvQUFBQUFBMmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEeGloR050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCRUFBQUFSQjVhakhkb1pXRmtBQUFCc0FBQUFDMEFBQUEyS2VMVEsyaG9aV0VBQUFIZ0FBQUFId0FBQUNRRkJnRFphRzEwZUFBQUFnQUFBQUFJQUFBQUNBWVlBRjlzYjJOaEFBQUNDQUFBQUFZQUFBQUdBQ0lBQUcxaGVIQUFBQUlRQUFBQUZ3QUFBQ0FBQkFBU2JtRnRaUUFBQWlnQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBQytBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpxMC9sZ3dNekZyTXg0SENqQWdWLy84ek1BQUErd01QZndCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFGOEFKd0Y3QWp3QUVBQUFBUU1HSXljbUp6Y1RQZ0UzTWhZWEJnY0JjZFFHREJZVEF3U2VBeGtlR1NZQkFRUUIzUDVjRVFjSERSQUJ1dzRnQVNBY0RBd0FlTnBqWUdSZ1lBQmlkcmJmVitQNWJiNHlNTE13Z01CajYrTS9rV21XVUNZYklNWEJ3QVRpQVFBbXZBbmpBQUFBZU5wallHUmdZTmI2WThuQXdCTEtFTS9nd1ZqTkFCUkJBVXdBU2lnQzR3QUVWUUFBQWNNQVh3QUFBQUFBSWdBQWVOcGpZR1JnWUdCaUVHUUEwUXhRRWdrQUFBSkdBQmNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9nQUFvQUFBQUFCQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjFVMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM1WjJ4NVpnQUFBV1FBQUFEaUFBQUE1SXZLUWdSb1pXRmtBQUFDU0FBQUFDOEFBQUEyS09MUzcyaG9aV0VBQUFKNEFBQUFIZ0FBQUNRR1F3Sk9hRzEwZUFBQUFwZ0FBQUFJQUFBQUNBWVFBSHRzYjJOaEFBQUNvQUFBQUFZQUFBQUdBSElBQUcxaGVIQUFBQUtvQUFBQUZ3QUFBQ0FBQkFCS2JtRnRaUUFBQXNBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTWFReE0vd0g4cGtoMGtocS9nT0ZBYkQ2RE1VQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZocC8vOUR5UCt6d1h3R0FGV2dCc0lBQUFCNDJoM0t5VTNEUUJpRzRmbG16RC9PNGhrN0hpOVliQmxITm9rSU9UaU1CVUsydUNFa0pEaHlvWUJJVkVBSkhHaUJMcWlBQ2lpQ0xsaUMzc3Q3ZUJqWTg4K1NmL0JQZHMwWWhBWkpCVWxWM2FGSk0wTXlQVVNIMXZWd2JVblYyZHBsemZiL1N6T0ZzcW9yMTFZcldFa2FqVXVOSkltdjgyQVFGWk9ycGIwVm1DY0xZUkt0NHYzWlRqVFppMFlQUVd6MG95SXY5NFB5L3ZqbWo2UUxnZkZCcU9NaUc0N3pwOEQ0d3NQTDkzdG5MK2RGdzJGUHJSVjFOQjFLY082U2Z2TzJ1UUFGWm9DNzZkRTZqRlllWmlkYlFyWHlPZkt3ZndYdGpnUVkrd1hVZVIySEFBQjQybU5nWkdCZ0FHS0RxMHJINC9sdHZqSXdzekNBd0dQcjR6OFI5SDlkNWhDbXkwQXVCd01UU0JRQVE4d0x0UUI0Mm1OZ1pHQmdadmpQQUNSREdLci9mMmM2eWdBVVFRRk1BR3NmQkpZQUFBTlVBQUFDdkFCN0FBQUFBQUJ5QUFCNDJtTmdaR0JnWUdMd1pBRFJERkFTQ1FBQUI3NEFUd0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktKVFR5V2hvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRqYlhGVC9qK1cyK01qQ3pNSURBWSt2alB4SDAvNy9NYkV4M2dWd09CaWFRS0FCaUJneS9BSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBL1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBtbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDOEFBQUEwRThPekgxb1pXRmtBQUFDSUFBQUFDMEFBQUEyS09EUzcyaG9aV0VBQUFKUUFBQUFIZ0FBQUNRRkxBSzRhRzEwZUFBQUFuQUFBQUFLQUFBQUNnWGZBSnBzYjJOaEFBQUNmQUFBQUFnQUFBQUlBRFlBYUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBZ2JtRnRaUUFBQXB3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBZElsRE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaSmoxbjRIeE9ETURneHdEQXlNZkl6dWJ1QmdZaXJBcHFlc3hxcXVwbTVuYk1acWJHWW1Kc2pFZUNXcGxaVmJpNE5LdDRHQmtrM0pVOUZLd1pXR3hWZkJTZEpSaVkyUjZidloxVDJ5bGhIaFZLZ3NYQzVlSmJKUnR3WW9WaGJhUnNpWmNMSndNUU1ESWtBeTBhd0xRTG1rZ2g0MGRaSnVhUHFNSjJBSWhOWFUxSUVOY2psRmNqSEVDMUZSbUpsYjFjRFZUeHJSaWRtWm1pSVdNREJBekdWazVPRmhrazhPYUdLVit4M0p6c3pLQ0xRUUFFYU1qajNqYVkyQmtZR0FBNG4zbER0YngvRFpmR1poWkdFRGdzZlh4bndqNlB3TnpFRE9JeThIQUJLSUFMcXdLZGdBQUFIamFZMkJrWUdCbStNOEFKSU1Za2htU0dZOHpBRVZRQUJNQVJza0M2Z0FBQTFJQUFBSXFBSm9BWXdBQUFBQUFBQUEyQUdoNDJtTmdaR0JnWUdhUVp3RFJERkFTQ1FBQUE3OEFKZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktKclM1V2hvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaW83bGhqUEg4Tmw4Wm1Ga1lRT0N4OWZHZkNQcS9Qak1QMDNFZ2w0T0JDU1FLQUIzd0Nwc0FlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUkFBQW9BQUFBQUJOZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGMy9HTnRZWEFBQUFFOEFBQUFNUUFBQUR3SEZmMTBaMng1WmdBQUFYQUFBQUYzQUFBQnFKVjJCMnRvWldGa0FBQUM2QUFBQUM4QUFBQTJLRlRTNzJob1pXRUFBQU1ZQUFBQUlBQUFBQ1FGblFHYWFHMTBlQUFBQXpnQUFBQU1BQUFBREFjb0FIdHNiMk5oQUFBRFJBQUFBQWdBQUFBSUFHWUExRzFoZUhBQUFBTk1BQUFBR0FBQUFDQUFCZ0JGYm1GdFpRQUFBMlFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFTkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtU21LY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZlFiRGZBQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlxWXhiLzMvSDhnSDAvOW4vL0VGcXdJQ0FLSUZDWWNBQUFCNDJrWFB1MDdjUUJURzhmbG16SGpaaThkNzhYakJZR2ZYOWd3WFpXOUdOdHBGM29VdGtDQlNoQ0tCcUtJVU5Qc0N2QVVWQlczYVBBYzk0aDFTUnFKS0d6S3JGRG5GS2M2L09UOENjdmsrcEN2NlNoYUVnQWx3MjRIZFY3cEVKbjNKYlJtaHhKekZYT1YrVnFJdzk0bjBIY1JLcTd4UVF6aFVJTXNsMS9nK2RTMTNlL04wdkRjRkVrOHhpRWdJa2ZUWTdrQjhDbWxiWEFuUGtXZngvZ2tRUzlQZFVJaFdLNnhXdHIrdU14Ny9QRjgwRjBlZEpWTngrSUVtWE5jMktheEw3K24zRGV2YnVMa050RXFUL3dsYjZ1T0QxYStBbUtGazlQNExiM2doTTdJa3BIRGdjOS84UDhtTHZBaXh0ZzFnWU1XL25Vcy9oSkVvUFRCaUkvVkwrUG5hcHJtV2N6b0UvNUdsd0d3M3lqNmZ0NnhLZys2NTQ5WDFIZWh4eEdKcVBYNnJUM3JOQlBCa05aNDJydTRaVGRXczNodUJsVHVIdGJDYmRycmQ0YzlnM2o0SXFwUUdvUTBFdXE0c1hFeEhaeTJrMGVJTHdCM3V1WTAydFR0VmpBLzZiYWNDTkRvN05WanBocWtXcUtIOUJZNnROVmdBZU5wallHUmdZQUJpdnJXVHl1UDViYjR5TUxNd2dNQmo2K00vRWZSL2ZhWmpUQmVCWEE0R0pwQW9BRUk4Qy93QWVOcGpZR1JnWUdiNHo4REF3SFNNd2VEL0JhWXNCcUFJQ21BR0FHVjNCRHNDeGdBQUFqb0FTd0lvQURBQUFBQUFBR1lBMUhqYVkyQmtZR0JnWm5CaFlHSUFBVVlHTkFBQUIzTUFUSGphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9DQ3hkV0ZnWW1YcUF0aEZHV3dqSjBSQ3FqcjJkL2RoUFBRTlYrZCsyRURORHdYM0s1Z2x2VjlKSmU3QkZWUG1tU2ZpM2pMWExIam5pYUo4bHVTVmo4eWxOSitaSzE3NHlqeVIvRHR6ellyZlRYQ1g2MkNqMmdWam96ODUxNjMzTnZaZDhHcXBtK1MzMXR0NEdLeFJ4NXN5WTllUFo2ZGEzZWlXRFFISGhTc0Rsb2hpSjRsSjdEbEo1K2hZczA5Skx4d2tWeXpSTlAvNnJmUStiUTdwSnlPYkl6ZFJ3eWlMWHZRc1cwV2JYbXJhUDh1aEwvY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQzBBQUFBMktSN1RLMmhvWldFQUFBSGNBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZndBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPTGRMQmZQeHZQYmZHVmdabUVBZ2NmV3gzOGkwOHdUbVd5QUZBY0RFNGdIQUVFb0NwNEFBQUI0Mm1OZ1pHQmdWdnhqQkNRbk1oZ3l5REthTUFCRlVBQVRBRUVhQW00QUFBT1JBQUFCVVFBeEFBQUFBQUFnQUFCNDJtTmdaR0JnWUdMZ1p3RFJERkFTQ1FBQUFoUUFGUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY4IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi41NzcwMTIsLTYwLjU2NjQ3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01NS4xMDUwMTMnIHk9Jy02NC4xODE4MzQnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MC41NjY0NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjQ1OTMyLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYwLjU2NjQ3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy02MC41NjY0Nyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTQuNTIwNDA0JyB5PSctNjQuMTgxODM0Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINDYuNDAzNzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNjUzNzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNS44ODg2Nyw1LjkwMDcxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MC41NjY0NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNjIuNTc3MDEyJyB5PSctNjAuNTY2NDcnPs61PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01OC44MTI5OScgeT0nLTU4LjczNDQyNyc+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjgnIHg9Jy01MC40MTk5MDQnIHk9Jy01OC43MzQ0MjcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTQ3LjcyMTY0OScgeT0nLTU4LjczNDQyNyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDMuNzI2MTc5JyB5PSctNjAuMjAxMTU2Jz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTQxLjAzMTQwNCcgeT0nLTU4LjczNDQyNyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS04LjYwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTUwLjgyNjY3MycgeT0nLTYwLjU2NjQ3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny43MTMzMycgeT0nLTYwLjU2NjQ3Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00My4wNDY3NDYnIHk9Jy02My41NzI5ODcnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNDAuMzUxOTcxJyB5PSctNjAuNTY2NDcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjUwNTU0LTU2LjkwNTVINDcuODA2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTAuNzU1NTQsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNi45NDE3OSwtNjQuOTY3MzIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYwLjU2NjQ3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Mi41NzcwMTInIHk9Jy02MC41NjY0Nyc+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy01MC44MjY2NzMnIHk9Jy02MC41NjY0Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuNzEzMzMnIHk9Jy02MC41NjY0Nyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNDMuMDQ2NzQ2JyB5PSctNjAuNTY2NDcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J004LjIzODEzLTQ4LjY2MjQ2TDUwLjE0NTkyLTYuNzYzMjMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNywwLjcwNzAyLC0wLjcwNzAyLDAuNzA3MTcsNTAuMzIyNzEsLTYuNTg2NDkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \SpliceDiagramSquare {
          nw = A',
          nw/style = pullback,
          sw = A,
          ne = B',
          se = B,
          north = \varepsilon _{\mathsf {Img}(f')},
          east = \mathsf {Img}(f'),
          east/style = {>->},
          south = \mathsf {Img}(f),
          south/style = {>->},
        }
        \draw  [->,morphism,exists] (sw) to (ne);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>We can now extract the components of the unit and the counit from this correspondence.</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
      
  <html:tr>
        
  <html:th>Unit (<fr:tex
display="inline"><![CDATA[\vartheta ]]></fr:tex>)</html:th>

        
  <html:th>Counit (<fr:tex
display="inline"><![CDATA[\zeta ]]></fr:tex>)</html:th>

      </html:tr>

      
  <html:tr>
        
  <html:td>
          <fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be an object in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. The identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}\colon \mathsf {Img}(f)\to \mathsf {Img}(f)]]></fr:tex> is, by definition, the identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}\colon \exists _{f}(\mathsf {id}_{A})\to \mathsf {Img}(f)]]></fr:tex>, which corresponds to the unit <fr:tex
display="inline"><![CDATA[\eta _{\mathsf {id}_{A}}\colon \mathsf {id}_{A}\to f^{*}(\mathsf {Img}(f))]]></fr:tex> of the adjunction <html:span
style="white-space: nowrap"><fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex></html:span>.</fr:p>
          <fr:p>Then since <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)]]></fr:tex> is monic, <fr:tex
display="inline"><![CDATA[\eta _{\mathsf {id}_{A}}]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f)}\eta _{\mathsf {id}_{A}}\colon f\to \mathsf {Img}(f)]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> is the counit of the adjunction <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex>. This defines the component of <fr:tex
display="inline"><![CDATA[\vartheta ]]></fr:tex> at <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. This is precisely the lifting of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> against <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f)}]]></fr:tex>.</fr:p>
          
    
      
      <fr:figure><fr:resource
hash="9412b64af3fb67acab4f1f858195b591"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0Mi41MjA3MjdwdCcgaGVpZ2h0PScxMTguNzcxMjE4cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTUuMDEzODE4IDc5LjE4MDgxMic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUMwQUFBQTJLR0hUQkdob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0dU94LzUzaitXMitNakN6TUlEQVkrc1R6QWo2UHlQVFpUQ1hnNEVKUkFFQUtHNEp3d0FBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9nQUFvQUFBQUFCQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjFVMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM1WjJ4NVpnQUFBV1FBQUFEaUFBQUE1SXZLUWdSb1pXRmtBQUFDU0FBQUFDOEFBQUEyS09MVEEyaG9aV0VBQUFKNEFBQUFIZ0FBQUNRR1F3Sk9hRzEwZUFBQUFwZ0FBQUFJQUFBQUNBWVFBSHRzYjJOaEFBQUNvQUFBQUFZQUFBQUdBSElBQUcxaGVIQUFBQUtvQUFBQUZ3QUFBQ0FBQkFCS2JtRnRaUUFBQXNBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTWFReE0vd0g4cGtoMGtocS9nT0ZBYkQ2RE1VQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZocC8vOUR5UCt6d1h3R0FGV2dCc0lBQUFCNDJoM0t5VTNEUUJpRzRmbG16RC9PNGhrN0hpOVliQmxITm9rSU9UaU1CVUsydUNFa0pEaHlvWUJJVkVBSkhHaUJMcWlBQ2lpQ0xsaUMzc3Q3ZUJqWTg4K1NmL0JQZHMwWWhBWkpCVWxWM2FGSk0wTXlQVVNIMXZWd2JVblYyZHBsemZiL1N6T0ZzcW9yMTFZcldFa2FqVXVOSkltdjgyQVFGWk9ycGIwVm1DY0xZUkt0NHYzWlRqVFppMFlQUVd6MG95SXY5NFB5L3ZqbWo2UUxnZkZCcU9NaUc0N3pwOEQ0d3NQTDkzdG5MK2RGdzJGUHJSVjFOQjFLY082U2Z2TzJ1UUFGWm9DNzZkRTZqRlllWmlkYlFyWHlPZkt3ZndYdGpnUVkrd1hVZVIySEFBQjQybU5nWkdCZ0FHS0RxMHJ6NC9sdHZqSXdzekNBd0dQckU4d0krcjh1Y3dqVFpTQ1hnNEVKSkFvQUVSQUpvd0I0Mm1OZ1pHQmdadmpQQUNSREdLci9mMmM2eWdBVVFRRk1BR3NmQkpZQUFBTlVBQUFDdkFCN0FBQUFBQUJ5QUFCNDJtTmdaR0JnWUdMd1pBRFJERkFTQ1FBQUI3NEFUd0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktKVFQzV2hvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRqYlhGUmZqK1cyK01qQ3pNSURBWStzVHpBajYvMTltTnFhN1FDNEhBeE5JRkFBdlNncXRBSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU4wQUFvQUFBQUFBL1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBtbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDOEFBQUEwRThPekgxb1pXRmtBQUFDSUFBQUFDd0FBQUEyS09EVEEyaG9aV0VBQUFKTUFBQUFIZ0FBQUNRRkxBSzRhRzEwZUFBQUFtd0FBQUFLQUFBQUNnWGZBSnBzYjJOaEFBQUNlQUFBQUFnQUFBQUlBRFlBYUcxaGVIQUFBQUtBQUFBQUZ3QUFBQ0FBQlFBZ2JtRnRaUUFBQXBnQUFBREtBQUFCTXVzSWtlWndiM04wQUFBRFpBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBZElsRE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaSmoxbjRIeE9ETURneHdEQXlNZkl6dWJ1QmdZaXJBcHFlc3hxcXVwbTVuYk1acWJHWW1Kc2pFZUNXcGxaVmJpNE5LdDRHQmtrM0pVOUZLd1pXR3hWZkJTZEpSaVkyUjZidloxVDJ5bGhIaFZLZ3NYQzVlSmJKUnR3WW9WaGJhUnNpWmNMSndNUU1ESWtBeTBhd0xRTG1rZ2g0MGRaSnVhUHFNSjJBSWhOWFUxSUVOY2psRmNqSEVDMUZSbUpsYjFjRFZUeHJSaWRtWm1pSVdNREJBekdWazVPRmhrazhPYUdLVit4M0p6c3pLQ0xRUUFFYU1qajNqYVkyQmtZR0FBNG4zbERzTHgvRFpmR1poWkdFRGdzZlVKWmdUOW40RTVDTXpsWUdBQ1VRRDc0UWhrZU5wallHUmdZR2I0endBa2d4aVNHWklaanpNQVJWQUFFd0JHeVFMcUFBQURVZ0FBQWlvQW1nQmpBQUFBQUFBQUFEWUFhSGphWTJCa1lHQmdacEJuQU5FTVVCSUpBQUFEdndBbUFIamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU3ArYm00T1RxOFBickFuU29hbWt0ZWdpL25SdlEvQUdEdDg5NTl3QUdTOFNoa21ZQngwbWxUZVBQT2FIUmVTSitLdklHYitzR1pHa00zRlc3Q0tuVFBtUFBHWkpHWGtpL2lOeXhoL3ZmVlBmN3AzMTZ0Z1k2OTJsOXR1VDlXM1ZPTFhSK2JBZXJMUCszRm1qeXFjeWZkWDIxMW9WT3RjRmV4cHFidHpwc0hnVVIzRk1ZTWRGTXMrV1U5aGJLc21jZERabzhtOTZrTlNGeGpuOFlxUlI4aFExOUhMVGlsNmxxeWpDbmFiNEFGVXlMa01BQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXOTBuR050WVhBQUFBRTRBQUFBTXdBQUFFUUFld0VnWjJ4NVpnQUFBV3dBQUFGTUFBQUJqUE53SkpOb1pXRmtBQUFDdUFBQUFDOEFBQUEyS0pyUytXaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR053SjFhRzEwZUFBQUF3Z0FBQUFRQUFBQUVBajlBTlpzYjJOaEFBQURHQUFBQUFvQUFBQUtBTlFBaUcxaGVIQUFBQU1rQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQXp3QUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TXVReWMvOEg4cG01R2RIVS9BY0tBd0REN3d6N2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VROEdkSVpjdi8vUjdEKzcvZy8rLzgwc0Zvd0FBRHNod3VWQUhqYVZWRExUc0pRRUoyWlcxb2dXQVNsRmR0VWFXTUxpQkI1dE1CVkVoY1NJeXBxNGtJa1NHVGpqeGcrRFJNU0VxSWY0dGFGNE1XTm1rbE96bU5tY1FZUVJnQXdwUWt3Z0kyRWs1ZyswK1NySVRRSXgxcVdLSTd2VUFJT0hRRFVQVWRXZEMybG9pSjdzbUpoVVBGMVRZeUt0dXU1ZmxCRXp3L2NXZ3NEWDI4aDAxYU80NjQyZFhFcDZ4YVdSZTZKSVJhcmNsT1NUSHk2MkcrRUdCWGlqOFpSM3ExS05KNk5HUm81SllGUzJxSGhaYkZ4L0xDME9XRXQ3d2owZTZQbW1zcG84RElncVJCZkwrSzhMU0VMNXc1UGgwUzd0T01taUNKaHpicmkzUzdmNU5zUnoyb2FCM1dSTWx1TExqNnd5Q3ZWSDNobHBxbGtzdGxNVmcyUkxDb0R3cDBvSHNNMzJCTkMvTU12b2V1cHFLZiswVXJLRjExRXhjQkNGcjFucXBRODQyWDhKYmZ0M25sVFR0NmM5RG1XRm5QTXB1MlF6VmkvOXZtWHpqclh4T3BiaGs5c0NOL3JyRDNyZU5wallHUmdZQUJpbzdtaE4rUDViYjR5TUxNd2dNQmo2eFBNQ1BxL1BqTVAwM0VnbDRPQkNTUUtBQllJQ1lnQWVOcGpZR1JnWU9iK3p3QWs0eG5rR0FTWmVSaUFJaWlBQlFBdXZ3RzBBQUFDVUFBQUFTNEFZd0lnQUI0RFh3QlZBQUFBQUFBT0FJZ0F4Z0FBZU5wallHUmdZR0JoOEdGZ1pnQUJSZ1kwQUFBSWJRQldlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQzBBQUFBMktSN1RQMmhvWldFQUFBSGNBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZndBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPTGRMQmVYeHZQYmZHVmdabUVBZ2NmV0o1aVJhZWFKVERaQWlvT0JDY1FEQUE1c0NJd0FBQUI0Mm1OZ1pHQmdWdnhqQkNRbk1oZ3l5REthTUFCRlVBQVRBRUVhQW00QUFBT1JBQUFCVVFBeEFBQUFBQUFnQUFCNDJtTmdaR0JnWUdMZ1p3RFJERkFTQ1FBQUFoUUFGUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVjQUFvQUFBQUFCZmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjRNR050WVhBQUFBRThBQUFBTXdBQUFFUUR5UVNoWjJ4NVpnQUFBWEFBQUFKSkFBQUN1SE55R29ab1pXRmtBQUFEdkFBQUFDOEFBQUEyS0ZUVEEyaG9aV0VBQUFQc0FBQUFJQUFBQUNRRndnR2JhRzEwZUFBQUJBd0FBQUFRQUFBQUVBbnFBS3RzYjJOaEFBQUVIQUFBQUFvQUFBQUtBY0lBMUcxaGVIQUFBQVFvQUFBQUdBQUFBQ0FBQndCWWJtRnRaUUFBQkVBQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRkVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXFtS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVY5a1p2Z1A1RE16TUlLRUdSRXEvZ09GQVFBT0RpUUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGswcGkzTWwvOC94L0Irai83ais4Zkk3QmFNQUFBREhzTWFnQjQya1dSUDIvVFFCakcvWnlkYytJa1BqZTJ6Mm1jT2swYzI2V1VwSEZTR3lYQlNWTUIvUU10RlNnVlFtcFZwQzRkRUF2aVc4RFNnWldWejhHTytBNk1TRXhkS1pjaXhKMTB3L3ZvcFBmMy9DUklCemRkY2ttK1MxTkpnc3hBVlIxcUs0d3k5TG5EcWNvYnlEQ1JmUm9tVGo5REt1WXhkM1Q0WVJRbWFkaUZUaGo2Q2FjUlBnOE54YWdWdG50clE2QnRoekpZZ3pIV2Jzb3JIZmJFSXlZN1pyYk9aLzZkTWVCemtSc2VZNVdLcCtWclo0c1lWNysvN2k5TkI5YU9IUHJlS21uVHFGZ2dVQTdzVDljbmNrdkZ5VXMzQ29QMi93akw0YjBQU2lzUFNSd2liZDc4eEM5OGswYlNqaVNsT2h6cWlQM2pKRTFTRHd1MkRnUlkrdmROdU9OQmtJUlJSeEFMVWllRGt5ellJaHJ4Q2VtQ2Z1a0h3R2lsMFQ5NlhGSHlaYkptOUM3bkZ5RDNHN0pQbEt2elV0eGNhZ00yMS94aCtmaTlUSUp3VkdwdVFzN3FkNHRlTmJDcTFlNFBkMkt1dXhvaHJxY0NibFFLRmV3UE4yY1ZCSTNwYzREcTFEYktKbEV0RGIzMWxxbm5nYkpWTDBJSmNpSlZRUDZ4WFpPUHd0T2VOQmVtSEc2cEVWVnZieGdsRXpuWkdvU1JVS2VqaXc0UzRVa2dPeGFUcVUyNUU5OE9oSzJGMkZTSWRiZ3E1SXBpYmorSmtqaVp0NXh5M3gxVzNZZno4Um1CWmpLVk1OTnJGWE9xVnFUZ3JCUjVHeE1vVEhWeVpEWHhIelRyN1ZJMnpnOXo1UFhza2FmbXVGajN0Q3JERGVLblJPblZCbmlya3FxU3Z6Z1B2R2NLQnJ1K2Z6UmFLZWgySFpoMnJDSUlNWGJxZkJVWWJHaEwyOHVuTmJPMlJiSlIvRzVnQkhUdGNPK05ySXhMK214YzJBMWV2SW9QaVh3NjNtNGFOVkhISDZMT1dFWUFBQUI0Mm1OZ1pHQmdBT0tBNDhGUDQvbHR2akl3c3pDQXdHUHJFOHdJK3I4KzB6R21pMEF1QndNVFNCUUFMa3dLblFCNDJtTmdaR0JnWnZqUHdNREFkSXpCNFA4RnBuNEdvQWdLWUFFQWFEY0VZUUxHQUFBQ09nQkxBaWdBTUFMQ0FEQUFBQUFBQUdZQTFBRmNBQUI0Mm1OZ1pHQmdZR0VJWjJCaUFBRkdCalFBQUFscEFHQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjE1Mjc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuMDY0NjAyJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01NS4xMDUwMTMnIHk9Jy02NC42Nzk5NjYnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy4yNjM4OSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjQ1OTMyLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuMDY0NjAyJz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01NC41MjA0MDQnIHk9Jy02NC42Nzk5NjYnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjA2NDYwMic+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOS43MDgzMyAwSDQ2LjQwMzc4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjY1Mzc4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTcuMjQxMTIsNS40MDA3MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPs61PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01OC44MTI5OScgeT0nLTU5LjczMDcwNyc+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy01MC40MTk5MDQnIHk9Jy01OS43MzA3MDcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQ3LjcyMTY0OScgeT0nLTU5LjczMDcwNyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNDMuNzI2MTc5JyB5PSctNTkuNzMwNzA3Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTguNjA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwtOC44NTk3MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjA2NDYwMic+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy01MC44MjY2NzMnIHk9Jy02MS4wNjQ2MDInPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ3LjcxMzMzJyB5PSctNjEuMDY0NjAyJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy00My4wNDY3NDYnIHk9Jy02MS4wNjQ2MDInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J004LjIzODEzLTQ4LjY2MjQ2TDUwLjE0NTkyLTYuNzYzMjMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNywwLjcwNzAyLC0wLjcwNzAyLDAuNzA3MTcsNTAuMzIyNzEsLTYuNTg2NDkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTTIxLjY5OTEtMzQuMzE5NDNIMzcuMDM4NTJWLTIxLjQyNTAySDIxLjY5OTFaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC42OTkxLC0yOS4yODYxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjA2NDYwMic+z5E8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTU3Ljc2NjA3MScgeT0nLTYwLjAwNzQ1NSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                nw = A',
                nw/style = pullback,
                sw = A,
                ne = B',
                se = B,
                north = \varepsilon _{\mathsf {Img}(f)},
                east = \mathsf {Img}(f),
                east/style = {>->},
                south = f,
              }
              \draw  [->,morphism,exists] (sw) to node[desc] {$\vartheta _{f}$} (ne);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
        </html:td>

        
  <html:td>
          <fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A\rightarrowtail B]]></fr:tex> be an object in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. Then the identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}_{f}\colon f\to f]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[s\colon \mathsf {id}_{A}\to f^{*}(f)]]></fr:tex> by the universal property of pullbacks.</fr:p>
          <fr:p>This morphism corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\exists _{f}(\mathsf {id}_{A}) \to  f]]></fr:tex> under the adjunction <fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex>, which we take as the component of <fr:tex
display="inline"><![CDATA[\zeta ]]></fr:tex> at <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p>
        </html:td>

      </html:tr>

    </html:table>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>822</fr:anchor><fr:addr
type="machine">#303</fr:addr><fr:route>unstable-303.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has images, then we may define <fr:tex
display="inline"><![CDATA[\exists _{f}\colon \mathsf {Sub}(A)\to \mathsf {Sub}(B)]]></fr:tex> as the following composite:</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Sub}(A) \hookrightarrow  {{\mathcal {C}}_{/{A}}} \xrightarrow {\Sigma _{f}} {{\mathcal {C}}_{/{B}}} \xrightarrow {\mathsf {Img}} \mathsf {Sub}(B)     ]]></fr:tex><fr:p>Let <fr:tex
display="inline"><![CDATA[i_{A}\colon \mathsf {Sub}(A)\hookrightarrow {{\mathcal {C}}_{/{A}}}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[i_{B}\colon \mathsf {Sub}(B)\hookrightarrow {{\mathcal {C}}_{/{B}}}]]></fr:tex> be the inclusion functors. Note that</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Img}\Sigma _{f} \dashv  f^{*}i_{B}     ]]></fr:tex><fr:p>Since <fr:tex
display="inline"><![CDATA[f^{*}i_{B} \cong  i_{A}f^{*}]]></fr:tex> by construction, we have</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Img}\Sigma _{f} \dashv  i_{A}f^{*}     ]]></fr:tex><fr:p>Let <fr:tex
display="inline"><![CDATA[\eta ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> be the unit and counit of this adjunction respectively. Since <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> is a full subcategory of <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>, there is a natural isomorphism <fr:tex
display="inline"><![CDATA[\iota \colon \mathsf {id}_{{{\mathcal {C}}_{/{A}}}}\stackrel {\sim }{\smash {\longrightarrow }\rule {0pt}{0.4ex}}i_{A}]]></fr:tex>. Then we can define <fr:tex
display="inline"><![CDATA[\eta ']]></fr:tex> as follows:</fr:p><fr:tex
display="block"><![CDATA[       \eta ' := \mathsf {id}_{{{\mathcal {C}}_{/{A}}}} \xrightarrow {\eta } i_{A}f^{*}\mathsf {Img}\Sigma _{f}       \xrightarrow {\iota _{f^{*}\mathsf {Img}\Sigma _{f}}} f^{*}\mathsf {Img}\Sigma _{f}       \xrightarrow {f^{*}\mathsf {Img}\Sigma _{f}(\iota )} f^{*}\mathsf {Img}\Sigma _{f}i_{A}     ]]></fr:tex><fr:p>Then <fr:tex
display="inline"><![CDATA[\eta ']]></fr:tex> and <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> form the unit and counit of the adjunction <fr:tex
display="inline"><![CDATA[\mathsf {Img}\Sigma _{f}i_{A} \dashv  f^{*}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>823</fr:anchor><fr:addr
type="user">ct-000Q</fr:addr><fr:route>ct-000Q.xml</fr:route><fr:title
text="Cover-mono factorization"><fr:link
type="local"
href="ct-000M.xml"
addr="ct-000M"
title="Extremal epimorphism">Cover</fr:link>-mono factorization</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">images</fr:link> and equalizers. Then every morphism of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> can be factored as a cover followed by a monomorphism. Moreover, this factorization is unique up to isomorphism in the sense that if <fr:tex
display="inline"><![CDATA[A \twoheadrightarrow  C \rightarrowtail  B]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A \twoheadrightarrow  C' \rightarrowtail  B]]></fr:tex> are both cover-mono factorizations of the same morphism, then <fr:tex
display="inline"><![CDATA[C \cong  C']]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>824</fr:anchor><fr:addr
type="machine">#296</fr:addr><fr:route>unstable-296.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By the construction of images, every morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> can be factored as <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)\vartheta _{f}]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\vartheta ]]></fr:tex> is the unit of the image adjunction. <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)]]></fr:tex> is monic by construction and <fr:tex
display="inline"><![CDATA[\vartheta _{f}]]></fr:tex> is a cover by <fr:ref
addr="ct-000N"
href="ct-000N.xml"
taxon="Lemma" />.</fr:p>

  <fr:p>To show the second half of the lemma, it suffices to show that every cover-mono factorization of a morphism <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is isomorphic to <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)\vartheta _{f}]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[hg]]></fr:tex> be a cover-mono factorization of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. Then by the universal property of adjunction, there is a morphism <fr:tex
display="inline"><![CDATA[s]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[s\vartheta _{f} = g]]></fr:tex>. By the definition of <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>, we also have <fr:tex
display="inline"><![CDATA[hs = \mathsf {Img}(f)]]></fr:tex>. Then, it follows that <fr:tex
display="inline"><![CDATA[s]]></fr:tex> is monic.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="f1814c95b43add0fe5227a5148011755"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE1Mi4wNzM4MzNwdCcgaGVpZ2h0PScxNTQuMDkyODIycHQnIHZpZXdCb3g9Jy03MiAtNzIgMTAxLjM4MjU1NSAxMDIuNzI4NTQ4Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzBBQUFBMktHSFRCR2hvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTR1T3gvNTNqK1cyK01qQ3pNSURBWStzVHpBajZQeVBUWlRDWGc0RUpSQUVBS0c0Snd3QUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzODtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUVlBQW9BQUFBQUJNd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFc5MG5HTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWV3RWdaMng1WmdBQUFXd0FBQUZNQUFBQmpQTndKSk5vWldGa0FBQUN1QUFBQUM4QUFBQTJLSnJTK1dob1pXRUFBQUxvQUFBQUhnQUFBQ1FHTndKMWFHMTBlQUFBQXdnQUFBQVFBQUFBRUFqOUFOWnNiMk5oQUFBREdBQUFBQW9BQUFBS0FOUUFpRzFoZUhBQUFBTWtBQUFBR0FBQUFDQUFDQUJOYm1GdFpRQUFBendBQUFET0FBQUJPQWQxS3Ixd2IzTjBBQUFFREFBQUFBd0FBQUFnQUFNQUFIamFZMkJtc21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcDZNdVF5Yy84SDhwbTVHZEhVL0FjS0F3REQ3d3o3ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVE4R2RJWmN2Ly9SN0QrNy9nLysvODBzRm93QUFEc2h3dVZBSGphVlZETFRzSlFFSjJaVzFvZ1dBU2xGZHRVYVdNTGlCQjV0TUJWRWhjU0l5cHE0a0lrU0dUamp4ZytEUk1TRXFJZjR0YUY0TVdObWtsT3ptTm1jUVlRUmdBd3BRa3dnSTJFazVnKzArU3JJVFFJeDFxV0tJN3ZVQUlPSFFEVVBVZFdkQzJsb2lKN3NtSmhVUEYxVFl5S3R1dTVmbEJFencvY1dnc0RYMjhoMDFhTzQ2NDJkWEVwNnhhV1JlNkpJUmFyY2xPU1RIeTYyRytFR0JYaWo4WlIzcTFLTko2TkdSbzVKWUZTMnFIaFpiRngvTEMwT1dFdDd3ajBlNlBtbXNwbzhESWdxUkJmTCtLOExTRUw1dzVQaDBTN3RPTW1pQ0poemJyaTNTN2Y1TnNSejJvYUIzV1JNbHVMTGo2d3lDdlZIM2hscHFsa3N0bE1WZzJSTENvRHdwMG9Ic00zMkJOQy9NTXZvZXVwcUtmKzBVcktGMTFFeGNCQ0ZyMW5xcFE4NDJYOEpiZnQzbmxUVHQ2YzlEbVdGblBNcHUyUXpWaS85dm1YempyWHhPcGJoazlzQ04vcnJEM3JlTnBqWUdSZ1lBQmlvN21oTitQNWJiNHlNTE13Z01CajZ4UE1DUHEvUGpNUDAzRWdsNE9CQ1NRS0FCWUlDWWdBZU5wallHUmdZT2IrendBazR4bmtHQVNaZVJpQUlpaUFCUUF1dndHMEFBQUNVQUFBQVM0QVl3SWdBQjREWHdCVkFBQUFBQUFPQUlnQXhnQUFlTnBqWUdSZ1lHQmg4R0ZnWmdBQlJnWTBBQUFJYlFCV2VOcE5qRDF2d2pBUWhwK29DVkxEd0lJNk1MUWVPbHRCWVdCaVlXQmlaV0lCN0tJTWNaQWRJaUZWSGZuZFBZd0h6dExwZVQvT1FNa2ZHWS9KbU1UOW1KeEMxSk1MeGt3VGowUjlKUzZaOGMwYldmNHV6aWVyeExrays4UUZIL3drSG9uL203aGt3WDNkdFpkcmI3M2Fkc1o2ZDJwRFdPNnNEMDNuMUZ4WFVXK3NzLzdRVzZPT04yV0dKZ3puVnRXNjBqVnJPbG91WE9teGVCUmJjVXhreDBteUlHL0pManFCUmxJbnJUbWE2aVhmU081aTV4Qi9NdEk1Y3BOdEdPUXF5RDVMVzFISFMwMzlEK3B0TURzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9nQUFvQUFBQUFCQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjFVMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM1WjJ4NVpnQUFBV1FBQUFEaUFBQUE1SXZLUWdSb1pXRmtBQUFDU0FBQUFDOEFBQUEyS09MVEEyaG9aV0VBQUFKNEFBQUFIZ0FBQUNRR1F3Sk9hRzEwZUFBQUFwZ0FBQUFJQUFBQUNBWVFBSHRzYjJOaEFBQUNvQUFBQUFZQUFBQUdBSElBQUcxaGVIQUFBQUtvQUFBQUZ3QUFBQ0FBQkFCS2JtRnRaUUFBQXNBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTWFReE0vd0g4cGtoMGtocS9nT0ZBYkQ2RE1VQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZocC8vOUR5UCt6d1h3R0FGV2dCc0lBQUFCNDJoM0t5VTNEUUJpRzRmbG16RC9PNGhrN0hpOVliQmxITm9rSU9UaU1CVUsydUNFa0pEaHlvWUJJVkVBSkhHaUJMcWlBQ2lpQ0xsaUMzc3Q3ZUJqWTg4K1NmL0JQZHMwWWhBWkpCVWxWM2FGSk0wTXlQVVNIMXZWd2JVblYyZHBsemZiL1N6T0ZzcW9yMTFZcldFa2FqVXVOSkltdjgyQVFGWk9ycGIwVm1DY0xZUkt0NHYzWlRqVFppMFlQUVd6MG95SXY5NFB5L3ZqbWo2UUxnZkZCcU9NaUc0N3pwOEQ0d3NQTDkzdG5MK2RGdzJGUHJSVjFOQjFLY082U2Z2TzJ1UUFGWm9DNzZkRTZqRlllWmlkYlFyWHlPZkt3ZndYdGpnUVkrd1hVZVIySEFBQjQybU5nWkdCZ0FHS0RxMHJ6NC9sdHZqSXdzekNBd0dQckU4d0krcjh1Y3dqVFpTQ1hnNEVKSkFvQUVSQUpvd0I0Mm1OZ1pHQmdadmpQQUNSREdLci9mMmM2eWdBVVFRRk1BR3NmQkpZQUFBTlVBQUFDdkFCN0FBQUFBQUJ5QUFCNDJtTmdaR0JnWUdMd1pBRFJERkFTQ1FBQUI3NEFUd0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVp3QUFvQUFBQUFCOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjRMbU50WVhBQUFBRThBQUFBTlFBQUFFUUFpUVNsWjJ4NVpnQUFBWFFBQUFPUUFBQUVkRmZ2cUZ4b1pXRmtBQUFGQkFBQUFDOEFBQUEyS0ZUVEFXaG9aV0VBQUFVMEFBQUFJQUFBQUNRRnZnR2RhRzEwZUFBQUJWUUFBQUFZQUFBQUdBN1FBVDFzYjJOaEFBQUZiQUFBQUE0QUFBQU9BK2dDaG0xaGVIQUFBQVY4QUFBQUdBQUFBQ0FBQ1FCWWJtRnRaUUFBQlpRQUFBRE5BQUFCT1BOZktxTndiM04wQUFBR1pBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXFtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVY5a1p2Z1A1RE16TUlLRUdSRXEvZ09GQWY5RkRpSUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtNaGlLbVMvKy93OWtwVUZZLzJmL24vakhCS3dXREFBQ1p3d3JBQUFBZU5wRmswdHZHMVVVeCtlY081Nnhaenh6NTNuSHNaM3hZMTZPY01hSkgyT2FUT3c0RHFWcDJqU3Rxb1FBU2dXb0d4YW9DQ0Voa0pENEFvQVFDN2JzK0FyZEYzWE5SK0JEdEJLYmhEc09FWE5uZGM5ZG5OLzUvWThBd3ZIMUFEL0h2NFI5UVFCQ1FaSjFrTHR4TW9NUjg1Z2tzeGJNWUU0Q0tjNjgwUXltL0g3SVBCMkNPSW16YVR3QUhTbU1NaVlsOFB1T0lScjF5bUs3dHdNUXVqRUIycUtVaGgyeW50SUhQdHIwTVhWMWRoQnM1QUFCNDNYRHA5U3lmS1ZjZjFhVTRkZXJWL2ZOL2JHekpISGd0ekdVRXJXQ0lCNjd2NzA1SjEwWnppOGFTUnlGLzVkZ0xkNzhVZXlXUWVBZkN2M3JUWXpnbFpBS3k0S0drMGdyRXQ2eEk4a2VHN0dNQTh3NVpBcEpOaTJPRHg2bjRnL0lITEtFUTBseU1RTG1EWXVuMkhsUitlcWJ3YVhJK3pVWjZGYlQ3RGg1MEdTeU56MWFYQ0JaVVBQb29qZlJTTjNTWFBobFFNQnh4L1ZsMnpWTWlCUC9vRm1WNGR1cnhlQkRnbTUvdldQYnFxK1VFTlRtMmxiNzQ1RUk1NmZQVDJ4NlNDQmtCZ1BEdlBybkpWV2pRSVRlSkY3c1A1cEMxS1lhWndQaDRmVmIvQTVmQzhjRkdXL1pSMW02MGVWS1JiUFp5UE01THovYzNwakRGSGh4VXN5QWl0eFhDcE9wUFlNNHVKRTd6WmdNaTVQbWt6dDN4MVZBQisycXBwQm1LN2ZRVkNUd1ZET1k5ZDRGb3VtTUliSmVmbHFqSmJ0ZEtTdGV4VEpMUDR0SXc0b0JvTXVIL1Fqd2o2dlhuUkdVQm1NdHphWGRScWRqZG5HK1p5RjZXeDVMeGNGR1ZXMkhCOHR0ZHh0eDJXUHEvZS9qQmxYQjFoZ2VhbFFSRlZxV1JWTGxuRWZYYitGditITmxNT1ZSWEJFNkxlQkI1SUc4QlN5a0ZrNTl1SEdhcExkL3ZOS2FGUmxOTVlPWDFwNmxiekt6ZHFmbkQ4eStpRTNOMi9yeXdRYzhnVjRvdHRiczl6dEszbTU3UVBhZFVXcFZQY0NhWXZZKzIzNUtNSElaZVBCRFhRTlpVME1yMHN1aVhhblAxb2ZNU3NWSjJnMWlyMVdxMlZBMm5DMDlibUJGMTVWd3ZUWXc2RHNsMkJoR0RHaTNVZVJ5Ni9vTi9zUjM3RWc0NDFRZWMrUkVXcEh3ZUdaemtrM0dLMUU2RERoeWdWUEUwcUZFY3FYL2dsaHNXa0U5NVRQZ1UrQ0xlV3UzbUF1ZWRUMXQxTmlwTmQ0N3k1OGhLRGFWa2RwK1Z5M0ppaW9CbzlYRTc4OUJwTEpYd25ZVzdIV2FZWFdXbDNkSytPbkJYVjh1TVFEcHNrYWdFUTBmb3JoZEg4TUxHV3RpK2ZrbmtYOHF3dmhlRUR6YVhhL29iaE5nUDNWVVFEU1dUZFlHR1BjVmM3RjJXYmZyRTV6dERyOGVHNUhVT3puNmdvaDVWVC9JSy9laXB4OE5UNUJjNW91T1VlZFIvaGVxeUpMZWVOcGpZR1JnWUFEaUJndlZxZkg4Tmw4Wm1Ga1lRT0N4OVFsbUJQMWZsK2tZMDBVZ2w0T0JDU1FLQUFoVENiNEFlTnBqWUdSZ1lHYjR6OERBd0hTTVFlZi9CYVorQnFBSUNtQURBR2ZkQkY4Q3hnQUFBam9BU3dJNkFDd0NyQUJOQWlnQVNRTENBREFBQUFBQUFHWUExQUZJQWJJQ09nQUFlTnBqWUdSZ1lHQmpDR2RnWWdBQlJnWTBBQUFKbndCaWVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTMEFBb0FBQUFBQlZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwL21OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDV1oyeDVaZ0FBQVdRQUFBSHFBQUFDSFBUL0V6dG9aV0ZrQUFBRFVBQUFBQzhBQUFBMktKblR5V2hvWldFQUFBT0FBQUFBSGdBQUFDUUdNZ0hkYUcxMGVBQUFBNkFBQUFBUUFBQUFFQXRaQUlKc2IyTmhBQUFEc0FBQUFBb0FBQUFLQVdJQXNHMWhlSEFBQUFPOEFBQUFHQUFBQUNBQUNBQTZibUZ0WlFBQUE5UUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVxQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c1k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQm1admdQNURORHBKSFUvQWNLQXdEekFBMUtlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2ak8vLzhEU2NmLy8vOGZBUE1aQUZLNUJwOTQyalhRejJvVFVSUUc4UHZkazduVEpKT1o2S1F6bGFaVDB2eVp0cEtrZElhWnRvc29qWWsxeGJRMlVJSUVnb0lXQkFVMVJoY3Vzb2dMUVZkQ1FWeTRjZWNEdUhIbHFnL2cxb1c0RWg5QmtuaEg2TG1idzhkZC9MN0RPQ3ZNWnZ3bi84R3FiSk94RUVHNGFkbG14dklDUzFTaHVpWFhEMndyQ0t2SXFTSmoyWUd0UStaUjdOVVFldlFGOTBRbUpWQ3p5dlBRbE1Gb1RrRXFhZm9VVjZlemRpcHJwZ2dwNWFTclFZdXYxTjcveVEzNWNScHhZekt5REZwU1FRUStaNmlBWnQ5dmpET0ZOTGloaXloT0dBTDVNeHd4T2NRdXp5WWsrRmZtc0hXMkphV21uM2VGdE9VY3pPdFFIZGpDZ0ZCejRyL1hqSEJCeWMyWGhFcm5POGtQM3FlM2krNlNZYURidTB1anpuNEgvSHI2NXJQcHU2eXU3emdmVC9zRGprcDl2R3dxajk3MGhweHY3SDFyeGdEOWtHOWY0SlJWd1cvdHRFNk1SSHQ3ZjFldnhhSUdNTkdnSjgzQ05RN2owdVF6UFc4WEQybjY2NkpJTUFibXpYNVRrbitQekNBZGVYblJLL0JMcmpSSFlOdEJLTThiQ1pmaHlBSXlyOEFOd3VoWnRtV0hzZzRscnBKSXhCVndIQjgwWG0wMEY0V0YyTXNicS8zQUw0dFlYRldvM0Z4N1hIL3hnYWpqdDU2T08ydXJZaytIeHMrbWYzVnBWbzNTN1FkQWZhdmJYK2lWaDNjNFZ0WXJ2WVVrd0xXSHUwVVBkRHA2UFdqNVJ4UXJGUFVEblJOai93QWQwbHIrQUFCNDJtTmdaR0JnQUdMMnBuczM0L2x0dmpJd3N6Q0F3R1ByRTh3SSt2OUxabTZtdTBBdUJ3TVRTQlFBTE9ZS21nQjQybU5nWkdCZ1p2alBBQ1E1R0ZUK1gyRG1aZ0NLb0FBV0FFcjNBeFVBQUFKMkFBQURBQUFrQXdnQUt3TGJBRE1BQUFBQUFGUUFzQUVPQUFCNDJtTmdaR0JnWUdHd1pHQm1BQUZHQmpRQUFBYVNBRU40MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02My45NzQ1NTgsLTYwLjQ0NzUwMSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuOTc0NTU4JyB5PSctNjAuNDQ3NTAxJz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDgxLjMxNDg3LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuOTc0NTU4JyB5PSctNjAuNDQ3NTAxJz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDAuMCwtNDUuMTc5MTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg1LjM1ODI2LC00NS4xNzkxMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguOTI5MTIsLTQ1LjE3OTExKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYzLjk3NDU1OCcgeT0nLTYwLjQ0NzUwMSc+QTwvdGV4dD4KPHJlY3QgeD0nLTYzLjk3NDU1OCcgeT0nLTU5LjI1MjA0OCcgaGVpZ2h0PScuMzk4NDg0JyB3aWR0aD0nNy40NzE5OTUnLz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzOC43NDc4OCwtODcuODU4MjMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuOTc0NTU4JyB5PSctNjAuNDQ3NTAxJz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0IDBINzYuMjU5MzInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzYuNTA5MzIsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MC4xOTAzOCw0LjE3MjkxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjk3NDU1OCcgeT0nLTYwLjQ0NzUwMSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNi40MDk4Mi02LjQwOTczTDMxLjc3MTctMzEuNzY4OTUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNCwtMC43MDcwNiwwLjcwNzA2LDAuNzA3MTQsMzEuNjgzMywtMzEuNjgwNTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00xMi43NTQ3NS0yNy4yMDYyMkgyOC4wOTQxN1YtMTQuMzExODFIMTIuNzU0NzVaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNS43NTQ3NSwtMjIuMTcyOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My45NzQ1NTgnIHk9Jy02MC40NDc1MDEnPs+RPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01OS4xNjM2MTYnIHk9Jy01OS4zOTAzNTQnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLS4zODQxNy02LjQwOTczQy0zLjAxNDQzLTM3Ljk4NjAyIDguMTYxNjUtNjEuNjk0ODQgMzEuMDkzNTQtNzcuNjEwMzUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC44MjE1LC0wLjU3MDEzLDAuNTcwMTMsMC44MjE1LDMwLjk5MDg0LC03Ny41MzkwOCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lam9pbj0nbWl0ZXInPgogPHBhdGggZD0nTTMuMzk3MTMgMEwuMjUgMS44NzQ5NFYwVi0xLjg3NDk0WicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xLjI2MDEsLTUzLjk3NzM0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjk3NDU1OCcgeT0nLTYwLjQ0NzUwMSc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTIuNDc0MTQtMzIuODgwNjhMNzguNTk3My02Ljc2MzIzJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjcwNzE3LC0wLjcwNywwLjcwNywtMC43MDcxNyw1Mi42NTA5NCwtMzIuNzAzOTIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTcsMC43MDcwMiwtMC43MDcwMiwwLjcwNzE3LDc4Ljc3NDEsLTYuNTg2NDkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTTUwLjU3MDM3LTI2LjkyMjlINzkuMjk4ODlWLTEzLjkyMjlINTAuNTcwMzdaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1My41NzAzNywtMjIuMTcyOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02My45NzQ1NTgnIHk9Jy02MC40NDc1MDEnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTIuMjI0MjE4JyB5PSctNjAuNDQ3NTAxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00OS4xMTA4NzUnIHk9Jy02MC40NDc1MDEnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ0LjQ0NDI5MScgeT0nLTYwLjQ0NzUwMSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Mi45NzMyLTc4LjUwNjY3Qzc3LjE5NjYtNjEuNjk0ODQgODguMzcyNy0zNy45ODYwMiA4NS43ODM5NC02LjkwNzk3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjgyMTUsLTAuNTcwMTMsMC41NzAxMywtMC44MjE1LDUzLjE3ODU5LC03OC4zNjQxNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuMDgzMDEsMC45OTY0OSwtMC45OTY0OSwtMC4wODMwMSw4NS43NjMxOCwtNi42NTg4NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODIuNDY1OSwtNTUuODI0NTQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjMuOTc0NTU4JyB5PSctNjAuNDQ3NTAxJz5oPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J000Mi42NzkxMi01My4yODg3MVYtNzYuNjE1MTknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCw0Mi42NzkxMiwtNTMuNTM4NzEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNDIuNjc5MTIsLTc2Ljg2NTE5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00zNy43OTE5Ni02OC44NTE5NEg0Ny41NjYyOFYtNTkuODM4MDVIMzcuNzkxOTZaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MC43OTE5NiwtNjUuODUxOTQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjMuOTc0NTU4JyB5PSctNjAuNDQ3NTAxJz5zPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    
    \begin {tikzpicture}[diagram,node distance = 3cm]
      \node  (1) {$A$};
      \node  [right = of 1] (2) {$B$};
      \node  [below = 1.5cm of 1] (1') {};
      \node  [below = 1.5cm of 2] (2') {};
      \node  [between = 1' and 2'] (3) {$\underline {A}$};
      \node  [below = 1.5cm of 3] (4) {$C$};
      \draw  [->,morphism] (1) to node {$f$} (2);
      \draw  [cover,morphism] (1) to node[desc] {$\vartheta _{f}$} (3);
      \draw  [cover,morphism,bend right] (1) to node[swap] {$g$} (4);
      \draw  [>->,morphism] (3) to node[desc] {$\mathsf {Img}(f)$} (2);
      \draw  [>->,morphism,bend right] (4) to node[swap] {$h$} (2);
      \draw  [>->,morphism] (3) to node[desc] {$s$} (4);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Since <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is extremal, <fr:tex
display="inline"><![CDATA[s]]></fr:tex> must be an isomorphism.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>825</fr:anchor><fr:addr
type="user">ct-000P</fr:addr><fr:route>ct-000P.xml</fr:route><fr:title
text="Equivalent condition for regular categories">Equivalent condition for <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular categories</fr:link></fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is regular iff it is cartesian and has <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">images</fr:link> that commute with pullbacks, i.e., the following diagram commutes up to isomorphism for any object <fr:tex
display="inline"><![CDATA[f \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="d7848f567449dd029989d612a2f5eab3"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzNy44Mjg0NzNwdCcgaGVpZ2h0PScxMTkuNjk2ODYycHQnIHZpZXdCb3g9Jy03MiAtNzIgOTEuODg1NjQ5IDc5Ljc5NzkwOCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXOTBuR050WVhBQUFBRTRBQUFBTXdBQUFFUUFld0VnWjJ4NVpnQUFBV3dBQUFGTUFBQUJqUE53SkpOb1pXRmtBQUFDdUFBQUFDOEFBQUEyS0pyUzJXaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR053SjFhRzEwZUFBQUF3Z0FBQUFRQUFBQUVBajlBTlpzYjJOaEFBQURHQUFBQUFvQUFBQUtBTlFBaUcxaGVIQUFBQU1rQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQXp3QUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TXVReWMvOEg4cG01R2RIVS9BY0tBd0REN3d6N2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VROEdkSVpjdi8vUjdEKzcvZy8rLzgwc0Zvd0FBRHNod3VWQUhqYVZWRExUc0pRRUoyWlcxb2dXQVNsRmR0VWFXTUxpQkI1dE1CVkVoY1NJeXBxNGtJa1NHVGpqeGcrRFJNU0VxSWY0dGFGNE1XTm1rbE96bU5tY1FZUVJnQXdwUWt3Z0kyRWs1ZyswK1NySVRRSXgxcVdLSTd2VUFJT0hRRFVQVWRXZEMybG9pSjdzbUpoVVBGMVRZeUt0dXU1ZmxCRXp3L2NXZ3NEWDI4aDAxYU80NjQyZFhFcDZ4YVdSZTZKSVJhcmNsT1NUSHk2MkcrRUdCWGlqOFpSM3ExS05KNk5HUm81SllGUzJxSGhaYkZ4L0xDME9XRXQ3d2owZTZQbW1zcG84RElncVJCZkwrSzhMU0VMNXc1UGgwUzd0T01taUNKaHpicmkzUzdmNU5zUnoyb2FCM1dSTWx1TExqNnd5Q3ZWSDNobHBxbGtzdGxNVmcyUkxDb0R3cDBvSHNNMzJCTkMvTU12b2V1cHFLZiswVXJLRjExRXhjQkNGcjFucXBRODQyWDhKYmZ0M25sVFR0NmM5RG1XRm5QTXB1MlF6VmkvOXZtWHpqclh4T3BiaGs5c0NOL3JyRDNyZU5wallHUmdZQUJpbzdsaGt2SDhObDhabUZrWVFPQ3g5ZkhQQ1BxL1BqTVAwM0VnbDRPQkNTUUtBQ0RrQ3FjQWVOcGpZR1JnWU9iK3p3QWs0eG5rR0FTWmVSaUFJaWlBQlFBdXZ3RzBBQUFDVUFBQUFTNEFZd0lnQUI0RFh3QlZBQUFBQUFBT0FJZ0F4Z0FBZU5wallHUmdZR0JoOEdGZ1pnQUJSZ1kwQUFBSWJRQldlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLSlRUdldob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0amJYbFlMeC9EWmZHWmhaR0VEZ3NmWHh6d2o2LzE5bU5xYTdRQzRIQXhOSUZBQTZKZ3ZNQUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmdBQW9BQUFBQUE5UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFVOejdHTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUNnQUFBQXJLQUNIYVJvWldGa0FBQUNCQUFBQUMwQUFBQTJLQTdTNDJob1pXRUFBQUkwQUFBQUh3QUFBQ1FFandHOGFHMTBlQUFBQWxRQUFBQUtBQUFBQ2dSR0FHUnNiMk5oQUFBQ1lBQUFBQWdBQUFBSUFDd0FWbTFoZUhBQUFBSm9BQUFBRndBQUFDQUFCUUFaYm1GdFpRQUFBb0FBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFEVUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtdk1jNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwVFVZTkJrWnZnUDVETkRwSkhVL0FjS0F3RHZrUTBlZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pFajV6OEFZd3N6QUlNN0F3Q3FpcEthdXgyaXVabVp1eDJqRXo4akhLTTRtSk04b3hoZ3NsbXlvS2NQSUtLTm1tQ2JHeUJQbndjamtFcy9QL0kwcktUNWlsYTNUd3REa1ZCNkJ4RC90bGYvK3BRaXlNQUFCSTRNbDBGeE5pTG1NWW16c2ZJeEtwa0JUMVUzVTlCblZ6TTJNeE1UbEdCazF3Q2FLOHNaNk1RWDdDREV6TW9xQzdXR0FtcGowdDNYaEIxOGhGaWF3UFFBVkpDRk1lTnBqWUdSZ1lBRGl6OHlGN2ZIOE5sOFptRmtZUU9DeDlmSFBDUG8vQTFNRE00akx3Y0FFb2dBNk1nclZBQUFBZU5wallHUmdZR2I0ejhEQXdOVEFZTWxneVJqQ0FCUkJBVXdBTzJ3Q1VBQUNnQUFBQVkwQVpBQTVBQUFBQUFBQUFDd0FWbmphWTJCa1lHQmdacEJnQU5FTVVCSUpBQUFERUFBZkFIamFSWXd4YjhJd0VJVy9pQVNKZE9oU2RXQUFEOHhXb2pCM1lXQmlaV0lCYktJTWNaQVRJaUdoanYzZFBZd2xibmo2N3IxM0IrVDhrdkNjaE0rZ3owbkpaSHR4eGdkZmthZXlMU1BuekZreElVbG40aXo0aVp4S2NvaWM4YzBsOGxUOFIrU2NOWCticnIzZUJ1dlZyalBXdTNQcnkySnZmZDkwVHBXNkNQdldPdXVQZ3pYcWRGZG1iUHF4YmxXbEMxMnhvYVBseW8wQmkwZXhFOGNFZHB3bDg1UVU3SVBUMDBqcXBGV2l4WDNuVzhsZDZCekRKeU9kRTNkUnd5aFh2V2d0YlVVVkxqWFZQMk05THc4QUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaUU5eUJtTnRZWEFBQUFFOEFBQUFLUUFBQURRQURBQ1daMng1WmdBQUFXZ0FBQUN5QUFBQXVMVzFUNVZvWldGa0FBQUNIQUFBQUM4QUFBQTJLS3JUbldob1pXRUFBQUpNQUFBQUhnQUFBQ1FGU1A5QWFHMTBlQUFBQW13QUFBQUlBQUFBQ0FVM0FBbHNiMk5oQUFBQ2RBQUFBQVlBQUFBR0FGd0FBRzFoZUhBQUFBSjhBQUFBRndBQUFDQUFCQUE1Ym1GdFpRQUFBcFFBQUFEVEFBQUJQcTgzZGVGd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtbXMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBabkJtbHZxanljREFMTVY4SFZYTi8vOE1EQUQyZnc1RUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ1VnRFFMRUlMNHp2Ly9ROGovKzhCOEJnQlN3UWFmQUFBQWVOcGpZR1RnL1ArY1NabnBNb001QTRNcUd6c0lLcW1wcTlrem1wbWJnUWt4Y1RaK1JqNUdkaloxY3p0R2N6VjJJQk9JNUJpQlBLQThXQW5qSDBZVEJYMnYrS2dNUm1aeEZzbFFsVUQyNEh3NVl5Wm1jUlV1SFFGdVJuWnVWU1ltTzc5NFJRMGpScVkwZDJOWENYNTJmbjVlZnM2RndpWUtzb2FzRllWYThYekp1WG9tekVZc2pKS2E2Z2F1ZkJLTVRKejh3b0d5NWt5TUxrYjJDenlLc3hnWmRWVkZPTGc0MkJnWkdSZ0E1VXdiUEFBQWVOcGpZR1JnWUFEaTVEZjFrdkg4Tmw4Wm1Ga1lRT0N4OWZIUENQci9jMllacHN0QUxnY0RFMGdVQUVxOURDUUFlTnBqWUdSZ1lKYjZvd2trWlJnNC8vOWdVbVlBaXFBQUpnQlc2UU9MQUFBREhBQUFBaHNBQ1FBQUFBQUFYQUFBZU5wallHUmdZR0Jpc0dBQTBReFFFZ2tBQUFZVkFENEFlTnBOanJGcXd6QVFoajlUeDFBbmtLa2RPaFJOR1lXTjh3Q0ZESm15Wml3a2tRZ09XQTZTWS9CUzhnQjk2RjRVRFQzQjhlbS83NFNBa2g4eUhwV3hqUDFST1lYY25qeGp6bHZpUW81S1hQTEJpaGV5L0ZXU1Q3NFM1eXo0VGp6am5VdmlRdko3NHBJMXY1dSt1OTRHNjlXdU45YTdVeGVtdXRwYkg5cmVxVnBYejJCcm5mV0h3UnAxbkpRWjJ6Q2VPOVhvU2pkczZPbTRjbVBBNHVWbk8wbE1aTWRKWm9HSm1vcDl6QUt0ekoxNE5WclMvOFpXREJldFEzek5pSFdVbVJJYVpTOUlQNHV2YU9LdXB2a0RDVkV4RXdCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoWGQwZzJOdFlYQUFBQUU0QUFBQU13QUFBRVFBZGdFeVoyeDVaZ0FBQVd3QUFBRTZBQUFCVUNpQ2IyZG9aV0ZrQUFBQ3FBQUFBQzhBQUFBMko3alRxR2hvWldFQUFBTFlBQUFBSHdBQUFDUUZOd0ZnYUcxMGVBQUFBdmdBQUFBT0FBQUFEZ2JFQUlGc2IyTmhBQUFEQ0FBQUFBb0FBQUFLQVBvQWhtMWhlSEFBQUFNVUFBQUFHQUFBQUNBQUJ3QXlibUZ0WlFBQUF5d0FBQURUQUFBQlBxa3JkZHR3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1VbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvR001UXljLzRIOHBrNUdkSFUvQWNLQXdDNmFnenFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1U0NHWklZU3YvL1I3RCtyL3UvNEg4ZldDMFlBQUR1aGd1aUFIamFQWTZ4VHNKUUFFWGZmVlVhSFFxdkRUVUlGZ3RDb1FZcUpmQ0NHZ2l4RVRFR0dqVEI2S0k0cUluT2F0VE53ZEZmY0RYeEU1ZzcrZ082T0RtNHVvTFBHRTN1Y3U0ZDdpRWdoZkVIeHZTTkxCRUN1UWhMZ1d4ZzVqOENRMW1MRytCMWNESC9KdnREcm83WGNLTFhhSFZBNDdKdUwzcWJLVFVOZW5Qc1huamh0U3R6dlFQTVJ0UkNvN0NSWEpGd2ZjYjM2Rk12bGdOdE95bDdVb3RNTXlPanRkemQyd2trODl1VmVVcjlpbGxTVkJhZU1zeG1zM3NweFFnaGxPeU12L0JKQXhJaENVSTBWdjh6RXliUk5OT2lPdGVyUWs1VzhPajBrKzE5S3AxM3k1N3ErOWFxZXlCSi9aTE5hVEI2V1loQnVqODZ2YU93VkVjVUQrOGVoVDhZQ00yYytBSHBpWjhoQXFJS1lPbUtnblFSbkpWWlNIZXJuR0c0WlIzYWRRYytuVHRwQWNHb1ZqTGphTmJRSHoybk1ud1orVytuZEVCU0FBQjQybU5nWkdCZ0FPS2VUN3J0OGZ3Mlh4bVlXUmhBNExIMThjOEkrdjhMSmkybXUwQXVCd01UU0JRQVdMQU1od0I0Mm1OZ1pHQmc1dnpQd01EQVpNR2d5NkRDK0o4QktJSUNtQUUvWUFLY0FBSXFBQUFDT0FBdEFoQUFWQUJTQUFBQUFBQUFBRklBaGdDb0FBQjQybU5nWkdCZ1lHRXdaR0JpQUFGR0JqUUFBQVd6QURwNDJrMk9zV3JETUJDR1AxUGJVTGZRcVIwNkZFMFpoWTM3QUlVTW1iSm1MQ1NSTUM1WURwSmo4Rkw2QUhub1hCUU52WU9mVC8vOWR3aW8rQ1hqVmhrdlVXK1ZVOHJyemdWUHZDWXVwVlhpaW5kV1BKRGxqK0o4OEpVNDU1bnZ4QVZ2L0NRdXhmOUxYUEhKWlQwT3AvTmt2ZHFPeG5wM0hFSm82cDMxb1IrZGFuUjlOemJXV2IrZnJGR0hSWm01RDNNM3FGYlh1bVhOeU1DSk14TVdMei9iaW1NaU80NHlDOUlOTmJ2b0JYcVpPOGsxYUhIL0p6YVNjREcxajllTXBBNHNvb1paOW9Kb0ozbEZHM2MxN1JYK0NERDdBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQzBBQUFBMktlTFN2MmhvWldFQUFBSkFBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbUFBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDYUFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKd0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGlXdWs5VytQNWJiNHlNTE13Z01CajYrT2ZrV21XVU1ZN1FJcURnUW5FQXdBMUxRcWlBQUFBZU5wallHUmdZTmI2WThuQXdCTEswTWZRejVUTUFCUkJBVXdBVW9BRFFnQUVWUUFBQXZJQWpnQUFBQUFBVkFBQWVOcGpZR1JnWUdCaU1HVUEwUXhRRWdrQUFBWEtBRHNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVQ4QUFvQUFBQUFCYndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVcDFJMk50WVhBQUFBRTRBQUFBTlFBQUFFUUFWd0QvWjJ4NVpnQUFBWEFBQUFJbkFBQUNlSVl3N2hob1pXRmtBQUFEbUFBQUFDNEFBQUEyS09mUzQyaG9aV0VBQUFQSUFBQUFIZ0FBQUNRR2xnSkthRzEwZUFBQUErZ0FBQUFVQUFBQUZBNDdBUjFzYjJOaEFBQUQvQUFBQUF3QUFBQU1BUFFCc20xaGVIQUFBQVFJQUFBQUdBQUFBQ0FBQ1FCQ2JtRnRaUUFBQkNBQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRThBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzRTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWjBoalp2Z1A1RE5EcEpIVS9BY0tBd0QxZ3cxZGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VUMEdad1kwdjcvQjdNY1Fhei9sLzRmL0Q4UHJCWU1BT0c2QzFBQUFBQjQya1dTeldzVFFSakc1NW1aem1TVHVMdlpKTE1tMnFTYmpidHFQNktKM2RqWXhyWVdXaEpyYlh1b0ZTRVhFU29GQlJFRXY2aDQwSXNuRHg2ODlDQVVieDZGM3ZRZjBKNFUvdzF2YmVLc0lGNW01bjBmZVBrOXo3d0U1TnFBVUlNUmtpYkVnSkNWTUdpaURWZFI5Ri93NHprT2lXZERvNXpTZzhORmx4V1p6VDdIRnlHRWt0Wmd3R2JvVDlJZ0VTRk5STTI2Y3JNNTFhaXJmRTdXSUNjd3FVZTEwUXc5Q3lKZlFzTlZyZ210aUxDTmhoWThkb0JIeVlLWm9EZlZhTnJPdFdaZUpnVnNZNnlJUXYvWFdsSlFQNUVTZ0RXMGRTUE5ZQ1hHTHUxQ25udE1seFRTbWFQWFdaT244bURnU0xLTUJES0pqOCtkbEpGTFVXYm9tblBZbG1Sbjk3RkNDQ09kd1NIYnBQdkVJK05rU2hObm0xRlFneStDeVBWSzBHUlNuMEtqU2kvdXFTZ2JNMFpCNkFkQ3NuOXZKdFNYVnh5R1hURExjRXc4dkgwUGJLZTNkZ3QwMlZsLzBuOXdrbWFPVFEzdjdXMDlCWjFjZmwrMmgrNS82TzB3dEpkK2RKRytUa2VVRkdDOElrSFhweGZ1T01uVmk5MDVzODI0cngwNFdHRGI4OTRpaDZtT1B0SHRsVnFIOXI5TEhUaElkMUNqZCtrM01xc0xGbU5xNGtvUVI2bGNKYVFxNjUrN3pQNzZpV0Yxdng3bjdRZGhFRFcxVTVOYWFFUktoTmh0MmR3dUduUG5UN2VBYWo3UTBaWXR5NnA2YkhqQ3VscWlXV3ZWeXB0cTNqOHpEZmhLNjNiSnNoeW5sRXdVZTdHTXQvMnZuY3pzaGR3VkZ2aWxFVm9WWWNxZzROMzh1OThiVEZ2YjJEd1JCcWVxL3lVVWd2RTN2SktBWHAwLzhQeGVld0I0Mm1OZ1pHQmdBR0xOd3p2SzQvbHR2akl3c3pDQXdHUHI0NThSOUg4RzVraG1FSmVEZ1FsRUFRQS9QUXJjQUFCNDJtTmdaR0JnWnZqUEFDUkxHS3orWDJDT1pBQ0tvQUJXQUYxSUErWUFBQUxHQUFBQ1Z3Qk9BM0FBT2dOMEFFb0NPZ0JMQUFBQUFBQWVBSFlBMWdFOGVOcGpZR1JnWUdCbGNHUmdaZ0FCUmdZMEFBQUhkUUJNZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3MxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5MTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTYuOTE0MTUxLC02MC40NDc1MDEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOC4xMjI3NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTYuOTE0MTUxLC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU2LjkxNDE1MScgeT0nLTYwLjQ0NzUwMSc+QzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNTEuNjY4NTI5JyB5PSctNTguNjQ4Njc0Jz4vQjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNy43MjI5MywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01Ni45MTQxNTEnIHk9Jy02MC40NDc1MDEnPkM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUxLjY2ODUyOScgeT0nLTU4LjY0ODY3NCc+Lzx0c3BhbiB4PSctNDguMDE1NTQxJz5BPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOS45NjUzVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMi4xMjg1NCwtMzEuMDYzODcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ni45MTQxNTEsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNTYuOTE0MTUxJyB5PSctNjAuNDQ3NTAxJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01Mi4yNDc1NjYnIHk9Jy02My40NTQwMTgnPuKIlzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MS4wMjg3NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTYuOTE0MTUxLC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU2LjkxNDE1MScgeT0nLTYwLjQ0NzUwMSc+U3ViPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy00MS4wODQ1OTUnIHk9Jy02MC40NDc1MDEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM3LjIxMDIyMicgeT0nLTYwLjQ0NzUwMSc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjkuMTUzNjEzJyB5PSctNjAuNDQ3NTAxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQxLjMyMjE0LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTYuOTE0MTUxLC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU2LjkxNDE1MScgeT0nLTYwLjQ0NzUwMSc+U3ViPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy00MS4wODQ1OTUnIHk9Jy02MC40NDc1MDEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM3LjIxMDIyMicgeT0nLTYwLjQ0NzUwMSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjkuNzM4MjIzJyB5PSctNjAuNDQ3NTAxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMi42NzgzIDBIMzUuOTczMicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzNi4yMjMyLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTguNjc4NTQsNC4xNzI5MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01Ni45MTQxNTEnIHk9Jy02MC40NDc1MDEnPkltZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS04LjkwOTczVi00Ny40OTU3NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ3Ljc0NTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMzAuMjAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ni45MTQxNTEsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNTYuOTE0MTUxJyB5PSctNjAuNDQ3NTAxJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01Mi4yNDc1NjYnIHk9Jy02My40NTQwMTgnPuKIlzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTIuMjc4NDctNTYuOTA1NUgzNi4yNjY2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM2LjUxNjYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE4LjYyNTM0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01Ni45MTQxNTEnIHk9Jy02MC40NDc1MDEnPkltZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = {{\mathcal {C}}_{/{B}}},
    sw = {{\mathcal {C}}_{/{A}}},
    ne = \mathsf {Sub}(B),
    se = \mathsf {Sub}(A),
    north = \mathsf {Img},
    south = \mathsf {Img},
    west = f^{*},
    east = f^{*},
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>826</fr:anchor><fr:addr
type="machine">#299</fr:addr><fr:route>unstable-299.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>827</fr:anchor><fr:addr
type="machine">#297</fr:addr><fr:route>unstable-297.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a cartesian category with images that commute with pullbacks.
      Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be a morphism and <fr:tex
display="inline"><![CDATA[g\colon B'\twoheadrightarrow B]]></fr:tex> be a cover.
      Then note that <fr:tex
display="inline"><![CDATA[\mathsf {Img}(g)]]></fr:tex> is an isomorphism.
      Since images commute with pullbacks by hypothesis, we can form the following diagram.</fr:p>
    
      
      <fr:figure><fr:resource
hash="fe831617b13b46498327edb3e5b9e92b"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIxMC4zODc1MjdwdCcgaGVpZ2h0PSc5Ny45OTk5NXB0JyB2aWV3Qm94PSctNzIgLTcyIDE0MC4yNTgzNTEgNjUuMzMzMyc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXOTBuR050WVhBQUFBRTRBQUFBTXdBQUFFUUFld0VnWjJ4NVpnQUFBV3dBQUFGTUFBQUJqUE53SkpOb1pXRmtBQUFDdUFBQUFDOEFBQUEyS0pyUzVXaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR053SjFhRzEwZUFBQUF3Z0FBQUFRQUFBQUVBajlBTlpzYjJOaEFBQURHQUFBQUFvQUFBQUtBTlFBaUcxaGVIQUFBQU1rQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQXp3QUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TXVReWMvOEg4cG01R2RIVS9BY0tBd0REN3d6N2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VROEdkSVpjdi8vUjdEKzcvZy8rLzgwc0Zvd0FBRHNod3VWQUhqYVZWRExUc0pRRUoyWlcxb2dXQVNsRmR0VWFXTUxpQkI1dE1CVkVoY1NJeXBxNGtJa1NHVGpqeGcrRFJNU0VxSWY0dGFGNE1XTm1rbE96bU5tY1FZUVJnQXdwUWt3Z0kyRWs1ZyswK1NySVRRSXgxcVdLSTd2VUFJT0hRRFVQVWRXZEMybG9pSjdzbUpoVVBGMVRZeUt0dXU1ZmxCRXp3L2NXZ3NEWDI4aDAxYU80NjQyZFhFcDZ4YVdSZTZKSVJhcmNsT1NUSHk2MkcrRUdCWGlqOFpSM3ExS05KNk5HUm81SllGUzJxSGhaYkZ4L0xDME9XRXQ3d2owZTZQbW1zcG84RElncVJCZkwrSzhMU0VMNXc1UGgwUzd0T01taUNKaHpicmkzUzdmNU5zUnoyb2FCM1dSTWx1TExqNnd5Q3ZWSDNobHBxbGtzdGxNVmcyUkxDb0R3cDBvSHNNMzJCTkMvTU12b2V1cHFLZiswVXJLRjExRXhjQkNGcjFucXBRODQyWDhKYmZ0M25sVFR0NmM5RG1XRm5QTXB1MlF6VmkvOXZtWHpqclh4T3BiaGs5c0NOL3JyRDNyZU5wallHUmdZQUJpbzdsaGpQSDhObDhabUZrWVFPQ3g5ZkdmQ1BxL1BqTVAwM0VnbDRPQkNTUUtBQjN3Q3BzQWVOcGpZR1JnWU9iK3p3QWs0eG5rR0FTWmVSaUFJaWlBQlFBdXZ3RzBBQUFDVUFBQUFTNEFZd0lnQUI0RFh3QlZBQUFBQUFBT0FJZ0F4Z0FBZU5wallHUmdZR0JoOEdGZ1pnQUJSZ1kwQUFBSWJRQldlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBL1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBtbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDOEFBQUEwRThPekgxb1pXRmtBQUFDSUFBQUFDMEFBQUEyS09EUzcyaG9aV0VBQUFKUUFBQUFIZ0FBQUNRRkxBSzRhRzEwZUFBQUFuQUFBQUFLQUFBQUNnWGZBSnBzYjJOaEFBQUNmQUFBQUFnQUFBQUlBRFlBYUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBZ2JtRnRaUUFBQXB3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBZElsRE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaSmoxbjRIeE9ETURneHdEQXlNZkl6dWJ1QmdZaXJBcHFlc3hxcXVwbTVuYk1acWJHWW1Kc2pFZUNXcGxaVmJpNE5LdDRHQmtrM0pVOUZLd1pXR3hWZkJTZEpSaVkyUjZidloxVDJ5bGhIaFZLZ3NYQzVlSmJKUnR3WW9WaGJhUnNpWmNMSndNUU1ESWtBeTBhd0xRTG1rZ2g0MGRaSnVhUHFNSjJBSWhOWFUxSUVOY2psRmNqSEVDMUZSbUpsYjFjRFZUeHJSaWRtWm1pSVdNREJBekdWazVPRmhrazhPYUdLVit4M0p6c3pLQ0xRUUFFYU1qajNqYVkyQmtZR0FBNG4zbER0YngvRFpmR1poWkdFRGdzZlh4bndqNlB3TnpFRE9JeThIQUJLSUFMcXdLZGdBQUFIamFZMkJrWUdCbStNOEFKSU1Za2htU0dZOHpBRVZRQUJNQVJza0M2Z0FBQTFJQUFBSXFBSm9BWXdBQUFBQUFBQUEyQUdoNDJtTmdaR0JnWUdhUVp3RFJERkFTQ1FBQUE3OEFKZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUUwQUFBQmdxb1ppT1dOdFlYQUFBQUZFQUFBQU13QUFBRHllTldTbFoyeDVaZ0FBQVhnQUFBQ29BQUFBc05GYzhJdG9aV0ZrQUFBQ0lBQUFBQzBBQUFBMktSN1RLMmhvWldFQUFBSlFBQUFBSGdBQUFDUUdsdi9rYUcxMGVBQUFBbkFBQUFBTUFBQUFEQWh6QUlCc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURnQVdHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWpibUZ0WlFBQUFwd0FBQURPQUFBQk9CTi9LcnR3YjNOMEFBQURiQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c2c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFBQkJnWUhHRHVsdUN5ZGdVM0o1b0VCcytJZkl3WUdaa1htYzBCaFJvVHEvLzhaR0FBMTN3Ky9BQUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFabVJnVXJKNVlQRC9Qd01EaEw1N1ZQNFNXQlVRQUFDc0JBblhBSGphWTJCazhHY29aM1ptN0dSUVpHQmc1R05rMTJOV0I1SWliT3hzYXVwMmpPWnl6T0pBMHNUTTNFd01xQ28xd2pveElNemN3NStaalllWmw1RXhKY0ltSVNqTTFDT0FtWTJibVk4eEliS0hoY25lMzVxUkpjbWFSNWFSa1ZjR1NZQmJEaWpBd01oZ3lLRE9hTUprdzhBSHRJK1pUWTlSM1Z3WVpBK2p1QmlqNWtGMkFUa20xbllXQ1ZrSlpVWW14c2YvSWtTWWVia0VHSGZ6S1RJeXlrbHlNQUFBWS9FWW1IamFZMkJrWUdBQTRwdlROUVhqK1cyK01qQ3pNSURBWSt2alA1RnA1b2xNTmtDS2c0RUp4QU1BSSs4SjZ3QUFBSGphWTJCa1lHQlcvR01FSkNjeUdETElNanN6QUVWUUFETUFRbUFDZ0FBQUE1RUFBQU9SQUU4QlVRQXhBQUFBQUFBNEFGaDQybU5nWkdCZ1lHWlFZZ0RSREZBU0NRQUFCQW9BS1FCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFQQUFBb0FBQUFBQkV3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wbTJOdFlYQUFBQUU0QUFBQU1nQUFBRHdBWkFCeVoyeDVaZ0FBQVd3QUFBRDRBQUFCR0pKQnA3Vm9aV0ZrQUFBQ1pBQUFBQzBBQUFBMktNYlM4R2hvWldFQUFBS1VBQUFBSGdBQUFDUUdnZ0xRYUcxMGVBQUFBclFBQUFBUUFBQUFFQW5uQVFWc2IyTmhBQUFDeEFBQUFBb0FBQUFLQUx3QVlHMWhlSEFBQUFMUUFBQUFHQUFBQUNBQUJ3QWNibUZ0WlFBQUF1Z0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQUR0QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1OZ3lNL3dIOHBraDBraHEvZ09GQWMyQ0RNNEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEthakxZL3Y4UDVHdUE2UDgzL3g4RHF3SUNBSXl6Q05BQUFIamFZMkJrS1BuUHlOakF6TUFneGNEQUtDNG13czdHejhqR3ppWUdaUEl6cXFrRG9ibWFQYU1aWXc0dk83dWpGYnNsTTJOWUdoYzdiNnNwSDdjcUU1TXVueGt6QXlPVEFKdEpqa0Roc2Q2ZnNad0NUSXhKdFlvS3RjbEZ6YXBOUUNNWlBJRG1oMERNRndhYUtpN0dMc0xHenNlb1ptNWl6MmpIYUs3SHFLNW1hbVllMDJJR01sQlR5U3hQbXBHWlB5U0drYm5RalpPUmpaa0JZbHJVUW9mRVpDWXVaaFpCbi9jTGp6eTE0bUxqWkdJQUFpWUdUNFl5Wmd2R2JnWnVCbkdnZFlwc2FpWm00b3BtWWtCTGtOak1RbjlqZVNVbGVaaVc4Z0RKdjlGQWtwZHBNVkNFTVlLUlE0V0RFVVE4Z0xNWUdBQU5NQ3dSZU5wallHUmdZQUJpOWFOdDF2SDhObDhabUZrWVFPQ3g5ZkdmQ1BvL0k3TUZNNGpMd2NBRW9nQXNCUXBhQUFBQWVOcGpZR1JnWUdiNHp3QWtteGc4R0R5WkxSaUFJaWlBQlFBOGR3SmFBQUFDMHdBQUFja0FkQUhKQUVnRGdnQkpBQUFBQUFBd0FHQUFqQUFBZU5wallHUmdZR0Joa0daZ1lnQUJSZ1kwQUFBRGpRQWtlTm85akRHcndqQVVoYjlpRmUwYkhBU0hOMGp3QjRSS0g3aTRPVGk1T3J6Tm1pQWRta3BhaXk3aVQvYzJCRy9nOE4xenpnMlE4U0pobUlSNTBHRlNlZlBJWTM1WVJKNkl2NHFjOGN1YUVVazZFMmZGTG5MS2xQL0lZNWFVa1NmaVB5Sm4vUEhlTi9YdDNsbXZqbzJ4M2wxcXZ6MVozMWFOVXh1ZEQrdkJPdXZQblRXcWZDclRWMjEvclZXaGMxMndwNkhteHAwT2kwZHhGTWNFZGx3azgydzVoYjJsa3N4Slo0TW0vNllIU1Yxb25NTXZSaG9sVDFGREx6ZXQ2Rlc2aWlMY2FZb1BXS3d1U3dBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUlFBQW9BQUFBQUJPUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFlGMVFHTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQzZaMng1WmdBQUFXUUFBQUdTQUFBQnZHRTBiejlvWldGa0FBQUMrQUFBQUM4QUFBQTJLT0xTN21ob1pXRUFBQU1vQUFBQUhnQUFBQ1FHTFFKUGFHMTBlQUFBQTBnQUFBQU1BQUFBREFqZEFPQnNiMk5oQUFBRFZBQUFBQWdBQUFBSUFISUEzbTFoZUhBQUFBTmNBQUFBR0FBQUFDQUFCZ0JLYm1GdFpRQUFBM1FBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFFUkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtK3NJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUk1ZMGhuWnZnUDVETkRwSkhVL0FjS0F3QUdoQTJ4ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy84RHliVC8vLy9QQnZNWkFGV3hCc040MmlXUFFXN1RRQmlGNTgyNDQ4U0pQWFpzajkyUWhHYmMyRTJWeEZIYzJpcFVObEJWUkRSSWJYZElDS2xDc0NpdzdJbzFHMWgweDVwYndBVjZBZzdCSVpCYVlxci9MWDdwZll2M0VaRFBkMU42UTMrVEpTRmdBbHkzb1BNNEtaSEp3T082ZklnU1JWNGhMeUllNysvbFFWYi8vMDhHRnFJNGlmTWlUcUYwTHBEbDB0TzVqajhIWnRQcGRwNU8xVXVHc2IvTFBGOVlibjk3dytuMG5OWXIwL1hFRzR0clljT016blplckJHNXk5QWUyTUx0QmtZNy9HUjZEYWJoMiszUFVoMk91eG1GbWluRkVtZG82S0EwOTZ2TEg1ZVB3RTJ2aWRQaDFwN3RwQnEySnpYQ0U2dEJFZHJWTmZobWk0RVFRc203dXduOWloc3lJMGUxNVhvMVQxRTdMcVIvN3loTFdtRnRQa055TDdlUVFWNE00T3RGWHFQcnlvSS9RRkhXb1Y4K2V0Y2YwdjFXcG1HMGtJWk4xVFNvbm9jODdLd1dKKzhwTzNZNnB4ZnF5YWFqWFBmN0ZMNFdISTZYc3QrakIxczd4MzJyaWF2YjFjbVNObGs3N1krNm90RVRHeFF3NXZQZWhUMmllSDMrZHVXS1oreUJTZ0RmK3Z2TGlMalNNSS9TcStIakNaRDBoU0QvQU5kZlBSZ0FBSGphWTJCa1lHQUE0b2ErL2RMeC9EWmZHWmhaR0VEZ3NmWHhud2o2dnc1ekNOTmxJSmVEZ1Fra0NnQkR1Z3V1QUhqYVkyQmtZR0JtK004QUpFTVlVdjkvWnpyS0FCUkJBY3dBYVNZRWdRQUFBMVFBQUFLOEFIc0N6UUJsQUFBQUFBQnlBTjU0Mm1OZ1pHQmdZR2J3WkdCaUFBRkdCalFBQUFmd0FGRjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5vQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDMEFBQUEyS2VMU3kyaG9aV0VBQUFKQUFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFtQUFBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNhQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUp3QUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9nQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFdBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaVd1azljK1A1YmI0eU1MTXdnTUJqNitNL2tXbVdVTVk3UUlxRGdRbkVBd0F5T1FxV0FBQUFlTnBqWUdSZ1lOYjZZOG5Bd0JMSzBNZlF6NVRNQUJSQkFVd0FVb0FEUWdBRVZRQUFBdklBamdBQUFBQUFWQUFBZU5wallHUmdZR0JpTUdVQTBReFFFZ2tBQUFYS0FEc0FlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ2xKV0ZnWW1WcVF0Z2d6TEVRWGFJRktucXlPL3U0WHJvRGFmbi9iZ0RTbjdJZUU3R2E5elB5U2xFL1hIQkMyK0pwNklXaVVzK1dESWh5MmZpek5ra3ppWDVTbHp3emlYeFZQenZ4Q1dmUExaZGU3djMxcXQ5WjZ4MzV6YU02NFAxb2VtY1d1a3E2cDExMWg5N2E5UnBWR1pvd25CdFZhMHJYYk9sbytYR25SNkxSN0VYeDBSMm5DVUxqS3c1UkNmUVNPcWt0VUpUL2N0M2tydllPY1pQUmpvblNaVFFJRmRCOWxYYWlqcGVhdXBmNytrd1J3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVVlBQW9BQUFBQUJmQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGNE5XTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SFRmMWFaMng1WmdBQUFYQUFBQUpJQUFBQ3VQTzJ2NU5vWldGa0FBQUR1QUFBQUM4QUFBQTJLRlRTN1dob1pXRUFBQVBvQUFBQUlBQUFBQ1FGdmdHYmFHMTBlQUFBQkFnQUFBQVFBQUFBRUFuOEFLZHNiMk5oQUFBRUdBQUFBQW9BQUFBS0FjSUExRzFoZUhBQUFBUWtBQUFBR0FBQUFDQUFCd0JZYm1GdFpRQUFCRHdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGREFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVjlrWnZnUDVETXpNSUtFR1JFcS9nT0ZBUUhmRGlrQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlxWXpYL3ovSDhoUEE5SC9aLzh4QXFzQ0FnQ2xVd21sQUFCNDJrV1J3VzdUUUJSRi9XYWNtU1JPUEhac2oxdkhkWk00dG9PVUptM2lPRkl3U1p3QWFpaTBSVUt0Q2lnVlNOMndRSlVRRXVJalFFSXMyUElaN1BzRGZFd1hiRnJHRlJMemRuUGZrKzY1VndMcDRMYVAzcUhmMGx5U0FETWdWQVhhQ3FNcERMbk5DZVhiTUlVWjlrbVkyTU1wak1YL2dOc3ErR0VVSnVPd0R5cGlNRXc0aWVEblJKTTFwNVR0ZFNZQWJTdkV3TFlaWSswbTN1cXhweDR5MkhObXFYemgzMHNCZkM1MHpXT3NWdlBLUmVjOGwrSDd6ZFVUZlI2YlN4ejZYZ08xU2FTVUVNZ0gxby9yVTl5aWNIcFdqOEtnL1YrQ3pYRG5pOXdxZ2lRZWtycTNPeWlBSzZrbkxYTWFRVUx1U0lSamsxQ2JEM2tpQUdZQ3NnZFJNczdIQTF0UWlRVThneVFTVUlUbUVYQjdrSytpNW1YcHc2ZitXaForZFE1cXpkV2JadXE3bk5yalZYYUdjTWIwMVZsblZNVk9yV3JCdHo0RzA0cWRaY1BTZEFnamIrRldLSHkreWZvdk1iSzZXMDNEVUx4eUFZSGlidTQyWGc5bE9EMitPRFRZUXd4dHJuSFE5SnMvdjVnUytESjBSbUUyUHhwRDBHRFZPN2JkMjJ2MFZmUzBrazRFbTgxTkd1VldTWTZZekhBeWlzTklBS3ZRaHg3azNuTTBrMkZpa1g4d2VWdDVIR05Sck0ycEtGY0VjSGNrU3Vib3BHVlhoL1hKUnYzUlNYcU9vR3d3aXBqaHRaUUNMU3NFT0t0RVhuY0dNcU4yQVRVUy8wSFRiVmVtYVhGU1FHOFhqejFhNEFCa3ZZR2hIZ3llSVhuUGllR1NvZzI1ZVBFbThJNWxpUGQ5LytqK1ZrbTFYSUI1ejFRQUlXM3A4Z1pBM0MzcjJlYmFNWndSbXQ0ZmZJeTFnSFFPVisreG5GYlVSVnJhRDE2OEdod2l2RTZ6cHVhSU9QNEMwclZjdUhqYVkyQmtZR0FBWWs4SmlkUHgvRFpmR1poWkdFRGdzZlh4bndqNnZ5N1RNYWFMUUM0SEF4TklGQUFycXd0NkFIamFZMkJrWUdCbStNL0F3TUIwakVIbi93V21mZ2FnQ0FwZ0FRQm4yd1JkQXNZQUFBSTZBRXNDT2dBc0FzSUFNQUFBQUFBQVpnRFVBVndBQUhqYVkyQmtZR0JnWVFobllHSUFBVVlHTkFBQUNXa0FZSGphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9DQ3hkV0ZnWW1YcUF0aEZHV3dqSjBSQ3FqcjJkL2RoUFBRTlYrZCsyRURORHdYM0s1Z2x2VjlKSmU3QkZWUG1tU2ZpM2pMWExIam5pYUo4bHVTVmo4eWxOSitaSzE3NHlqeVIvRHR6ellyZlRYQ1g2MkNqMmdWam96ODUxNjMzTnZaZDhHcXBtK1MzMXR0NEdLeFJ4NXN5WTllUFo2ZGEzZWlXRFFISGhTc0Rsb2hpSjRsSjdEbEo1K2hZczA5Skx4d2tWeXpSTlAvNnJmUStiUTdwSnlPYkl6ZFJ3eWlMWHZRc1cwV2JYbXJhUDh1aEwvY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE5UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MDRXTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ1VaMng1WmdBQUFXUUFBQUNvQUFBQXFML3NEZVZvWldGa0FBQUNEQUFBQUM4QUFBQTJLRy9UeTJob1pXRUFBQUk4QUFBQUhRQUFBQ1FHQndJaWFHMTBlQUFBQWx3QUFBQUlBQUFBQ0FWMkFDUnNiMk5oQUFBQ1pBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSnNBQUFBRmdBQUFDQUFCUUEwYm1GdFpRQUFBb1FBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtMnMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJrWnZnUDVETkRwSkhVL0FjS0F3RG85dzB0ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlPLy85RHlQOEh3SHdHQUZLWEJwMEFBQUFBQWdBay8vOEM0UUxkQUM4QU1nQUFOd0UyTnpJV0Z4TVVGak0yRmdZdkFRY25KaWMwTmhjV05qY3ZBU0VIQmhRV0Z6WVhEZ0V2QVFjbUp6UTJNejRCTnpNRHR3RmxCaFFOQmdFK0ZpMFZBUXdGZElBSUJRRU5DeE0wQXdrSC92OU9EUndURFFNQkRRVm5XQXdCREFraVBwbnJJWFlDVmhBQkNRLzlnQllQQXgwSEFRTURBUUlJRHdjQkFRd1haa1dFRkNRUUFRSVBEZ1lCQXdNQkNnOEdBU1BJQVZJQUFBQjQybU5nWkdCZ0FPSUdxKy9HOGZ3Mlh4bVlXUmhBNExIMThaOEkrdjkvcG9kTWQ0RmNEZ1lta0NnQVZvUU5Fd0I0Mm1OZ1pHQmdadmpQQUNJWlZCamttUjR5QUVWUUFCTUFOWXdDTUFBQUFBSjJBQUFEQUFBa0FBQUFBQUJVQUFCNDJtTmdaR0JnWUdJd0JtSVFZR1JBQXdBRnJ3QTZBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNyB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjIuNTc3MDEyLC01OS4xNzU4NzIpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4xNTI3OSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC01OS4xNzU4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTU5LjE3NTg3Mic+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTUuMTA1MDEzJyB5PSctNjIuNzkxMjM2Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzYuNDg4MywtNDIuNzM4MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNTkuMTc1ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy01OS4xNzU4NzInPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzUuMzIzOCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC01OS4xNzU4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTU5LjE3NTg3Mic+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTUuMTA1MDEzJyB5PSctNjIuNzkxMjM2Jz7ugLA8L3RleHQ+CjxyZWN0IHg9Jy02Mi41NzcwMTInIHk9Jy01Ny45ODA0MTknIGhlaWdodD0nLjM5ODQ4NCcgd2lkdGg9JzEwLjI2NzA3MScvPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDExNC40MDkzMywtNDIuNzM4MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNTkuMTc1ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy01OS4xNzU4NzInPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU1LjEwNTAxMycgeT0nLTYyLjc5MTIzNic+7oCw7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002LjQwOTQyLTYuNDA5NzNMMzEuNjQ1MzYtMzEuNjQxNzQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNCwtMC43MDcwMywwLjcwNzAzLDAuNzA3MTQsMzEuODIyMTQsLTMxLjgxODUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjMyNjg3LC0yNy4zNTg0NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNTkuMTc1ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy01OS4xNzU4NzInPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU3LjkxMDQyOCcgeT0nLTYyLjE4MjM4OSc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy01My43NDU0NTknIHk9Jy01OS4xNzU4NzInPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUwLjYzMjExNicgeT0nLTU5LjE3NTg3Mic+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNDYuNDk1MTY1JyB5PSctNTkuMTc1ODcyJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINjYuOTk2MTQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjYuODcxMTQsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjguOTI4NzcsNS40NDkzMSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNTkuMTc1ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy01OS4xNzU4NzInPs+RPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01Ny43NjYwNzEnIHk9Jy01Ny43OTM1NTknPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTUzLjc3MDYwMScgeT0nLTU5LjI2MDI4Nyc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy00OS42MDU2MzInIHk9Jy01Ny43OTM1NTknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQ2LjkwNzM3NycgeT0nLTU3Ljc5MzU1OSc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNDMuMjM4ODInIHk9Jy01Ny43OTM1NTknPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTcwLjUxMTY2LTkuOTY1MDdMNDguODMxMjUtMzEuNjQxNzQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNSwwLjcwNzAzLC0wLjcwNzAzLDAuNzA3MTUsNzAuMzM0ODcsLTEwLjE0MTgzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC43MDcxNSwtMC43MDcwMywwLjcwNzAzLC0wLjcwNzE1LDQ4LjY1NDQ2LC0zMS44MTg1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00zOC42MTY3NC0yNi43MDI0Mkg4MS45MjgzMlYtMTMuNjA4MjdIMzguNjE2NzRaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MS42MTY3NCwtMjEuOTUyNDIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTU5LjE3NTg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNjIuNTc3MDEyJyB5PSctNTkuMTc1ODcyJz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTUwLjgyNjY3MycgeT0nLTU5LjE3NTg3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDcuNzEzMzMnIHk9Jy01OS4xNzU4NzInPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQzLjA0Njc0NicgeT0nLTYyLjE4MjM4OSc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zOC44ODE3NzYnIHk9Jy01OS4xNzU4NzInPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM1Ljc2ODQzMycgeT0nLTU5LjE3NTg3Mic+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzEuNjMxNDgzJyB5PSctNTkuMTc1ODcyJz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004OC44ODY4NC04LjQwOTZMMTExLjQzNzczLTMwLjk1NzIzJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTQsLTAuNzA3MDMsMC43MDcwMywwLjcwNzE0LDExMS42MTQ1MiwtMzEuMTMzOTkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTTk0LjIxNDA3LTI1LjExMDE3SDEwNi40NjQwN1YtMTQuMjMzMDdIOTQuMjE0MDdaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5Ny4yMTQwNywtMjEuNjEwMTcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTU5LjE3NTg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjIuNTc3MDEyJyB5PSctNjAuODU4MTE2Jz7iiLw8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTYyLjUyMTY2MycgeT0nLTU4LjY3Nzc0Jz49PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwNy42NTM4LTQwLjIzODNINDkuMDQzODQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA3LjQwMzgsLTQwLjIzODMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDQ4Ljc5Mzg0LC00MC4yMzgzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC41NDMwMywtNDguMzk0MjYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTU5LjE3NTg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctNTkuMTc1ODcyJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01Ny45MTA0MjgnIHk9Jy02Mi4xODIzODknPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTMuNzQ1NDU5JyB5PSctNTkuMTc1ODcyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01MC42MzIxMTYnIHk9Jy01OS4xNzU4NzInPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzguODgxNzc2JyB5PSctNTkuMTc1ODcyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0zNS43Njg0MzMnIHk9Jy01OS4xNzU4NzInPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTMxLjYzMTQ4MycgeT0nLTU5LjE3NTg3Mic+KSk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \node  (1) {$A'$};
        \node  [below right = of 1] (3) {$A$};
        \node  [above right = of 3] (2) {$\underline {A'}$};
        \node  [below right = of 2] (4) {$A''$};
        \draw  [->,morphism] (1) to node[swap] {$f^{*}(g)$} (3);
        \draw  [cover,morphism] (1) to node {$\vartheta _{f^{*}(g)}$} (2);
        \draw  [>->,morphism] (2) to node[desc] {$\mathsf {Img}(f^{*}(g))$} (3);
        \draw  [->,morphism] (2) to node[desc] {$\cong $} (4);
        \draw  [>->,morphism] (4) to node {$f^{*}(\mathsf {Img}(g))$} (3);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Since isomorphisms are stable under pullback, <fr:tex
display="inline"><![CDATA[f^{*}(\mathsf {Img}(g))]]></fr:tex> is also an isomorphism.
      Thus, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f^{*}(g))]]></fr:tex> is an isomorphism.
      Then since <fr:tex
display="inline"><![CDATA[f^{*}(g)]]></fr:tex> is the composite of two covers, it is itself a cover.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>828</fr:anchor><fr:addr
type="machine">#298</fr:addr><fr:route>unstable-298.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is regular, then by <fr:ref
addr="ct-000N"
href="ct-000N.xml"
taxon="Lemma" />, the unit <fr:tex
display="inline"><![CDATA[\vartheta \colon \mathsf {id}\to \mathsf {Img}]]></fr:tex> consists of <fr:link
type="local"
href="ct-000M.xml"
addr="ct-000M"
title="Extremal epimorphism">covers</fr:link>.
      Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be any morphism in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g\colon B'\to B]]></fr:tex> be an object in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>.
      By <fr:ref
addr="ct-000Q"
href="ct-000Q.xml"
taxon="Lemma" />, <fr:tex
display="inline"><![CDATA[g]]></fr:tex> can be factored as <fr:tex
display="inline"><![CDATA[\vartheta _{g}\mathsf {Img}(g)]]></fr:tex>.
      Form the following pullbacks.
      Note that since covers are stable under pullback by hypothesis, <fr:tex
display="inline"><![CDATA[\widehat {\vartheta _{g}}]]></fr:tex> is also a cover.
      Then by the <fr:link
type="local"
href="ct-0008.xml"
addr="ct-0008"
title="Pasting lemma of pullbacks">pasting lemma</fr:link>, the composite <fr:tex
display="inline"><![CDATA[f^{*}(\mathsf {Img}(g)) \circ  \widehat {\vartheta _{g}}]]></fr:tex> is isomorphic to <fr:tex
display="inline"><![CDATA[f^{*}(g)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="da7334f99682b52474eec73093f5ecbf"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMS4wMzI5OTZwdCcgaGVpZ2h0PScxMjUuMTE0MDkycHQnIHZpZXdCb3g9Jy03MiAtNzIgMTM0LjAyMTk5OCA4My40MDkzOTUnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPVUFBb0FBQUFBQS93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWUoxWEdOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDNloyeDVaZ0FBQVdRQUFBRFlBQUFBMk5WcUxUdG9aV0ZrQUFBQ1BBQUFBQzhBQUFBMktPTFIxR2hvWldFQUFBSnNBQUFBSGdBQUFDUUY4UUthYUcxMGVBQUFBb3dBQUFBSUFBQUFDQVloQUdWc2IyTmhBQUFDbEFBQUFBWUFBQUFHQUd3QUFHMWhlSEFBQUFLY0FBQUFGZ0FBQUNBQUJRQkZibUZ0WlFBQUFyUUFBQUROQUFBQk9QTmJLcDl3YjNOMEFBQURoQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1GbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBxbU02UXpNL3dIOHBraDBraHEvZ09GQWJRZURNOEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2anAvLzlEeVArendId0dBRlcxQnNNQUFBQUFBZ0JsL3l3Q2lnSEZBQzRBUXdBQUFRTU9BU01HTHdFbUp6NEJNaFlWRkFZSEZoOEJGajRDUHdFT0FRY3VBU2MyTnpZM05qY3lGaGMyTng0QkZRYzNOaThCSmljT0FRY09BUlVlQVRjK0FUYytBUUtGYkJTUGF5ODFDek1FQVNVeUZnb1FBaUl0Rno5SEdBWVlFa3d5UzJZQ0EwVVJFbEJoSWtBWkVTSVRFNVl0QVJVRUZ6d3BTQllkSEFJNUlDaEZIUTRKQVhYK1RFdElBZ2tEREM4ZEpSb1BDQndQQlFJQkFRb3dNQnhoRUNVQ0FWeFNZMHdURDBJREd5SW5BUUVWRHZ1NENpTUdJZ1FCTUNNdmRTRTdMQUVCSngwUER3QjQybU5nWkdCZ0FPSjU4bjZWOGZ3Mlh4bVlXUmhBNExIMThjOEkrcjhPY3dqalVTQ1hnNEVKSkFvQU1EOExMd0I0Mm1OZ1pHQmdadmpQQUNSREdGSVpuSm02R0lBaUtJQUpBRUFXQXBJQUFBTlVBQUFDelFCbEFBQUFBQUJzQUFCNDJtTmdaR0JnWUdKd0FXSVFZR1JBQXdBSFdBQkxBQUI0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21leDc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQUxzQUFvQUFBQUFBMHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2NHQmE2R050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0MyWjJ4NVpnQUFBV3dBQUFBb0FBQUFLTFR0YTVab1pXRmtBQUFCbEFBQUFDMEFBQUEyS2cvVCtXaG9aV0VBQUFIRUFBQUFId0FBQUNRSG8vak5hRzEwZUFBQUFlUUFBQUFJQUFBQUNBYTFBQXhzYjJOaEFBQUI3QUFBQUFZQUFBQUdBQlFBQUcxaGVIQUFBQUgwQUFBQUZ3QUFBQ0FBQkFBSGJtRnRaUUFBQWd3QUFBRFBBQUFCT0JGOUtvTndiM04wQUFBQzNBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWptS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTFCOG9Oa1pwRXZSZ3dNekNMYzU0RENqQWdWLy84ek1BQUFIdUlRQndCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1ErUy8vK0hrUEx6d1BJTUFHaWhCNThBQUFBQkFBd0NSZ1NDQXhRQUJRQUFBUVVISlFVbkFrY0NPd3I5ei8zTkNBTVVyaUNMaXlBQUFBQjQybU5nWkdCZ0FPSmpEMk5leHZQYmZHVmdabUVBZ2NmV3g3OGcweXhOekNKQWlvT0JDY1FEQUZkTUN1NEFBQUI0Mm1OZ1pHQmdGdmxpeE1EQTBzdkF3OEROMHNRQUZFRUJUQUEvaGdKd0FBSW9BQUFFalFBTUFBQUFBQUFVQUFCNDJtTmdaR0JnWUdKZ1l3RFJERkFTQ1FBQUFUTUFEQUI0MmsyTVBXL0NNQkNHbjZnSlV0T2hTOVdoQS9YUTJRcEtKVFlXQmlaV0poYkFWNVFoRG5KQ0JCTHEyTi9kdy9YUUc4N1ArM0VHU3I3SnVFL0djOXozeVNsVS9YSEJFeStKSjZyZUU1ZTg4Y0VEV2Y2b3pwUkY0bHlUYmVLQ1Y3NFNUOVMvSlM3NTVHZlp0YWZ6SU1Hc095ZkJIMXE1ekRjUytxYnpabWFycUZmaUpld0djV1ovTlc1cyt2SFltdHBXdG1aSlI4dUpNd05Dd0xCV3gwWDJIRFFUTHN6WlJLZW4wZFJyYTRhbCtwZXY5UFd4czRzL09lM3N1ZXAyakhyVjZ6NXEyMURIUzB2OUM5Z1RNQk1BZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUM0QUFBQTJLR0hTNW1ob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0dU94Lyt2aitXMitNakN6TUlEQVkrdmpYeEQwZjBhbXk4d2dMZ2NERTRnQ0FGMmdDOThBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5vQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDMEFBQUEyS2VMU3dXaG9aV0VBQUFKQUFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFtQUFBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNhQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUp3QUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9nQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFdBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaVd1azlHK1A1YmI0eU1MTXdnTUJqNitOZmtHbVdVTVk3UUlxRGdRbkVBd0EwcndxZ0FBQUFlTnBqWUdSZ1lOYjZZOG5Bd0JMSzBNZlF6NVRNQUJSQkFVd0FVb0FEUWdBRVZRQUFBdklBamdBQUFBQUFWQUFBZU5wallHUmdZR0JpTUdVQTBReFFFZ2tBQUFYS0FEc0FlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ2xKV0ZnWW1WcVF0Z2d6TEVRWGFJRktucXlPL3U0WHJvRGFmbi9iZ0RTbjdJZUU3R2E5elB5U2xFL1hIQkMyK0pwNklXaVVzK1dESWh5MmZpek5ra3ppWDVTbHp3emlYeFZQenZ4Q1dmUExaZGU3djMxcXQ5WjZ4MzV6YU02NFAxb2VtY1d1a3E2cDExMWg5N2E5UnBWR1pvd25CdFZhMHJYYk9sbytYR25SNkxSN0VYeDBSMm5DVUxqS3c1UkNmUVNPcWt0VUpUL2N0M2tydllPY1pQUmpvblNaVFFJRmRCOWxYYWlqcGVhdXBmNytrd1J3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzODtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUVlBQW9BQUFBQUJNd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFc5MG5HTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWV3RWdaMng1WmdBQUFXd0FBQUZNQUFBQmpQTndKSk5vWldGa0FBQUN1QUFBQUM4QUFBQTJLSnJTMjJob1pXRUFBQUxvQUFBQUhnQUFBQ1FHTndKMWFHMTBlQUFBQXdnQUFBQVFBQUFBRUFqOUFOWnNiMk5oQUFBREdBQUFBQW9BQUFBS0FOUUFpRzFoZUhBQUFBTWtBQUFBR0FBQUFDQUFDQUJOYm1GdFpRQUFBendBQUFET0FBQUJPQWQxS3Ixd2IzTjBBQUFFREFBQUFBd0FBQUFnQUFNQUFIamFZMkJtc21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcDZNdVF5Yy84SDhwbTVHZEhVL0FjS0F3REQ3d3o3ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVE4R2RJWmN2Ly9SN0QrNy9nLysvODBzRm93QUFEc2h3dVZBSGphVlZETFRzSlFFSjJaVzFvZ1dBU2xGZHRVYVdNTGlCQjV0TUJWRWhjU0l5cHE0a0lrU0dUamp4ZytEUk1TRXFJZjR0YUY0TVdObWtsT3ptTm1jUVlRUmdBd3BRa3dnSTJFazVnKzArU3JJVFFJeDFxV0tJN3ZVQUlPSFFEVVBVZFdkQzJsb2lKN3NtSmhVUEYxVFl5S3R1dTVmbEJFencvY1dnc0RYMjhoMDFhTzQ2NDJkWEVwNnhhV1JlNkpJUmFyY2xPU1RIeTYyRytFR0JYaWo4WlIzcTFLTko2TkdSbzVKWUZTMnFIaFpiRngvTEMwT1dFdDd3ajBlNlBtbXNwbzhESWdxUkJmTCtLOExTRUw1dzVQaDBTN3RPTW1pQ0poemJyaTNTN2Y1TnNSejJvYUIzV1JNbHVMTGo2d3lDdlZIM2hscHFsa3N0bE1WZzJSTENvRHdwMG9Ic00zMkJOQy9NTXZvZXVwcUtmKzBVcktGMTFFeGNCQ0ZyMW5xcFE4NDJYOEpiZnQzbmxUVHQ2YzlEbVdGblBNcHUyUXpWaS85dm1YempyWHhPcGJoazlzQ04vcnJEM3JlTnBqWUdSZ1lBQmlvN2xob3ZIOE5sOFptRmtZUU9DeDlmRXZDUHEvUGpNUDAzRWdsNE9CQ1NRS0FDQm1DcVVBZU5wallHUmdZT2IrendBazR4bmtHQVNaZVJpQUlpaUFCUUF1dndHMEFBQUNVQUFBQVM0QVl3SWdBQjREWHdCVkFBQUFBQUFPQUlnQXhnQUFlTnBqWUdSZ1lHQmg4R0ZnWmdBQlJnWTBBQUFJYlFCV2VOcE5qRDF2d2pBUWhwK29DVkxEd0lJNk1MUWVPbHRCWVdCaVlXQmlaV0lCN0tJTWNaQWRJaUZWSGZuZFBZd0h6dExwZVQvT1FNa2ZHWS9KbU1UOW1KeEMxSk1MeGt3VGowUjlKUzZaOGMwYldmNHV6aWVyeExrays4UUZIL3drSG9uL203aGt3WDNkdFpkcmI3M2Fkc1o2ZDJwRFdPNnNEMDNuMUZ4WFVXK3NzLzdRVzZPT04yV0dKZ3puVnRXNjBqVnJPbG91WE9teGVCUmJjVXhreDBteUlHL0pManFCUmxJbnJUbWE2aVhmU081aTV4Qi9NdEk1Y3BOdEdPUXF5RDVMVzFISFMwMzlEK3B0TURzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVZQUFvQUFBQUFCZkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjROV050WVhBQUFBRThBQUFBTWdBQUFEd0hUZjFhWjJ4NVpnQUFBWEFBQUFKSUFBQUN1UE8ydjVOb1pXRmtBQUFEdUFBQUFDOEFBQUEyS0ZUUzQyaG9aV0VBQUFQb0FBQUFJQUFBQUNRRnZnR2JhRzEwZUFBQUJBZ0FBQUFRQUFBQUVBbjhBS2RzYjJOaEFBQUVHQUFBQUFvQUFBQUtBY0lBMUcxaGVIQUFBQVFrQUFBQUdBQUFBQ0FBQndCWWJtRnRaUUFBQkR3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRkRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXFtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVY5a1p2Z1A1RE16TUlLRUdSRXEvZ09GQVFIZkRpa0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5cVl6WC96L0g4aFBBOUgvWi84eEFxc0NBZ0NsVXdtbEFBQjQya1dSd1c3VFFCUkYvV2FjbVNST1BIWnNqMXZIZFpNNHRvT1VKbTNpT0ZJd1Nad0FhaWkwUlVLdENpZ1ZTTjJ3UUpVUUV1SWpRRUlzMlBJWjdQc0RmRXdYYkZyR0ZSTHpkblBmays2NVZ3THA0TGFQM3FIZjBseVNBRE1nVkFYYUNxTXBETG5OQ2VYYk1JVVo5a21ZMk1NcGpNWC9nTnNxK0dFVUp1T3dEeXBpTUV3NGllRG5SSk0xcDVUdGRTWUFiU3ZFd0xZWlkrMG0zdXF4cHg0eTJITm1xWHpoMzBzQmZDNTB6V09zVnZQS1JlYzhsK0g3emRVVGZSNmJTeHo2WGdPMVNhU1VFTWdIMW8vclU5eWljSHBXajhLZy9WK0N6WERuaTl3cWdpUWVrcnEzT3lpQUs2a25MWE1hUVVMdVNJUmprMUNiRDNraUFHWUNzZ2RSTXM3SEExdFFpUVU4Z3lRU1VJVG1FWEI3a0sraTVtWHB3NmYrV2haK2RRNXF6ZFdiWnVxN25OcmpWWGFHY01iMDFWbG5WTVZPcldyQnR6NEcwNHFkWmNQU2RBZ2piK0ZXS0h5K3lmb3ZNYks2VzAzRFVMeHlBWUhpYnU0MlhnOWxPRDIrT0RUWVF3eHRybkhROUpzL3Y1Z1MrREowUm1FMlB4cEQwR0RWTzdiZDIydjBWZlMwa2s0RW04MU5HdVZXU1k2WXpIQXlpc05JQUt2UWh4N2szbk0wazJGaWtYOHdlVnQ1SEdOUnJNMnBLRmNFY0hja1N1Ym9wR1ZYaC9YSlJ2M1JTWHFPb0d3d2lwamh0WlFDTFNzRU9LdEVYbmNHTXFOMkFUVVMvMEhUYlZlbWFYRlNRRzhYanoxYTRBQmt2WUdoSGd5ZUlYblBpZUdTb2cyNWVQRW04STVsaVBkOS8raitWa20xWElCNXoxUUFJVzNwOGdaQTNDM3IyZWJhTVp3Um10NGZmSXkxZ0hRT1YrK3huRmJVUlZyYUQxNjhHaHdpdkU2enB1YUlPUDRDMHJWY3VIamFZMkJrWUdBQVlrOEppZnZ4L0RaZkdaaFpHRURnc2ZYeEx3ajZ2eTdUTWFhTFFDNEhBeE5JRkFBdUlRdUVBSGphWTJCa1lHQm0rTS9Bd01CMGpFSG4vd1dtZmdhZ0NBcGdBUUJuMndSZEFzWUFBQUk2QUVzQ09nQXNBc0lBTUFBQUFBQUFaZ0RVQVZ3QUFIamFZMkJrWUdCZ1lRaG5ZR0lBQVVZR05BQUFDV2tBWUhqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLUjdUSVdob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0xkTEJjZnh2UGJmR1ZnWm1FQWdjZld4NzhnMDh3VG1XeUFGQWNERTRnSEFFT2VDcWdBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVWtBQW9BQUFBQUJmUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUYyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1haMng1WmdBQUFXUUFBQUpZQUFBQ3VKSGpjY2xvWldGa0FBQUR2QUFBQUM4QUFBQTJLTVhUcTJob1pXRUFBQVBzQUFBQUhnQUFBQ1FHWGdJbGFHMTBlQUFBQkF3QUFBQVVBQUFBRkE2b0FLdHNiMk5oQUFBRUlBQUFBQXdBQUFBTUFXSUNERzFoZUhBQUFBUXNBQUFBR0FBQUFDQUFDUUE2Ym1GdFpRQUFCRVFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGR0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtZXNjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJoWnZnUDVETkRwSkhVL0FjS0F3RDcxUTFqZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1Fndmd1Ly84RFNjZi8vLzhmQVBNWkFGTEtCcUI0MmpYUnYwOFRZUnpIOGVmemZOdm5hR252S2xmdWFxRFhsSlllWUZvSXZkd0JpY1ZRcVFpeC9LaEJnbzFFRXlTU2lEOUFaR0RvZ0RFYUdJd0ppWEZ3ME0wNHV6ZzVNVG01T3FpVDhVOHdiWDJPaE9kWm5ueHp3L3Y3T3NaWnR0M21QL2tQTnN4R0dmUGdlcU9HcWNlTm9tdUlZU2gyem5aYzAzQzlZYVFWRVRkTTExUWg1LzY0V0lKWHBNOVlGL0dvUU1uSWR5TVMzR2wwQkJIdDFCMEtLYTEyTmRxclJ3blI0TVpLQkpGUVgrbk4zL1F1WDQ0aHBEVWJoa1pKQlVUZ0hab0NSTXk3MHdmeGJBeGNVNFUvRG1zQ21STXNNWG1JWFdnM1NmQXZ6R0pEYkV5VzZrN0dGckl0YmFGYmhXTEJGQnFFa2hhbnZib2Y1K2JzVEU0b2RQWW0rVUh4dzFHUG5kUTByTlR2VUtNMlZ3Ty9FcnYycFBXNlYxVW5ySGZIYXpzY2hmSkJTZzl1SGRaM09SK1orVm9KQU9vQ0h6L0hxVmNCWDV5WTNkREMxZkc1S2JVVThEZUFqbWw2WE1sZTV0RE9Oei9TMDJyL0FyVitkNGt3WTJERjloL3E1Ti85WnBDS2pCU2RoSk96WmJNZmJGcndKSzlmbUlJbEY1RHpBbXpYODY5aEdxWW4xNkh3SlJMaFVCQWN5L1BUejBZcVBjSkFZUC9xd0pycjVFVWdwQVFwWHhsOFZONTdTMVJ6WnJjUGFvTURZa1pGaEorMC9xbXlXZEZ5cTV0QWVXeGxMVkhQNzk3bTZCc3ExQk9kQUkvY24rb3ZnbzRiTDNabW5TVUtaUHZWZVpXVE5PZHNVSnA3MGp6QjhyNjRld1p1Q3NXL1o5YW5ycWEvd2lSY3V3QkZxcjgvUXRtS1NlYnRmZEQ4ME5obW8vVXBxVW5pWDRjKzU4dGJlK1pFb3FNTC9GNTFLNlZMM1JoUlV2NzJWdytlUDd5WXYwNWtDUW5MeTgxdjBoR0JoZFRpemZRTmUzMFYwR1RhZi9RQmQxZDQybU5nWkdCZ0FPSmpXWkttOGZ3Mlh4bVlXUmhBNExIMThTOEkrdjlMWm5PbXUwQXVCd01UU0JRQU92SUw1QUI0Mm1OZ1pHQmdadmpQQUNUOUdWVCtYMkEyWndDS29BQldBRlVyQTRrQUFBSjJBQUFEQUFBa0F3Z0FLd0xiQURNRFR3QXBBQUFBQUFCVUFMQUJEZ0ZjZU5wallHUmdZR0Jsc0dSZ1pnQUJSZ1kwQUFBR3JRQkVlTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtZXg3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjkzMTI0LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+QzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS40NDYxOCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUuNTkxODA4JyB5PSctNTcuNjEwOTA5Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzIuNDY0OCcgeT0nLTYxLjIyNjI3Myc+7oCwPC90ZXh0Pgo8cmVjdCB4PSctNS41OTE4MDgnIHk9Jy01Ni40MTU0NTYnIGhlaWdodD0nLjM5ODQ4NCcgd2lkdGg9JzEwLjg1MTY3MScvPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ3LjQ3Nzk1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00Ny43Mjc5NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuMjYzODksLTI4Ljk0MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUzLjE1NTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUuNTkxODA4JyB5PSctNTcuNjEwOTA5Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjg2MjEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTAuNjg2NzggMEg0OC4wOTk5NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMC45MzY3OCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjM0OTk2LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOS44ODc1Nyw0LjU2MTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLS45MjUyMjQnIHk9Jy02MC42MTc0MjYnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSczLjIzOTc0NScgeT0nLTU3LjYxMDkwOSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc2LjM1MzA4OCcgeT0nLTU3LjYxMDkwOSc+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9JzE4LjEwMzQyNycgeT0nLTU3LjYxMDkwOSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PScyMS4yMTY3NycgeT0nLTU3LjYxMDkwOSc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PScyNS4zNTM3MjEnIHk9Jy01Ny42MTA5MDknPikpPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUuNTkxODA4JyB5PSctNTcuNjEwOTA5Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMi4yMDE3Mi01Ni45MDU1SDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDEyLjQ1MTcyLC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTguMDU1NzEsLTY0Ljk2NzMyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSc2LjE1ODUzMScgeT0nLTU3LjYxMDkwOSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc5LjI3MTg3NCcgeT0nLTU3LjYxMDkwOSc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PScxMy40MDg4MjQnIHk9Jy01Ny42MTA5MDknPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS01MS4yMTUwNC0xNC4yMjYzNkgtNDIuNjc5MTRWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYxLjE4Mzk4LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+RDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjIuMzUxNjgsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScyLjQ2NDgnIHk9Jy02MS4yMjYyNzMnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTQ4LjA3MTQ5IDBILTEyLjI1ODkxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMi4zODM5MSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzIuNzg0NzksNC43ODQwMyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuMDc0MjE4JyB5PSctNTkuNDUxMjIyJz7ugaM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUuNTkxODA4JyB5PSctNTcuNjEwOTA5Jz7PkTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctLjc4MDg2NycgeT0nLTU2LjYxNDY0NSc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTU2LjkwNTUtNi40MDk3M1YtNDcuNDc3OTUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwtNTYuOTA1NSwtNDcuNzI3OTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDYuOTAzNzgtNTYuOTA1NUgtMTMuNzczODUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEzLjg5ODg1LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMyLjk1ODQsLTY0LjU3ODQxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPs+RPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0uNzgwODY3JyB5PSctNTYuNjE0NjQ1Jz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \SpliceDiagramSquare {
          nw = C,
          ne = A,
          sw = \underline {B'},
          se = B,
          north = f^{*}(\mathsf {Img}(g)),
          east = f,
          south = \mathsf {Img}(g),
          north/style = {>->},
          south/style = {>->},
          nw/style = pullback,
        }
        \node  [left = of nw,pullback] (1) {$D$};
        \node  [left = of sw] (2) {$B'$};
        \draw  [cover,morphism] (1) to node {$\widehat {\vartheta _{g}}$} (nw);
        \draw  [->,morphism] (1) to (2);
        \draw  [cover,morphism] (2) to node[swap] {$\vartheta _{g}$} (sw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Thus, <fr:tex
display="inline"><![CDATA[f^{*}(g)]]></fr:tex> admits another cover-mono factorization.</fr:p>
    
      
      <fr:figure><fr:resource
hash="b9c08c521816bfce626332248a40053d"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIyNy4xODE0cHQnIGhlaWdodD0nMTUxLjY5NzQ4NHB0JyB2aWV3Qm94PSctNzIgLTcyIDE1MS40NTQyNjcgMTAxLjEzMTY1Nic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUEvUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMG1tTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM4QUFBQTBFOE96SDFvWldGa0FBQUNJQUFBQUMwQUFBQTJLT0RURDJob1pXRUFBQUpRQUFBQUhnQUFBQ1FGTEFLNGFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dYZkFKcHNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEWUFhRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFnYm1GdFpRQUFBcHdBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNm1HY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFkSWxETTBBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pKajFuNEh4T0RNRGd4d0RBeU1mSXp1YnVCZ1lpckFwcWVzeHFxdXBtNW5iTVpxYkdZbUpzakVlQ1dwbFpWYmk0Tkt0NEdCa2szSlU5Rkt3WldHeFZmQlNkSlJpWTJSNmJ2WjFUMnlsaEhoVktnc1hDNWVKYkpSdHdZb1ZoYmFSc2laY0xKd01RTURJa0F5MGF3TFFMbWtnaDQwZFpKdWFQcU1KMkFJaE5YVTFJRU5jamxGY2pIRUMxRlJtSmxiMWNEVlR4clJpZG1abWlJV01EQkF6R1ZrNU9GaGtrOE9hR0tWK3gzSnpzektDTFFRQUVhTWpqM2phWTJCa1lHQUE0bjNsOXIvaitXMitNakN6TUlEQVkrc1RuQWo2UHdOekVET0l5OEhBQktJQUk5QUpWd0FBQUhqYVkyQmtZR0JtK004QUpJTVlraG1TR1k4ekFFVlFBQk1BUnNrQzZnQUFBMUlBQUFJcUFKb0FZd0FBQUFBQUFBQTJBR2g0Mm1OZ1pHQmdZR2FRWndEUkRGQVNDUUFBQTc4QUpnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVxZm01dURrNnZEMjZ3SjBxR3BwTFhvSXY1MGIwUHdCZzdmUGVmY0FCa3ZFb1pKbUFjZEpwVTNqenptaDBYa2lmaXJ5Qm0vckJtUnBETnhWdXdpcDB6NWp6eG1TUmw1SXY0amNzWWY3MzFUMys2ZDllcllHT3ZkcGZiYmsvVnQxVGkxMGZtd0hxeXovdHhabzhxbk1uM1Y5dGRhRlRyWEJYc2FhbTdjNmJCNEZFZHhUR0RIUlRMUGxsUFlXeXJKbkhRMmFQSnZlcERVaGNZNS9HS2tVZklVTmZSeTA0cGVwYXNvd3AybStBQlZNaTVEQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJRQUFvQUFBQUFCT1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZRjFRR050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFHU0FBQUJ2R0UwYno5b1pXRmtBQUFDK0FBQUFDOEFBQUEyS09MVERtaG9aV0VBQUFNb0FBQUFIZ0FBQUNRR0xRSlBhRzEwZUFBQUEwZ0FBQUFNQUFBQURBamRBT0JzYjJOaEFBQURWQUFBQUFnQUFBQUlBSElBM20xaGVIQUFBQU5jQUFBQUdBQUFBQ0FBQmdCS2JtRnRaUUFBQTNRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRVJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbStzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWTBoblp2Z1A1RE5EcEpIVS9BY0tBd0FHaEEyeGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOER5YlQvLy8vUEJ2TVpBRld4QnNONDJpV1BRVzdUUUJpRjU4MjQ0OFNKUFhac2o5MlFoR2JjMkUyVnhGSGMyaXBVTmxCVlJEUkliWGRJQ0tsQ3NDaXc3SW8xRzFoMHg1cGJ3QVY2QWc3QklaQmFZcXIvTFg3cGZZdjNFWkRQZDFONlEzK1RKU0ZnQWx5M29QTTRLWkhKd09PNmZJZ1NSVjRoTHlJZTcrL2xRVmIvLzA4R0ZxSTRpZk1pVHFGMExwRGwwdE81amo4SFp0UHBkcDVPMVV1R3NiL0xQRjlZYm45N3crbjBuTllyMC9YRUc0dHJZY09Nem5aZXJCRzV5OUFlMk1MdEJrWTcvR1I2RGFiaDIrM1BVaDJPdXhtRm1pbkZFbWRvNktBMDk2dkxINWVQd0UydmlkUGgxcDd0cEJxMkp6WENFNnRCRWRyVk5maG1pNEVRUXNtN3V3bjlpaHN5STBlMTVYbzFUMUU3THFSLzd5aExXbUZ0UGtOeUw3ZVFRVjRNNE90RlhxUHJ5b0kvUUZIV29WOCtldGNmMHYxV3BtRzBrSVpOMVRTb25vYzg3S3dXSis4cE8zWTZweGZxeWFhalhQZjdGTDRXSEk2WHN0K2pCMXM3eDMycmlhdmIxY21TTmxrNzdZKzZvdEVUR3hRdzV2UGVoVDJpZUgzK2R1V0taK3lCU2dEZit2dkxpTGpTTUkvU3ErSGpDWkQwaFNEL0FOZGZQUmdBQUhqYVkyQmtZR0FBNG9hK2ZiZmorVzIrTWpDek1JREFZK3NUbkFqNnZ3NXpDTk5sSUplRGdRa2tDZ0E0M2dxUEFIamFZMkJrWUdCbStNOEFKRU1ZVXY5L1p6cktBQlJCQWN3QWFTWUVnUUFBQTFRQUFBSzhBSHNDelFCbEFBQUFBQUJ5QU41NDJtTmdaR0JnWUdid1pHQmlBQUZHQmpRQUFBZndBRkY0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktKclRCV2hvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaW83bWhCK1A1YmI0eU1MTXdnTUJqNnhPY0NQcS9Qak1QMDNFZ2w0T0JDU1FLQUJNVUNYd0FlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmtBQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUN3QUFBQTJLZUxTNjJob1pXRUFBQUk4QUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQWx3QUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ1pBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSnNBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb1FBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEVkFBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpV3VrOXNmSDhObDhabUZrWVFPQ3g5UWxPWkpvbGxQRU9rT0pnWUFMeEFQeDZDSGg0Mm1OZ1pHQmcxdnBqeWNEQUVzclF4OURQbE13QUZFRUJUQUJTZ0FOQ0FBUlZBQUFDOGdDT0FBQUFBQUJVQUFCNDJtTmdaR0JnWUdJd1pRRFJERkFTQ1FBQUJjb0FPd0I0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQ1VsWVdCaVpXcEMyQ0RNc1JCZG9nVXFlckk3KzdoZXVnTnArZjl1QU5LZnNoNFRzWnIzTS9KS1VUOWNjRUxiNG1ub2hhSlN6NVlNaUhMWitMTTJTVE9KZmxLWFBET0pmRlUvTy9FSlo4OHRsMTd1L2ZXcTMxbnJIZm5Ob3pyZy9XaDZaeGE2U3JxblhYV0gzdHIxR2xVWm1qQ2NHMVZyU3RkczZXajVjYWRIb3RIc1JmSFJIYWNKUXVNckRsRUo5Qkk2cVMxUWxQOXkzZVN1OWc1eGs5R09pZEpsTkFnVjBIMlZkcUtPbDVxNmwvdjZUQkhBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUEFBQW9BQUFBQUJFd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMG0yTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QVpBQnlaMng1WmdBQUFXd0FBQUQ0QUFBQkdKSkJwN1ZvWldGa0FBQUNaQUFBQUMwQUFBQTJLTWJURUdob1pXRUFBQUtVQUFBQUhnQUFBQ1FHZ2dMUWFHMTBlQUFBQXJRQUFBQVFBQUFBRUFubkFRVnNiMk5oQUFBQ3hBQUFBQW9BQUFBS0FMd0FZRzFoZUhBQUFBTFFBQUFBR0FBQUFDQUFCd0FjYm1GdFpRQUFBdWdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEdEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNTmd5TS93SDhwa2gwa2hxL2dPRkFjMkNETTRBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLYWpMWS92OFA1R3VBNlA4My94OERxd0lDQUl5ekNOQUFBSGphWTJCa0tQblB5TmpBek1BZ3hjREFLQzRtd3M3R3o4akd6aVlHWlBJenFxa0RvYm1hUGFNWll3NHZPN3VqRmJzbE0yTllHaGM3YjZzcEg3Y3FFNU11bnhrekF5T1RBSnRKamtEaHNkNmZzWndDVEl4SnRZb0t0Y2xGemFwTlFDTVpQSURtaDBETUZ3YWFLaTdHTHNMR3pzZW9abTVpejJqSGFLN0hxSzVtYW1ZZTAySUdNbEJUeVN4UG1wR1pQeVNHa2JuUWpaT1JqWmtCWWxyVVFvZkVaQ1l1WmhaQm4vY0xqenkxNG1MalpHSUFBaVlHVDRZeVpndkdiZ1p1Qm5HZ2RZcHNhaVptNG9wbVlrQkxrTmpNUW45amVTVWxlWmlXOGdESnY5RkFrcGRwTVZDRU1ZS1JRNFdERVVROGdMTVlHQUFOTUN3UmVOcGpZR1JnWUFCaTlhT3R2K1A1YmI0eU1MTXdnTUJqNnhPY0NQby9JN01GTTRqTHdjQUVvZ0FoS1FrN0FBQUFlTnBqWUdSZ1lHYjR6d0FrbXhnOEdEeVpMUmlBSWlpQUJRQThkd0phQUFBQzB3QUFBY2tBZEFISkFFZ0RnZ0JKQUFBQUFBQXdBR0FBakFBQWVOcGpZR1JnWUdCaGtHWmdZZ0FCUmdZMEFBQURqUUFrZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktIN2k0T1RpNU9yek5taUFkbWtwYWl5N2lUL2MyQkcvZzhOMXp6ZzJROFNKaG1JUjUwR0ZTZWZQSVkzNVlSSjZJdjRxYzhjdWFFVWs2RTJmRkxuTEtsUC9JWTVhVWtTZmlQeUpuL1BIZU4vWHQzbG12am8yeDNsMXF2ejFaMzFhTlV4dWREK3ZCT3V2UG5UV3FmQ3JUVjIxL3JWV2hjMTJ3cDZIbXhwME9pMGR4Rk1jRWRsd2s4Mnc1aGIybGtzeEpaNE1tLzZZSFNWMW9uTU12UmhvbFQxRkRMemV0NkZXNmlpTGNhWW9QV0t3dVN3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVZQUFvQUFBQUFCZkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjROV050WVhBQUFBRThBQUFBTWdBQUFEd0hUZjFhWjJ4NVpnQUFBWEFBQUFKSUFBQUN1UE8ydjVOb1pXRmtBQUFEdUFBQUFDOEFBQUEyS0ZUVERXaG9aV0VBQUFQb0FBQUFJQUFBQUNRRnZnR2JhRzEwZUFBQUJBZ0FBQUFRQUFBQUVBbjhBS2RzYjJOaEFBQUVHQUFBQUFvQUFBQUtBY0lBMUcxaGVIQUFBQVFrQUFBQUdBQUFBQ0FBQndCWWJtRnRaUUFBQkR3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRkRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXFtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVY5a1p2Z1A1RE16TUlLRUdSRXEvZ09GQVFIZkRpa0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5cVl6WC96L0g4aFBBOUgvWi84eEFxc0NBZ0NsVXdtbEFBQjQya1dSd1c3VFFCUkYvV2FjbVNST1BIWnNqMXZIZFpNNHRvT1VKbTNpT0ZJd1Nad0FhaWkwUlVLdENpZ1ZTTjJ3UUpVUUV1SWpRRUlzMlBJWjdQc0RmRXdYYkZyR0ZSTHpkblBmays2NVZ3THA0TGFQM3FIZjBseVNBRE1nVkFYYUNxTXBETG5OQ2VYYk1JVVo5a21ZMk1NcGpNWC9nTnNxK0dFVUp1T3dEeXBpTUV3NGllRG5SSk0xcDVUdGRTWUFiU3ZFd0xZWlkrMG0zdXF4cHg0eTJITm1xWHpoMzBzQmZDNTB6V09zVnZQS1JlYzhsK0g3emRVVGZSNmJTeHo2WGdPMVNhU1VFTWdIMW8vclU5eWljSHBXajhLZy9WK0N6WERuaTl3cWdpUWVrcnEzT3lpQUs2a25MWE1hUVVMdVNJUmprMUNiRDNraUFHWUNzZ2RSTXM3SEExdFFpUVU4Z3lRU1VJVG1FWEI3a0sraTVtWHB3NmYrV2haK2RRNXF6ZFdiWnVxN25OcmpWWGFHY01iMDFWbG5WTVZPcldyQnR6NEcwNHFkWmNQU2RBZ2piK0ZXS0h5K3lmb3ZNYks2VzAzRFVMeHlBWUhpYnU0MlhnOWxPRDIrT0RUWVF3eHRybkhROUpzL3Y1Z1MrREowUm1FMlB4cEQwR0RWTzdiZDIydjBWZlMwa2s0RW04MU5HdVZXU1k2WXpIQXlpc05JQUt2UWh4N2szbk0wazJGaWtYOHdlVnQ1SEdOUnJNMnBLRmNFY0hja1N1Ym9wR1ZYaC9YSlJ2M1JTWHFPb0d3d2lwamh0WlFDTFNzRU9LdEVYbmNHTXFOMkFUVVMvMEhUYlZlbWFYRlNRRzhYanoxYTRBQmt2WUdoSGd5ZUlYblBpZUdTb2cyNWVQRW04STVsaVBkOS8raitWa20xWElCNXoxUUFJVzNwOGdaQTNDM3IyZWJhTVp3Um10NGZmSXkxZ0hRT1YrK3huRmJVUlZyYUQxNjhHaHdpdkU2enB1YUlPUDRDMHJWY3VIamFZMkJrWUdBQVlrOEppZTU0ZnB1dkRNd3NEQ0R3MlBvRUo0TCtyOHQwak9raWtNdkJ3QVFTQlFEMTdBbGNBSGphWTJCa1lHQm0rTS9Bd01CMGpFSG4vd1dtZmdhZ0NBcGdBUUJuMndSZEFzWUFBQUk2QUVzQ09nQXNBc0lBTUFBQUFBQUFaZ0RVQVZ3QUFIamFZMkJrWUdCZ1lRaG5ZR0lBQVVZR05BQUFDV2tBWUhqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFMEFBQUJncW9aaU9XTnRZWEFBQUFGRUFBQUFNd0FBQUR5ZU5XU2xaMng1WmdBQUFYZ0FBQUNvQUFBQXNORmM4SXRvWldGa0FBQUNJQUFBQUMwQUFBQTJLUjdUUzJob1pXRUFBQUpRQUFBQUhnQUFBQ1FHbHYva2FHMTBlQUFBQW5BQUFBQU1BQUFBREFoekFJQnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEZ0FXRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFqYm1GdFpRQUFBcHdBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFEYkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNnNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBQUJCZ1lIR0R1bHVDeWRnVTNKNW9FQnMrSWZJd1lHWmtYbWMwQmhSb1RxLy84WkdBQTEzdysvQUFBQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWm1SZ1VySjVZUEQvUHdNRGhMNTdWUDRTV0JVUUFBQ3NCQW5YQUhqYVkyQms4R2NvWjNabTdHUlFaR0JnNUdOazEyTldCNUlpYk94c2F1cDJqT1p5ek9KQTBzVE0zRXdNcUNvMXdqb3hJTXpjdzUrWmpZZVpsNUV4SmNJbUlTak0xQ09BbVkyYm1ZOHhJYktIaGNuZTM1cVJKY21hUjVhUmtWY0dTWUJiRGlqQXdNaGd5S0RPYU1Ka3c4QUh0SStaVFk5UjNWd1laQStqdUJpajVrRjJBVGttMW5ZV0NWa0paVVlteHNmL0lrU1llYmtFR0hmektUSXl5a2x5TUFBQVkvRVltSGphWTJCa1lHQUE0cHZUTlM3Rzg5dDhaV0JtWVFDQng5WW5PSkZwNW9sTU5rQ0tnNEVKeEFNQUdSTUl6QUFBQUhqYVkyQmtZR0JXL0dNRUpDY3lHRExJTWpzekFFVlFBRE1BUW1BQ2dBQUFBNUVBQUFPUkFFOEJVUUF4QUFBQUFBQTRBRmg0Mm1OZ1pHQmdZR1pRWWdEUkRGQVNDUUFBQkFvQUtRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU04QUFvQUFBQUFBNlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDA1bU50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNVWjJ4NVpnQUFBV1FBQUFDQUFBQUFnQUdRVnpOb1pXRmtBQUFCNUFBQUFDMEFBQUEyS0d2VDdXaG9aV0VBQUFJVUFBQUFIUUFBQUNRR0FRSWxhRzEwZUFBQUFqUUFBQUFJQUFBQUNBV0FBQ0ZzYjJOaEFBQUNQQUFBQUFZQUFBQUdBRUFBQUcxaGVIQUFBQUpFQUFBQUZnQUFBQ0FBQlFBb2JtRnRaUUFBQWx3QUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRExBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbU9zQTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCa1p2Z1A1RE5EcEpIVS9BY0tBd0RxeUEweWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpTy8vOUR5UDhId0h3R0FGS1hCcDBBQUFBQUFnQWhBQUFDM2dMZUFDTUFKZ0FBQVJNZUFUY3pGU1lyQVFjMUZqWTNMd0VqQndZVkZCWVhGU2NITlRJMk54TTJGeklXQndNekFaamRCeU10RWtKRVMwZ1hPd01ETi8wdkFpY21kbWdxT2c3VUJSUUxDVE55NWdMSi9ZQVpFUUVnQXdNZ0FRa1dENXlHQndnVkhnRWdBd01nSFNjQ1pSVUJDbjMrc3dBQUFIamFZMkJrWUdBQVlzMnEzOC9qK1cyK01qQ3pNSURBWStzVG5NZzAwejJtZTBDS2c0RUp4QU1BSnlFSjFnQUFBSGphWTJCa1lHQm0rTThBSWhrVUdaU1k3akVBUlZBQUV3QTFUUUl0QUFBQUFvQUFBQU1BQUNFQUFBQUFBRUFBQUhqYVkyQmtZR0JnWWxBSFloQmdaRUFEQUFTREFDNEFBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVNrQUFvQUFBQUFCVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDFFV050WVhBQUFBRTRBQUFBTXdBQUFEd0FXQUNjWjJ4NVpnQUFBV3dBQUFIVEFBQUNBQmc4em54b1pXRmtBQUFEUUFBQUFDOEFBQUEyS01YVDFXaG9aV0VBQUFOd0FBQUFIZ0FBQUNRR1hnSWthRzEwZUFBQUE1QUFBQUFRQUFBQUVBdWdBSUJzYjJOaEFBQURvQUFBQUFvQUFBQUtBVlFBc20xaGVIQUFBQU9zQUFBQUdBQUFBQ0FBQndBNmJtRnRaUUFBQThRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRW1BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzRTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaFp2Z1A1RE5EcEpIVS9BY0tBd0Q1cHcxZGVOb2Rpb0VKQUNBUUF1OHJtcUFoV3VPcHZXc3prd1E5UklFQ1ZIczQ0N014elc2RzEyUkw3c21TZEhYK3kzcVFYUWp1QUhqYUhaQTliOU5RR0lYdnVXOThiejRjTzZxRGJ5U0lvelJwM0ZSeWdtckxEcFZJRVZFcjZOQ1VGcFdvVkZRTUJWR0pMN1dxT25USVVJUkFNTEFnSVVabVpoWitRQ2NtVmdiWUVEOEJKZUdHOTB6dk16M25NTTdxa3duL3lYK3dObHRrTEVHY0xMcktLYnBoN0lvMnBOL3dvMWk1Y2RKR1ZZcWlxMkpsUWZNcERydElRdnFDZlZITUMzVGQ0QUpNNDJpWU5wRFBPUkZsNUhpeW5yL2s1QWw1NCtIQWhKbVo3WDc0VXozbTJ3Vms3TkhRdGFrc1FRU2V0aVZncWdjclo4VjZBZHkyeEJSbmJZSGFPVGFaUHJCdzhwdHkvRHZyNkljczFMVFpNcUtHYjBFS0cwSjVTTFNtVm9vcjhDQ2s1aTM0Y1RLTnExeVY2QnFVdlVZaW16SEFzZDFmZVhGNTlhSndrVHE5T2I4WFI0RklaYVJCd1dyemVlL2tJOUZXdEhaNHR0V2NGemNzbVB4OC9OZVM0Tkp1N0J3QXZjNWdyN1FiSE4vbm1GMW83Wlp5QURjZlg1OExRZStIcjQ3V29rMUsxZWVzdnNWSnUzUFduSXdvNFY5WmlRVjZZeWYyaFI2MTZrRUpPVTFWL04vWUlkMGpWTk1LeTRqOUZtU3RJVDY5UmM4cjJCZ2Nub0w2QzUyRDRmaHoyYmFXdkY5dlVvRDErdDZKV2lxbFo4QWZyVCtwT0J2OFNvR29yT2Q3OS9UbHM2dkJiU0pQQUE3dmpiN05pQ3hTRzVWYmQ2dDMvUDBkd05acS93QzZ6MVZnQUhqYVkyQmtZR0FBNHYzK0dlTHgvRFpmR1poWkdFRGdzZlVKVGdUOS95V3pPZE5kSUplRGdRa2tDZ0FUY1FvZkFIamFZMkJrWUdCbStNOEFKUDBaVlA1ZllEWm5BSXFnQUJZQVZTb0RpQUFBQW5ZQUFBTUFBQ1FDMndBekEwOEFLUUFBQUFBQVZBQ3lBUUFBQUhqYVkyQmtZR0JnWWJCa1lHSUFBVVlHTkFBQUJuc0FRbmphVFk2eGFzTXdFSVkvVThkUXA5Q3BIVG9VVFJtRmpmc0FnUXlac21Zc0pKRUlEa2dLc21QSUV2b0FmZWhlRkEwOXdmSGRkNytFZ0pvYkJmY3FlRTM5WGlXVlRBK2VNZWN0Y3lWSFphNzVZTUVUUmZrczVwTmw1cElYdmpQUGVPZVV1UkwvazdubWk5OVZjT2ZMYUtQYUJHT2pQempYdDgzV3hxRVBYclc2ZVlpMTlUYnVSbXZVL3FyTTFBL1QwYWxPTjdwalJjQng1c0tJSmNyUE5tSk1ZczlCZG82ZWxvWnRjb05NUVRaS25CYjdQN0dXaEUrcFhYck5TR3JQVmJwaGtzd2cvU2hwUlpmdWFyby8zL1F3dXdBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjcge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjgge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4xNTI3OSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctMjEuNTE3MTUnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU1LjEwNTAxMycgeT0nLTI1LjEzMjUxNCc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI4LjQ1Mjc0LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjQuMTc0MjcsNDAuMTc5MTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy0yMS41MTcxNSc+RDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4MS40MjcsNDAuMTc5MTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy0yMS41MTcxNSc+QzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMTAuMDYxMDIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTYyLjU3NzAxMicgeT0nLTIxLjUxNzE1Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU2LjkwNTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS43NTI3MiwtNDUuMTc5MTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy0yMS41MTcxNSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTUuMTA1MDEzJyB5PSctMjUuMTMyNTE0Jz7ugLA8L3RleHQ+CjxyZWN0IHg9Jy02Mi41NzcwMTInIHk9Jy0yMC4zMjE2OTcnIGhlaWdodD0nLjM5ODQ4NCcgd2lkdGg9JzEwLjI2NzA3MScvPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ljk0OTAyIDguOTI3NTVMMjMuOTAzODUgMzUuODUzNDInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC41NTQ3NiwwLjgzMTk1LC0wLjgzMTk1LDAuNTU0NzYsMjQuMDQyNTQsMzYuMDYxNDIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTTguOTQwMTIgMTcuMzQ4NDZIMjEuMTkwMTJWMjguMjI1NTZIOC45NDAxMlonIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDExLjk0MDEyLDIwLjg0ODQ2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjIuNTc3MDEyJyB5PSctMjMuMTk5Mzk0Jz7iiLw8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTYyLjUyMTY2MycgeT0nLTIxLjAxOTAxOCc+PTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00zNy4yODY3NiA0Mi42NzkxMkg3My4wOTkzMycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3Mi45NzQzMyw0Mi42NzkxMiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lam9pbj0nbWl0ZXInPgogPHBhdGggZD0nTTMuMzk3MTMgMEwuMjUgMS44NzQ5NFYwVi0xLjg3NDk0WicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J005MC44NTE3NiAzNC40MzkwNEwxMDguMDQwMyA4LjY1OTAzJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjU1NDcsMC44MzE5OSwtMC44MzE5OSwtMC41NTQ3LDkwLjk5MDQzLDM0LjIzMTAzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjU1NDcsLTAuODMxOTksMC44MzE5OSwwLjU1NDcsMTA4LjE3ODk3LDguNDUxMDMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwMi4yMzg0MiwyNi44MTgwNCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTIxLjUxNzE1Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01Ny45MTA0MjgnIHk9Jy0yNC41MjM2NjcnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNTMuNzQ1NDU5JyB5PSctMjEuNTE3MTUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUwLjYzMjExNicgeT0nLTIxLjUxNzE1Jz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTM4Ljg4MTc3NicgeT0nLTIxLjUxNzE1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0zNS43Njg0MzMnIHk9Jy0yMS41MTcxNSc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMzEuNjMxNDgzJyB5PSctMjEuNTE3MTUnPikpPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBIMTA1LjAwNTQ4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwNS4yNTU0OCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTTQ0Ljk3MzMzLTYuNUg3MC4yNDA0OFY2LjU5NDE1SDQ0Ljk3MzMzWicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuOTczMzMsLTEuNzUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy0yMS41MTcxNSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTcuOTEwNDI4JyB5PSctMjQuNTIzNjY3Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTUzLjc0NTQ1OScgeT0nLTIxLjUxNzE1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01MC42MzIxMTYnIHk9Jy0yMS41MTcxNSc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNDYuNDk1MTY1JyB5PSctMjEuNTE3MTUnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC41NDQzMS02LjQwOTczTDQ0LjE3OTY0LTMzLjEzODgyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzk5OTYsLTAuNjAwMDIsMC42MDAwMiwwLjc5OTk2LDQ0LjA3OTY1LC0zMy4wNjM4MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lam9pbj0nbWl0ZXInPgogPHBhdGggZD0nTTMuMzk3MTMgMEwuMjUgMS44NzQ5NFYwVi0xLjg3NDk0WicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEuOTg3ODEsLTI4LjU3ODg2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctMjEuNTE3MTUnPs+RPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01Ny43NjYwNzEnIHk9Jy0yMC4xMzQ4MzcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTUzLjc3MDYwMScgeT0nLTIxLjYwMTU2Nic+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjgnIHg9Jy00OS42MDU2MzInIHk9Jy0yMC4xMzQ4MzcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQ2LjkwNzM3NycgeT0nLTIwLjEzNDgzNyc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y4JyB4PSctNDMuMjM4ODInIHk9Jy0yMC4xMzQ4MzcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTY4LjM3MzY2LTM0LjA3OTcxTDEwNS4xMDU1MS02LjUyNTUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNzk5OTMsLTAuNjAwMDUsMC42MDAwNSwtMC43OTk5Myw2OC41NzM2NCwtMzMuOTI5NjkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzk5OTMsMC42MDAwNSwtMC42MDAwNSwwLjc5OTkzLDEwNS4zMDU1LC02LjM3NTQ5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OS4zMjM1MywtMjguOTY4NjEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02Mi41NzcwMTInIHk9Jy0yMS41MTcxNSc+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy01MC44MjY2NzMnIHk9Jy0yMS41MTcxNSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDcuNzEzMzMnIHk9Jy0yMS41MTcxNSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDMuMDQ2NzQ2JyB5PSctMjQuNTIzNjY3Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTM4Ljg4MTc3NicgeT0nLTIxLjUxNzE1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0zNS43Njg0MzMnIHk9Jy0yMS41MTcxNSc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMzEuNjMxNDgzJyB5PSctMjEuNTE3MTUnPikpPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram, node distance = 4cm,baseline = (2.base)]
        \node  (1) {$A'$};
        \node  [right = 1cm of 1] (ref1) {};
        \node  [above = 1.5cm of ref1] (2) {$D$};
        \node  [right = 2cm of 2] (3) {$C$};
        \node  [right = of 1] (4) {A};
        \node  [between = 1 and 4] (ref2) {};
        \node  [below = 1.5cm of ref2] (5) {$\underline {A'}$};
        \draw  [->,morphism] (1) to node[desc] {$\cong $} (2);
        \draw  [cover,morphism] (2) to (3);
        \draw  [>->,morphism] (3) to node {$f^{*}(\mathsf {Img}(g))$} (4);
        \draw  [->,morphism] (1) to node[desc] {$f^{*}(g)$} (4);
        \draw  [cover,morphism] (1) to node[swap] {$\vartheta _{f^{*}(g)}$} (5);
        \draw  [>->,morphism] (5) to node[swap] {$\mathsf {Img}(f^{*}(g))$} (4);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Then by uniqueness, <fr:tex
display="inline"><![CDATA[C \cong  \underline {A'}]]></fr:tex>.
      Thus, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f^{*}(g)) \cong  f^{*}(\mathsf {Img}(g))]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>  
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>829</fr:anchor><fr:addr
type="user">ct-000R</fr:addr><fr:route>ct-000R.xml</fr:route><fr:title
text="Frobenius reciprocity">Frobenius reciprocity</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be a morphism in a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>. Then for any two subobjects <fr:tex
display="inline"><![CDATA[A' \rightarrowtail  A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[B' \rightarrowtail  B]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[\exists _{f}(A' \cap  f^{*}(B')) \cong  \exists _{f}(A') \cap  B']]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\exists _{f}]]></fr:tex> is the left adjoint of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> constructed in <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>830</fr:anchor><fr:addr
type="machine">#295</fr:addr><fr:route>unstable-295.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By the construction of <fr:tex
display="inline"><![CDATA[\exists _{f}]]></fr:tex>, this is equivalent to showing the following isomorphism.
    <fr:tex
display="block"><![CDATA[       \mathsf {Img}(f \circ  (A' \cap  f^{*}(B'))) \cong  \mathsf {Img}(f \circ  A') \cap  B'     ]]></fr:tex></fr:p>

  <fr:p>Form the following diagram, where the front, left, and right faces are pullbacks.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="bf49bce97599e5b73ef05c076baf2bb8"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMyMy44MTk1MzdwdCcgaGVpZ2h0PScyNDIuODk0ODU0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMjE1Ljg3OTY5MSAxNjEuOTI5OTAzJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUklBQW9BQUFBQUJPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFZ4MXNtTnRZWEFBQUFFNEFBQUFNUUFBQUR3QW5RQjVaMng1WmdBQUFXd0FBQUdDQUFBQnNNRXdtL3hvWldGa0FBQUM4QUFBQUM4QUFBQTJLVlhURzJob1pXRUFBQU1nQUFBQUlBQUFBQ1FITXdNZ2FHMTBlQUFBQTBBQUFBQU1BQUFBREFvMUFPUnNiMk5oQUFBRFRBQUFBQWdBQUFBSUFHWUEyRzFoZUhBQUFBTlVBQUFBR0FBQUFDQUFCZ0JLYm1GdFpRQUFBMndBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFFUEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtVG1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwbzZNcVF4TS93SDhwa2gwa2hxL2dPRkFjOENEUDhBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pLay9mOFA1SVBwL3dmK3p3R3JBZ0lBbEQwSkVBQUFBSGphSFpETlR0dEFGSVhuM0RFelRqeittZGl4UTRDMHNaRlRFQ1JBZ2kwUVNnQ2hpQllodGN1eTZMNUliRnFwbTc0QkxDcjFDWGdJSlBaSUNJa3RhM1pJOEJJazJOeXp1VDluY2I3TGlQMmNUdmtkUGJJdHRzTVkvQmI2V1JpRnNnY1hhV2VJS016eUh0cFN1Q1JrQzNrVVJnN0tZNXgyMGl3ZklzY1FHNkhrYlhyNWc4YWE1UVBOM2YzUEJ6WEFWK2EyWWV2SnZXL3dJeVZBcVdsSlFJdmZnNjVoRWFTenZ0L0NmK25GNnVRSkNkMjhubXNiUXMwUkJ6aThlZ1dRZW53Q01zNENxMUtyZ3JncWxnYTRyTklzSWVuUzJGTHExK1NLRlFYMmQ3cEt0L1RBRG91QnV4RFNnUlFsUlQrTUFpSEREMFhXUEJzaHl4T1JiZzZ5cUYvMjd5cXhrbmVrdEllNHdDMy9FRWdoOGJ4bFYzU3p0cmNhSDNNczFaZDVVSGNkZjJGeFJ0Zm10ZlhkOWdQM2h5T01obWtuM3o1OUtTemhNb2RxZWE3ZmpLcXFjV1lISmpkd01ia2V4anRMelQ0aDdzWXg3K2gyVllJb3E0OU9MMCszSWV5Z2dxL3Rqd05QOXd3c3JwUVcwWEZNUXNNYi9ZT1l0VGdZZXdOejFqbGZBQUI0Mm1OZ1pHQmdBT0pkSnNueDhmdzJYeG1ZV1JoQTRMSDFDUzRFL1YrWCtUalRYU0NYZzRFSkpBb0FGWUlLR0FCNDJtTmdaR0JnWnZqUHdNREFvc3FRK2Y4NzgzRUdvQWdLWUFZQVpUOEVXZ05VQUFBRUpRQnBBcndBZXdBQUFBQUFaZ0RZZU5wallHUmdZR0JtOEdSZ1lnQUJSZ1kwQUFBSDhBQlJlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ3dOcUZnWW1WcVF0Z0YyV3dqWndRQ2FucTJOL2RoL0hRTjF5ZCsyRUROVDhVM0s5Z2x2UitKWlc0QjFkTW1XZWVpSHZMWExQZ25TZUs4bG1TVno0eWw5SjhacTU0NFN2elJQTHZ6RFVyZmpmQlhhNkRqV29YakkzKzVGeTMzdHZZZDhHcnBXNlMzMXB2NDJHd1JoMXZ5b3hkUDU2ZGFuV2pXellFSEJldURGZ2lpcDBrSnJIbkpKMmpZODArSmIxd2tGeXhSTlA4NjdmUys3UTVwSitNYkk3Y1JBMmpMSHJSczJ3VmJYcXBhZjhBeUJFdjd3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT01BQW9BQUFBQUJCd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncWs2VCsyTnRZWEFBQUFGQUFBQUFNd0FBQUR3aVlTSTZaMng1WmdBQUFYUUFBQUM4QUFBQTVFUEJQS3RvWldGa0FBQUNNQUFBQUM4QUFBQTJLS3JUdzJob1pXRUFBQUpnQUFBQUhnQUFBQ1FGeGYrQWFHMTBlQUFBQW9BQUFBQU1BQUFBREFmK0FIQnNiMk5oQUFBQ2pBQUFBQWdBQUFBSUFEUUFjbTFoZUhBQUFBS1VBQUFBRndBQUFDQUFCUUFtYm1GdFpRQUFBcXdBQUFEVEFBQUJQcTgzZGVGd2IzTjBBQUFEZ0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtV3NVNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1c1NzNUltczlRZlRRWUdaaW5tNjBCaFJvVFMvLzhaR0FBRkdBNThBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZTklBMEc1Qm1aR0JTWWxiUy9QK2ZnUUZDMy8xMzl5WllGUkFBQUk0T0NOa0FlTnBqWUdTdy9QK2ZpWkhwQklNc0F3T2pvQmlidWlLYm1vbVp1S0lnR20wbXhzVEF5Q3Z4cjRGWFRJeVhzZnJmWkY1UlVWN0czSCt0WUg2REJDL1Rvci9Oa3J5TWpPeXk3SXlNYWlnVUg5Qm9CdlAvcjVpS21WSVlWQ0QyS0ttWkM1cXBxZXN4c3F1eHN3RWhUTWllMGN6WVNGeE1YSXlwQ0t5WlNkSkNLMXpGeUVWSjFwb0ZMTURpS3hHY0dCMGtLT0ROMlBxdmswOU1qSSt4U0R4UVhVcVlrVkdNVzF3ejZsOHZXS3dpMDV4Zlg1dVR4NHdCQUl6TUpOTjQybU5nWkdCZ0FPSWRueVNYeC9QYmZHVmdabUVBZ2NmV0o3Z1E5UDlYekRKTUo0QmNEZ1lta0NnQU4ya0t6d0I0Mm1OZ1pHQmdsdnFqQ1NSbEdNd1p6Sm1LR1lBaUtJQVpBRHM5QWtvQUFBTWNBQUFDT0FBNUFxb0FOd0FBQUFBQU5BQnllTnBqWUdSZ1lHQm1VR1VBMFF4UUVna0FBQVJWQUN3QWVOcE5qckZxd3pBUWhqOVR4MUFua0trZE9oUk5HWVdOOHdDRkRKbXlaaXdra1FnT1dBNlNZL0JTOGdCOTZGNFVEVDNCOGVtLzc0U0FraDh5SHBXeGpQMVJPWVhjbmp4anpsdmlRbzVLWFBMQmloZXkvRldTVDc0UzV5ejRUanpqblV2aVF2Sjc0cEkxdjV1K3U5NEc2OVd1TjlhN1V4ZW11dHBiSDlyZXFWcFh6MkJybmZXSHdScDFuSlFaMnpDZU85WG9TamRzNk9tNGNtUEE0dVZuTzBsTVpNZEpab0dKbW9wOXpBS3R6SjE0TlZyUy84WldEQmV0UTN6TmlIV1VtUklhWlM5SVA0dXZhT0t1cHZrRENWRXhFd0I0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0dIVEVtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHVPeC85WGorVzIrTWpDek1JREFZK3NUWEFqNlB5UFRaV1lRbDRPQkNVUUJBQ1Q4Q2JVQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRQUFBb0FBQUFBQklnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUUwQUFBQmd5bU5pZDJOdFlYQUFBQUZFQUFBQU5BQUFBRVFsK3dLeFoyeDVaZ0FBQVhnQUFBRW1BQUFCU0JrODJ5cG9aV0ZrQUFBQ29BQUFBQzBBQUFBMktlTFRUV2hvWldFQUFBTFFBQUFBSHdBQUFDUUYvUURiYUcxMGVBQUFBdkFBQUFBUUFBQUFFQXY4QVcxc2IyTmhBQUFEQUFBQUFBb0FBQUFLQVBnQWdtMWhlSEFBQUFNTUFBQUFHQUFBQUNBQUJ3QTJibUZ0WlFBQUF5UUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUQ5QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0rczg0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFBQkJnVUhHRHVsdUN5ZGdVMUovSUVCczlZZlN3WUdaaTNtNDBCaFJvVHEvLzhaR0FCSjlBLzZBQUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FBdVdVeEZXZlBURDQveC9CdXZ2cWxvejhaYkJhTUFBQUc3Z016SGphTFkvUFNnSlJGTWJQZDY3Y2l6a3pPYzUxL2xDTk50TE1ybERNZ1FoN0JxRm9FMGtFQTRvdWN1dW1kV21QWU5DdVorZzFXclR3T1lJMjB1M1A1anZuZkI5OC9BNkJucWpGdDFoVGx3aDVyK05ydVEwLzhBTUg2UkVha09vUTNUTW9tU1dwbVdtV1puMTBHc2pTNDI0djl3T0ZoMmNyMHE1OHZiendHRG9xdjlpU0U5ZVQxdU9CdE91aDhUV2pIdG9yUzNwdXdoWHNETXM2Y2JpL3Q2L0Ntb2E4S1U1aWdWclFMczdyMEVuMVB5Z1BpL2FXWFFNM3JvbVk3a254REY5VW9jQ1FPakJjaGlTUElZeWEzVGd4ZUNhV28vRkNpTVY0dFB3Y1RKZ25nOEdVZVFvYUxZWEpmblh6OFdQL2hSTlRSa1BLTU9kVHFwcER5SmI1TWZkTWE4Y1BwTUxkdTdSOFQ1UldJb3FqRkNoaHZibHlsYktyZUhPYWFPNWFGbjBEeXhvME13QUFlTnBqWUdSZ1lBRGlqeHQ0cDhmejIzeGxZR1poQUlISDFpZTRrR21XVUNZYklNWEJ3QVRpQVFBUWxnaHZBQUFBZU5wallHUmdZTmI2WThuQXdCTEtFTS9nd1ZURUFCUkJBU3dBU1pNQzNRQUVWUUFBQXZJQWpnTHlBSUFCd3dCZkFBQUFBQUJVQUlJQXBBQUFlTnBqWUdSZ1lHQmhNR1ZnWWdBQlJnWTBBQUFHRndBK2VOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdvQUFvQUFBQUFCcEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hkeDRwR050WVhBQUFBRThBQUFBTlFBQUFFUUFld1IrWjJ4NVpnQUFBWFFBQUFMT0FBQURUUFBzVlRKb1pXRmtBQUFFUkFBQUFDOEFBQUEyS09mVEdtaG9aV0VBQUFSMEFBQUFIZ0FBQUNRR2pBSkthRzEwZUFBQUJKUUFBQUFVQUFBQUZBNm1BUDlzYjJOaEFBQUVxQUFBQUF3QUFBQU1BWFlDWG0xaGVIQUFBQVMwQUFBQUdBQUFBQ0FBQ1FCWWJtRnRaUUFBQk13QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRm5BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFIwWkw3SXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBbHR3NXpBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtuQmpTbUMvKy93OWtPVUpZL3cvOG4vdkhHS3dXREFENk53djJBQUFBZU5wRmtzMXJFMEVZeHVkOVp6T1RiT0xPNW11MlNkdHRONXZzK3BFbW1xUWJUZE8wVGF2MnczNVphYTFLZzZLQ0lpcUlJS2lJNEVFdmV2SGd3WXNIUWJ4NTk2Yi9nSHBTL0RlOGFlTnNRWnlCWWQ3M1llRDVQZk1TSksxK24wN2lEMUluQVNGTkNKbzFhYVV6c2w2VDJReXZBcS9BZUFlc0RqUjlSd0RMMmxDM3BHV0FVcGpmZ2JvU0hQb043dWs1STRybjVLR0VtV2xOUHRFWm1MRnlIbks3UDAvckROMW9uQUdJeUxXekNRb2lXcDU0QS96d2ZaeVhrRWorZVpZMnRIZ1dLR2lnMHlRSFNFYmZQMHJGWTVrNDBwaXFOUTFNd2VuQmo3QktDQ1dML2Q5MEd6OFNoNHlSWThweHVobDRWWENaRjFpT0Rjb1pWeWRUVnJrVDltU1FEajBHbnU5NmpOTi9kOHJrcDZjYXhNeWNNUUlwQSs1ZXZnWDBjZS8wQmNEbDFNYUQzVHREbU54M2JQamR1MnNQQWNlWFg0K1lrZHR2ZTQ4cGRPYS9MMEZpRFVjbFowQzFBZ2ZjYU05ZFRlbnJSNWRtakE3VlhFV1Fnamw2byt1YzFNQ1FmejdnamRYcUl1NSs1WlFRSUV2OUtsN0hMMlJhRlRTMHFSd1h2REJLYVVuRzVRaDBZSXJ1OFlSbVZiOFc1dTE2dmhjMEZhbUJBdXFCWkQ2OGFabWFtWS9OSE5uZkFpaG1QUlh0aUJDaTZORGhpamhsWTFxc2k2d2h1KzZCTm9BcmxXN2FRcVJTdGg3TjkwSVpYdTUrWGt4T056S3oxSFB0VVN3eVB4NUQwSmF5cjM1dFVZVzJ0VDNvZTZYaWZ3bHkzdGh6clJBRm9oYVN3LzFmK0VLeExKQk5SV1BKRFBjWjM5dWVIMHpSWUx6aCtRb3ZuSmFLbWl5Rm8vNG1JeWpMTW1uVjlocUtLSVJ2S25oTGNoVkFFUDZQZXFTQ2tMaFpzUGJWQjFzRGc4YzMyejBFUFMwNGlyUmRpRWU0cmtaS2lvUnZsNmRBRTl5SzRHamdUanBEeFVTbkhXMUY4RkwzaE0wakVvRHRERkFZTE5XV1VUdVNiOEJ0amdOYTlNckZrcjJtUVdQZWRWY25obU5HZGdoZ3VwS0pBNkk1T3lSSEFScGxQVG1UMjhtbjgrUFltYWpkYlpnbHRuOWw0U2JWMmdtajI0N05sODZjcjYwZzNXblBPR1pleGZFWFQ3MTVFUUFBZU5wallHUmdZQUJpYjZuTGIrUDViYjR5TUxNd2dNQmo2eE5jQ1BxL1BuTWsweTBnbDRPQkNTUUtBQ0ovQ2g0QWVOcGpZR1JnWUdiNHp3QWtTeGdNL2w5Z2ptUUFpcUFBVmdCY1lnUGNBQUFDeGdBQUEzQUFPZ04wQUVvQ09nQkxBc0lBTUFBQUFBQUFXQUM0QVI0QnBuamFZMkJrWUdCZ1pRaG5ZR1lBQVVZR05BQUFDWnNBWW5qYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzODtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUVlBQW9BQUFBQUJNd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFc5MG5HTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWV3RWdaMng1WmdBQUFXd0FBQUZNQUFBQmpQTndKSk5vWldGa0FBQUN1QUFBQUM4QUFBQTJLSnJUQjJob1pXRUFBQUxvQUFBQUhnQUFBQ1FHTndKMWFHMTBlQUFBQXdnQUFBQVFBQUFBRUFqOUFOWnNiMk5oQUFBREdBQUFBQW9BQUFBS0FOUUFpRzFoZUhBQUFBTWtBQUFBR0FBQUFDQUFDQUJOYm1GdFpRQUFBendBQUFET0FBQUJPQWQxS3Ixd2IzTjBBQUFFREFBQUFBd0FBQUFnQUFNQUFIamFZMkJtc21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcDZNdVF5Yy84SDhwbTVHZEhVL0FjS0F3REQ3d3o3ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVE4R2RJWmN2Ly9SN0QrNy9nLysvODBzRm93QUFEc2h3dVZBSGphVlZETFRzSlFFSjJaVzFvZ1dBU2xGZHRVYVdNTGlCQjV0TUJWRWhjU0l5cHE0a0lrU0dUamp4ZytEUk1TRXFJZjR0YUY0TVdObWtsT3ptTm1jUVlRUmdBd3BRa3dnSTJFazVnKzArU3JJVFFJeDFxV0tJN3ZVQUlPSFFEVVBVZFdkQzJsb2lKN3NtSmhVUEYxVFl5S3R1dTVmbEJFencvY1dnc0RYMjhoMDFhTzQ2NDJkWEVwNnhhV1JlNkpJUmFyY2xPU1RIeTYyRytFR0JYaWo4WlIzcTFLTko2TkdSbzVKWUZTMnFIaFpiRngvTEMwT1dFdDd3ajBlNlBtbXNwbzhESWdxUkJmTCtLOExTRUw1dzVQaDBTN3RPTW1pQ0poemJyaTNTN2Y1TnNSejJvYUIzV1JNbHVMTGo2d3lDdlZIM2hscHFsa3N0bE1WZzJSTENvRHdwMG9Ic00zMkJOQy9NTXZvZXVwcUtmKzBVcktGMTFFeGNCQ0ZyMW5xcFE4NDJYOEpiZnQzbmxUVHQ2YzlEbVdGblBNcHUyUXpWaS85dm1YempyWHhPcGJoazlzQ04vcnJEM3JlTnBqWUdSZ1lBQmlvN21oZStQNWJiNHlNTE13Z01CajZ4TmNDUHEvUGpNUDAzRWdsNE9CQ1NRS0FCS1dDWG9BZU5wallHUmdZT2IrendBazR4bmtHQVNaZVJpQUlpaUFCUUF1dndHMEFBQUNVQUFBQVM0QVl3SWdBQjREWHdCVkFBQUFBQUFPQUlnQXhnQUFlTnBqWUdSZ1lHQmg4R0ZnWmdBQlJnWTBBQUFJYlFCV2VOcE5qRDF2d2pBUWhwK29DVkxEd0lJNk1MUWVPbHRCWVdCaVlXQmlaV0lCN0tJTWNaQWRJaUZWSGZuZFBZd0h6dExwZVQvT1FNa2ZHWS9KbU1UOW1KeEMxSk1MeGt3VGowUjlKUzZaOGMwYldmNHV6aWVyeExrays4UUZIL3drSG9uL203aGt3WDNkdFpkcmI3M2Fkc1o2ZDJwRFdPNnNEMDNuMUZ4WFVXK3NzLzdRVzZPT04yV0dKZ3puVnRXNjBqVnJPbG91WE9teGVCUmJjVXhreDBteUlHL0pManFCUmxJbnJUbWE2aVhmU081aTV4Qi9NdEk1Y3BOdEdPUXF5RDVMVzFISFMwMzlEK3B0TURzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBzQUFvQUFBQUFCSVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRTBBQUFCZ3ltRmh6R050WVhBQUFBRkVBQUFBTkFBQUFFUWwrd0t4WjJ4NVpnQUFBWGdBQUFFVEFBQUJSTDU0NDJkb1pXRmtBQUFDakFBQUFDMEFBQUEyS1I3VFRXaG9aV0VBQUFLOEFBQUFIZ0FBQUNRRld2L2xhRzEwZUFBQUF0d0FBQUFRQUFBQUVBbVFBTnRzYjJOaEFBQUM3QUFBQUFvQUFBQUtBUFlBZ20xaGVIQUFBQUw0QUFBQUdBQUFBQ0FBQndBM2JtRnRaUUFBQXhBQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBRDRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVNtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBZzRJRGpKMVNYSmJPd0tZay9zQ0FXZkdQRVFNRHN5THpPYUF3STBMMS8vOE1EQUFQeXc5TkFBQUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUUF1V1V4RldmUFRENC94L0J1dnZxbG96OFpiQmFNQUFBRzdnTXpIamFOWTZ4U3NOUUZJYlBmOUxjcEdtOFNUQnBJdWd0V3RyZzBtSnRtMEZwY0pMcUlHNkNwaEg2QnE3cTdLQ2JpT0RzV3pqNUd1TG1Td2hDOVJKMStUam4rK0huSjlBcHRmR0ZkeG9SZFdLRlNGaWlqeFlrTnJwcDVuRTNIWTV6cEQyTXh0bWdoVDVQc0szZ0llZG1IQW9MaDArMlpDWEVnMnNpQ2lNRWQyNWRzZlR1SysrNHQ2YkRpSnpZWWY4ditkNHpHcDR5VUp0ZkRBSXBnK2ZDaHFHa0svTGZvRjdzSENlQnhLcjMrSjhRTVIxUmh5MjlzMEV4a1o1bjlaQk9rQ2tZbXZyV1JvRXR2cG9WMTF6eGJWb3l6dzRxZ3M2MHZTd3JMajY1bk82ZmMwVmRSbHVVWXNpN0pQVmpDRjJXTFZmVmNST2JyNWF2Mkx5cEpXdEpHNHlQeFVsb0xEaytYdVE2b0ZacytnSHdZUzljQUhqYVkyQmtZR0FBNG5WM0dHZkc4OXQ4WldCbVlRQ0J4OVludUpCcDVvbE1Oa0NLZzRFSnhBTUFEWXdJaVFBQUFIamFZMkJrWUdCVy9HTUVKQ2N5R0RMSU1yRXpBRVZRQUFzQVBka0NSQUFBQTVFQUFBSlhBRnNDVndCUEFWRUFNUUFBQUFBQVZBQ0NBS0lBQUhqYVkyQmtZR0JnWVRCallHSUFBVVlHTkFBQUJqQUFQM2phVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9GUmlZMkZnWW1YcUF0aWdESEdRSFNKRnFqcnl1M3U0SG5yRDZYay83b0NTSHpLZWsvRWE5M055Q2xGL1hQRENXK0twcUVYaWtnK1dUTWp5bVRoek5vbHpTYjRTRjd4elNUd1YvenR4eVNlUGJkZmU3cjMxYXQ4WjY5MjVEZVA2WUgxb09xZFd1b3A2WjUzMXg5NGFkUnFWR1pvd1hGdFY2MHJYYk9sb3VYR254K0pSN01VeGtSMW55UUlqYXc3UkNUU1NPbW10MEZULzhwM2tMbmFPOFpPUnpra1NKVFRJVlpCOWxiYWlqcGVhK2hmemVUQlBBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzBBQUFBMktBN1RFV2hvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaXo4eUYydkg4Tmw4Wm1Ga1lRT0N4OVFrdUJQMmZnYW1CR2NUbFlHQUNVUUFCRUFpcEFBQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTOEFBb0FBQUFBQld3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwNTJOdFlYQUFBQUU0QUFBQU1nQUFBRHdBblFCN1oyeDVaZ0FBQVd3QUFBSHFBQUFDTExsR1dXaG9aV0ZrQUFBRFdBQUFBQzhBQUFBMktKVFRIR2hvWldFQUFBT0lBQUFBSGdBQUFDUUdMUUhOYUcxMGVBQUFBNmdBQUFBUUFBQUFFQXB6QUlWc2IyTmhBQUFEdUFBQUFBb0FBQUFLQVdvQXNHMWhlSEFBQUFQRUFBQUFHQUFBQUNBQUNBQkNibUZ0WlFBQUE5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVzQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1tc000Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpFaGpadmdQNURORHBKSFUvQWNLQXdEaDVRMHplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPakdrL2Y4UDVEdUM2UDhIL3M4RnF3SUNBSlJmQ1JJQUFIamFOZEV4YjlOQUZBZncrOS9GNXlUWVBoUEhkcXZFU1J5bk5pb2lLWFd3MndvTWFtaEFyUklWS2xDSFNraEkwQTBoMUJiWU1uU0VDWUVFQ3dzYkg0QUJKaVkrQUNzRFl1UXpKT0ZjaVp2dS91OE52M2VQVU5LWnorbHYrb3YweUNvaEtaSjAxWEd0cWhNbkR1OUJqY0tvbjdoT2t2YmdxN3pxdUlsclFPWjVIR2RJWS9ZRmozaFY1OGljU3pZMDVXaFNWS0Nmcy9xc3BNN21ZNzF1NlF5NmNyaXZRU3Uxcy9kLy9STjYzMFJKVENlT1lKNEt4a0NMUWdVMDkvSFdhYlZqZ2dxRDUzRlpjQVEvY0pmSXc4akYrWlJ4K28wMHlESlprMUtySDBSYzJ2d0diQU5xQXk0WDRLclB6N3hXamt2Q0tBaTV5djdmbVd5SVA3MnVSWjRRMkQ5NHlDWjdPM3VndDh6UjhleE4zVEEyR2gvZlBUaWk2QTVPbTVieTVOWEJDYVVydDc4UEM0Q3hTOWZQVTFaWFFlOXNiQitLOG5oOVo5UElDdmtFc0xERm5nMDdOeW5FNHZRemV6NWUybVd6UHhWZUpnUWttWGZwRmZxVDNKQ1BIS0JLYkR1TU1zVHlveDB1NGFua1dVSHVqcThqZ3l0ekE0SHNDWk8wQzVXclhOQjhIUkZlWklZaVhPUHFjaXNCQWx2WW9HNWdlb1VvMUVZRHp4VERoZkxpdU9ZbkZHMWJPTUJDU3pRTHZsQ0ttbjJ2QmxQZ3crenJ3THAydWJsSk80SFhxbFQwc0NCWHg1Nk84Slo1SEM4dmJLL1FvSE5XV1ZMeVNsTVAxNDd6c1FuNUJ4a25WSUlBQUhqYVkyQmtZR0FBNHZwRndmWHgvRFpmR1poWkdFRGdzZlVKTGdUOVg0K1pqZWt1a012QndBUVNCUUFYSUFtYkFIamFZMkJrWUdCbStNOEFKRGtZVlA0ZllHWmpBSXFnQUJZQVNVZ0RBQUFBQW5ZQUFBTUFBQ1FEQ0FBckFmVUFOZ0FBQUFBQVZBQ3dBUllBQUhqYVkyQmtZR0JnWVhCa1lHWUFBVVlHTkFBQUIxb0FTM2phVFk2eGFzTXdFSVkvVThkUXA5Q3BIVG9VVFJtRmpmc0FnUXlac21Zc0pKRUlEa2dLc21QSUV2b0FmZWhlRkEwOXdmSGRkNytFZ0pvYkJmY3FlRTM5WGlXVlRBK2VNZWN0Y3lWSFphNzVZTUVUUmZrczVwTmw1cElYdmpQUGVPZVV1UkwvazdubWk5OVZjT2ZMYUtQYUJHT2pQempYdDgzV3hxRVBYclc2ZVlpMTlUYnVSbXZVL3FyTTFBL1QwYWxPTjdwalJjQng1c0tJSmNyUE5tSk1ZczlCZG82ZWxvWnRjb05NUVRaS25CYjdQN0dXaEUrcFhYck5TR3JQVmJwaGtzd2cvU2hwUlpmdWFyby8zL1F3dXdBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY4IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTQuNjE5ODMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00MS42MzM1MzInIHk9Jy0yMC44MzUxOTgnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTM1LjY4MzU4NScgeT0nLTI0LjQ1MDU2Mic+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0zMS4xMDM1MzEnIHk9Jy0yMC44MzUxOTgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTI3LjIyOTE1NycgeT0nLTIwLjgzNTE5OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTkuMTcyNTQ5JyB5PSctMjQuNDUwNTYyJz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTE2LjM3NzQ3MycgeT0nLTIwLjgzNTE5OCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtMTAyLjA4NDY0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC0xMS4xMDk3M1YtOTAuODQxNicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDAuMCwtMTEuMzU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC05MS4wOTE2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjcuNDY2NDYsLTUxLjg3NTY2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzYuOTY2OTQ4JyB5PSctMjMuODQxNzE1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTMyLjgwMTk3OCcgeT0nLTIwLjgzNTE5OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMjkuNjg4NjM1JyB5PSctMjAuODM1MTk4Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy4zMjk0NzMnIHk9Jy0yMy44NDE3MTUnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y4JyB4PSctMjAuNjM0Njk5JyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDk0LjEzODQ2LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zMy41NzY5MjQnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NS41NDEyNCwtMTAyLjA4NDY0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTkuMTc1MzcgMEg4OS4wODI5MicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OS4zMzI5MiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU0LjM3OTE0LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005OS41ODQ2NC04LjYwOTczVi05MC44NDE2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsOTkuNTg0NjQsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsOTkuNTg0NjQsLTkxLjA5MTYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwMi44NDg1MywtNTAuNjI1NjYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0LTk5LjU4NDY0SDkwLjQ4NTcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTAuNzM1NywtOTkuNTg0NjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ3LjMwMzU3LC0xMDcuMjU3NTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU2LjkwNTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzEuNTc3MzgsNDAuMTc5MTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zNC4xNjE1MzMnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMjkuMTUyNTkxJyB5PSctMjAuODM1MTk4Jz7iiKk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTIwLjI5Njk0MycgeT0nLTIwLjgzNTE5OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTQuMzQ2OTk2JyB5PSctMjQuNDUwNTYyJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTkuNzY2OTQyJyB5PSctMjAuODM1MTk4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01Ljg5MjU2OCcgeT0nLTIwLjgzNTE5OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScyLjE2NDA0JyB5PSctMjQuNDUwNTYyJz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nNC45NTkxMTYnIHk9Jy0yMC44MzUxOTgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTMxLjA3NjkzLDQwLjE3OTEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+4oiDPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0zNi4wOTg3MTUnIHk9Jy0xOS4zNDA4MTcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTMwLjkzNDAwMScgeT0nLTIwLjgzNTE5OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMjcuMDU5NjI3JyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xOS41ODc2MjgnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMTYuNzkyNTUyJyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xMC43MDQzMTInIHk9Jy0yMC44MzUxOTgnPuKIqTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMS44NDg2NjQnIHk9Jy0yMC44MzUxOTgnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNi4yMDc5NDQnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS43NTI3MiwtNTkuNDA1NTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zNC4xNjE1MzMnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNDIuMDc4NjMsLTU5LjQwNTUyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+4oiDPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0zNi4wOTg3MTUnIHk9Jy0xOS4zNDA4MTcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTMwLjkzNDAwMScgeT0nLTIwLjgzNTE5OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMjcuMDU5NjI3JyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xOS41ODc2MjgnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMTYuNzkyNTUyJyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1IDMxLjU2OTRWLTQ3LjQ3Nzk3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwzMS4zMTk0KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ3LjcyNzk3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNMTU2LjQ5MDE0IDMxLjIwODMxVi00Ny40Nzc5NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDE1Ni40OTAxNCwzMC45NTgzMSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwxNTYuNDkwMTQsLTQ3LjcyNzk3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNNjYuNjEzODMtNTYuOTA1NTJIMTMzLjc1MDk2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEzMy42MjU5NiwtNTYuOTA1NTIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J003MC44ODgzOC02NC40NjY2NEg5Ny43OTM5Vi01MC43OTQ0M0g3MC44ODgzOFonIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDczLjg4ODM4LC01OC42NTU1MiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00MS42MzM1MzInIHk9Jy0yMC44MzUxOTgnPs+RPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zNi44MjI1OTEnIHk9Jy0xOS4wMDMxNTUnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMyLjgyNzEyJyB5PSctMTkuMDAzMTU1Jz7il6Y8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTI5LjE2MDI3JyB5PSctMTkuMDAzMTU1Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy45OTg5ODknIHk9Jy0yMC40Njk4ODQnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J000Ni42MDM5LTY0LjYzNTIyTDguNzA1NTItOTMuMDU5MTcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43OTk5NywwLjU5OTk5LC0wLjU5OTk5LDAuNzk5OTcsNDYuNDAzOSwtNjQuNzg1MjIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjc5OTk3LC0wLjU5OTk5LDAuNTk5OTksLTAuNzk5OTcsOC41MDU1NCwtOTMuMjA5MTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J00xNDIuMzc1MjMtNjcuNDk2MjNMMTA4LjU4MzU3LTkyLjgzOTI4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzk5OTksMC41OTk5NiwtMC41OTk5NiwwLjc5OTk5LDE0Mi4xNzUyMywtNjcuNjQ2MjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjc5OTk5LC0wLjU5OTk2LDAuNTk5OTYsLTAuNzk5OTksMTA4LjM4MzU4LC05Mi45ODkyNiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTI5LjQyMzI4LC04OC4yNjUxNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy00MS42MzM1MzInIHk9Jy0yMC44MzUxOTgnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y4JyB4PSctMjkuODgzMTkzJyB5PSctMjAuODM1MTk4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0yNi43Njk4NDknIHk9Jy0yMC44MzUxOTgnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIwLjI4OTA4NScgeT0nLTIwLjgzNTE5OCc+4pemPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xNC4zOTI5NjgnIHk9Jy0yMC44MzUxOTgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTguNDAxNTA2JyB5PSctMjMuODQxNzE1Jz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTUuNzA2NzMyJyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004Ni43ODkxNyA0Mi42NzkxMkgxMjYuMDIxNCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMjYuMjcxNCw0Mi42NzkxMiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPHBhdGggZD0nTTQzLjI2OTA3IDMyLjQ0OTYzTDEyLjI5OTAxIDkuMjI3NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjgwMDA1LDAuNTk5OSwtMC41OTk5LDAuODAwMDUsNDMuMDY5MDYsMzIuMjk5NjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjgwMDA1LC0wLjU5OTksMC41OTk5LC0wLjgwMDA1LDEyLjA5OSw5LjA3NzUzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNMTQyLjM3NTggMzIuMDg4NDFMMTA5Ljk4NjM2IDcuNzk2ODMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43OTk5OSwwLjU5OTk2LC0wLjU5OTk2LDAuNzk5OTksMTQyLjE3NTgsMzEuOTM4NCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNzk5OTksLTAuNTk5OTYsMC41OTk5NiwtMC43OTk5OSwxMDkuNzg2MzYsNy42NDY4NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram,node distance = 3.5cm]
      \SpliceDiagramSquare {
        width = 3.5cm,
        height = 3.5cm,
        nw = f^{*}(B'),
        sw = A,
        ne = B',
        se = B,
        west = f^{*}(B'),
        west/style = {>->},
        south = f,
        east/style = {>->},
      }
      \node  [right = 2cm of nw] (ref1) {};
      \node  [above = 1.5cm of ref1] (nw') {$A' \cap  f^{*}(B')$};
      \node  [right = of nw'] (ne') {$\exists _{f}(A') \cap  B'$};
      \node  [below = of nw'] (sw') {$A'$};
      \node  [below = of ne'] (se') {$\exists _{f}(A')$};
      \draw  [>->,morphism] (nw') to (sw');
      \draw  [>->,morphism] (ne') to (se');
      \draw  [cover,morphism] (sw') to node[near start,desc] {$\vartheta _{f \circ  A'}$} (se');
      \draw  [>->,morphism] (sw') to (sw);
      \draw  [>->,morphism] (se') to node {$\mathsf {Img}(f \circ  A')$} (se);
      \draw  [->,morphism] (nw') to (ne');
      \draw  [>->,morphism] (nw') to (nw);
      \draw  [>->,morphism] (ne') to (ne);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By the <fr:link
type="local"
href="ct-0008.xml"
addr="ct-0008"
title="Pasting lemma of pullbacks">pasting lemma</fr:link>, the back square is also a pullback. Then since covers are stable under pullback in a regular category, the north edge of the back square is also a cover. The diagonal of the right face is <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f \circ  A') \cap  B']]></fr:tex>, which forms a cover-mono factorization of the composite <fr:tex
display="inline"><![CDATA[f \circ  (A' \cap  f^{*}(B'))]]></fr:tex>. Thus, by <fr:link
type="local"
href="ct-000Q.xml"
addr="ct-000Q"
title="Cover-mono factorization">uniqueness</fr:link>, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f \circ  (A' \cap  f^{*}(B'))) \cong  \mathsf {Img}(f \circ  A') \cap  B']]></fr:tex> as required.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Backlinks">Backlinks</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1564</fr:anchor><fr:addr
type="user">log-000J</fr:addr><fr:route>log-000J.xml</fr:route><fr:title
text="Subobject doctrine of a regular category">Subobject doctrine of a regular category</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>, then the subobject doctrine <fr:tex
display="inline"><![CDATA[\mathsf {Sub}\colon \mathcal {C}^\mathrm {op}\to \mathsf {Lat}]]></fr:tex> has <fr:link
type="local"
href="log-000I.xml"
addr="log-000I"
title="Comprehension schema">comprehension schema</fr:link>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>862</fr:anchor><fr:addr
type="machine">#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Each fiber <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> has finite limits inherited from <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
    By <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />, each <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> has the required left adjoint <fr:tex
display="inline"><![CDATA[\exists _{f}]]></fr:tex>.
    They satisfy the <fr:link
type="local"
href="log-000E.xml"
addr="log-000E"
title="Beck-Chevalley condition">Beck-Chevalley condition</fr:link> because images commute with pullbacks in a regular category.
    Then by construction the <fr:link
type="local"
href="log-000H.xml"
addr="log-000H"
title="Naming fucntor">naming functor</fr:link> <fr:tex
display="inline"><![CDATA[{\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{X}\colon {{\mathcal {C}}_{/{X}}}\to \mathsf {Sub}(X)]]></fr:tex> is just <fr:tex
display="inline"><![CDATA[\mathsf {Img}]]></fr:tex>, which admits the inclusion functor as a right adjoint.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1565</fr:anchor><fr:addr
type="user">ct-001A</fr:addr><fr:route>ct-001A.xml</fr:route><fr:title
text="Beck-Chevalley condition">Beck-Chevalley condition</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-0019.xml"
addr="ct-0019"
title="Heyting category">Heyting category</fr:link> and the following square be a pullback in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="d804ae405338fd0a02688b09c61d7252"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNy40MDc2NTZwdCcgaGVpZ2h0PScxMTQuOTAyMzMxcHQnIHZpZXdCb3g9Jy03MiAtNzIgNzguMjcxNzcxIDc2LjYwMTU1NCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdVQUFvQUFBQUFCdGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjB4Mk50WVhBQUFBRTRBQUFBTWdBQUFEd0FnZ0RDWjJ4NVpnQUFBV3dBQUFMQ0FBQURuUEtyWjJSb1pXRmtBQUFFTUFBQUFDOEFBQUEyS0ZUVEFXaG9aV0VBQUFSZ0FBQUFJQUFBQUNRRnFnR2NhRzEwZUFBQUJJQUFBQUFVQUFBQUZBeFVBUkZzYjJOaEFBQUVsQUFBQUF3QUFBQU1BYTRDb20xaGVIQUFBQVNnQUFBQUdBQUFBQ0FBQ0FCWWJtRnRaUUFBQkxnQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRmlBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUttZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTVdRek0vd0g4cGtoMGtocS9nT0ZBZG1BRFRnQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS1pqQmsvLzhQNUtlQjZQK3ovODhFcXdJQ0FKbU5DVDRBQUhqYWJkTkxiOU5BRUFkd3o2d2ZzUk43NDllNlRWSTNpWjExcXFaSjI2Uk9XMExhTkFXcDd4WUpTaEdDRXlCeFF1S0NRT0lUSUlRUUI2N2MrQXJjSy9YTWh3R0pTOHVhOGpoUTcyMW5EL09iLzFnQ2FlZWlnMC94cTdRdVNVQW9xSm9GV3AwblEraXlnS2thbTRZaHJKRkk1V25RSFVKZjNDK3l3SUtJSnp6dDh3NVlTS0diTWpXQlQ2dEZ1VmpTUnd2TlZZRFk1d1RvTktVMHJwR3BOdDBOMGFWSDFMZllSalF6QUlpWXFCZERTaDBuTkhLbGgxa1pQcHlmYnR2clBXOU1lQlJXTVZhVHZJNGc3L2dmdngyVHVnYkhKK1dFTitKL0paamtjMi9sZWc0azhhSFV1cGpEQnB4S2JXbWNhWVJFL1NVUkhYdXFGckF1U3dWZ1RTRGJrS1Q5N0lRUUNKVjRRTllnVFFSSzFiSVJzR0F4ZTRxMVovcnpGNTBIc3VqWFptQTVGYnZtRGFJSzA0TCsxdWdFeVlqYVd5Zk5KWk9VSE5PSDl4MENudDhyamF0KzBRYWVoQnVWZ2dZdnowZWRld1Q5MWxUTmRmT2hvU0RrSzVQejFmdGRHWTRQSCsyN2RKTkF6SW9NaXZiNWp5ODAzNGhrYUM3eDBmcEJIeHBWYWdvYlNIc1gzL0VWbmtrN21VeTBIS0ttWHNibHExbXphVGNJaFZjY2tWNVBZREllVDdJWlVGbmsxWWFsdmpzRUhsMkcyMCtaQnFQOXlxMlZtNzBDb0lkdXdUUklaWHJnb0cyb0VPVHRhTmhjQm1KYWpDR3k1dUJ3Z2lwdVZjOFpnZTdZeWpzWmFhd1hBU3h0czlVQS9IeCtWdXVDMHVtWjdZRjZyVnlyMlhWY3UrNGdCdk1CYTh1ZG1VSytHbStNRi93RnhIR1Q1YmRmOHpMTmcyc3kzRFNwSVJzMHA4bWs4TnQ1UXpqdlpNNHNnMFhtLzEwM29jM01ZalBGOFNqeFdIQzVrOW5GSHp6dnA0bklsNElGZFg0Rit2SDAzZVRvTmhjakZ5c1lWQzF2OWlEaHdVUzFSK204akVRQjZ2RlpnMmlHcmdJVURhK3lrb3dSRkFLd3ZSeFJPZUJYOFo5WXU0Mmxsb0JqYk1VNUMyQ1YxenpSZ3FLekZVTTN5Njc0a2VTOW1CcUlodEl1VjlweU43VWNTMjBteXB0VlorSy9RVWpTVHd5d2RSSUFBSGphWTJCa1lHQUE0dENVdmFueC9EWmZHWmhaR0VEZ3NmVUpaZ1Q5WDVmcEdOTkZJSmVEZ1Fra0NnQWFaUW9uQUhqYVkyQmtZR0JtK00vQXdNQjBqRUhuL3dXbWFnYWdDQXBnQlFCbVlBUktBc1lBQUFJNkFFc0NPZ0FzQXF3QVRRSnVBRTBBQUFBQUFHWUExQUZJQWM1NDJtTmdaR0JnWUdVSVoyQmlBQUZHQmpRQUFBbUVBR0Y0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVWtBQW9BQUFBQUJmUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUYyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1haMng1WmdBQUFXUUFBQUpZQUFBQ3VKSGpjY2xvWldGa0FBQUR2QUFBQUM4QUFBQTJLTVhUeVdob1pXRUFBQVBzQUFBQUhnQUFBQ1FHWGdJbGFHMTBlQUFBQkF3QUFBQVVBQUFBRkE2b0FLdHNiMk5oQUFBRUlBQUFBQXdBQUFBTUFXSUNERzFoZUhBQUFBUXNBQUFBR0FBQUFDQUFDUUE2Ym1GdFpRQUFCRVFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGR0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtZXNjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJoWnZnUDVETkRwSkhVL0FjS0F3RDcxUTFqZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1Fndmd1Ly84RFNjZi8vLzhmQVBNWkFGTEtCcUI0MmpYUnYwOFRZUnpIOGVmemZOdm5hR252S2xmdWFxRFhsSlllWUZvSXZkd0JpY1ZRcVFpeC9LaEJnbzFFRXlTU2lEOUFaR0RvZ0RFYUdJd0ppWEZ3ME0wNHV6ZzVNVG01T3FpVDhVOHdiWDJPaE9kWm5ueHp3L3Y3T3NaWnR0M21QL2tQTnN4R0dmUGdlcU9HcWNlTm9tdUlZU2gyem5aYzAzQzlZYVFWRVRkTTExUWg1LzY0V0lKWHBNOVlGL0dvUU1uSWR5TVMzR2wwQkJIdDFCMEtLYTEyTmRxclJ3blI0TVpLQkpGUVgrbk4zL1F1WDQ0aHBEVWJoa1pKQlVUZ0hab0NSTXk3MHdmeGJBeGNVNFUvRG1zQ21STXNNWG1JWFdnM1NmQXZ6R0pEYkV5VzZrN0dGckl0YmFGYmhXTEJGQnFFa2hhbnZib2Y1K2JzVEU0b2RQWW0rVUh4dzFHUG5kUTByTlR2VUtNMlZ3Ty9FcnYycFBXNlYxVW5ySGZIYXpzY2hmSkJTZzl1SGRaM09SK1orVm9KQU9vQ0h6L0hxVmNCWDV5WTNkREMxZkc1S2JVVThEZUFqbWw2WE1sZTV0RE9Oei9TMDJyL0FyVitkNGt3WTJERjloL3E1Ti85WnBDS2pCU2RoSk96WmJNZmJGcndKSzlmbUlJbEY1RHpBbXpYODY5aEdxWW4xNkh3SlJMaFVCQWN5L1BUejBZcVBjSkFZUC9xd0pycjVFVWdwQVFwWHhsOFZONTdTMVJ6WnJjUGFvTURZa1pGaEorMC9xbXlXZEZ5cTV0QWVXeGxMVkhQNzk3bTZCc3ExQk9kQUkvY24rb3ZnbzRiTDNabW5TVUtaUHZWZVpXVE5PZHNVSnA3MGp6QjhyNjRld1p1Q3NXL1o5YW5ycWEvd2lSY3V3QkZxcjgvUXRtS1NlYnRmZEQ4ME5obW8vVXBxVW5pWDRjKzU4dGJlK1pFb3FNTC9GNTFLNlZMM1JoUlV2NzJWdytlUDd5WXYwNWtDUW5MeTgxdjBoR0JoZFRpemZRTmUzMFYwR1RhZi9RQmQxZDQybU5nWkdCZ0FPSmpXUkkvNC9sdHZqSXdzekNBd0dQckU4d0krdjlMWm5PbXUwQXVCd01UU0JRQU1KUUt4d0I0Mm1OZ1pHQmdadmpQQUNUOUdWVCtYMkEyWndDS29BQldBRlVyQTRrQUFBSjJBQUFEQUFBa0F3Z0FLd0xiQURNRFR3QXBBQUFBQUFCVUFMQUJEZ0ZjZU5wallHUmdZR0Jsc0dSZ1pnQUJSZ1kwQUFBR3JRQkVlTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02MS4zNDIwMzUnIHk9Jy02MS44MDM1Myc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy45MzEyNCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTcuNjg0MDUsLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPms8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuNjI3MDMsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02MS4zNDIwMzUnIHk9Jy02MS44MDM1Myc+RDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NCAwSDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY1MTgsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5oPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjQ4Njc5LTU2LjkwNTVINDcuNTcxNDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuODIxNDksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI2LjIwMjkxLC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = A,
    nw/style = {pullback},
    ne = B,
    sw = C,
    se = D,
    north = h,
    south = g,
    west = k,
    east = f,
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Then the following square commutes up to isomorphism.</fr:p>
    
      
      <fr:figure><fr:resource
hash="4e921109a6b663fb65b4091b43e7e844"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0NS41NDM3NDFwdCcgaGVpZ2h0PScxMTkuMTA2NTlwdCcgdmlld0JveD0nLTcyIC03MiA5Ny4wMjkxNjEgNzkuNDA0Mzk0Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmtBQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUN3QUFBQTJLZUxTNFdob1pXRUFBQUk4QUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQWx3QUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ1pBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSnNBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb1FBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEVkFBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpV3VrOWhmSDhObDhabUZrWVFPQ3g5UWtXWkpvbGxQRU9rT0pnWUFMeEFQN3dDSUo0Mm1OZ1pHQmcxdnBqeWNEQUVzclF4OURQbE13QUZFRUJUQUJTZ0FOQ0FBUlZBQUFDOGdDT0FBQUFBQUJVQUFCNDJtTmdaR0JnWUdJd1pRRFJERkFTQ1FBQUJjb0FPd0I0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQ1VsWVdCaVpXcEMyQ0RNc1JCZG9nVXFlckk3KzdoZXVnTnArZjl1QU5LZnNoNFRzWnIzTS9KS1VUOWNjRUxiNG1ub2hhSlN6NVlNaUhMWitMTTJTVE9KZmxLWFBET0pmRlUvTy9FSlo4OHRsMTd1L2ZXcTMxbnJIZm5Ob3pyZy9XaDZaeGE2U3JxblhYV0gzdHIxR2xVWm1qQ2NHMVZyU3RkczZXajVjYWRIb3RIc1JmSFJIYWNKUXVNckRsRUo5Qkk2cVMxUWxQOXkzZVN1OWc1eGs5R09pZEpsTkFnVjBIMlZkcUtPbDVxNmwvdjZUQkhBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5nQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTno3R050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDZ0FBQUFyS0FDSGFSb1pXRmtBQUFDQkFBQUFDMEFBQUEyS0E3VEJXaG9aV0VBQUFJMEFBQUFId0FBQUNRRWp3RzhhRzEwZUFBQUFsUUFBQUFLQUFBQUNnUkdBR1JzYjJOaEFBQUNZQUFBQUFnQUFBQUlBQ3dBVm0xaGVIQUFBQUpvQUFBQUZ3QUFBQ0FBQlFBWmJtRnRaUUFBQW9BQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRFVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXZNYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWU5Ca1p2Z1A1RE5EcEpIVS9BY0tBd0R2a1EwZWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaRWo1ejhBWXdzekFJTTdBd0NxaXBLYXV4Mml1Wm1adXgyakV6OGpIS000bUpNOG94aGdzbG15b0tjUElLS05tbUNiR3lCUG53Y2prRXMvUC9JMHJLVDVpbGEzVHd0RGtWQjZCeEQvdGxmLytwUWl5TUFBQkk0TWwwRnhOaUxtTVltenNmSXhLcGtCVDFVM1U5Qm5Wek0yTXhNVGxHQmsxd0NhSzhzWjZNUVg3Q0RFek1vcUM3V0dBbXBqMHQzWGhCMThoRmlhd1BRQVZKQ0ZNZU5wallHUmdZQURpejh5Rnp2SDhObDhabUZrWVFPQ3g5UWtXQlAyZmdhbUJHY1RsWUdBQ1VRQUVCQWkxQUFBQWVOcGpZR1JnWUdiNHo4REF3TlRBWU1sZ3lSakNBQlJCQVV3QU8yd0NVQUFDZ0FBQUFZMEFaQUE1QUFBQUFBQUFBQ3dBVm5qYVkyQmtZR0JnWnBCZ0FORU1VQklKQUFBREVBQWZBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU0VBQW9BQUFBQUJUd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMVdHTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWdnQytaMng1WmdBQUFXd0FBQUhBQUFBQ0ROQU9ldkpvWldGa0FBQURMQUFBQUM4QUFBQTJLT0xUQldob1pXRUFBQU5jQUFBQUhnQUFBQ1FHUXdKUGFHMTBlQUFBQTN3QUFBQU1BQUFBREFrWUFQcHNiMk5oQUFBRGlBQUFBQWdBQUFBSUFISUJCbTFoZUhBQUFBT1FBQUFBRndBQUFDQUFCUUJmYm1GdFpRQUFBNmdBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFFZUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtNW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F6TS93SDhwa2gwa2hxL2dPRkFiR0xETW9BZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpGay8vOFA1SVBwLzdQL1R3ZXJBZ0lBbVVrSk9nQUFBSGphSFpBOWN0TkFHSWIxZmxydnlyWitMRm5lZFp6WXhKSm5aVHUyVEpBdDhXZDc2QmdHWnBJaUJRVVUwR1dHaG82aDRBQU1jSVVjZ0o2R2x1RUFISUlUMENhc011OFdXenpGOXp3V3JJODNTL3BGZjZ5bmxnVTdBQmMrQk5mWkRvVlVNUmZ5RG5hb3lqM0tLdVY2c3k1VlVmOXZKNVdQVkdlNnJQUUtpZUFCaWxMR2dndjhmZUExdzBIMFpKbThzREhyemUyNEYvamQ0YVFSUmtkaCs2WFhqWVBYUG1kOXgwdlBwODhNSXVjMjNGRW42QTVVeSsyLzgyTEhadmg4L1dPWFBKNE5Da0tTSjRtZGhlT1dBRkhaMjE5ZVhUNEU5K0ltenNiSDYwNjRZcGdzYW9SbnZrUG9kL2Jmd0EvYU5peWpaWDI2K1VmZjZiZjFxbllzS3lOMHI3NDl5N0hSUmkxSGFxVE5NN0pTU2NFVmw4cEFwb0VhbVJwbWlkR3N5a3pYUzJ0VVoxWFhoRERpSmxaNUcwajJKRDY4ZlZSVWJ3cDlDbHBFZllsZzNHUkJ1TGhZK0d0WjNPOXNHSGdENkJ6TlZzSnVlcTZEMkkyUzdlbzVnVEd3UEl4T2V6bkpZY3JZRjBady9MUWRFWEc3OGRXTlFWZlg3dzhYK1JZbmVuNE1IUHJzeEdjTmdjM0VtM29VY2JWMTFaQkZVMkpuSTc5RkpPOGVxQldyU2hFSHpqTGtyUG5UMVlTSm9rM0VPUWVaZnE0cDVLTGhNWlBwUHdvS1B4MTQybU5nWkdCZ0FPS0Zmb3R2eHZQYmZHVmdabUVBZ2NmV0oxZ1E5SDlkNWhDbXkwQXVCd01UU0JRQUxic0tTZ0I0Mm1OZ1pHQmdadmpQQUNSREdLci9mMmM2eWdBVVFRSE1BR3NnQkpjQUFBTlVBQUFDdkFCN0F3Z0Fmd0FBQUFBQWNnRUdlTnBqWUdSZ1lHQm1pR01BMFF4UUVna0FBQW5tQUdVQWVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnd05xRmdZbVZxUXRnRjJXd2pad1FDYW5xMk4vZGgvSFFOMXlkKzJFRE5UOFUzSzlnbHZSK0paVzRCMWRNbVdlZWlIdkxYTFBnblNlSzhsbVNWejR5bDlKOFpxNTQ0U3Z6UlBMdnpEVXJmamZCWGE2RGpXb1hqSTMrNUZ5MzN0dllkOEdycFc2UzMxcHY0Mkd3UmgxdnlveGRQNTZkYW5Xald6WUVIQmV1REZnaWlwMGtKckhuSkoyalk4MCtKYjF3a0Z5eFJOUDg2N2ZTKzdRNXBKK01iSTdjUkEyakxIclJzMndWYlhxcGFmOEF5QkV2N3dBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1rQUFvQUFBQUFBNFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWtBQUFCZ3FrbVVTMk50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pUWjJ4NVpnQUFBV3dBQUFCZ0FBQUFZTDd2a0xkb1pXRmtBQUFCekFBQUFDOEFBQUEyS1IvVHVHaG9aV0VBQUFIOEFBQUFIZ0FBQUNRRnV2L1VhRzEwZUFBQUFod0FBQUFJQUFBQUNBWW5BQkJzYjJOaEFBQUNKQUFBQUFZQUFBQUdBREFBQUcxaGVIQUFBQUlzQUFBQUZnQUFBQ0FBQlFBWWJtRnRaUUFBQWtRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBREZBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtYWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhvQUFIR0NPbHVDeWRnVTJKUVltQldmR1BFUU9RWkQ0SEZHWkVLUDMvbjRFQkFNc1FEY2dBQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VvTS8vOUR5SHVNWUhrR0FFazJCWDhBQUFBQ0FCRC83QUtJQXNjQUV3QVdBQUFKQVFjR0J5WW5BU2MyTnhZZkFTRTNQZ0VYRmdFYkFRS0EvdWtHQWhVVkJ2N21Cd0lZRkFaZUFWTmVCeWdFQXY0dmxaTUNtdjF4REJBREFoVUNseE1ZQWdJVzNONFZBUm9CL3ZYK3BBRmNBSGphWTJCa1lHQUFZc2M1UEFmaitXMitNakN6TUlEQVkrc1RMQWo2L3h2bWlVekhnVndPQmlhUUtBQVord3A1QUhqYVkyQmtZR0JXL0dNRUpDY3lDRER3TVhVd0FFVlFBQk1BUXpnQ2t3QUFBNUVBQUFLV0FCQUFBQUFBQURBQUFIamFZMkJrWUdCZ1loQUhZaEJnWkVBREFBTHpBQjRBQUhqYVRZdzliOEl3RUlhZmlBU0pkT2hTZGVnQUhwaXRvRlJpWTJGZ1ltWHFBdGlnREhHUUhTSkZxanJ5dTN1NEhuckQ2WGsvN29DU0h6S2VrL0VhOTNOeUNsRi9YUERDVytLcHFFWGlrZytXVE1qeW1UaHpOb2x6U2I0U0Y3eHpTVHdWL3p0eHlTZVBiZGZlN3IzMWF0OFo2OTI1RGVQNllIMW9PcWRXdW9wNlo1MzF4OTRhZFJxVkdab3dYRnRWNjByWGJPbG91WEdueCtKUjdNVXhrUjFueVFJamF3N1JDVFNTT21tdDBGVC84cDNrTG5hTzhaT1J6a2tTSlRUSVZaQjlsYmFpanBlYStoZnplVEJQQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVa0FBb0FBQUFBQmZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxRjJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDWFoyeDVaZ0FBQVdRQUFBSllBQUFDdUpIamNjbG9aV0ZrQUFBRHZBQUFBQzhBQUFBMktNWFR5MmhvWldFQUFBUHNBQUFBSGdBQUFDUUdYZ0lsYUcxMGVBQUFCQXdBQUFBVUFBQUFGQTZvQUt0c2IyTmhBQUFFSUFBQUFBd0FBQUFNQVdJQ0RHMWhlSEFBQUFRc0FBQUFHQUFBQUNBQUNRQTZibUZ0WlFBQUJFUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZHQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmhadmdQNURORHBKSFUvQWNLQXdENzFRMWplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2Z3UvLzhEU2NmLy8vOGZBUE1aQUZMS0JxQjQyalhSdjA4VFlSekg4ZWZ6Zk52bmFHbnZLbGZ1YXFEWGxKWWVZRm9JdmR3QmljVlFxUWl4L0toQmdvMUVFeVNTaUQ5QVpHRG9nREVhR0l3SmlYRncwTTA0dXpnNU1UbTVPcWlUOFU4d2JYMk9oT2Rabm54encvdjdPc1padHQzbVAva1BOc3hHR2ZQZ2VxT0dxY2VOb211SVlTaDJ6blpjMDNDOVlhUVZFVGRNMTFRaDUvNjRXSUpYcE05WUYvR29RTW5JZHlNUzNHbDBCQkh0MUIwS0thMTJOZHFyUnduUjRNWktCSkZRWCtuTjMvUXVYNDRocERVYmhrWkpCVVRnSFpvQ1JNeTcwd2Z4YkF4Y1U0VS9EbXNDbVJNc01YbUlYV2czU2ZBdnpHSkRiRXlXNms3R0ZySXRiYUZiaFdMQkZCcUVraGFudmJvZjUrYnNURTRvZFBZbStVSHh3MUdQbmRRMHJOVHZVS00yVndPL0VydjJwUFc2VjFVbnJIZkhhenNjaGZKQlNnOXVIZFozT1IrWitWb0pBT29DSHovSHFWY0JYNXlZM2REQzFmRzVLYlVVOERlQWptbDZYTWxlNXRET056L1MwMnIvQXJWK2Q0a3dZMkRGOWgvcTVOLzlacENLakJTZGhKT3paYk1mYkZyd0pLOWZtSUlsRjVEekFtelg4NjloR3FZbjE2SHdKUkxoVUJBY3kvUFR6MFlxUGNKQVlQL3F3SnJyNUVVZ3BBUXBYeGw4Vk41N1MxUnpacmNQYW9NRFlrWkZoSiswL3FteVdkRnlxNXRBZVd4bExWSFA3OTdtNkJzcTFCT2RBSS9jbitvdmdvNGJMM1ptblNVS1pQdlZlWldUTk9kc1VKcDcwanpCOHI2NGV3WnVDc1cvWjlhbnJxYS93aVJjdXdCRnFyOC9RdG1LU2VidGZkRDgwTmhtby9VcHFVbmlYNGMrNTh0YmUrWkVvcU1ML0Y1MUs2VkwzUmhSVXY3MlZ3K2VQN3lZdjA1a0NRbkx5ODF2MGhHQmhkVGl6ZlFOZTMwVjBHVGFmL1FCZDFkNDJtTmdaR0JnQU9KaldSSmY0L2x0dmpJd3N6Q0F3R1ByRXl3SSt2OUxabk9tdTBBdUJ3TVRTQlFBTUJZS3hRQjQybU5nWkdCZ1p2alBBQ1Q5R1ZUK1gyQTJad0NLb0FCV0FGVXJBNGtBQUFKMkFBQURBQUFrQXdnQUt3TGJBRE1EVHdBcEFBQUFBQUJVQUxBQkRnRmNlTnBqWUdSZ1lHQmxzR1JnWmdBQlJnWTBBQUFHclFCRWVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSUUFBb0FBQUFBQk93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWUowMjJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDN1oyeDVaZ0FBQVdRQUFBR1NBQUFCeE9iUmpMUm9aV0ZrQUFBQytBQUFBQzhBQUFBMktGVFMrV2hvWldFQUFBTW9BQUFBSHdBQUFDUUZxUUhmYUcxMGVBQUFBMGdBQUFBTUFBQUFEQWVzQUhsc2IyTmhBQUFEVkFBQUFBZ0FBQUFJQUc0QTRtMWhlSEFBQUFOY0FBQUFHQUFBQUNBQUJnQk5ibUZ0WlFBQUEzUUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUVSQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm02bU9jd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBxbU0yUXdNL3dIOHBraDBraHEvZ09GQWVHakRVMEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2Z1ovLzhEeWZULy8vL1BBdk1aQUZYR0JzUjQyaDJRelc3VFFCUkdmZTg0TTQzL0pyYmpHV2lOYThlSjdVckJidXZFQmhFYzNFUklCVkVxTnFnSXNldStFaHRVSko0QjhSUzhBbnVrdmhFU214UWJmZHV6T09kVFVKbmZQOFlaL0ZaeVphTW9RQ3hnTkVrYktFK0ZIRk1tUlNtcXVvRTFVSlpEV3RYOUFwQU4xQjFBMWxDbFNacFFScGtGUXA3MktFWTN3ODlmaWs4cXhNSVdZRG0rSFkxWHNTK1lyTS9iS3lRdHQ4K3ZzcVZKOWgzVGd4OEZnYkczMk4rRTNzaUdKQTNPZklQQjdhNHRQaEQwNW84aTE5VURiWUNnK3crUHc0K2xDdTh2cnk5Y3ZpVXdGU01CSTN2Mzl4ZlhaN0VLMlRKcFg3eXRZUlp5VStsaWxEZjNmL0FyM2ltdis3Sk9PVUJHT2ZTdUh1MWxxMUlHWFcrM1NaSXV1cGcrTDBuN0Q3aHFRWnpEc25ZYlNPTEovMHZxU2pCb0wveDNUMTh1RE1BeHVvYXBFZjl3NWFDdFVaQzZIVGZaRXlDbUpRU2l5RmFYRC9qQURZZDdtaHc2OXVDN2ludzZIQUZZYkR1ZkFmN2MzVVVsRElxRm1hL29zNE1vc2llNGZ1NGd5bU1wY3JVNE12Undlclk1OFU0UU41blFYMzFMRHJnT3JpbHdhM0pOMWZnZVU0bnhEN2pQTzhzQUFIamFZMkJrWUdBQTRzb2JiZGJ4L0RaZkdaaFpHRURnc2ZVSkZnVDlYNWZwR05OeElKZURnUWtrQ2dBa2Z3cFdBSGphWTJCa1lHQm0rTS9Bd01CMGpFR0hRWlNwbWdFb2dnS1lBVUVkQW80QUFzWUFBQUk2QUN3Q3JBQk5BQUFBQUFCdUFPSjQybU5nWkdCZ1lHYndZV0JpQUFGR0JqUUFBQWc3QUZSNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hYZDBnMk50WVhBQUFBRTRBQUFBTXdBQUFFUUFkZ0V5WjJ4NVpnQUFBV3dBQUFFNkFBQUJVQ2lDYjJkb1pXRmtBQUFDcUFBQUFDOEFBQUEySjdqVHltaG9aV0VBQUFMWUFBQUFId0FBQUNRRk53RmdhRzEwZUFBQUF2Z0FBQUFPQUFBQURnYkVBSUZzYjJOaEFBQURDQUFBQUFvQUFBQUtBUG9BaG0xaGVIQUFBQU1VQUFBQUdBQUFBQ0FBQndBeWJtRnRaUUFBQXl3QUFBRFRBQUFCUHFrcmRkdHdiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9HTTVReWMvNEg4cGs1R2RIVS9BY0tBd0M2YWd6cWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VTQ0daSVlTdi8vUjdEK3IvdS80SDhmV0MwWUFBRHVoZ3VpQUhqYVBZNnhUc0pRQUVYZmZWVWFIUXF2RFRVSUZndENvUVlxSmZDQ0dnaXhFVEVHR2pUQjZLSTRxSW5PYXRUTndkRmZjRFh4RTVnNytnTzZPRG00dW9MUEdFM3VjdTRkN2lFZ2hmRUh4dlNOTEJFQ3VRaExnV3hnNWo4Q1ExbUxHK0IxY0RIL0p2dERybzdYY0tMWGFIVkE0N0p1TDNxYktUVU5lblBzWG5qaHRTdHp2UVBNUnRSQ283Q1JYSkZ3ZmNiMzZGTXZsZ050T3lsN1VvdE1NeU9qdGR6ZDJ3a2s4OXVWZVVyOWlsbFNWQmFlTXN4bXMzc3B4UWdobE95TXYvQkpBeEloQ1VJMFZ2OHpFeWJSTk5PaU90ZXJRazVXOE9qMGsrMTlLcDEzeTU3cSs5YXFleUJKL1pMTmFUQjZXWWhCdWo4NnZhT3dWRWNVRCs4ZWhUOFlDTTJjK0FIcGlaOGhBcUlLWU9tS2duUVJuSlZaU0hlcm5HRzRaUjNhZFFjK25UdHBBY0dvVmpMamFOYlFIejJuTW53WitXK25kRUJTQUFCNDJtTmdaR0JnQU9LZVQ3ck84ZncyWHhtWVdSaEE0TEgxQ1JZRS9mOEZreGJUWFNDWGc0RUpKQW9BSW9JS1p3QjQybU5nWkdCZzV2elB3TURBWk1HZ3k2REMrSjhCS0lJQ21BRS9ZQUtjQUFJcUFBQUNPQUF0QWhBQVZBQlNBQUFBQUFBQUFGSUFoZ0NvQUFCNDJtTmdaR0JnWUdFd1pHQmlBQUZHQmpRQUFBV3pBRHA0MmsyT3NXckRNQkNHUDFQYlVMZlFxUjA2RkUwWmhZMzdBSVVNbWJKbUxDU1JNQzVZRHBKajhGTDZBSG5vWEJRTnZZT2ZULy85ZHdpbytDWGpWaGt2VVcrVlU4cnJ6Z1ZQdkNZdXBWWGlpbmRXUEpEbGorSjg4SlU0NTVudnhBVnYvQ1F1eGY5TFhQSEpaVDBPcC9Oa3ZkcU94bnAzSEVKbzZwMzFvUitkYW5SOU56YldXYitmckZHSFJabTVEM00zcUZiWHVtWE55TUNKTXhNV0x6L2JpbU1pTzQ0eUM5SU5OYnZvQlhxWk84azFhSEgvSnphU2NERzFqOWVNcEE0c29vWlo5b0pvSjNsRkczYzE3UlgrQ0REN0FIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3MxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTEuNjU4OTEsLTYxLjMyMjI3MilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNS44NzY3NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYxLjMyMjI3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTEuNjU4OTEnIHk9Jy02MS4zMjIyNzInPlN1YjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzUuODI5MzU1JyB5PSctNjEuMzIyMjcyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zMS45NTQ5ODEnIHk9Jy02MS4zMjIyNzInPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTIzLjg5ODM3MicgeT0nLTYxLjMyMjI3Mic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTYuMTExODMsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjEuMzIyMjcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01MS42NTg5MScgeT0nLTYxLjMyMjI3Mic+U3ViPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zNS44MjkzNTUnIHk9Jy02MS4zMjIyNzInPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMxLjk1NDk4MScgeT0nLTYxLjMyMjI3Mic+RDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjMuNDI5OTkyJyB5PSctNjEuMzIyMjcyJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTguOTA5NzNWLTQ3LjQ5NTc3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00Ny43NDU3NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEyLjMwMjEyLC0zMC4yMDI3NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MS4zMjIyNzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUxLjY1ODkxJyB5PSctNjEuMzIyMjcyJz7iiIA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQ3LjE0ODAyNScgeT0nLTYwLjI2NTEyNSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MS4zMjIxNCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYxLjMyMjI3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTEuNjU4OTEnIHk9Jy02MS4zMjIyNzInPlN1YjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzUuODI5MzU1JyB5PSctNjEuMzIyMjcyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zMS45NTQ5ODEnIHk9Jy02MS4zMjIyNzInPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTI0LjQ4Mjk4MicgeT0nLTYxLjMyMjI3Mic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MS4xNDA5LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYxLjMyMjI3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTEuNjU4OTEnIHk9Jy02MS4zMjIyNzInPlN1YjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzUuODI5MzU1JyB5PSctNjEuMzIyMjcyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zMS45NTQ5ODEnIHk9Jy02MS4zMjIyNzInPkM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTI0LjEyMTg2NycgeT0nLTYxLjMyMjI3Mic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMjAuNDMyMyAwSDM2LjI2NjYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzYuNTE2NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0LjE2ODI3LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjEuMzIyMjcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01MS42NTg5MScgeT0nLTYxLjMyMjI3Mic+aDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDYuOTk0NjUxJyB5PSctNjQuMzI4NzknPuKIlzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS04LjkwOTczVi00Ny40OTU3NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ3Ljc0NTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMzAuMjAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjEuMzIyMjcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01MS42NTg5MScgeT0nLTYxLjMyMjI3Mic+4oiAPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny4xNDgwMjUnIHk9Jy02MC4yNjUxMjUnPms8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTIwLjY2NzM3LTU2LjkwNTVIMzYuMDg1MzYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzYuMzM1MzYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0LjQ1OTg0LC02NS4wNjE0OCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MS4zMjIyNzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUxLjY1ODkxJyB5PSctNjEuMzIyMjcyJz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00Ny41MjE5NTknIHk9Jy02NC4zMjg3OSc+4oiXPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = {\mathsf {Sub}(B)},
    ne = {\mathsf {Sub}(A)},
    sw = {\mathsf {Sub}(D)},
    se = {\mathsf {Sub}(C)},
    north = {h^{*}},
    west = {\forall _{f}},
    south = {g^{*}},
    east = {\forall _{k}},
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>848</fr:anchor><fr:addr
type="machine">#284</fr:addr><fr:route>unstable-284.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Consider the corresponding left adjoint square.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="ed07d9d46bf3793064647aa72d9389df"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0NS41NDM3NDFwdCcgaGVpZ2h0PScxMjAuMTYxODEzcHQnIHZpZXdCb3g9Jy03MiAtNzIgOTcuMDI5MTYxIDgwLjEwNzg3NSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJjQUFvQUFBQUFCUGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFjbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUM3WjJ4NVpnQUFBV1FBQUFHZUFBQUIwRWdYV254b1pXRmtBQUFEQkFBQUFDOEFBQUEyS09MUzRHaG9aV0VBQUFNMEFBQUFIZ0FBQUNRR1dnS2JhRzEwZUFBQUExUUFBQUFNQUFBQURBbHdBT1JzYjJOaEFBQURZQUFBQUFnQUFBQUlBR3dBNkcxaGVIQUFBQU5vQUFBQUdBQUFBQ0FBQmdCUmJtRnRaUUFBQTRBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRVVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVZtV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTJRd00vd0g4cGtoMGtocS9nT0ZBYnZjRE9VQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZnWi8vOER5ZlQvLy8vUEF2TVpBRlhHQnNSNDJoMlFNVy9UVUJTRmZhN3Q1OFIrdFJQYjd6bEFIRnFiMkNta2NacTJ0cXFHcEdvb1ZFclVWcXdncEFyQkFtc0hKaVlraEFSc3pQd01aaVRFRDBKTVNDM1AxVG5EMVQxM09OL1ZTSHQxUGFSUCtLV050SVdtUVhlUnNnSlpQc05FaXBCWjhpN2tqT1p3WVkyUWwxV3RpWXpLcWdkaFZXVjlxaUlYb29kcVZwcyt2QTIvdmluMm5CMEQvWW0wVzVSc1JmTW5IZGJ4VjVQbGE5S1AyLzc1UlhKNHE1MEV3YmN0Q0NPYWJwN0l1RXY3NjRQajJHM2k4bXExUEtHbXpvdTRmOXRyZEQyVEFIczg3bDYwK29UblQxK3VBdTlJdjVQa2dIRC8vYkJUbGhnWXA4WGx4c0VReUdQUFV5RGErK3UvOUlkK2EyYzFsV3FtK2pJUHRRV0xicHJ1UkRJS0xhYWt5SGJuS0pXcjNTeTk0ZkZJZlNMTHEwQXRzd0lzcTluVkxJWEV1M1A1WW5tNnBNQU1iYytpalh6bUdnM09tNGg1ZTdBb0RxRzN1Q0NoZ3VtejlkQzFFOHZzdGxMRCtHd1FHbTdxK0VSTU43L3dFUFQ5Nm1lODBMRW83eC93L1U0ZXRsS2RIZzI5SnBFVGJvZCtvY0EydVpQM0hyTHBLQm5RNCsxZSt1QmpKeEM0RjlHZXp4Z0RnYTF4UndlSHVXYjhCODVTUGdnQUFIamFZMkJrWUdBQTRvMUJ6NzdHODl0OFpXQm1ZUUNCeDliSGZ5RG8venJNSVV6SGdWd09CaWFRS0FCc25BeVdBSGphWTJCa1lHQm0rTThBSkVNWVVobWNtVDR6QUVWUUFETUFSK0lDL0FBQUExUUFBQUxOQUdVRFR3Qi9BQUFBQUFCc0FPaDQybU5nWkdCZ1lHWUlZR0JpQUFGR0JqUUFBQWlmQUZoNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTWdBQW9BQUFBQUE0d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncWt5VVRtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSldaMng1WmdBQUFXd0FBQUJjQUFBQWFKNWdWSVpvWldGa0FBQUJ5QUFBQUM4QUFBQTJLUi9UdEdob1pXRUFBQUg0QUFBQUhnQUFBQ1FGdXdBVWFHMTBlQUFBQWhnQUFBQUlBQUFBQ0FZbkFGQnNiMk5oQUFBQ0lBQUFBQVlBQUFBR0FEUUFBRzFoZUhBQUFBSW9BQUFBRndBQUFDQUFCQUFmYm1GdFpRQUFBa0FBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFERUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1hY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeG9BQUhHQ09sdUN5ZGdVMkpXWW1aV2ZHUEVRTURzeUx6T2FBd0kwTHAvLzhNREFETHhBM09BQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJNLy85RHlMdi93UElNQUZCdEJvRUFBSGphWTJCa0NQai9uOG1ENlFTRExBTURvNkFZbTdvaW01cUptYmlpSUJwdEpzYmt6aWdvK1MrS1QwcVNuM0hPdjBJZVNSayt4cTUvS1dEK01rbEJwdmwvTzZYNEdSazVWRGdZR1NVaGxEZ2pwekluSTZNQUF3RDdOaEhOZU5wallHUmdZQURpcG5YTkYrUDViYjR5TUxNd2dNQmo2K00vRVBULy84d1RtVTRBdVJ3TVRDQlJBR3pIRFUwQWVOcGpZR1JnWUZiOFl3UWtKeklFTVBneGVUQUFSVkFBRXdCSmVBTFRBQUFEa1FBQUFwWUFVQUFBQUFBQU5BQUFlTnBqWUdSZ1lHQmlrR01BMFF4UUVna0FBQU9MQUNRQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnVkdKallXQmlaZW9DMktBTWNaQWRJa1dxT3ZLN2U3Z2Vlc1BwZVQvdWdKSWZNcDZUOFJyM2MzSUtVWDljOE1KYjRxbW9SZUtTRDVaTXlQS1pPSE0yaVhOSnZoSVh2SE5KUEJYL08zSEpKNDl0MTk3dXZmVnEzeG5yM2JrTjQvcGdmV2c2cDFhNmlucG5uZlhIM2hwMUdwVVptakJjVzFYclN0ZHM2V2k1Y2FmSDRsSHN4VEdSSFdmSkFpTnJEdEVKTkpJNmFhM1FWUC95bmVRdWRvN3hrNUhPU1JJbE5NaFZrSDJWdHFLT2w1cjZGL041TUU4QUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3MxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFhkMGcyTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWRnRXlaMng1WmdBQUFXd0FBQUU2QUFBQlVDaUNiMmRvWldGa0FBQUNxQUFBQUM4QUFBQTJKN2pUc21ob1pXRUFBQUxZQUFBQUh3QUFBQ1FGTndGZ2FHMTBlQUFBQXZnQUFBQU9BQUFBRGdiRUFJRnNiMk5oQUFBRENBQUFBQW9BQUFBS0FQb0FobTFoZUhBQUFBTVVBQUFBR0FBQUFDQUFCd0F5Ym1GdFpRQUFBeXdBQUFEVEFBQUJQcWtyZGR0d2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtVW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb0dNNVF5Yy80SDhwazVHZEhVL0FjS0F3QzZhZ3pxZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVNDR1pJWVN2Ly9SN0Qrci91LzRIOGZXQzBZQUFEdWhndWlBSGphUFk2eFRzSlFBRVhmZlZVYUhRcXZEVFVJRmd0Q29RWXFKZkNDR2dpeEVURUdHalRCNktJNHFJbk9hdFROd2RGZmNEWHhFNWc3K2dPNk9EbTR1b0xQR0UzdWN1NGQ3aUVnaGZFSHh2U05MQkVDdVFoTGdXeGc1ajhDUTFtTEcrQjFjREgvSnZ0RHJvN1hjS0xYYUhWQTQ3SnVMM3FiS1RVTmVuUHNYbmpodFN0enZRUE1SdFJDbzdDUlhKRndmY2IzNkZNdmxnTnRPeWw3VW90TU15T2p0ZHpkMndrazg5dVZlVXI5aWxsU1ZCYWVNc3htczNzcHhRZ2hsT3lNdi9CSkF4SWhDVUkwVnY4ekV5YlJOTk9pT3RlclFrNVc4T2owaysxOUtwMTN5NTdxKzlhcWV5QkovWkxOYVRCNldZaEJ1ajg2dmFPd1ZFY1VEKzhlaFQ4WUNNMmMrQUhwaVo4aEFxSUtZT21LZ25RUm5KVlpTSGVybkdHNFpSM2FkUWMrblR0cEFjR29WakxqYU5iUUh6Mm5NbndaK1crbmRFQlNBQUI0Mm1OZ1pHQmdBT0tlVDdyRjhmdzJYeG1ZV1JoQTRMSDE4UjhJK3Y4TEppMm11MEF1QndNVFNCUUFWam9NZlFCNDJtTmdaR0JnNXZ6UHdNREFaTUdneTZEQytKOEJLSUlDbUFFL1lBS2NBQUlxQUFBQ09BQXRBaEFBVkFCU0FBQUFBQUFBQUZJQWhnQ29BQUI0Mm1OZ1pHQmdZR0V3WkdCaUFBRkdCalFBQUFXekFEcDQyazJPc1dyRE1CQ0dQMVBiVUxmUXFSMDZGRTBaaFkzN0FJVU1tYkptTENTUk1DNVlEcEpqOEZMNkFIbm9YQlFOdllPZlQvLzlkd2lvK0NYalZoa3ZVVytWVThycnpnVlB2Q1l1cFZYaWluZFdQSkRsaitKODhKVTQ1NW52eEFWdi9DUXV4ZjlMWFBISlpUME9wL05rdmRxT3hucDNIRUpvNnAzMW9SK2RhblI5TnpiV1diK2ZyRkdIUlptNUQzTTNxRmJYdW1YTnlNQ0pNeE1XTHovYmltTWlPNDR5QzlJTk5idm9CWHFaTzhrMWFISC9KemFTY0RHMWo5ZU1wQTRzb29aWjlvSm9KM2xGRzNjMTdSWCtDREQ3QUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUlFBQW9BQUFBQUJRZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMHltTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWdnQytaMng1WmdBQUFXd0FBQUdNQUFBQjJBdloyckJvWldGa0FBQUMrQUFBQUM4QUFBQTJLRlRTN1dob1pXRUFBQU1vQUFBQUlBQUFBQ1FGdUFHYWFHMTBlQUFBQTBnQUFBQU1BQUFBREFkdUFKaHNiMk5oQUFBRFZBQUFBQWdBQUFBSUFHWUE3RzFoZUhBQUFBTmNBQUFBRndBQUFDQUFCUUJZYm1GdFpRQUFBM1FBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFUkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1LY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F6TS93SDhwa2gwa2hxL2dPRkFkcVhEVHNBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpGay8vOFA1SVBwLzdQL1R3ZXJBZ0lBbVVrSk9nQUFBSGphUlpFN2J4TkJGSVgzek16dWVBYzhkMk92WjBNYy9OcnhURkNDQTNHeVN5eGs4cUxKUXlnRkJDbzZrUGd0Q0ZGUTBOTHhRNUNvK1RGUUpzd3FFdHpUbmRPYzc5d0kwZG5OTnZ2QWZrVUhVUVJPU0tTR25EaS94TndVSnBGbWlDV2U4VEp4VlRGZm9nNytqaWswU3VkZFZidHRhRWFZVnlieCtMYklSTGFXSGo3ZVdBQzI1emhvU0VSMnpPL1A2SHpBdW5SSlBXMk95Z2RQZ2RLRVBCc1FkVG9EMVZwNzI4VDRjdjNqZE9WZ056L21yaHlNbUUzOG5aUkJuUFcrL3I3aUU0bXJOMzN2cHZaL2hIdnU0U2N4YVNFS2gramk1Zzk3em41R3J4cVdLblRkTWIxL1ZRTllneGVvZ25MaXVTbHVlUnBESmtFQjI5V1ZuOEVUTkNadXIrNHU0Y3JiTmVyS1NCeStHNzcybHk4ZGJGTy9HT2w4ODRWM3hlcG9sK2lSWUR3RzVXNVRjYW5TQk1oVXZyN3ZqeGxpRHB3K0tVa1ViaVgrTEJqWk5BTzBQTm1hZ24yL2ZxL1BwM3RiL2ZHWVdXMWJHbGk0Y1I0cXhLblpWMm03M3cxUEVCZVdGR01xbnZYWFoySmU2WTVPTm56OGNkRlo3YllOTzJtVEVvcGFVdkM3WVlxLzR4UTVTSGphWTJCa1lHQUFZbjNmbHh2aitXMitNakN6TUlEQVkrdmpQeEQwZjMybVkwd1hnVndPQmlhUUtBQlB6Z3hNQUhqYVkyQmtZR0JtK00vQXdNQjBqTUg3L3dXbUxBYWdDQXBnQmdCbjVBUldBc1lBQUFJNkFFc0NiZ0JOQUFBQUFBQm1BT3g0Mm1OZ1pHQmdZR1lJWndEUkRGQVNDUUFBQ1RjQVhnQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5vQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDMEFBQUEyS2VMU3lXaG9aV0VBQUFKQUFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFtQUFBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNhQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUp3QUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9nQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFdBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaVd1azlDK1A1YmI0eU1MTXdnTUJqNitNL2tHbVdVTVk3UUlxRGdRbkVBd0F5dHdxWUFBQUFlTnBqWUdSZ1lOYjZZOG5Bd0JMSzBNZlF6NVRNQUJSQkFVd0FVb0FEUWdBRVZRQUFBdklBamdBQUFBQUFWQUFBZU5wallHUmdZR0JpTUdVQTBReFFFZ2tBQUFYS0FEc0FlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ2xKV0ZnWW1WcVF0Z2d6TEVRWGFJRktucXlPL3U0WHJvRGFmbi9iZ0RTbjdJZUU3R2E5elB5U2xFL1hIQkMyK0pwNklXaVVzK1dESWh5MmZpek5ra3ppWDVTbHp3emlYeFZQenZ4Q1dmUExaZGU3djMxcXQ5WjZ4MzV6YU02NFAxb2VtY1d1a3E2cDExMWg5N2E5UnBWR1pvd25CdFZhMHJYYk9sbytYR25SNkxSN0VYeDBSMm5DVUxqS3c1UkNmUVNPcWt0VUpUL2N0M2tydllPY1pQUmpvblNaVFFJRmRCOWxYYWlqcGVhdXBmNytrd1J3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmdBQW9BQUFBQUE5UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFVOejdHTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUNnQUFBQXJLQUNIYVJvWldGa0FBQUNCQUFBQUMwQUFBQTJLQTdTN1dob1pXRUFBQUkwQUFBQUh3QUFBQ1FFandHOGFHMTBlQUFBQWxRQUFBQUtBQUFBQ2dSR0FHUnNiMk5oQUFBQ1lBQUFBQWdBQUFBSUFDd0FWbTFoZUhBQUFBSm9BQUFBRndBQUFDQUFCUUFaYm1GdFpRQUFBb0FBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFEVUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtdk1jNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwVFVZTkJrWnZnUDVETkRwSkhVL0FjS0F3RHZrUTBlZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pFajV6OEFZd3N6QUlNN0F3Q3FpcEthdXgyaXVabVp1eDJqRXo4akhLTTRtSk04b3hoZ3NsbXlvS2NQSUtLTm1tQ2JHeUJQbndjamtFcy9QL0kwcktUNWlsYTNUd3REa1ZCNkJ4RC90bGYvK3BRaXlNQUFCSTRNbDBGeE5pTG1NWW16c2ZJeEtwa0JUMVUzVTlCblZ6TTJNeE1UbEdCazF3Q2FLOHNaNk1RWDdDREV6TW9xQzdXR0FtcGowdDNYaEIxOGhGaWF3UFFBVkpDRk1lTnBqWUdSZ1lBRGl6OHlGeGZIOE5sOFptRmtZUU9DeDlmRWZDUG8vQTFNRE00akx3Y0FFb2dBM3ZBckxBQUFBZU5wallHUmdZR2I0ejhEQXdOVEFZTWxneVJqQ0FCUkJBVXdBTzJ3Q1VBQUNnQUFBQVkwQVpBQTVBQUFBQUFBQUFDd0FWbmphWTJCa1lHQmdacEJnQU5FTVVCSUpBQUFERUFBZkFIamFSWXd4YjhJd0VJVy9pQVNKZE9oU2RXQUFEOHhXb2pCM1lXQmlaV0lCYktJTWNaQVRJaUdoanYzZFBZd2xibmo2N3IxM0IrVDhrdkNjaE0rZ3owbkpaSHR4eGdkZmthZXlMU1BuekZreElVbG40aXo0aVp4S2NvaWM4YzBsOGxUOFIrU2NOWCticnIzZUJ1dlZyalBXdTNQcnkySnZmZDkwVHBXNkNQdldPdXVQZ3pYcWRGZG1iUHF4YmxXbEMxMnhvYVBseW8wQmkwZXhFOGNFZHB3bDg1UVU3SVBUMDBqcXBGV2l4WDNuVzhsZDZCekRKeU9kRTNkUnd5aFh2V2d0YlVVVkxqWFZQMk05THc4QUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVWtBQW9BQUFBQUJmUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUYyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1haMng1WmdBQUFXUUFBQUpZQUFBQ3VKSGpjY2xvWldGa0FBQUR2QUFBQUM4QUFBQTJLTVhUczJob1pXRUFBQVBzQUFBQUhnQUFBQ1FHWGdJbGFHMTBlQUFBQkF3QUFBQVVBQUFBRkE2b0FLdHNiMk5oQUFBRUlBQUFBQXdBQUFBTUFXSUNERzFoZUhBQUFBUXNBQUFBR0FBQUFDQUFDUUE2Ym1GdFpRQUFCRVFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGR0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtZXNjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJoWnZnUDVETkRwSkhVL0FjS0F3RDcxUTFqZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1Fndmd1Ly84RFNjZi8vLzhmQVBNWkFGTEtCcUI0MmpYUnYwOFRZUnpIOGVmemZOdm5hR252S2xmdWFxRFhsSlllWUZvSXZkd0JpY1ZRcVFpeC9LaEJnbzFFRXlTU2lEOUFaR0RvZ0RFYUdJd0ppWEZ3ME0wNHV6ZzVNVG01T3FpVDhVOHdiWDJPaE9kWm5ueHp3L3Y3T3NaWnR0M21QL2tQTnN4R0dmUGdlcU9HcWNlTm9tdUlZU2gyem5aYzAzQzlZYVFWRVRkTTExUWg1LzY0V0lKWHBNOVlGL0dvUU1uSWR5TVMzR2wwQkJIdDFCMEtLYTEyTmRxclJ3blI0TVpLQkpGUVgrbk4zL1F1WDQ0aHBEVWJoa1pKQlVUZ0hab0NSTXk3MHdmeGJBeGNVNFUvRG1zQ21STXNNWG1JWFdnM1NmQXZ6R0pEYkV5VzZrN0dGckl0YmFGYmhXTEJGQnFFa2hhbnZib2Y1K2JzVEU0b2RQWW0rVUh4dzFHUG5kUTByTlR2VUtNMlZ3Ty9FcnYycFBXNlYxVW5ySGZIYXpzY2hmSkJTZzl1SGRaM09SK1orVm9KQU9vQ0h6L0hxVmNCWDV5WTNkREMxZkc1S2JVVThEZUFqbWw2WE1sZTV0RE9Oei9TMDJyL0FyVitkNGt3WTJERjloL3E1Ti85WnBDS2pCU2RoSk96WmJNZmJGcndKSzlmbUlJbEY1RHpBbXpYODY5aEdxWW4xNkh3SlJMaFVCQWN5L1BUejBZcVBjSkFZUC9xd0pycjVFVWdwQVFwWHhsOFZONTdTMVJ6WnJjUGFvTURZa1pGaEorMC9xbXlXZEZ5cTV0QWVXeGxMVkhQNzk3bTZCc3ExQk9kQUkvY24rb3ZnbzRiTDNabW5TVUtaUHZWZVpXVE5PZHNVSnA3MGp6QjhyNjRld1p1Q3NXL1o5YW5ycWEvd2lSY3V3QkZxcjgvUXRtS1NlYnRmZEQ4ME5obW8vVXBxVW5pWDRjKzU4dGJlK1pFb3FNTC9GNTFLNlZMM1JoUlV2NzJWdytlUDd5WXYwNWtDUW5MeTgxdjBoR0JoZFRpemZRTmUzMFYwR1RhZi9RQmQxZDQybU5nWkdCZ0FPSmpXWktxOGZ3Mlh4bVlXUmhBNExIMThSOEkrdjlMWm5PbXUwQXVCd01UU0JRQU9Qb0wzQUI0Mm1OZ1pHQmdadmpQQUNUOUdWVCtYMkEyWndDS29BQldBRlVyQTRrQUFBSjJBQUFEQUFBa0F3Z0FLd0xiQURNRFR3QXBBQUFBQUFCVUFMQUJEZ0ZjZU5wallHUmdZR0Jsc0dSZ1pnQUJSZ1kwQUFBR3JRQkVlTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE1Ljg3Njc1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01MS42NTg5MScgeT0nLTYwLjc0NjM2OCc+U3ViPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zNS44MjkzNTUnIHk9Jy02MC43NDYzNjgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMxLjk1NDk4MScgeT0nLTYwLjc0NjM2OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjMuODk4MzcyJyB5PSctNjAuNzQ2MzY4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNi4xMTE4MywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MC43NDYzNjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjAuNzQ2MzY4Jz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYwLjc0NjM2OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjAuNzQ2MzY4Jz5EPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yMy40Mjk5OTInIHk9Jy02MC43NDYzNjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOS40MDk3M1YtNDcuOTk1NzcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwwLjAsLTkuMTU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMi4xMjg1NCwtMzAuMjAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01MS42NTg5MScgeT0nLTYwLjc0NjM2OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDYuOTkyMzI1JyB5PSctNjMuNzUyODg1Jz7iiJc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMzIyMTQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MC43NDYzNjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjAuNzQ2MzY4Jz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYwLjc0NjM2OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjAuNzQ2MzY4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNC40ODI5ODInIHk9Jy02MC43NDYzNjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMTQwOSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MC43NDYzNjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjAuNzQ2MzY4Jz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYwLjc0NjM2OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjAuNzQ2MzY4Jz5DPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNC4xMjE4NjcnIHk9Jy02MC43NDYzNjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTIwLjkzMjMgMEgzNi43NjY2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDIwLjY4MjMsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4wMTY2NiwzLjg3MjkyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYwLjc0NjM2OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuNjU4OTEnIHk9Jy02MC43NDYzNjgnPuKIgzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuMTQ4MDI1JyB5PSctNTkuNjg5MjIxJz5oPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTkuNDA5NzNWLTQ3Ljk5NTc3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwtOS4xNTk3MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTMwLjIwMjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYwLjc0NjM2OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTEuNjU4OTEnIHk9Jy02MC43NDYzNjgnPms8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ3LjI1NTI1NScgeT0nLTYzLjc1Mjg4NSc+4oiXPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00yMS4xNjczNy01Ni45MDU1SDM2LjU4NTM2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDIwLjkxNzM3LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4yNzEzMiwtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01MS42NTg5MScgeT0nLTYwLjc0NjM2OCc+4oiDPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny4xNDgwMjUnIHk9Jy01OS43NTAxMDQnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = {\mathsf {Sub}(B)},
      ne = {\mathsf {Sub}(A)},
      sw = {\mathsf {Sub}(D)},
      se = {\mathsf {Sub}(C)},
      north = {\exists _{h}},
      north/style = {<-},
      west = {f^{*}},
      west/style = {<-},
      south = {\exists _{g}},
      south/style = {<-},
      east = {k^{*}},
      east/style = {<-},
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />, the two composites can be constructed as <fr:tex
display="inline"><![CDATA[f^{*}\mathsf {Img}\Sigma _{g}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathsf {Img}\Sigma _{h}k^{*}]]></fr:tex> respectively.
    Since images commute with pullbacks in a regular category, we have <fr:tex
display="inline"><![CDATA[f^{*}\mathsf {Img}\Sigma _{g} \cong  \mathsf {Img}f^{*}\Sigma _{g}]]></fr:tex>.
    Then by the <fr:link
type="local"
href="ct-0008.xml"
addr="ct-0008"
title="Pasting lemma of pullbacks">pasting lemma</fr:link>, <fr:tex
display="inline"><![CDATA[f^{*}\Sigma _{g}(m) \cong  \Sigma _{h}k^{*}(m)]]></fr:tex> for any subobject <fr:tex
display="inline"><![CDATA[m \in  \mathsf {Sub}(C)]]></fr:tex>, which assembles into a natural isomorphism <fr:tex
display="inline"><![CDATA[f^{*}\Sigma _{g} \cong  \Sigma _{h}k^{*}]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="3daae68dc6dbc9f518795c108aad88f9"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMC44NjUzN3B0JyBoZWlnaHQ9JzExNC45MDIzMzFwdCcgdmlld0JveD0nLTcyIC03MiAxMzMuOTEwMjQ3IDc2LjYwMTU1NCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS1I3VFFXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZExCY1h4dlBiZkdWZ1ptRUFnY2ZXSjFpUWFlYUpURFpBaW9PQkNjUURBQTN1Q0lvQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV1VBQW9BQUFBQUJ0Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMHgyTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWdnRENaMng1WmdBQUFXd0FBQUxDQUFBRG5QS3JaMlJvWldGa0FBQUVNQUFBQUM4QUFBQTJLRlRUQTJob1pXRUFBQVJnQUFBQUlBQUFBQ1FGcWdHY2FHMTBlQUFBQklBQUFBQVVBQUFBRkF4VUFSRnNiMk5oQUFBRWxBQUFBQXdBQUFBTUFhNENvbTFoZUhBQUFBU2dBQUFBR0FBQUFDQUFDQUJZYm1GdFpRQUFCTGdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGaUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtS21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F6TS93SDhwa2gwa2hxL2dPRkFkbUFEVGdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLWmpCay8vOFA1S2VCNlArei84OEVxd0lDQUptTkNUNEFBSGphYmROTGI5TkFFQWR3ejZ3ZnNSTjc0OWU2VFZJM2laMTFxcVpKMjZST1cwTGFOQVdwN3hZSlNoR0NFeUJ4UXVLQ1FPSVRJSVFRQjY3YytBcmNLL1hNaHdHSlM4dWE4amhRNzIxbkQvT2IvMWdDYWVlaWcwL3hxN1F1U1VBb3FKb0ZXcDBuUStpeWdLa2FtNFlockpGSTVXblFIVUpmM0MreXdJS0lKenp0OHc1WVNLR2JNaldCVDZ0RnVWalNSd3ZOVllEWTV3VG9OS1UwcnBHcE50ME4wYVZIMUxmWVJqUXpBSWlZcUJkRFNoMG5OSEtsaDFrWlBweWZidHZyUFc5TWVCUldNVmFUdkk0ZzcvZ2Z2eDJUdWdiSEorV0VOK0ovSlpqa2MyL2xlZzRrOGFIVXVwakRCcHhLYldtY2FZUkUvU1VSSFh1cUZyQXVTd1ZnVFNEYmtLVDk3SVFRQ0pWNFFOWWdUUVJLMWJJUnNHQXhlNHExWi9yekY1MEhzdWpYWm1BNUZidm1EYUlLMDRMKzF1Z0V5WWphV3lmTkpaT1VITk9IOXgwQ250OHJqYXQrMFFhZWhCdVZnZ1l2ejBlZGV3VDkxbFROZGZPaG9TRGtLNVB6MWZ0ZEdZNFBIKzI3ZEpOQXpJb01pdmI1ank4MDM0aGthQzd4MGZwQkh4cFZhZ29iU0hzWDMvRVZua2s3bVV5MEhLS21Yc2JscTFtemFUY0loVmNja1Y1UFlESWVUN0laVUZuazFZYWx2anNFSGwyRzIwK1pCcVA5eXEyVm03MENvSWR1d1RSSVpYcmdvRzJvRU9UdGFOaGNCbUphakNHeTV1QndnaXB1VmM4WmdlN1l5anNaYWF3WEFTeHRzOVVBL0h4K1Z1dUMwdW1aN1lGNnJWeXIyWFZjdSs0Z0J2TUJhOHVkbVVLK0dtK01GL3dGeEhHVDViZGY4ekxOZzJzeTNEU3BJUnMwcDhtazhOdDVRemp2Wk00c2cwWG0vMTAzb2MzTVlqUEY4U2p4V0hDNWs5bkZIenp2cDRuSWw0SUZkWDRGK3ZIMDNlVG9OaGNqRnlzWVZDMXY5aURod1VTMVIrbThqRVFCNnZGWmcyaUdyZ0lVRGEreWtvd1JGQUt3dlJ4Uk9lQlg4WjlZdTQybGxvQmpiTVU1QzJDVjF6elJncUt6RlVNM3k2NzRrZVM5bUJxSWh0SXVWOXB5TjdVY1MyMG15cHRWWitLL1FValNUd3l3ZFJJQUFIamFZMkJrWUdBQTR0Q1V2WW54L0RaZkdaaFpHRURnc2ZVSkZnVDlYNWZwR05ORklKZURnUWtrQ2dBWjV3b2xBSGphWTJCa1lHQm0rTS9Bd01CMGpFSG4vd1dtYWdhZ0NBcGdCUUJtWUFSS0FzWUFBQUk2QUVzQ09nQXNBcXdBVFFKdUFFMEFBQUFBQUdZQTFBRklBYzU0Mm1OZ1pHQmdZR1VJWjJCaUFBRkdCalFBQUFtRUFHRjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVa0FBb0FBQUFBQmZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxRjJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDWFoyeDVaZ0FBQVdRQUFBSllBQUFDdUpIamNjbG9aV0ZrQUFBRHZBQUFBQzhBQUFBMktNWFR5MmhvWldFQUFBUHNBQUFBSGdBQUFDUUdYZ0lsYUcxMGVBQUFCQXdBQUFBVUFBQUFGQTZvQUt0c2IyTmhBQUFFSUFBQUFBd0FBQUFNQVdJQ0RHMWhlSEFBQUFRc0FBQUFHQUFBQUNBQUNRQTZibUZ0WlFBQUJFUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZHQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmhadmdQNURORHBKSFUvQWNLQXdENzFRMWplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2Z3UvLzhEU2NmLy8vOGZBUE1aQUZMS0JxQjQyalhSdjA4VFlSekg4ZWZ6Zk52bmFHbnZLbGZ1YXFEWGxKWWVZRm9JdmR3QmljVlFxUWl4L0toQmdvMUVFeVNTaUQ5QVpHRG9nREVhR0l3SmlYRncwTTA0dXpnNU1UbTVPcWlUOFU4d2JYMk9oT2Rabm54encvdjdPc1padHQzbVAva1BOc3hHR2ZQZ2VxT0dxY2VOb211SVlTaDJ6blpjMDNDOVlhUVZFVGRNMTFRaDUvNjRXSUpYcE05WUYvR29RTW5JZHlNUzNHbDBCQkh0MUIwS0thMTJOZHFyUnduUjRNWktCSkZRWCtuTjMvUXVYNDRocERVYmhrWkpCVVRnSFpvQ1JNeTcwd2Z4YkF4Y1U0VS9EbXNDbVJNc01YbUlYV2czU2ZBdnpHSkRiRXlXNms3R0ZySXRiYUZiaFdMQkZCcUVraGFudmJvZjUrYnNURTRvZFBZbStVSHh3MUdQbmRRMHJOVHZVS00yVndPL0VydjJwUFc2VjFVbnJIZkhhenNjaGZKQlNnOXVIZFozT1IrWitWb0pBT29DSHovSHFWY0JYNXlZM2REQzFmRzVLYlVVOERlQWptbDZYTWxlNXRET056L1MwMnIvQXJWK2Q0a3dZMkRGOWgvcTVOLzlacENLakJTZGhKT3paYk1mYkZyd0pLOWZtSUlsRjVEekFtelg4NjloR3FZbjE2SHdKUkxoVUJBY3kvUFR6MFlxUGNKQVlQL3F3SnJyNUVVZ3BBUXBYeGw4Vk41N1MxUnpacmNQYW9NRFlrWkZoSiswL3FteVdkRnlxNXRBZVd4bExWSFA3OTdtNkJzcTFCT2RBSS9jbitvdmdvNGJMM1ptblNVS1pQdlZlWldUTk9kc1VKcDcwanpCOHI2NGV3WnVDc1cvWjlhbnJxYS93aVJjdXdCRnFyOC9RdG1LU2VidGZkRDgwTmhtby9VcHFVbmlYNGMrNTh0YmUrWkVvcU1ML0Y1MUs2VkwzUmhSVXY3MlZ3K2VQN3lZdjA1a0NRbkx5ODF2MGhHQmhkVGl6ZlFOZTMwVjBHVGFmL1FCZDFkNDJtTmdaR0JnQU9KaldSSmY0L2x0dmpJd3N6Q0F3R1ByRXl3SSt2OUxabk9tdTBBdUJ3TVRTQlFBTUJZS3hRQjQybU5nWkdCZ1p2alBBQ1Q5R1ZUK1gyQTJad0NLb0FCV0FGVXJBNGtBQUFKMkFBQURBQUFrQXdnQUt3TGJBRE1EVHdBcEFBQUFBQUJVQUxBQkRnRmNlTnBqWUdSZ1lHQmxzR1JnWmdBQlJnWTBBQUFHclFCRWVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNzAzNTU3LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNS43MDM1NTcnIHk9Jy02MS44MDM1Myc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy45MzEyNCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNzAzNTU3LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNS43MDM1NTcnIHk9Jy02MS44MDM1Myc+QzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03LjY4NDA1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNzAzNTU3LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNS43MDM1NTcnIHk9Jy02MS44MDM1Myc+azwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjcwMzU1NywtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNzAzNTU3JyB5PSctNjEuODAzNTMnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuNjI3MDMsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjcwMzU1NywtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNzAzNTU3JyB5PSctNjEuODAzNTMnPkQ8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQgMEg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1Ljk2NTE4LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjcwMzU1NywtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTUuNzAzNTU3JyB5PSctNjEuODAzNTMnPmg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjQ4Njc5LTU2LjkwNTVINDcuNTcxNDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuODIxNDksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI2LjIwMjkxLC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNTEuMjE1MDQtMTQuMjI2MzZILTQyLjY3OTE0Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi4wNTgyOSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzEuNzY4NDQyJyB5PSctNjUuNDE4ODk0Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjIzOTUyLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5DPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzIuMTI5NTU3JyB5PSctNjUuNDE4ODk0Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00NC44MTU5NS01Ni45MDU1SC04Ljk4Njc5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLC00NC41NjU5NSwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTguNzM2NzksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDQuOTk3MTggMEgtOC44MDU1NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwtNDQuNzQ3MTgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOC41NTU1NCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J00tNTYuOTA1NS02LjQwOTczVi00Ny40Nzc5NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLC01Ni45MDU1LC00Ny43Mjc5NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw = A,
        nw/style = {pullback},
        ne = B,
        sw = C,
        se = D,
        north = h,
        south = g,
        west = k,
        east = f,
      }
      \node  [left = of nw,pullback] (1) {$A'$};
      \node  [left = of sw] (2) {$C'$};
      \draw  [>->,morphism] (2) to (sw);
      \draw  [>->,morphism] (1) to (nw);
      \draw  [->,morphism] (1) to (2);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Thus, we can extend this natural isomorphism as follows:</fr:p>
  <fr:tex
display="block"><![CDATA[     f^{*}\mathsf {Img}\Sigma _{g} \cong  \mathsf {Img}f^{*}\Sigma _{g} \cong  \mathsf {Img}\Sigma _{h}k^{*}   ]]></fr:tex>
  <fr:p>Then both <fr:tex
display="inline"><![CDATA[\forall _{k}h^{*}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g^{*}\forall _{f}]]></fr:tex> are right adjoint to <fr:tex
display="inline"><![CDATA[f^{*}\exists _{g}]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[\forall _{k}h^{*} \cong  g^{*}\forall _{f}]]></fr:tex> by the uniqueness of adjoint.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1566</fr:anchor><fr:addr
type="user">ct-0011</fr:addr><fr:route>ct-0011.xml</fr:route><fr:title
text="Coherent categories admit distributive law"><fr:link
type="local"
href="ct-000X.xml"
addr="ct-000X"
title="Coherent category">Coherent categories</fr:link> admit distributive law</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a coherent category.
  Then intersections distribute over unions, i.e., for any three subobjects <fr:tex
display="inline"><![CDATA[A_{1}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[A_{3}]]></fr:tex> of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, the following holds.</fr:p><fr:tex
display="block"><![CDATA[   A_{1} \cap  (A_{2} \cup  A_{3}) \cong  (A_{1} \cap  A_{2}) \cup  (A_{1} \cap  A_{3}) ]]></fr:tex>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>839</fr:anchor><fr:addr
type="machine">#290</fr:addr><fr:route>unstable-290.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  Let <fr:tex
display="inline"><![CDATA[m\colon A_{1}\rightarrowtail A]]></fr:tex> be a subobject of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
  Then by <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />, <fr:tex
display="inline"><![CDATA[A_{1} \cap  (\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]]></fr:tex> can be described as the composite <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A) \xrightarrow {m^{*}} \mathsf {Sub}(A_{1}) \xrightarrow {\exists _{m}} \mathsf {Sub}(A)]]></fr:tex>.
  Thus, we have
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  <fr:tex
display="block"><![CDATA[   \begin {align*}     A_{1} \cap  (A_{2} \cup  A_{3}) &\cong  \exists _{m}m^{*}(A_{2} \cup  A_{3}) && \text {$m^{*}$ preserves finite unions}\\                             &\cong  \exists _{m}(m^{*}(A_{2}) \cup  m^{*}(A_{3})) && \text {left adjoint preserves finite unions}\\                             &\cong  \exists _{m}m^{*}(A_{2}) \cup  \exists _{m}m^{*}(A_{3})\\                             &\cong  (A_{1} \cap  A_{2}) \cup  (A_{1} \cap  A_{3})   \end {align*} ]]></fr:tex></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1567</fr:anchor><fr:addr
type="user">ct-0012</fr:addr><fr:route>ct-0012.xml</fr:route><fr:title
text="Union as a pushout of intersection">Union as a pushout of intersection</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-000X.xml"
addr="ct-000X"
title="Coherent category">coherent category</fr:link> and <fr:tex
display="inline"><![CDATA[A_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex> be subobjects of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>.
  Then the following square is both a pullback and a pushout in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="63ee177bd1f9d5cf84e6aab9ab9a84cf"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE1MC4zMzYwOXB0JyBoZWlnaHQ9JzExNS41MTQ2NzVwdCcgdmlld0JveD0nLTcyIC03MiAxMDAuMjI0MDYgNzcuMDA5NzgzJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9jQUFvQUFBQUFCREFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FuU1VJbU50WVhBQUFBRkFBQUFBTXdBQUFEd2lQU0tGWjJ4NVpnQUFBWFFBQUFESUFBQUErQ2M2UHI1b1pXRmtBQUFDUEFBQUFDOEFBQUEyS0tyVFVHaG9aV0VBQUFKc0FBQUFIZ0FBQUNRRnhmOS9hRzEwZUFBQUFvd0FBQUFLQUFBQUNnWDlBRGRzYjJOaEFBQUNtQUFBQUFnQUFBQUlBRDRBZkcxaGVIQUFBQUtnQUFBQUZ3QUFBQ0FBQlFBbWJtRnRaUUFBQXJnQUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRGpBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXVzQTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTcHBJV3M5UWZUUVlHWmlubTYwQmhSb1RTLy84WkdBQVhuUTdKQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWU5JQTBHNUJtWkdCUzBsVFMrditmZ1FGQzM3MXg5d1pZRlJBQUFKTEZDUUFBZU5wallHUXcvLytLcVpncGhVR0ZnWUZSVUl4TlNjMWMwRXhOWFkrUlhZMmREUWhoUXZhTVpzWkc0bUxpWWt4RmpPeXk3SXhNa2haYTRTcEdMa3F5MWl4Z0FSWmZpZURFNkNCQkFXL0cxbitkZkdKaWZJeEY0b0hxVXNLTWpHTGM0cHBSLzNyQlloV1o1dno2MnB3OFprRHJnSGEvQk5xZERMR2JqWitSVFZsSlhRMElCZFhNak1UWUJkbkV4T1VZamNYTXpZQVFMTVJVaExDRkJhc3ptT3ovZFFKdE1ORG00akhMWkN6akZ4WGwvOWN2SHFRdUtjd29EbklGWXhGUWlJRUJBQWhOS0VONDJtTmdaR0JnQU9LdnIwU2Q0L2x0dmpJd3N6Q0F3R1ByRTh3SSt2OUxaaG1tRkNDWGc0RUpKQW9BS2Q0S0tRQjQybU5nWkdCZ2x2cWpDU1JsR013WnpKbUtHWUFpS0lBSkFEczhBa2tBQUFNY0FBQUNxZ0EzQURjQUFBQUFBQUFBUGdCOGVOcGpZR1JnWUdCbVVHVUEwUXhRRWdrQUFBUlZBQ3dBZU5wTmpyRnF3ekFRaGo5VHgxQW5rS2tkT2hSTkdZV044d0NGREpteVppd2trUWdPV0E2U1kvQlM4Z0I5NkY0VURUM0I4ZW0vNzRTQWtoOHlIcFd4alAxUk9ZWGNuanhqemx2aVFvNUtYUExCaWhleS9GV1NUNzRTNXl6NFRqempuVXZpUXZKNzRwSTF2NXUrdTk0RzY5V3VOOWE3VXhlbXV0cGJIOXJlcVZwWHoyQnJuZldId1JwMW5KUVoyekNlTzlYb1NqZHM2T200Y21QQTR1Vm5PMGxNWk1kSlpvR0ptb3A5ekFLdHpKMTROVnJTLzhaV0RCZXRRM3pOaUhXVW1SSWFaUzlJUDR1dmFPS3VwdmtEQ1ZFeEV3QjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRc0FBb0FBQUFBQk53QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWVIwdDJOdFlYQUFBQUU0QUFBQU1RQUFBRHdBa3dDNloyeDVaZ0FBQVd3QUFBRm9BQUFCckZGUG1NZG9aV0ZrQUFBQzFBQUFBQzhBQUFBMktGVFRuV2hvWldFQUFBTUVBQUFBSHdBQUFDUUZ0UUg2YUcxMGVBQUFBeVFBQUFBTUFBQUFEQWNYQUdCc2IyTmhBQUFETUFBQUFBZ0FBQUFJQUdBQTFtMWhlSEFBQUFNNEFBQUFHQUFBQUNBQUJnQk9ibUZ0WlFBQUExQUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUVJQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1pbVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwbU1wUXlNL3dIOHBraDBraHEvZ09GQWRHTkRTc0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtaaktVL3Y4UDVJUHAvelArOTRKVkFRRUFtc2dKUndBQUFIamFYYy9MVHNKQUZBYmcrUTkwS2hkYldxWXpqQmR1RllxYWxJSVVMMEJSRStLR3hCZHdiZUpibUxqeVFXVHZPL2dDTG53S3Q4YWQwWUdsT2FzLzU1emsveGl4NVBjYjk3UmlSVFpsREE3c0dHbUdvY3pOTVU1SGRwdmJQSXk2MGVoMGJLWU94VjNpdGdNMU5QbEUxV0diQS9NVGpiRkVxeVlDaE1maS9YS0g2L3BVd0N0eDFFcGVtQjJuZ0tXMTcxWnllNDFKbGJ3Q2h5ejU0Y3dzaUI1bEMxQ3ViT21mejVkclVZbHlrK3NLVWNFWnlDQzJNRHp3S2xkWHZhUG1Bdk9aVDZRU0plTThCcDBhZytuL1JVOTRZMHZHT3FlbXVCSXVPUWlFVkJrTW9RR3B4TG9pNzBZR3g2T1kxcEQvc0tGVWE1WE4xMjhtNHpYbDRqelBROGtMVHJVWmJtM2xTMFdPcXIrWGxtK0VudlV2a3QweS9KNEgzWmhXTjA1Vk5zN2VHYkN0MmlCNTBzOWNzbFlmK3FCaHErZTdJSGFDZmRBaTJ1VUdYTFF1V3lNaTJkZUhvRkNmTjIvdnczWUg4MnlqVHBSUkp6MVZQM3ZvZTNPTEpqczV3ZGdmUkp3MTJIamFZMkJrWUdBQTRpVS9jaGZHODl0OFpXQm1ZUUNCeDlZbm1CSDAveTlNeDVpV0Fia2NERXdnVVFCSXZ3dVNBSGphWTJCa1lHQm0rTS9Bd01CMGpNR0F3WUNwbVFFb2dnS1lBVVJJQXJVQUFzWUFBQUdlQURBQ3N3QXdBQUFBQUFCZ0FOWjQybU5nWkdCZ1lHYndaV0JpQUFGR0JqUUFBQWhVQUZWNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPZ0FBb0FBQUFBQkFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVXgwakdOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDRloyeDVaZ0FBQVdRQUFBRGtBQUFBNU91YmdpOW9aV0ZrQUFBQ1NBQUFBQzBBQUFBMktHRFRyR2hvWldFQUFBSjRBQUFBSHdBQUFDUUZTQUlZYUcxMGVBQUFBcGdBQUFBS0FBQUFDZ1ZiQUhCc2IyTmhBQUFDcEFBQUFBZ0FBQUFJQUN3QWNtMWhlSEFBQUFLc0FBQUFGd0FBQUNBQUJRQXJibUZ0WlFBQUFzUUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQURrQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvYU1oZ3hNL3dIOHBraDBraHEvZ09GQWN2bURNZ0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aEcvLzhEU2NQLy8vOWZBUE1aQUZGWUJvNEFBUUJ3QUFBQjVBS3BBQmtBQUFFUkJoWTdBUlV2QVE4Qk5UTXlOaWNSRGdFbk5SWTJOellXQVZjRElFa25aMUJ3UmlkSklBTXNWQlFoZERNVkN3S0wvY2thRlNVREFRSUNKUlVhQWdvVUNRRWtBaFl1QVFvQUFBRUFRUUFBQWdVQ3FBQXBBQUFsQnlFM05qOEJQZ0ltSnlZR0J4NEJCdzRCSXdZbUp6NEJOeDRCRnc0QkR3RUdCemMyTno0Qk53SUZILzViQVFJSDl4dENBMDlOSmxZWkp4WUJBU0lUQ2lvQ0FYTmhaWWNEQWxVN1ZTcE84aVVMQ2c0Q3Vyb2NCZ2IwRzJhRVlBSUJLelVDSlE4Y0d3RVZKa2xyQXdGcFhrZHFMRVVpUlFFQkJBcEFFd0I0Mm1OZ1pHQmdBT0ptN1N1YThmdzJYeG1ZV1JoQTRMSDFDV1prbXVreTAwb2d4Y0hBQk9JQkFQN1RDTEFBQUFCNDJtTmdaR0JnWnZqUHdNREFkSm5Ca2NHSmlaVUJLSUlDbUFBL013Sm1BQUxUQUFBQ1J3QndBRUVBQUFBQUFBQUFMQUJ5ZU5wallHUmdZR0JtMEdJQTBReFFFZ2tBQUFUU0FERUFlTm85akRHcndqQVVoYjlpRmUwYkhBU0hOMGp3QjRSS0g3aTRPVGk1T3J6Tm1pQWRta3BhaXk3aVQvYzJCRy9nOE4xenpnMlE4U0pobUlSNTBHRlNlZlBJWTM1WVJKNkl2NHFjOGN1YUVVazZFMmZGTG5MS2xQL0lZNWFVa1NmaVB5Sm4vUEhlTi9YdDNsbXZqbzJ4M2wxcXZ6MVozMWFOVXh1ZEQrdkJPdXZQblRXcWZDclRWMjEvclZXaGMxMndwNkhteHAwT2kwZHhGTWNFZGx3azgydzVoYjJsa3N4Slo0TW0vNllIU1Yxb25NTXZSaG9sVDFGREx6ZXQ2Rlc2aWlMY2FZb1BXS3d1U3dBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU93QUFvQUFBQUFCQmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVeDFBbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNGWjJ4NVpnQUFBV1FBQUFEMEFBQUE5TnUrK1pKb1pXRmtBQUFDV0FBQUFDMEFBQUEyS04vVHJtaG9aV0VBQUFLSUFBQUFIZ0FBQUNRRnVnS3lhRzEwZUFBQUFxZ0FBQUFLQUFBQUNnWm5BSkpzYjJOaEFBQUN0QUFBQUFnQUFBQUlBRElBZW0xaGVIQUFBQUs4QUFBQUZ3QUFBQ0FBQlFBdGJtRnRaUUFBQXRRQUFBREtBQUFCTXVzSWtlWndiM04wQUFBRG9BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWVzMDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFEwWkRCaVp2Z1A1RE5EcEpIVS9BY0tBd0QyeEEwK2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoRy8vOERTY1AvLy85ZkFQTVpBRkZZQm80QUFRQ1NBQUFDTndLckFCNEFBQUVSQmhZN0FSVW1KeU1HQnpVek1qWW5FUTRCSnlNMU14WS9BVFkzTmhZQm1BUWlUak1zT3RFNkxETk9JUU11VkJNU0VoSStCejg1R0E0Q2kvM05GeFF0QXdFQkF5MFVGd0lBRWd3QkxRSUtBZ291QVFrQUFBRUFYUUFBQWxzQ3FnQXJBQUFsQnlFMU5EOENQZ0UzTGdFbklnWUhIZ0VYRGdFakJpWW5QZ0UzTWhZWERnRUhCZzhCSlRZM1BnRTNBbHNpL2lRRENmbzlUUUVDYUUwMFVoWVlJUUVCSmhVT0xBSUNoR3B3bXdNQ2FFZ3ZOV2tCQWlvS0RROEN4c1lmQlFJSjFERnFQMHhUQVNvakFoOGJJQjBCR1NkTlpRSnBZMUJwTGlBblRnRUJCQXRCRWdBQWVOcGpZR1JnWUFEaVJZOGU1Y2Z6MjN4bFlHWmhBSUhIMWllWWtXbm1JS2JWUUlxRGdRbkVBd0FzWUFsY0FBQUFlTnBqWUdSZ1lHYjR6d0FrZ3hoaUdXS1pvaG1BSWlpQUNRQTkwUUp6QUFBRFVnQUFBcmdBa2dCZEFBQUFBQUFBQURJQWVuamFZMkJrWUdCZ1p0QmhBTkVNVUJJSkFBQUZCQUF6QUhqYVBZd3hxOEl3RklXL1loWHRHeHdFaHpkSThBZUVTcCtibTRPVHE4UGJyQW5Tb2Fta3RlZ2kvblJ2US9BR0R0ODk1OXdBR1M4U2hrbVlCeDBtbFRlUFBPYUhSZVNKK0t2SUdiK3NHWkdrTTNGVzdDS25UUG1QUEdaSkdYa2kvaU55eGgvdmZWUGY3cDMxNnRnWTY5Mmw5dHVUOVczVk9MWFIrYkFlckxQKzNGbWp5cWN5ZmRYMjExb1ZPdGNGZXhwcWJ0enBzSGdVUjNGTVlNZEZNcytXVTloYktzbWNkRFpvOG05NmtOU0Z4am44WXFSUjhoUTE5SExUaWw2bHF5akNuYWI0QUZVeUxrTUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5vQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDA0V050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNVWjJ4NVpnQUFBV1FBQUFDb0FBQUFxTC9zRGVWb1pXRmtBQUFDREFBQUFDOEFBQUEyS0cvVDMyaG9aV0VBQUFJOEFBQUFIUUFBQUNRR0J3SWlhRzEwZUFBQUFsd0FBQUFJQUFBQUNBVjJBQ1JzYjJOaEFBQUNaQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUpzQUFBQUZnQUFBQ0FBQlFBMGJtRnRaUUFBQW9RQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRFdBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTJzMDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCa1p2Z1A1RE5EcEpIVS9BY0tBd0RvOXcwdGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpTy8vOUR5UDhId0h3R0FGS1hCcDBBQUFBQUFnQWsvLzhDNFFMZEFDOEFNZ0FBTndFMk56SVdGeE1VRmpNMkZnWXZBUWNuSmljME5oY1dOamN2QVNFSEJoUVdGellYRGdFdkFRY21KelEyTXo0Qk56TUR0d0ZsQmhRTkJnRStGaTBWQVF3RmRJQUlCUUVOQ3hNMEF3a0gvdjlPRFJ3VERRTUJEUVZuV0F3QkRBa2lQcG5ySVhZQ1ZoQUJDUS85Z0JZUEF4MEhBUU1EQVFJSUR3Y0JBUXdYWmtXRUZDUVFBUUlQRGdZQkF3TUJDZzhHQVNQSUFWSUFBQUI0Mm1OZ1pHQmdBT0lHcSsvYzhmdzJYeG1ZV1JoQTRMSDFDV1lFL2Y4LzAwT211MEF1QndNVFNCUUFJOGdMQVFCNDJtTmdaR0JnWnZqUEFDSVpWQmprbVI0eUFFVlFBQk1BTll3Q01BQUFBQUoyQUFBREFBQWtBQUFBQUFCVUFBQjQybU5nWkdCZ1lHSXdCbUlRWUdSQUF3QUZyd0E2QUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTAuMjM0NDI3LC02MS4wMzU1Njcpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTcuNTQxNjYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUwLjIzNDQyNywtNjEuMDM1NTY3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01MC4yMzQ0MjcnIHk9Jy02MS4wMzU1NjcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQyLjc2MjQyOCcgeT0nLTU5LjU0MTE4Nic+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzYuMDc5MTkyJyB5PSctNjEuMDM1NTY3Jz7iiKk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTI3LjIyMzU0NCcgeT0nLTYxLjAzNTU2Nyc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTkuNzUxNTQ1JyB5PSctNTkuNTQxMTg2Jz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01Ljk5MzA3LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTAuMjM0NDI3LC02MS4wMzU1Njcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUwLjIzNDQyNycgeT0nLTYxLjAzNTU2Nyc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDIuNzYyNDI4JyB5PSctNTkuNTQxMTg2Jz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTEwLjEwOTdWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsMC4wLC0xMC4zNTk3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC05Ljk5NiwtMzAuMDM2MDcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MC4yMzQ0MjcsLTYxLjAzNTU2NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTAuMjM0NDI3JyB5PSctNjEuMDM1NTY3Jz5pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny40MTU3JyB5PSctNjAuMDM5MzAzJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUwLjkxMjQzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MC4yMzQ0MjcsLTYxLjAzNTU2NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTAuMjM0NDI3JyB5PSctNjEuMDM1NTY3Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Mi43NjI0MjgnIHk9Jy01OS41NDExODYnPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzkuMzYzODUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MC4yMzQ0MjcsLTYxLjAzNTU2NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTAuMjM0NDI3JyB5PSctNjEuMDM1NTY3Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Mi43NjI0MjgnIHk9Jy01OS41NDExODYnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTM2LjA3OTE5MicgeT0nLTYxLjAzNTU2Nyc+4oiqPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0yNy4yMjM1NDQnIHk9Jy02MS4wMzU1NjcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTE5Ljc1MTU0NScgeT0nLTU5LjU0MTE4Nic+MjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMjQuMjk3MiAwSDQ1Ljg1Njg5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDI0LjU0NzIsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni4xMDY4OSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMwLjg2MDk4LDMuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MC4yMzQ0MjcsLTYxLjAzNTU2NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTAuMjM0NDI3JyB5PSctNjEuMDM1NTY3Jz5pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny40MTU3JyB5PSctNjAuMDM5MzAzJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTEwLjEwOTdWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwtMTAuMzU5NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTMwLjAzNjA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTAuMjM0NDI3LC02MS4wMzU1Njcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTUwLjIzNDQyNycgeT0nLTYxLjAzNTU2Nyc+dTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDUuNTI0MDMyJyB5PSctNjAuMDM5MzAzJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMi43NDg2MS01Ni45MDU1SDM0LjMwODMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTIuOTk4NjEsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM0LjU1ODMsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE4LjM2MywtNjIuNzMxMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUwLjIzNDQyNywtNjEuMDM1NTY3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01MC4yMzQ0MjcnIHk9Jy02MS4wMzU1NjcnPnU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ1LjUyNDAzMicgeT0nLTYwLjAzOTMwMyc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = {A_{1} \cap  A_{2}},
    ne = {A_{2}},
    sw = {A_{1}},
    se = {A_{1} \cup  A_{2}},
    north = {i_{2}},
    north/style = {>->},
    west = {i_{1}},
    west/style = {>->},
    south = {u_{1}},
    south/style = {>->},
    east = {u_{2}},
    east/style = {>->},
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>where the <fr:tex
display="inline"><![CDATA[i]]></fr:tex>'s and the <fr:tex
display="inline"><![CDATA[u]]></fr:tex>'s are the product projections and coproduct injections in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> respectively.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>841</fr:anchor><fr:addr
type="machine">#289</fr:addr><fr:route>unstable-289.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>The diagram commutes since <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> is a preorder: any two morphisms <fr:tex
display="inline"><![CDATA[A_{1} \cap  A_{2} \rightrightarrows  A_{1} \cup  A_{2}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> are equal.
    Moreover, this diagram is a pullback in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> as the pullback of <fr:tex
display="inline"><![CDATA[u_{2}]]></fr:tex> along <fr:tex
display="inline"><![CDATA[u_{1}]]></fr:tex> is just the largest subobject contained in both <fr:tex
display="inline"><![CDATA[A_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex>, i.e., the intersection.
    Then since both the inclusion <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A) \hookrightarrow  {{\mathcal {C}}_{/{A}}}]]></fr:tex> (as a right adjoint) and the forgetful functor <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}} \to  \mathcal {C}]]></fr:tex> preserve pullbacks, the square is a pullback in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p>
  <fr:p>Note that the forgetful functor <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}} \to  \mathcal {C}]]></fr:tex> preserves arbitrary colimits, but the inclusion functor does not necessarily preserve them, so the same strategy does not work for pushout.</fr:p>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A_{1}\to B]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g\colon A_{2}\to B]]></fr:tex> be morphisms in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[fi_{1} = gi_{2}]]></fr:tex>.
    Consider the joint morphisms <fr:tex
display="inline"><![CDATA[(f,u_{1})\colon A_{1}\rightarrowtail B \times  (A_{1} \cup  A_{2})]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(g,u_{2})\colon A_{2}\rightarrowtail B \times  (A_{1} \cup  A_{2})]]></fr:tex>, which are monic because <fr:tex
display="inline"><![CDATA[u_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[u_{2}]]></fr:tex> are.
    Let <fr:tex
display="inline"><![CDATA[(m,n)\colon U\rightarrowtail B \times  (A_{1} \cup  A_{2})]]></fr:tex> be the union of <fr:tex
display="inline"><![CDATA[(f,u_{1})]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(g,u_{2})]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B \times  (A_{1} \cup  A_{2}))]]></fr:tex>.
    We show that <fr:tex
display="inline"><![CDATA[n]]></fr:tex> is an isomorphism.</fr:p>
  <fr:p>The functor <fr:tex
display="inline"><![CDATA[\exists _{\pi _{2}}\colon \mathsf {Sub}(B \times  (A_{1} \cup  A_{2}))\to \mathsf {Sub}(A_{1} \cup  A_{2})]]></fr:tex> constructed in <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />, as a left adjoint, preserves arbitrary unions.
    Let us consider the image of <fr:tex
display="inline"><![CDATA[n]]></fr:tex>:</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       \exists _{\pi _{2}}(m, n) &\cong  \mathsf {Img}(\pi _{2}(m,n))\\                       &\cong  \mathsf {Img}(n)\\                       &\cong  \exists _{\pi _{2}}((f,u_{1}) \cup  (g,u_{2}))\\                       &\cong  \exists _{\pi _{2}}(f,u_{1}) \cup  \exists _{\pi _{2}}(g,u_{2})\\                       &\cong  \mathsf {Img}(\pi _{2}(f,u_{1})) \cup  \mathsf {Img}(\pi _{2}(g,u_{2}))\\                       &\cong  u_{1} \cup  u_{2}\\                       &\cong  \mathsf {id}_{A_{1} \cup  A_{2}}     \end {align*}   ]]></fr:tex>
  <fr:p>Thus, if <fr:tex
display="inline"><![CDATA[n]]></fr:tex> is monic then <fr:tex
display="inline"><![CDATA[\mathsf {Img}(n) \cong  n \cong  \mathsf {id}_{A_{1} \cup  A_{2}}]]></fr:tex>, i.e., <fr:tex
display="inline"><![CDATA[n]]></fr:tex> is the whole of <fr:tex
display="inline"><![CDATA[A_{1} \cup  A_{2}]]></fr:tex>, so it is an isomorphism.
    Let <fr:tex
display="inline"><![CDATA[a,b\colon V\rightrightarrows U]]></fr:tex> be a pair of morphisms such that <fr:tex
display="inline"><![CDATA[na = nb]]></fr:tex>.
    To show that <fr:tex
display="inline"><![CDATA[a = b]]></fr:tex>, it suffices to show <fr:tex
display="inline"><![CDATA[ma = mb]]></fr:tex> since <fr:tex
display="inline"><![CDATA[n]]></fr:tex> and <fr:tex
display="inline"><![CDATA[m]]></fr:tex> are jointly monic.
    To this end, we show that the equalizer of <fr:tex
display="inline"><![CDATA[ma]]></fr:tex> and <fr:tex
display="inline"><![CDATA[mb]]></fr:tex> is an isomorphism.</fr:p>
  <fr:p>The object <fr:tex
display="inline"><![CDATA[U]]></fr:tex> (when viewed as the maximal subobject in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(U)]]></fr:tex>) is the union of the coproduct injections <fr:tex
display="inline"><![CDATA[\ell ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[k]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="09f72e0bae0988d03ddb409aaa2144ec"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMC44NTkxMjNwdCcgaGVpZ2h0PScxMTMuMjc1MTI4cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTMzLjkwNjA4MiA3NS41MTY3NTInPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU93QUFvQUFBQUFCQmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVeDFBbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNGWjJ4NVpnQUFBV1FBQUFEMEFBQUE5TnUrK1pKb1pXRmtBQUFDV0FBQUFDMEFBQUEyS04vVGptaG9aV0VBQUFLSUFBQUFIZ0FBQUNRRnVnS3lhRzEwZUFBQUFxZ0FBQUFLQUFBQUNnWm5BSkpzYjJOaEFBQUN0QUFBQUFnQUFBQUlBRElBZW0xaGVIQUFBQUs4QUFBQUZ3QUFBQ0FBQlFBdGJtRnRaUUFBQXRRQUFBREtBQUFCTXVzSWtlWndiM04wQUFBRG9BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWVzMDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFEwWkRCaVp2Z1A1RE5EcEpIVS9BY0tBd0QyeEEwK2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoRy8vOERTY1AvLy85ZkFQTVpBRkZZQm80QUFRQ1NBQUFDTndLckFCNEFBQUVSQmhZN0FSVW1KeU1HQnpVek1qWW5FUTRCSnlNMU14WS9BVFkzTmhZQm1BUWlUak1zT3RFNkxETk9JUU11VkJNU0VoSStCejg1R0E0Q2kvM05GeFF0QXdFQkF5MFVGd0lBRWd3QkxRSUtBZ291QVFrQUFBRUFYUUFBQWxzQ3FnQXJBQUFsQnlFMU5EOENQZ0UzTGdFbklnWUhIZ0VYRGdFakJpWW5QZ0UzTWhZWERnRUhCZzhCSlRZM1BnRTNBbHNpL2lRRENmbzlUUUVDYUUwMFVoWVlJUUVCSmhVT0xBSUNoR3B3bXdNQ2FFZ3ZOV2tCQWlvS0RROEN4c1lmQlFJSjFERnFQMHhUQVNvakFoOGJJQjBCR1NkTlpRSnBZMUJwTGlBblRnRUJCQXRCRWdBQWVOcGpZR1JnWUFEaVJZOGVyWS9udC9uS3dNekNBQUtQclk5L1JxYVpnNWhXQXlrT0JpWVFEd0JpRUF0NkFBQUFlTnBqWUdSZ1lHYjR6d0FrZ3hoaUdXS1pvaG1BSWlpQUNRQTkwUUp6QUFBRFVnQUFBcmdBa2dCZEFBQUFBQUFBQURJQWVuamFZMkJrWUdCZ1p0QmhBTkVNVUJJSkFBQUZCQUF6QUhqYVBZd3hxOEl3RklXL1loWHRHeHdFaHpkSThBZUVTcCtibTRPVHE4UGJyQW5Tb2Fta3RlZ2kvblJ2US9BR0R0ODk1OXdBR1M4U2hrbVlCeDBtbFRlUFBPYUhSZVNKK0t2SUdiK3NHWkdrTTNGVzdDS25UUG1QUEdaSkdYa2kvaU55eGgvdmZWUGY3cDMxNnRnWTY5Mmw5dHVUOVczVk9MWFIrYkFlckxQKzNGbWp5cWN5ZmRYMjExb1ZPdGNGZXhwcWJ0enBzSGdVUjNGTVlNZEZNcytXVTloYktzbWNkRFpvOG05NmtOU0Z4am44WXFSUjhoUTE5SExUaWw2bHF5akNuYWI0QUZVeUxrTUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU84QUFvQUFBQUFCQ3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXdBQUFCZ2lTU1VTR050WVhBQUFBRkFBQUFBTVFBQUFEeERqdC9oWjJ4NVpnQUFBWFFBQUFEckFBQUE5S21UNDh0b1pXRmtBQUFDWUFBQUFDOEFBQUEyS0tyVEwyaG9aV0VBQUFLUUFBQUFIZ0FBQUNRRjJQK0FhRzEwZUFBQUFyQUFBQUFNQUFBQURBamlBTXRzYjJOaEFBQUN2QUFBQUFnQUFBQUlBRHdBZW0xaGVIQUFBQUxFQUFBQUZ3QUFBQ0FBQlFBbWJtRnRaUUFBQXR3QUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRHNBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbStzWTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU1tSUhhQWNWS0t5OUtCa3RlVnRKaWwvbWd5TURCTE1WOEhDak1pbFAvL3o4QUFBRGFqRDMxNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWU5JQTBHNUJtQk1wZVY5TDYveC9JQjlQL3RlN2VBS3NDQWdDamx3bU1BQUFBZU5vZGpURktBMEVVUVAvL3M1bEpOaWF6dzVBWkk2ekNKc3lnRnNvS000SkZHanV4aVlXZ2xWaWxqZUFSQkJ0dHZJS244QVl1U1pWTGVBT3I2TERsZXp4NGdQQUJQWHJCWDZnQU1BWnJMSmQwZ0VadzRVNVFESEhpdkp1aGR6SEUydUpiTTh3MUV0djcrcXd6Uk4zdmJKcGVseXZHaXRXcVlFenhETXR2aGFUenR1a3lUWlJ0bXJ4RFdnelc2NEZJREdrRjhlK0hudWdScGdrVWw4Z25sVThycjF5b2pWRGMySDA4TStrYVlxdG9tVjN2M2p6Y3oxVnhsYUVvQmRMNC9PaDJXbDlXNVVVcmFMWjlYVVI1ZXB6dmhBVSt5OUZJYnQvdDNJODEycjQ5dk1ObFVnRC9mWUVuMEFCNDJtTmdaR0JnQU9MWDd2Nko4ZncyWHhtWVdSaEE0TEgxOGM4SSt2OUxaaG1tWkNDWGc0RUpKQW9BUlZJTHNRQjQybU5nWkdCZ2x2cWpDU1JsR013WnpKbmFHSUFpS0lBWkFEeW1BbDBBQUFNY0FBQURIQUNVQXFvQU53QUFBQUFBUEFCNmVOcGpZR1JnWUdCbVVHVUEwUXhRRWdrQUFBUlZBQ3dBZU5wTmpyRnF3ekFRaGo5VHgxQW5rS2tkT2hSTkdZV044d0NGREpteVppd2trUWdPV0E2U1kvQlM4Z0I5NkY0VURUM0I4ZW0vNzRTQWtoOHlIcFd4alAxUk9ZWGNuanhqemx2aVFvNUtYUExCaWhleS9GV1NUNzRTNXl6NFRqempuVXZpUXZKNzRwSTF2NXUrdTk0RzY5V3VOOWE3VXhlbXV0cGJIOXJlcVZwWHoyQnJuZldId1JwMW5KUVoyekNlTzlYb1NqZHM2T200Y21QQTR1Vm5PMGxNWk1kSlpvR0ptb3A5ekFLdHpKMTROVnJTLzhaV0RCZXRRM3pOaUhXVW1SSWFaUzlJUDR1dmFPS3VwdmtEQ1ZFeEV3QjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5nQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTno3R050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDZ0FBQUFyS0FDSGFSb1pXRmtBQUFDQkFBQUFDMEFBQUEyS0E3UzVXaG9aV0VBQUFJMEFBQUFId0FBQUNRRWp3RzhhRzEwZUFBQUFsUUFBQUFLQUFBQUNnUkdBR1JzYjJOaEFBQUNZQUFBQUFnQUFBQUlBQ3dBVm0xaGVIQUFBQUpvQUFBQUZ3QUFBQ0FBQlFBWmJtRnRaUUFBQW9BQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRFVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXZNYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWU5Ca1p2Z1A1RE5EcEpIVS9BY0tBd0R2a1EwZWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaRWo1ejhBWXdzekFJTTdBd0NxaXBLYXV4Mml1Wm1adXgyakV6OGpIS000bUpNOG94aGdzbG15b0tjUElLS05tbUNiR3lCUG53Y2prRXMvUC9JMHJLVDVpbGEzVHd0RGtWQjZCeEQvdGxmLytwUWl5TUFBQkk0TWwwRnhOaUxtTVltenNmSXhLcGtCVDFVM1U5Qm5Wek0yTXhNVGxHQmsxd0NhSzhzWjZNUVg3Q0RFek1vcUM3V0dBbXBqMHQzWGhCMThoRmlhd1BRQVZKQ0ZNZU5wallHUmdZQURpejh5RnpmSDhObDhabUZrWVFPQ3g5ZkV2Q1BvL0ExTURNNGpMd2NBRW9nQTV0QXJUQUFBQWVOcGpZR1JnWUdiNHo4REF3TlRBWU1sZ3lSakNBQlJCQVV3QU8yd0NVQUFDZ0FBQUFZMEFaQUE1QUFBQUFBQUFBQ3dBVm5qYVkyQmtZR0JnWnBCZ0FORU1VQklKQUFBREVBQWZBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSWUFBb0FBQUFBQk53QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wUjJOdFlYQUFBQUU0QUFBQU5RQUFBRHdBVFFCK1oyeDVaZ0FBQVhBQUFBR0ZBQUFCcERZVzhJVm9aV0ZrQUFBQytBQUFBQzRBQUFBMktHSFM1bWhvWldFQUFBTW9BQUFBSHdBQUFDUUZTQUlhYUcxMGVBQUFBMGdBQUFBU0FBQUFFZ2p0QVN4c2IyTmhBQUFEWEFBQUFBd0FBQUFNQUx3Qk1tMWhlSEFBQUFOb0FBQUFGd0FBQUNBQUJ3QXJibUZ0WlFBQUE0QUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQUVUQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1NbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1CZ3hNL3dIOHBraDBraHEvZ09GQWJHK0RIb0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEthaklZL2Y4UDVHc3dHUDcvLy8vbS8wdGdWVUFBQUl0dUNNVUFBQUI0MmlYUVRVc2JVUlFHNFBPZXEvZVNDYzRrSkRQQkpOZ2tkV2FJWDRYR3VZTUdtaWlvRGJUYVJaSkNxNktWS3RwUXRIVXJsS3E0S1AwUjd0cS80TG9VK2o5MFhSQkJ1bWpyRFhMZ2ZHd2VYZzZCRHY4RG53UlJuZ2c1TDZ1a0E2bWtaMVlIUVdncURoclE2QTBwTlRlclpnUzYyNVlhT28zc3BNODhhV3RCNEpTYzdxVU9mbjc5czVaSU1kNGNsVXRIV3grTy9jK0dwS2ZHYjkvN0dhUG1QSldWeWtZUVR6ZndCUEVVd2lEUzhlcUo3b1BWaW41ZmdIRGFxeEFIaXdsSVFmZmFxL1BtNWhaYllpRDk3UGY1ajZ0WlN5YVlxTy92bTNiSjMybll6TFQwNm5BZndVRlVlNnpEdEkwdzhuU3NQYndVcFZhNDgySi9NV3lWeEVRN1d6NnN1VW4rOHZkWDN2VUZtSDAzejFZMmdWSDJwbUQxM1RraUh1UnZWQ1h5VlRuV0ppMmJiMGcxQWhQL29ReENrMzRFT1J2OWg4VTZOaWNQUHZqM0dxeHVDL05pNVhuUUhRNDlvSkt4eGhnZk45K2VDZTdVTzJQTDEzN1Nzdm5pb2lqbFRXSDdaSU14SHJIdkZBdHdnOVk3Z2QzMXBiMkpoY29DTUdBMU0zUUh2bDlFa1FBQUFIamFZMkJrWUdBQTRxZFZIOVRqK1cyK01qQ3pNSURBWSt2alh4RDBmMGFteTh3Z0xnY0RFNGdDQUZiQkM3TUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR1J3WW1KbFFFb2dnSllBRDgxQW1nQUF0TUFBQUhKQUhRQnlRQklBa2NBY0FCQkFBQUFBQUFBQURBQVlBQ01BTko0Mm1OZ1pHQmdZR1hRWWdEUkRGQVNDUUFBQlFnQU13QjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBZ1VBQW9BQUFBQUNvUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaFVoa3hHTnRZWEFBQUFFOEFBQUFTZ0FBQUZ6QmdpRjRaMng1WmdBQUFZZ0FBQVVQQUFBSEVDU3drUkZvWldGa0FBQUdtQUFBQUM4QUFBQTJLV3JTNDJob1pXRUFBQWJJQUFBQUlBQUFBQ1FHOXdMbmFHMTBlQUFBQnVnQUFBQWtBQUFBSkJaL0FkOXNiMk5oQUFBSERBQUFBQlFBQUFBVUJtWUlQRzFoZUhBQUFBY2dBQUFBR0FBQUFDQUFEQUJ2Ym1GdFpRQUFCemdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFJQ0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBR2pBSUxOa0ZKY2xnNlUxSG1Rd016d0g4aG5abUFFcTBHbytBOFVCZ0R4Z3czckFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzhnRFFmQXdkUWpvMUJoeUdkSVpzaGo2SDBRY0wvLzBCeEhZWTBJRDhYd3Y5LzlmK2MvelAvei9nL1NYNEZXRGNTQUFDYUZoUFBBQUI0Mm4yVjNZc2JWUmpHNTMzUGZHUm1Nbk15bWE5a041dVBtY2xNZHJOTnN2bk83amJaYkhicDE5WnRGYnV0bExZSVZoUUtRcWxJeFN1dmhDSWlYbmlyRnlJaWlKZUNsNlZlZXlGNDRaL1JGcnpaOVp6RXRsQm9aMkRnbkRNNWVaL2Y4NTVuQkJEdW5td0tUNFNQQlU4UUJvcXNOS0RiSHhUQmxTbklTcHowQjJQNE82M2JoVko1S1lyRXFscWxPZ0c1VThxa0ZJQkt1d0l3M2pqcUdXMUFRNUUyYmdyc0F1SENTUk0veEQrRkhUWWdmQ01UbENCT3h0RHhmRTlXdkJLTVlVSkNPZTc3blRHd3YraTBQZCtFTUU3aS9pQnVnb2tVT24xUFR1Qzd6WXlZV1ZLbkc3Vk5nTWlOQ2RBU3BUU3FrSlVHUFNpaVRTOVQxL1IydzlWdGdOQmo2NWtpcGRsc1VVc3QzZVRMOE0zeHcvUFdUdGVaa1Rnc2xqR1NFMTFGRUMrNDN6NDVJb0VDUjllV2s3Z2F2VmlDZkh6cVN6RklBZGVDd3ZySkthekNRNkVoekxnYXBrU2VLMkVWTzdMaWV4MlBNNW9BUjhkdzhic0lQbFBGWGlBVDZDZE1sS3h3Qko3ZjVxOWk1U1AxN2lmTkd5S3IxL0xBekJhc2lyTWRGanpGSDV5YlhrTXlwZGE1YTdXZVFaYXloZ3RmTndrNGJuZHBWbll6RnNSSmNiZVFWdUQrOGJUNURrRjNmYVZpMjNwUmt4RDBRcjVWdnQ0UjRlalNlMi9ZZEk5QTVHVTh5RmpILy81RzlXb29RcTBYVDNjT0IxQXRVMlB1MDhXVHA3aVBmd2hYdURKZVc5dHpuOXZBS3ViV01jZlk3VkRpZVA3Q0t6NmhjRW5NMG5qUVQ1aHVDaVlFY1c5Z2p5RU9GMDRQK3A0QzA5dWxxOG5sdDJOV0NyUEdMNXRPL1RDSi9WeTVTMmxMUkNJQmRlSzZSaFJObFFFeW1sTVlKVE1FaVFDY0g0WlU5R05MK2twRUdxa1pBRlBaVzY4Qy9uajh2bmxRN2EwdlZ5b1ltVkhLQk5pTUt3NHJRVks5a2FZYXl6WnJNUEZpUkRWRVRXb3NGeHBpcDI5bVRibVdTQTgyc3puYjhIRFBvSnFvMFpRaWt2U2laMXNuVDhrLzhFaTRJd2pWQ2V2UE9ERUpSWlBFeVlUMGUxMDJCRWFrQ1ExZ29IRE9vajkvZW42UjljU2l5MTJaZTl6dnpLY1doTG9UWkRQLy8zeXhZWGNBdjljcFFhYyt1bEEzbFJWSFV0MkNBMW85cmN2VUxnYTZwR2k2REk2bEpyTTl4VC9hV1gxVHkxM2RQNU1yNklBTzJycXBrWlh5WmhhempKcVh0c0xUdFJFUW8rb2l1cXZiaDNsVFZ3cXVsUEtXWFpEZStubmJEanNFdDhlVmxYdVhIR3F5aGxqN3BkWHdNMjRCWUtmaHNDMlJUb3QyaEd1OXloYmkyazQ0UThuUGRZM0d0cnpGSUZzQlRrNW5FZjJXN3pYRTVtcGFMOStlYmJnYmlMT2F1MVI4dHFsa1ArZUkzek9PaDRMd09uQ3ZBd2J6WS9UQ2dNOWVDV2I5Q3VGQTBvWkdDdVd0TEZxYURMNXVoZVBhRUVpYWVoNitESG42T3UyTmM2L1dITzNPTnJJdmdWem9mWXlmczN3NFlIM0RUeEE3S3NoMHpVOExVMUtDZVU3SVBEVjRkaVFOM2c2RHJoS3dxVERoemNESExDem1LU2t2K0F6ZzE1N3NqRVE1OUdUVnRNdGhLaVhxVEp1ZExmVFNaNXo4NmVabWF6a04yWm9GK2RLMkRSYWo0cWNYdXNId0EwQ3YweHhUbEg3NEt4K1ZGUCtMNjI3RGRGY0E5NU5sR2ZpeDJLbDBFYjFtZmhVd3pJL0toN2ZEb0FxVGNRWlJOVnUrMjVCYU5iODQvS0JwVFNUY1dpTE9QQXR6SjQvaEljdjFrWENXZnkxTWpMc1QwdVhCTVZnazM3TmttRnVyeUZ3OFg1c0ErNkp3ZFN3anVidGpTTHJLUXUvOVJGNHhkR0ltVlZGUHhZRWVHTlphcjVuV1VScXV0YWFCSmlMSXFsRVA5eXZNZkVVbDNjeXdQZDJhRGF1MVNZRkVxeXhYYU81Qm9PUWdyWWxtSllqMjI4bTkzVnpienJaRU1RenB1OWYzaDJkTHFWUXFzRTZWNmlLc0ZYVkVNQ1M5cGtaQWJ2MDBxZzF2ZmFyMVFUeFl2ek80SWZ3SHVpdml6UUI0Mm1OZ1pHQmdBR0pmQ3huWmVINmJyd3pNTEF3ZzhOajYrQmNFL1YrWCtRN1RSU0NYZzRFSkpBb0FGYjhMQVFCNDJtTmdaR0JnWnZqUHdNREF3c3NnOGY4Qzh4MEdvQWdLNEFRQVdnSUQ1UUxHQUFBQld3QnpBam9BU3dJNkFDd0NiZ0JOQkEwQU1BTFRBREFDc3dBd0Fla0FHQUFBQUFBQUtnQ1FBUDRCaEFJb0FxQURGZ09JZU5wallHUmdZT0JreUdOZ1lnQUJSZ1kwQUFBTUx3QjhlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUzRBQW9BQUFBQUJXZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUNHTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWV3Q01aMng1WmdBQUFXd0FBQUhtQUFBQ0tKb2lwSHhvWldGa0FBQURWQUFBQUM4QUFBQTJLSmpUcTJob1pXRUFBQU9FQUFBQUhnQUFBQ1FHTVFHOWFHMTBlQUFBQTZRQUFBQVFBQUFBRUFzNEFKSnNiMk5oQUFBRHRBQUFBQW9BQUFBS0FXZ0FzRzFoZUhBQUFBUEFBQUFBR0FBQUFDQUFDQUJBYm1GdFpRQUFBOWdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFckFBQUFBd0FBQUFnQUFNQUFIamFZMkJtT3NjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaQWhsWnZnUDVETkRwSkhVL0FjS0F3RHlJZzFVZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pHRS92OFA1RHVDNlA4SC9xOERxd0lDQUpKeUNRRUFBSGphTmRGTmF4TkJHQWZ3K1Qrem1jM2I3cVR1WmxmSkd6RXhxNFkwMGlTN3RzZ0tqWTFpTVVRRFVyQlk4S1cxSGdTMVZyM2xrSk1vSGlxQ0p4RzllUll2bmp6NUpUeUlKL0V6SkhFMnhibk16UFBNNGZkL2hoR3J6bWIwaTM2eUpsdGlMSUFmTERtdVpUc3QzeEZONkY3TmEvdXU0d2RObEhWaE82N3ZtbEQxcU53S0ViVDRWOXdWdGlFUU9vMHMwckc5VVR3R0kyVzFlVUtmenZwRzNqSTRqTmpPUmhycHhQSHczZC95UGwzUElDRW5JMGZ5Z2c3T1FYR3BBMmwzZTIxc1Z6TWdhWXFvbkpRQ2xSKzR4dFRpckQ2YmNFSGZXSkdkWm1lVjFHcFhQS0ZzNVNLeUp2UWlYQ0VoOUxLWWU2MEk1OWU4U2szby9QK1pxd2V0VDY5eVhrRktiR3plNHFQaCtoQjBNWFBseWZRZ2I1b3J4ZmR2dC9ZSWk5MXh5WW85ZUxtNVQzVG0wdmVlQnBnRFdsNGdudGRCVjFjdTc4aGtmM2w5MVF5MUtBRXNyUEZIdmVvRmdqdzIrY3lmOWs4TStQVDNFWkZrREt3Nys4T1R5aDJxQzFmUVJYaTE4OXp2SFBKTENGekh0WVVYT1ZXQUlpS3NGWEdGRjBLMW5SSk1lQ2JveFkzQ2h6dkR4MFNKazQyVVVDRU1NUjZyWVV1N1U5QnV4NG1vMXhrYzVMZUFmRjF5OVJYM2R4TkVTR3ZuR2pTWXZybjNXc1AyVGR2NytLWHVpc01vODlHYktrQTJOMzFZeVI1ZDdlTDVMcDZsRm5KS2FzNzdtb2oyVS84QXl2ZFltd0FBZU5wallHUmdZQURpUGROMy80L250L25Ld016Q0FBS1ByWTkvUWREL1h6SnpNZDBGY2prWW1FQ2lBSHlNRFVZQWVOcGpZR1JnWUdiNHp3QWtPUmhVL205ZzVtSUFpcUFBRmdCSVJBTDBBQUFDZGdBQUF3QUFKQU1JQUNzQ3VnQkRBQUFBQUFCVUFMQUJGQUFBZU5wallHUmdZR0Joc0dkZ1pnQUJSZ1kwQUFBSEtBQkplTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjEuNzM5ODY1LC02MS44MDM1MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01Ljk5MzA3LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS43Mzk4NjUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02MS43Mzk4NjUnIHk9Jy02MS44MDM1Myc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTQuMjY3ODY2JyB5PSctNjAuMzA5MTUnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuOTQ2NDksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjczOTg2NScgeT0nLTYxLjgwMzUzJz5VPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwNy44MTc5MywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuNzM5ODY1JyB5PSctNjEuODAzNTMnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU0LjI2Nzg2NicgeT0nLTYwLjMwOTE1Jz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1LjMyMDQ4LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuNzM5ODY1JyB5PSctNjEuODAzNTMnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjQ2OTM5MScgeT0nLTYxLjgwMzUzJz7DlzwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDEuNTA2Nzc3JyB5PSctNjEuODAzNTMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTM3LjYzMjQwNCcgeT0nLTYxLjgwMzUzJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0zMC4xNjA0MDUnIHk9Jy02MC4zMDkxNSc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMjMuNDc3MTY5JyB5PSctNjEuODAzNTMnPuKIqjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTQuNjIxNTIxJyB5PSctNjEuODAzNTMnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTcuMTQ5NTIyJyB5PSctNjAuMzA5MTUnPjI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIuNjgwMTUyJyB5PSctNjEuODAzNTMnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEyLjc0ODYxIDBINDcuODkwOTUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTIuOTk4NjEsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4xNDA5NSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI3Ljc5NjE0LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS43Mzk4NjUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02MS43Mzk4NjUnIHk9Jy02MS44MDM1Myc+7oGgPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMDEuMDYyNCAwSDY1LjkyMDA2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwMC44MTI0LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsNjUuNjcwMDYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4Mi4xMzExNSwyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuNzM5ODY1JyB5PSctNjEuODAzNTMnPms8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNDYzNjEtOS40NjUxNkw0Ny42NDczNy00Ny42NDIyNicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC43MDcxNSwwLjcwNzAzLC0wLjcwNzAzLC0wLjcwNzE1LDkuNjQwNCwtOS42NDE5MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNSwtMC43MDcwMywwLjcwNzAzLDAuNzA3MTUsNDcuODI0MTYsLTQ3LjgxOTAyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxLjgxNTM0LC0zNi4wMTQ1NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYxLjczOTg2NScgeT0nLTYxLjgwMzUzJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01OC42MjY1MjInIHk9Jy02MS44MDM1Myc+Zjx0c3BhbiB4PSctNTQuMzg4ODg3Jz4sPC90c3Bhbj48dHNwYW4geD0nLTUwLjY2MjExJz51PC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQ1Ljk1MTcxNScgeT0nLTYwLjgwNzI2Nic+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDIuMDYzNDY0JyB5PSctNjEuODAzNTMnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtOC42MDk3M1YtNDcuNDk1NzcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCw1Ni45MDU1LC04Ljg1OTczKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ3Ljc0NTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J000Mi44OTA0LTMzLjcwMjc0SDcwLjkyMDYxVi0yMC43MDI3NEg0Mi44OTA0Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDUuODkwNCwtMjguOTUyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS43Mzk4NjUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02MS43Mzk4NjUnIHk9Jy02MS44MDM1Myc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTguNjI2NTIyJyB5PSctNjEuODAzNTMnPm0sPHRzcGFuIHg9Jy00Ny44MzAxMzknPm48L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDIuOTA1Mjc3JyB5PSctNjEuODAzNTMnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTA0LjM0NzQtOS40NjUxNkw2Ni4xNjM2NC00Ny42NDIyNicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE1LDAuNzA3MDMsLTAuNzA3MDMsMC43MDcxNSwxMDQuMTcwNjEsLTkuNjQxOTIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjcwNzE1LC0wLjcwNzAzLDAuNzA3MDMsLTAuNzA3MTUsNjUuOTg2ODUsLTQ3LjgxOTAyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OS4xMjA0OCwtMzYuMDE0NTQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS43Mzk4NjUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02MS43Mzk4NjUnIHk9Jy02MS44MDM1Myc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTguNjI2NTIyJyB5PSctNjEuODAzNTMnPmc8dHNwYW4geD0nLTU0LjQ4OTU3Mic+LDwvdHNwYW4+PHRzcGFuIHg9Jy01MC43NjI3OTUnPnU8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDYuMDUyNCcgeT0nLTYwLjgwNzI2Nic+MjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDIuMTY0MTQ5JyB5PSctNjEuODAzNTMnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$A_{1}$};
      \node  [right = of 1] (2) {$U$};
      \node  [right = of 2] (3) {$A_{2}$};
      \node  [below = of 2] (4) {$B \times  (A_{1} \cup  A_{2})$};
      \draw  [>->,morphism] (1) to node {$\ell $} (2);
      \draw  [>->,morphism] (3) to node[swap] {$k$} (2);
      \draw  [>->,morphism] (1) to node[swap] {$(f,u_{1})$} (4);
      \draw  [>->,morphism] (2) to node[desc] {$(m,n)$} (4);
      \draw  [>->,morphism] (3) to node {$(g,u_{2})$} (4);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>The pullback of <fr:tex
display="inline"><![CDATA[\ell  \cup  k]]></fr:tex> along <fr:tex
display="inline"><![CDATA[a]]></fr:tex> or <fr:tex
display="inline"><![CDATA[b]]></fr:tex> are the maximal subobject of <fr:tex
display="inline"><![CDATA[V]]></fr:tex> since isomorphisms are stable under pullback.
    Thus, we have</fr:p>
  <fr:tex
display="block"><![CDATA[     V \cong  a^{*}(\ell  \cup  k) \cong  b^{*}(\ell  \cup  k)   ]]></fr:tex>
  <fr:p>Since finite unions are stable under pullback in a coherent category, we also have</fr:p>
  <fr:tex
display="block"><![CDATA[     V \cong  a^{*}(\ell ) \cup  a^{*}(k) \cong  b^{*}(\ell ) \cup  b^{*}(k)   ]]></fr:tex>
  <fr:p>Now, we can decompose <fr:tex
display="inline"><![CDATA[V]]></fr:tex> as the union of 4 subobjects using <fr:ref
addr="ct-0011"
href="ct-0011.xml"
taxon="Lemma" />.</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       V \cong  V \cap  V &\cong  (a^{*}(\ell ) \cup  a^{*}(k)) \cap  (b^{*}(\ell ) \cup  b^{*}(k))\\                    &\cong  ((a^{*}(\ell ) \cup  a^{*}(k)) \cap  b^{*}(\ell )) \cup  ((a^{*}(\ell ) \cup  a^{*}(k)) \cap  b^{*}(k))\\                    &\cong  (a^{*}(\ell ) \cap  b^{*}(\ell )) \cup  (a^{*}(\ell ) \cap  b^{*}(k)) \cup  (a^{*}(k) \cap  b^{*}(\ell )) \cup  (a^{*}(k) \cap  b^{*}(k))     \end {align*}   ]]></fr:tex>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[e\colon E\rightarrowtail V]]></fr:tex> be the equalizer of <fr:tex
display="inline"><![CDATA[ma]]></fr:tex> and <fr:tex
display="inline"><![CDATA[mb]]></fr:tex>.
    To show that it is an isomorphism, it suffices to show that each of the 4 subobjects is contained in <fr:tex
display="inline"><![CDATA[e]]></fr:tex>, i.e., each of the 4 subobjects equalizes <fr:tex
display="inline"><![CDATA[ma]]></fr:tex> and <fr:tex
display="inline"><![CDATA[mb]]></fr:tex>.
    Let <fr:tex
display="inline"><![CDATA[\ell ']]></fr:tex>, <fr:tex
display="inline"><![CDATA[\ell '']]></fr:tex>, <fr:tex
display="inline"><![CDATA[k']]></fr:tex>, and <fr:tex
display="inline"><![CDATA[k'']]></fr:tex> be given as follows:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="73af26b69a1e87847f10a59ec2830a1a"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzY1NC4wODU0MDVwdCcgaGVpZ2h0PScxMTcuMDI1MjU1cHQnIHZpZXdCb3g9Jy03MiAtNzIgNDM2LjA1NjkzNiA3OC4wMTY4MzcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPc0FBb0FBQUFBQkJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUUwQUFBQmdxbU5pZTJOdFlYQUFBQUZFQUFBQU13QUFBRHllV21SYloyeDVaZ0FBQVhnQUFBRGdBQUFBN0QwTlFsdG9aV0ZrQUFBQ1dBQUFBQ3NBQUFBMktlTFRRV2hvWldFQUFBS0VBQUFBSHdBQUFDUUY3Z0RhYUcxMGVBQUFBcVFBQUFBTUFBQUFEQWtLQU8xc2IyTmhBQUFDc0FBQUFBZ0FBQUFJQUZRQWRtMWhlSEFBQUFLNEFBQUFGd0FBQUNBQUJRQTJibUZ0WlFBQUF0QUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1abWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUE0TURqSjFTWEpiT3dLWWsvc0NBV2V1UEpRTURzeGJ6Y2FBd0kwTDEvLzhNREFEb3R3N2ZBQUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFabVJnVWhKL1lQRC9Qd01EaEw3N1N2NFNXQlVRQUFDbmlRbXlBSGphTFk1UFNzUXdIRWJ6cGNNdlZOUGFQMm5Tb2s3SERLYTdrU2wxQ2lMMUVvb2JzWWpRdld0dm9PQVJSbkRuR2J5R3l6bUxtTVdzSHQvN05vK0JmYkFsZjhhT2RZeWgzN1JhMFJHMDBTYUd1MEFORWl0ME54RFVXT2ZwR3RjTWFHczA3ckxiOU5vSXZIM0tTcVgwZlgrWGM2Z3EvSXFJMnpRbitYNU9VVkY2cnppS010cEt5bFBMRDNFOGhzckdmRGc5RTJXbVFFL1QxVHhBWnRiVGJRRmxrLzBSanRQNklNckE2MGVmeGtiVzRKVmZzOFNQZ0phK284OEg5SzAySlBEeVMxTG53V3diVlBQS0FUUHMvaDVTSWFJRVAvRUNpeE1wMlQ5dWZCL1FlTnBqWUdSZ1lBRGhlUTJoOGZ3Mlh4bVlXUmhBNExIMUNSWmttaVdVeVFaSWNUQXdnWGdBNmFrSGtRQjQybU5nWkdCZzF2cGp5Y0RBRXNvUXorREJsTXdBRkVFQnpBQklkUUxOQUFSVkFBQUM4Z0NPQWNNQVh3QUFBQUFBVkFCMmVOcGpZR1JnWUdCbU1HVUEwUXhRRWdrQUFBWGxBRHdBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSWUFBb0FBQUFBQk53QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wUjJOdFlYQUFBQUU0QUFBQU5RQUFBRHdBVFFCK1oyeDVaZ0FBQVhBQUFBR0ZBQUFCcERZVzhJVm9aV0ZrQUFBQytBQUFBQzRBQUFBMktHSFRCbWhvWldFQUFBTW9BQUFBSHdBQUFDUUZTQUlhYUcxMGVBQUFBMGdBQUFBU0FBQUFFZ2p0QVN4c2IyTmhBQUFEWEFBQUFBd0FBQUFNQUx3Qk1tMWhlSEFBQUFOb0FBQUFGd0FBQUNBQUJ3QXJibUZ0WlFBQUE0QUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQUVUQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1NbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1CZ3hNL3dIOHBraDBraHEvZ09GQWJHK0RIb0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEthaklZL2Y4UDVHc3dHUDcvLy8vbS8wdGdWVUFBQUl0dUNNVUFBQUI0MmlYUVRVc2JVUlFHNFBPZXEvZVNDYzRrSkRQQkpOZ2tkV2FJWDRYR3VZTUdtaWlvRGJUYVJaSkNxNktWS3RwUXRIVXJsS3E0S1AwUjd0cS80TG9VK2o5MFhSQkJ1bWpyRFhMZ2ZHd2VYZzZCRHY4RG53UlJuZ2c1TDZ1a0E2bWtaMVlIUVdncURoclE2QTBwTlRlclpnUzYyNVlhT28zc3BNODhhV3RCNEpTYzdxVU9mbjc5czVaSU1kNGNsVXRIV3grTy9jK0dwS2ZHYjkvN0dhUG1QSldWeWtZUVR6ZndCUEVVd2lEUzhlcUo3b1BWaW41ZmdIRGFxeEFIaXdsSVFmZmFxL1BtNWhaYllpRDk3UGY1ajZ0WlN5YVlxTy92bTNiSjMybll6TFQwNm5BZndVRlVlNnpEdEkwdzhuU3NQYndVcFZhNDgySi9NV3lWeEVRN1d6NnN1VW4rOHZkWDN2VUZtSDAzejFZMmdWSDJwbUQxM1RraUh1UnZWQ1h5VlRuV0ppMmJiMGcxQWhQL29ReENrMzRFT1J2OWg4VTZOaWNQUHZqM0dxeHVDL05pNVhuUUhRNDlvSkt4eGhnZk45K2VDZTdVTzJQTDEzN1Nzdm5pb2lqbFRXSDdaSU14SHJIdkZBdHdnOVk3Z2QzMXBiMkpoY29DTUdBMU0zUUh2bDlFa1FBQUFIamFZMkJrWUdBQTRxZFY3NS9IODl0OFpXQm1ZUUNCeDlZbldCRDBmMGFteTh3Z0xnY0RFNGdDQUV2bENwUUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR1J3WW1KbFFFb2dnSllBRDgxQW1nQUF0TUFBQUhKQUhRQnlRQklBa2NBY0FCQkFBQUFBQUFBQURBQVlBQ01BTko0Mm1OZ1pHQmdZR1hRWWdEUkRGQVNDUUFBQlFnQU13QjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLUjdUUVdob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0xkTEJjWHh2UGJmR1ZnWm1FQWdjZldKMWlRYWVhSlREWkFpb09CQ2NRREFBM3VDSW9BQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFXc0FBb0FBQUFBQnJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVjQUFBQmdoWDFrbG1OdFlYQUFBQUU4QUFBQU5RQUFBRVFBZ09FdFoyeDVaZ0FBQVhRQUFBTFVBQUFEZE56WS81Tm9aV0ZrQUFBRVNBQUFBQzhBQUFBMktGVFR5bWhvWldFQUFBUjRBQUFBSHdBQUFDUUZZd0hzYUcxMGVBQUFCSmdBQUFBVUFBQUFGQXVaQU9ac2IyTmhBQUFFckFBQUFBd0FBQUFNQWJJQ2ZHMWhlSEFBQUFTNEFBQUFHQUFBQUNBQUNBQllibUZ0WlFBQUJOQUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1DbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FHakFJTE5rRkpjbGc2VVRIeVF3TXp3SDhoblptQUVxMEdvK0E4VUJnRG5PQTN5QUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnTWdEUUhFSUxra2hpeUh5VDgvdzlrSlVKWS94ZjhueUcvQkt3V0RBQVFvZ3lIQUFBQWVOcFZrajl2MjFZVXhYbmVlK1NqS09zOVNhUklGWklwaTZRZUdjbFNYRXNtWlNlUUt0c3lFc05HRXZSUDRpQUpnZ0J0MGFGamwzcnAxaVZEUDBiUnFVdUg3Z0c2RmVnbktOQitoVFpiNHo0NmFJSGN1OTE3aC9NNzV4ckVXRno5VGU3aWxURTJQakFNTExEckI1SUl0RHcvV0dDSnZBYy84Q3l1VzZVQ2ZJSTBMOG9PUVlzOFZhbXl1QjZIS0JZb2N2eG9iblk4TkZzK3IwaDNLN1p0NWpnVzNFWW5EdzRiNGQzaDBVT3dwWFJQSHc5bTcwL2h0YWJCU2V4R3dIWVl6V3lGYjMyMzNyaC8vcVExRVg0WFpKMTJMQkRpbUt1dEtVVm5IR2JBMDdOUEg3ak5FNHJvemUrL2Jnd1NSckpiOFRmallnTFNzN3VHTG1JY1hiM0dIK1FYSXpKeXpVUkxaWDVnU1ZpbGZMWFVBeFZIS2wxZ3FoZTgzQyt3TjBFY2FSUjlwZGtoVG9MRGJQNk0wbFgvOUdMMUVXQ05KNDVGWkZKcEFKSWZieWNvc3JYYjNzUW92TDBRTmd2dEcrVDdOMy82R3ViRGl5L3V4OGNVRi9mcTBjOC9EWU9hd3h4cGMwWTMvbm1NMituT1pUeTdlU3lsdU16ZW14eG9nY2I1MVd1eTFuby9LZFhtUlJsQ1N5RFc1dWFGZXF1SiswSFpucVRYd2VpYmFUa29jK0VhUmVrc05KdUVRS1QyQ3ZkZFFxdys2ejFLSDN5c2tQaUtJdGdTM3VoZXFvTDIxa3pLSFVhb0NlbXBrVU81VTdHQXV1TjE5OU1qQXBNQ3AvTllza0Exek85WVNWOEhoS1lmUU1OK0xzNEdlOXVkZnA4a0lyRUZjS0Q2bnBaZ1Z2eDlwMUxydUg0UDdEeVJUaG5ocE5PZHNHa3Vtc0xLVXZQbFFiUHQxbnh5WEpQL20vTTJ1L2JWWDNoRmZqUDJqVHVHVVhCQjFHeEpaL24xZTEzM2Y5VGwzN1c0VmY1bnVWc2loRGFObHhucnQ5WDM2ZXo2aGx0ZnA5Wm1yVXBGT21CVlcwWFZxTllZN3QzY3FCSnpQdHhaUlE0anNDcTFVYnp1VjAzT0szUlduKyt1YmgzTkI5bXlTNU1iMmpQWmZobnhOalljSnZwUnN0NU52enBzNzdyTkhjYmlXTDU0c3A3ZjZkbTJIVFhHdlJIRE1Ld1NncHBaelNvSjZQTWY5clA1ODBzbkJ6dmIvcko0WnZ3THROMTE4SGphWTJCa1lHQUE0bWIrMTcvaitXMitNakN6TUlEQVkrc1RMQWo2L3hlbVkwd1hnVndPQmlhUUtBQkFxUXVOQUhqYVkyQmtZR0JtK00vQXdNQjBqRUdDUVlISmt3RW9nZ0pZQVR5RUFsVUFBc1lBQUFKNkFENENBZ0JEQW00QVRRSHBBQmdBQUFBQUFHb0F3Z0ZJQWJwNDJtTmdaR0JnWUdVSVoyQmlBQUZHQmpRQUFBbUVBR0Y0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU1VBQW9BQUFBQUJVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MDNHTnRZWEFBQUFFNEFBQUFOUUFBQUR3QWZBQ0taMng1WmdBQUFYQUFBQUcrQUFBQ0FEZ3VSdFJvWldGa0FBQURNQUFBQUM4QUFBQTJLS0hUeDJob1pXRUFBQU5nQUFBQUhRQUFBQ1FHT2dGSGFHMTBlQUFBQTRBQUFBQVFBQUFBRUFxRkFLRnNiMk5oQUFBRGtBQUFBQW9BQUFBS0FWUUF1RzFoZUhBQUFBT2NBQUFBR0FBQUFDQUFCd0JBYm1GdFpRQUFBN1FBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFaUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtV3NnNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaQWhqWnZnUDVETkRwSkhVL0FjS0F3RGg1ZzBvZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pLRS9mOFA1RHN5aFA3Ly8vL0EvN1ZnVlVBQUFKSm5DUUFBQUFCNDJqMlJ6VzdUUUJTRjU5eHh4bmJqc1ZQOEI4U21sRlFlb2hJaUpZNHRJV1FRRWUwT0ZhZ3FKQ1JZUUF0bGd4QUlsUldWeUlwTkY3QmhpWGlHaWcwUHdFdXdBSWtGNGhrU013bUl1eG5kY3pmZmQ0WVJXNnRyK2s3ZldKOE5HQ3RSbElNbzlvTm9XRVNpRDFObEtpL2lxQ2o3V0RWRkVNVkY3RUxuODNoWW9Senl6OWdWZ1JTb29sNElwL0hpMEdwQU52MmMyK2FzdmlFVFgzTEl4cU03RGh6N1hQWGg5K3BMMm1uQjlxYUhrY2RURTV5RExNOEVuSGp2K2lSWWE0RThWOHpqSlUrZzh4VzNtQjZ3Y2YyTEw5RVhWdW1GdXpBdlFtVlhlREhLTzBya3hRcktPSW9Eb1RKaGN1SGhET1owZmxsa1NxZ0sraHl0d0lWeVFXL3ZwaDhmM241T1pKL3ZOVVZicFZKTUpocmFDMGFwOGNBaW9vM1IxcnZrUHBDc2Uxd3JQZG0zaWVBWWwzdTBOWHYvK01qQTNyMUFmVHBlajhVeThlU2ZncXNWd3Zic1dTYzhlVzJNVi9zNGFDNjNOYW03dUJ0aS9uYTF4Nlg2Si9lMVI1Y3hHMExUOFR6ci9EWFFsU3NSK3ZvUC9sTVBRbE9ZbWFBM3N5TXJPTUZ2QnQxVFVqeDlMY2xyYm01Z3JIdTY0SEs0amQxdHFZWFNxN1E1UFE1Z0pIVGd0M2k2cVBHMENVcW5QNGlrYzViSVhYVHIyQlloWmV3UGdGOUtTUUFBZU5wallHUmdZQURpeGxlVmhmSDhObDhabUZrWVFPQ3g5UWtXQlAzL0tiTXcwMTBnbDRPQkNTUUtBREtnQ3JVQWVOcGpZR1JnWUdiNHp3QWlHVlQrT3pFTE13QkZVQUFMQUQ4aEFvY0FBQUFDZGdBQUF3QUFKQUs2QUVNQ1ZRQTZBQUFBQUFCVUFMZ0JBQUFBZU5wallHUmdZR0Joc0dkZ1lnQUJSZ1kwQUFBSEVRQkllTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ3LjY5Nzg1NywtNjAuODcyNTQzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuOTkzMDcsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ3LjY5Nzg1NywtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00Ny42OTc4NTcnIHk9Jy02MC44NzI1NDMnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTQwLjIyNTg1OCcgeT0nLTY0LjQ4NzkwNyc+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00MC4yMjU4NTgnIHk9Jy01OC4zOTk3MTQnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuMDI3NzcsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ny42OTc4NTcsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDcuNjk3ODU3JyB5PSctNjAuODcyNTQzJz5WPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTExLjA5MTgxVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDAuMCwtMTEuMzQxODEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIxLjM3OTQsLTMwLjUyNzEzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDcuNjk3ODU3LC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ3LjY5Nzg1NycgeT0nLTYwLjg3MjU0Myc+YTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDMuMzc2NDEzJyB5PSctNjMuODc5MDYnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMzkuMjExNDQ0JyB5PSctNjAuODcyNTQzJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zNi4wOTgxMDEnIHk9Jy02MC44NzI1NDMnPu6BoDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMzIuNzYzMzQ3JyB5PSctNjAuODcyNTQzJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUwLjkxMjQzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ny42OTc4NTcsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDcuNjk3ODU3JyB5PSctNjAuODcyNTQzJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00MC4yMjU4NTgnIHk9Jy01OS4zNzgxNjInPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuOTQ2NDksLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ny42OTc4NTcsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDcuNjk3ODU3JyB5PSctNjAuODcyNTQzJz5VPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMC41NDg2MSAwSDQ1Ljg1Njg5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjEwNjg5LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuNDI2NjgsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ3LjY5Nzg1NywtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Ny42OTc4NTcnIHk9Jy02MC44NzI1NDMnPu6BoDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDQuMzYzMTAzJyB5PSctNjMuODc5MDYnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS0xMC4xMDk3Vi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTEwLjM1OTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0zMC4wMzYwNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ3LjY5Nzg1NywtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Ny42OTc4NTcnIHk9Jy02MC44NzI1NDMnPu6BoDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC41ODMzMS01Ni45MDU1SDQ3Ljg5MDk1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjE0MDk1LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNi4zMTgzLC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDcuNjk3ODU3LC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ3LjY5Nzg1NycgeT0nLTYwLjg3MjU0Myc+YTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjUuOTg1NjAxLC02MC44NzI1NDMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNi4zMDU1NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg2NS45ODU2MDEsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSc2NS45ODU2MDEnIHk9Jy02MC44NzI1NDMnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nNzMuNDU3NjAxJyB5PSctNjQuNDg3OTA3Jz7ugLDugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNzMuNDU3NjAxJyB5PSctNTguMzk5NzE0Jz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00LjAyNzc3LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg2NS45ODU2MDEsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSc2NS45ODU2MDEnIHk9Jy02MC44NzI1NDMnPlY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtMTEuMDkxODFWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsMC4wLC0xMS4zNDE4MSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjAuNTU4NDEsLTMwLjUyNzEzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg2NS45ODU2MDEsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSc2NS45ODU2MDEnIHk9Jy02MC44NzI1NDMnPmI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNjkuNDg5MTM5JyB5PSctNjMuODc5MDYnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSc3My42NTQxMDgnIHk9Jy02MC44NzI1NDMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNzYuNzY3NDUxJyB5PSctNjAuODcyNTQzJz7ugaA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nODAuMTAyMjA2JyB5PSctNjAuODcyNTQzJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUwLjkxMjQzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDY1Ljk4NTYwMSwtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzY1Ljk4NTYwMScgeT0nLTYwLjg3MjU0Myc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSc3My40NTc2MDEnIHk9Jy01OS4zNzgxNjInPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuOTQ2NDksLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDY1Ljk4NTYwMSwtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzY1Ljk4NTYwMScgeT0nLTYwLjg3MjU0Myc+VTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTAuODYxMSAwSDQ1Ljg1Njg5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjEwNjg5LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjQuNDgwNDgsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNjUuOTg1NjAxLC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNjUuOTg1NjAxJyB5PSctNjAuODcyNTQzJz7ugaA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNjkuMzIwMzU2JyB5PSctNjMuODc5MDYnPu6AsO6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS0xMC4xMDk3Vi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTEwLjM1OTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0zMC4wMzYwNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNjUuOTg1NjAxLC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNjUuOTg1NjAxJyB5PSctNjAuODcyNTQzJz7ugaA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguNTgzMzEtNTYuOTA1NUg0Ny44OTA5NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4xNDA5NSwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjYuNzI4NzksLTY0LjU3ODQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDY1Ljk4NTYwMSwtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9JzY1Ljk4NTYwMScgeT0nLTYwLjg3MjU0Myc+YjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTgxLjU1NTg3NSwtNjAuODcyNTQzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuOTkzMDcsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTgxLjU1NTg3NSwtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzE4MS41NTU4NzUnIHk9Jy02MC44NzI1NDMnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTg5LjAyNzg3NCcgeT0nLTY0LjQ4NzkwNyc+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzE4OS4wMjc4NzQnIHk9Jy01OC4zOTk3MTQnPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuMDI3NzcsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDE4MS41NTU4NzUsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScxODEuNTU1ODc1JyB5PSctNjAuODcyNTQzJz5WPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTExLjA5MTgxVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDAuMCwtMTEuMzQxODEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIyLjQ1MjMsLTMwLjUyNzEzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxODEuNTU1ODc1LC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTgxLjU1NTg3NScgeT0nLTYwLjg3MjU0Myc+YTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScxODUuODc3MzE5JyB5PSctNjMuODc5MDYnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxOTAuMDQyMjg4JyB5PSctNjAuODcyNTQzJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzE5My4xNTU2MzEnIHk9Jy02MC44NzI1NDMnPms8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMTk3LjU1OTI4NScgeT0nLTYwLjg3MjU0Myc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MC45MTI0MywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxODEuNTU1ODc1LC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTgxLjU1NTg3NScgeT0nLTYwLjg3MjU0Myc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxODkuMDI3ODc0JyB5PSctNTkuMzc4MTYyJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjk0NjQ5LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxODEuNTU1ODc1LC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTgxLjU1NTg3NScgeT0nLTYwLjg3MjU0Myc+VTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTAuNTQ4NjEgMEg0NS44NTY4OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni4xMDY4OSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0Ljg5MDIzLDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDE4MS41NTU4NzUsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PScxODEuNTU1ODc1JyB5PSctNjAuODcyNTQzJz5rPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzE4NS45NTk1MjknIHk9Jy02My44NzkwNic+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTEwLjEwOTdWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwtMTAuMzU5NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTMwLjAzNjA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxODEuNTU1ODc1LC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTgxLjU1NTg3NScgeT0nLTYwLjg3MjU0Myc+azwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC41ODMzMS01Ni45MDU1SDQ3Ljg5MDk1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjE0MDk1LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNi4zMTgzLC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxODEuNTU1ODc1LC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTgxLjU1NTg3NScgeT0nLTYwLjg3MjU0Myc+YTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjk2LjcwNjA2MywtNjAuODcyNTQzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYuMzA1NTYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMjk2LjcwNjA2MywtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzI5Ni43MDYwNjMnIHk9Jy02MC44NzI1NDMnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMzA0LjE3ODA2MicgeT0nLTY0LjQ4NzkwNyc+7oCw7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzMwNC4xNzgwNjInIHk9Jy01OC4zOTk3MTQnPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuMDI3NzcsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDI5Ni43MDYwNjMsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScyOTYuNzA2MDYzJyB5PSctNjAuODcyNTQzJz5WPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTExLjA5MTgxVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDAuMCwtMTEuMzQxODEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIxLjYzMTMyLC0zMC41MjcxMyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMjk2LjcwNjA2MywtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9JzI5Ni43MDYwNjMnIHk9Jy02MC44NzI1NDMnPmI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMzAwLjIwOTYnIHk9Jy02My44NzkwNic+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzMwNC4zNzQ1NjknIHk9Jy02MC44NzI1NDMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMzA3LjQ4NzkxMicgeT0nLTYwLjg3MjU0Myc+azwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSczMTEuODkxNTY3JyB5PSctNjAuODcyNTQzJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUwLjkxMjQzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDI5Ni43MDYwNjMsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScyOTYuNzA2MDYzJyB5PSctNjAuODcyNTQzJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzMwNC4xNzgwNjInIHk9Jy01OS4zNzgxNjInPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuOTQ2NDksLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDI5Ni43MDYwNjMsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScyOTYuNzA2MDYzJyB5PSctNjAuODcyNTQzJz5VPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMC44NjExIDBINDUuODU2ODknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuMTA2ODksMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMy45NDQwMywyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgyOTYuNzA2MDYzLC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjk2LjcwNjA2MycgeT0nLTYwLjg3MjU0Myc+azwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSczMDEuMTA5NzE3JyB5PSctNjMuODc5MDYnPu6AsO6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS0xMC4xMDk3Vi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTEwLjM1OTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0zMC4wMzYwNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMjk2LjcwNjA2MywtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9JzI5Ni43MDYwNjMnIHk9Jy02MC44NzI1NDMnPms8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguNTgzMzEtNTYuOTA1NUg0Ny44OTA5NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4xNDA5NSwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjYuNzI4NzksLTY0LjU3ODQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDI5Ni43MDYwNjMsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PScyOTYuNzA2MDYzJyB5PSctNjAuODcyNTQzJz5iPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = {A_{1}'},
      nw/style = {pullback},
      ne = {A_{1}},
      sw = V,
      se = U,
      north = {\ell '},
      south = a,
      west = {a^{*}(\ell )},
      west/style = {>->},
      east = \ell ,
      east/style = {>->},
    }
    \qquad 
    \DiagramSquare {
      nw = {A_{1}''},
      nw/style = {pullback},
      ne = {A_{1}},
      sw = V,
      se = U,
      north = {\ell ''},
      south = b,
      west = {b^{*}(\ell )},
      west/style = {>->},
      east = \ell ,
      east/style = {>->},
    }
    \qquad 
    \DiagramSquare {
      nw = {A_{2}'},
      nw/style = {pullback},
      ne = {A_{2}},
      sw = V,
      se = U,
      north = {k'},
      south = a,
      west = {a^{*}(k)},
      west/style = {>->},
      east = k,
      east/style = {>->},
    }
    \qquad 
    \DiagramSquare {
      nw = {A_{2}''},
      nw/style = {pullback},
      ne = {A_{2}},
      sw = V,
      se = U,
      north = {k''},
      south = b,
      west = {b^{*}(k)},
      west/style = {>->},
      east = k,
      east/style = {>->},
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>First, let us consider the subobject <fr:tex
display="inline"><![CDATA[x := a^{*}(\ell ) \cap  b^{*}(\ell )]]></fr:tex>.
    Let <fr:tex
display="inline"><![CDATA[\pi _{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\pi _{2}]]></fr:tex> be the product projections of <fr:tex
display="inline"><![CDATA[x]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="0503c45a2a358ce757c967ee5247bd7e"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMS4zMjYxMDdwdCcgaGVpZ2h0PScxMDguMjczMDg2cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTM0LjIxNzQwNSA3Mi4xODIwNTcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU93QUFvQUFBQUFCQmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVeDFBbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNGWjJ4NVpnQUFBV1FBQUFEMEFBQUE5TnUrK1pKb1pXRmtBQUFDV0FBQUFDMEFBQUEyS04vVG1HaG9aV0VBQUFLSUFBQUFIZ0FBQUNRRnVnS3lhRzEwZUFBQUFxZ0FBQUFLQUFBQUNnWm5BSkpzYjJOaEFBQUN0QUFBQUFnQUFBQUlBRElBZW0xaGVIQUFBQUs4QUFBQUZ3QUFBQ0FBQlFBdGJtRnRaUUFBQXRRQUFBREtBQUFCTXVzSWtlWndiM04wQUFBRG9BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWVzMDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFEwWkRCaVp2Z1A1RE5EcEpIVS9BY0tBd0QyeEEwK2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoRy8vOERTY1AvLy85ZkFQTVpBRkZZQm80QUFRQ1NBQUFDTndLckFCNEFBQUVSQmhZN0FSVW1KeU1HQnpVek1qWW5FUTRCSnlNMU14WS9BVFkzTmhZQm1BUWlUak1zT3RFNkxETk9JUU11VkJNU0VoSStCejg1R0E0Q2kvM05GeFF0QXdFQkF5MFVGd0lBRWd3QkxRSUtBZ291QVFrQUFBRUFYUUFBQWxzQ3FnQXJBQUFsQnlFMU5EOENQZ0UzTGdFbklnWUhIZ0VYRGdFakJpWW5QZ0UzTWhZWERnRUhCZzhCSlRZM1BnRTNBbHNpL2lRRENmbzlUUUVDYUUwMFVoWVlJUUVCSmhVT0xBSUNoR3B3bXdNQ2FFZ3ZOV2tCQWlvS0RROEN4c1lmQlFJSjFERnFQMHhUQVNvakFoOGJJQjBCR1NkTlpRSnBZMUJwTGlBblRnRUJCQXRCRWdBQWVOcGpZR1JnWUFEaVJZOGV6WTdudC9uS3dNekNBQUtQclkvL1FLYVpnNWhXQXlrT0JpWVFEd0JmbWd0d0FBQUFlTnBqWUdSZ1lHYjR6d0FrZ3hoaUdXS1pvaG1BSWlpQUNRQTkwUUp6QUFBRFVnQUFBcmdBa2dCZEFBQUFBQUFBQURJQWVuamFZMkJrWUdCZ1p0QmhBTkVNVUJJSkFBQUZCQUF6QUhqYVBZd3hxOEl3RklXL1loWHRHeHdFaHpkSThBZUVTcCtibTRPVHE4UGJyQW5Tb2Fta3RlZ2kvblJ2US9BR0R0ODk1OXdBR1M4U2hrbVlCeDBtbFRlUFBPYUhSZVNKK0t2SUdiK3NHWkdrTTNGVzdDS25UUG1QUEdaSkdYa2kvaU55eGgvdmZWUGY3cDMxNnRnWTY5Mmw5dHVUOVczVk9MWFIrYkFlckxQKzNGbWp5cWN5ZmRYMjExb1ZPdGNGZXhwcWJ0enBzSGdVUjNGTVlNZEZNcytXVTloYktzbWNkRFpvOG05NmtOU0Z4am44WXFSUjhoUTE5SExUaWw2bHF5akNuYWI0QUZVeUxrTUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBvQUFvQUFBQUFCSEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDAxR050WVhBQUFBRTRBQUFBTVFBQUFEd0FmUUNKWjJ4NVpnQUFBV3dBQUFFZEFBQUJPTmVlVTRwb1pXRmtBQUFDakFBQUFDOEFBQUEyS0tIVHIyaG9aV0VBQUFLOEFBQUFIUUFBQUNRR09nRkdhRzEwZUFBQUF0d0FBQUFNQUFBQURBZkxBRjVzYjJOaEFBQUM2QUFBQUFnQUFBQUlBRlFBbkcxaGVIQUFBQUx3QUFBQUdBQUFBQ0FBQmdBMGJtRnRaUUFBQXdnQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRDNBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbW1zazRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkFoalp2Z1A1RE5EcEpIVS9BY0tBd0RlL2cwZ2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS09qS0UvZjhQNUlQcC93Zityd0dyQWdJQWttMEpBQUFBQUhqYUhjNUJTc05BRk1ieCtkNlltY1Jta21DbUU1UUdyUzBKQmFYUWhnUmNCRUcwTzBFUjhRTFZwUnNSZHhaMDc5cURpQnNQNENWY0tManlERzJjOWkxL2kvZjlHYkYrMDlBM2ZiRWhHekZXb2F4R0pvbTFHWmRHRENIekxDL0t4SlRWRUYwcHRFbktKSUQxSlk5clZHUCtqcW5RU3FBMisyMzR6dDNNZGFCYWNjRTl1V2hPVlNkV0hNcTV1ZkxoZTd2MTYxLzNuaTRqZU9GOFprS2VTbkFPY2tNSitNbjE4YlB1UjZBd0VFdGVEd1Y2bnpobjlzQU9tbDhlMHdjYk1PWkI1Q0xuUmRZVFJibU55cWJtb2gzYjlzeDZEVXVqdGhReUUvUzBlSEgxQmovVGcwMGxiaDhWaGEzSkNZN3MvNzJBSTNDbUY0cklTdzlwTW4vVFdPdlFReHp4ZERXL0pVSHAvSWRJK1R0RXdhcko5MXhDeXRnL2xUTXRNUUFBQUhqYVkyQmtZR0FBWXErNjlNWjRmcHV2RE13c0RDRHcyUHI0RHdUOS95bXpNTk5kSUplRGdRa2tDZ0JCQWd2MkFIamFZMkJrWUdCbStNOEFJaGxVL2pzeEN6TUFSVkFBTXdBL0lBS0dBQUFBQW5ZQUFBTUFBQ1FDVlFBNkFBQUFBQUJVQUp4NDJtTmdaR0JnWUdZd1ptQmlBQUZHQmpRQUFBWEtBRHQ0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVk4QUFvQUFBQUFCM2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWdBQUFCZ2hmMWtyR050WVhBQUFBRThBQUFBUEFBQUFFeTlxU2ZqWjJ4NVpnQUFBWGdBQUFOWUFBQUVKR0dsTHlsb1pXRmtBQUFFMEFBQUFDOEFBQUEyS0ZUVHNtaG9aV0VBQUFVQUFBQUFJQUFBQUNRRnJRSG1hRzEwZUFBQUJTQUFBQUFZQUFBQUdBNXVBUGhzYjJOaEFBQUZPQUFBQUE0QUFBQU9BOElDWW0xaGVIQUFBQVZJQUFBQUdBQUFBQ0FBQ1FCWWJtRnRaUUFBQldBQUFBRE5BQUFCT1BOZktxTndiM04wQUFBR01BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUdqQUlMTmtGSmNsZzZVVEh5UXdNendIOGhuWm1BRUNUTWlWUHdIQ2dNQUNNVU9pSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdzZ0RRWEF3ZFFqb2toaWFHQytjQ0RoUC8vZ1dLSk1QYi9CZis3LzdqSUx3WHJnQUlBbGtRUFozamFQWk83Yjl0V0ZNYnZ1YVQ0a3NSTGlpOHBsaWlLYjh0NjJKWk1LcFlyV3JabEpHNEtKK2dqY0pBRVFZQU1HYksxU3cwVVFaY3UyWXJ1SFl0T1hUcTBjNHB1QmZvWEZHai9oYlJiNHg3S1FYbTM4NTNoKzc3ZklhRmtjZlUzdlEydnlaQWNFZ0lMMkxVZFJsV3dUTnRaUUFGWkYyekhGRVI4Y2FLQ09JSWt5OHZuQXBkblNaekVnb2hqRi9JRjVCbjhVT2xzbU5Dd2JGRm1oaGRJRXE4b0FoajZSdVljNmU3dC92Rjk0QXRtbkQySXBqc1RNSzJKY3hvWVBzREE5YWRTREYvWmhxYmYvZUNoTlZMdE50QlZzaUVBcFVwbDZVMDQyQmk2S2NDak84L3VHWTFURHZ5M2YveFdpMEtlcHZQZzVUQWZBZTFLYllJZkpjZFgvOENmOUZmaWt3d3pjYVV6MnhFWUNLWDl1TUJCSFBoeHNvQUpDbUtwTDJCdkJJR1BVWEFMczRONjZoeWxzOGNjdCt5ZFhTdy9BaENHSTBXZ0xKUjFBQ2FlREVMSTA1WFI3TUNXZTdCUUpkNlZOdWwzYi8reU1jeUhGOC92QmljY1hKeHIvazgvOXAyNndpdE1Fbm11OXU4RE9FaTJMNFBwK0lReDlUSnRqZmJSSU5sQkJoL0RMK1FUUWdxYXJaMlVyUVpZNy9SZDJjNTFDQnppTE12ak1jVHJRUFphV0VNUy82ZjBMcHp0MkxqUVJhaFhnU3BDMEVydW1id29JNUJlblEzUEJvZE1uOGMrVmhrWk1XZTJHcnAxWTErTEdNQjdnL01HMVdVQnZMbzJlTjg3TlkxNW1CNVJDSnlJbzFvWEY1T2RGNi8yUFMzcUhoNG9JcVd5TTlIWXVBS3A1L1lCL0w3WHBTSHJ5UXFsTUo1L1UxaUxDcXd5bzBScDd6UzBNUTkrNHFWUjNQWnBLQ1JWaGFQMG9PeGhoRDE4RFQrdnFaWDU0NzBDemVjQjNwaUFnWk0xS0tlSFBhQ2FCRmdBRm1PWDk0ZXgxeklzQ3QxMVE4NXNudHdvR3VlYkZSWFQwaTI3dCtmQ2w2d05ITyswWHBhMkxFMEc2RFRxVnEwSzBLckJwMjlXSzc3RGt1MXY3MU5uVWdNS3NqdzNQUXRBdHBqY29IbDNYRngwYW9yWkFqQWliMTU4TWI2K3RlYlZHM2hOZnljM3lTMUNjbEdsOGJUZ2tGQ0paZjJRd2pVWjlHbUpRb21xMUFyMGJwWE84U2J4TjhQOVpMcmVFWVhQRTZGVHIzSnFFdkZWS2ZhcmZsM3Y3NDFyVlZxWjliZVh2c0pURU9UNlZyRHFWU3VpS0hOVGJiYTduQi9Qb3JSb2MrRm1hTWVzK2NvWG0xQlRlTFhuaDZ2ZDVMT2o1cTdSMk9iNUlHQlBINjVtdDdxU0pQbjZzTHZGUTkrdFlpSDFTaldWUStDZWZIOHpuVDI1VkRMZzd3eGU1SS9KZnlTUmpQVjQybU5nWkdCZ0FPTFB4MzdPak9lMytjckF6TUlBQW8rdGovOUEwUCsvTUIxanVnamtjakF3Z1VRQmtvNE9SZ0I0Mm1OZ1pHQmdadmpQd01EQWRJeEJna0dTYVRJRFVBUUZzQUVBUVhBQ21RTEdBQUFDZWdBK0FnSUFRd0tYQURFQ3JBQXVBZWtBR0FBQUFBQUFhZ0RDQVVZQm9BSVNBQUI0Mm1OZ1pHQmdZR01JWjJCaUFBRkdCalFBQUFtZkFHSjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUFVBQW9BQUFBQUJFd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMFFXTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QVRBQitaMng1WmdBQUFXd0FBQUVMQUFBQkdERTU0bXRvWldGa0FBQUNlQUFBQUM0QUFBQTJLR0hTN21ob1pXRUFBQUtvQUFBQUlBQUFBQ1FGTGdJaGFHMTBlQUFBQXNnQUFBQVFBQUFBRUFpc0FTeHNiMk5oQUFBQzJBQUFBQW9BQUFBS0FMd0FZRzFoZUhBQUFBTGtBQUFBRndBQUFDQUFCZ0FjYm1GdFpRQUFBdndBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEeUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtMG1hY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNQmd5TS93SDhwa2gwa2hxL2dPRkFhL1FESFFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLYWpJWS92OFA1R3VBNlA4My8xOENxd0lDQUl0WENNUUFBSGphSmN5L1M4TkFIQVh3Nzd1VE81TFNKTVhraW5GSnhTUUlXc0UyRjZ4Z2RTa1dIQnlDZ3RSQkMzWXAwa3JYZ3ZoakV2K0lqdjRmSXZoLzZPenNJSHFsUEhqdlRSOENUZjZBTzA0VUVxR3FmQ2xjQ0NtVXVTNlMxQ1JQMnRBWWxxVThiTWxkanROclc1YWZNcWNVTTdibGFFNWdubWdPdmZIN3k4K0Y1VEZjVFd2UnRILzdFTjhia282TVh5ejhaYU5XbGZTRmRKRGt6VGIya2RlUkpwbk9lNDk2RG02czZadFZjTGZvZ1k4N0ZnU25oWFkrTzdqc001c3ZWWTYvWjI5ZkxWdFlqR2p1ajB4OXNsZGFNVnNSYWcvQk5seGtqUjJkVmh5a21kSzVWampqVVRjZG5JdzZhVGZpbTRWZm16U0NFbnYrL1FpRG1JT3hPQWlaN1Z0WVo2b09tLzRCVWtjdG1BQjQybU5nWkdCZ0FPTDM3NFhxNC9sdHZqSXdzekNBd0dQcjR6OFE5SDlHcHN2TUlDNEhBeE9JQWdCV2RndTBBQUI0Mm1OZ1pHQmdadmpQd01EQWRKbkJnOEdUOFFrRFVBUUZzQUFBVU9JRFZBTFRBQUFCeVFCMEFja0FTQUpIQUhBQUFBQUFBREFBWUFDTUFBQjQybU5nWkdCZ1lHR1FaZ0RSREZBU0NRQUFBM1lBSXdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQzBBQUFBMktlTFN5V2hvWldFQUFBSkFBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbUFBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDYUFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKd0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGlXdWs5QytQNWJiNHlNTE13Z01CajYrTS9rR21XVU1ZN1FJcURnUW5FQXdBeXR3cVlBQUFBZU5wallHUmdZTmI2WThuQXdCTEswTWZRejVUTUFCUkJBVXdBVW9BRFFnQUVWUUFBQXZJQWpnQUFBQUFBVkFBQWVOcGpZR1JnWUdCaU1HVUEwUXhRRWdrQUFBWEtBRHNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS1I3VEtXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZExCY3Z4dlBiZkdWZ1ptRUFnY2ZXeDM4ZzA4d1RtV3lBRkFjREU0Z0hBRUdtQ3FBQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS45OTMwNywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTQuMjY3ODY2JyB5PSctNjYuMjYyOTI4Jz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU0LjI2Nzg2NicgeT0nLTYwLjE3NDczNSc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MC45MTI0MywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTQuMjY3ODY2JyB5PSctNjEuMTUzMTgzJz4xPC90ZXh0Pgo8cmVjdCB4PSctNjEuNzM5ODY1JyB5PSctNTkuOTU3NzMnIGhlaWdodD0nLjM5ODQ4NCcgd2lkdGg9JzExLjk0MTM2NScvPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwNy41MDU0NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTQuMjY3ODY2JyB5PSctNjYuMjYyOTI4Jz7ugLDugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU0LjI2Nzg2NicgeT0nLTYwLjE3NDczNSc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44Nzc3MywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02MS43Mzk4NjUnIHk9Jy02Mi42NDc1NjQnPlY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTQ0LjE1Njg5IDBIMTEuMDQ4NjEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDMuOTA2ODksMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMC43OTg2MSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0LjE2MzIsMy44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02MS43Mzk4NjUnIHk9Jy02Mi42NDc1NjQnPs+APC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01Ny4wODEwMjEnIHk9Jy02MS42NTEzJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002OS42NTQxMSAwSDEwMi40NDk5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDY5LjkwNDExLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTAyLjY5OTksMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4MC45MTI0NSwzLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+z4A8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTU3LjA4MTAyMScgeT0nLTYxLjY1MTMnPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjQ0MzUtMTAuNDQ3Mkw0OC4zMTM2Ny00OC4zMDg5NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC43MDcxNywwLjcwNywtMC43MDcsLTAuNzA3MTcsMTAuNjIwMywtMTAuNjIzOTYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTcsLTAuNzA3LDAuNzA3LDAuNzA3MTcsNDguNDkwNDYsLTQ4LjQ4NTcyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3LjM5ODEsLTM2LjkzMzA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+YTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTcuNDE4NDIxJyB5PSctNjUuNjU0MDgxJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUzLjI1MzQ1MicgeT0nLTYyLjY0NzU2NCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTAuMTQwMTA5JyB5PSctNjIuNjQ3NTY0Jz7ugaA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ2LjgwNTM1NScgeT0nLTYyLjY0NzU2NCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS0xMi4xMDk2Vi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTEyLjM1OTYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTTUxLjYzODE0LTM0LjAzNjAzSDYyLjE3Mjg3Vi0yNS4wMjIxNEg1MS42MzgxNFonIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU0LjYzODE0LC0zMS4wMzYwMyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02MS43Mzk4NjUnIHk9Jy02Mi42NDc1NjQnPng8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTAzLjM2NzUxLTEwLjQ0NzJMNjUuNDk3MzMtNDguMzA4OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNywwLjcwNywtMC43MDcsMC43MDcxNywxMDMuMTkwNywtMTAuNjIzOTYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjcwNzE3LC0wLjcwNywwLjcwNywtMC43MDcxNyw2NS4zMjA1NCwtNDguNDg1NzIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4LjI5NzQsLTM2LjkzMzA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+YjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTguMjM2MzI4JyB5PSctNjUuNjU0MDgxJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU0LjA3MTM1OCcgeT0nLTYyLjY0NzU2NCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTAuOTU4MDE1JyB5PSctNjIuNjQ3NTY0Jz7ugaA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ3LjYyMzI2MScgeT0nLTYyLjY0NzU2NCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$A_{1}'$};
      \node  [right = of 1] (2) {$\underline {A_{1}}$};
      \node  [right = of 2] (3) {$A_{1}''$};
      \node  [below = of 2] (4) {$V$};
      \draw  [>->,morphism] (2) to node[swap] {$\pi _{1}$} (1);
      \draw  [>->,morphism] (2) to node {$\pi _{2}$} (3);
      \draw  [>->,morphism] (1) to node[swap] {$a^{*}(\ell )$} (4);
      \draw  [>->,morphism] (2) to node[desc] {$x$} (4);
      \draw  [>->,morphism] (3) to node {$b^{*}(\ell )$} (4);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Note that</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       u_{1}\ell '\pi _{1} &= n\ell \ell '\pi _{1}\\                    &= naa^{*}(\ell )\pi _{1} && \text {since $na = nb$}\\                    &= nba^{*}(\ell )\pi _{1} && \text {since $a^{*}(\ell )\pi _{1} = x = b^{*}(\ell )\pi _{2}$}\\                    &= nbb^{*}(\ell )\pi _{2}\\                    &= n\ell \ell ''\pi _{2}\\                    &= u_{1}\ell ''\pi _{2}     \end {align*}   ]]></fr:tex>
  <fr:p>Since <fr:tex
display="inline"><![CDATA[u_{1}]]></fr:tex> is monic, <fr:tex
display="inline"><![CDATA[\ell '\pi _{1} = \ell ''\pi _{2}]]></fr:tex>.
    Then</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       max &= maa^{*}(\ell )\pi _{1}\\           &= m\ell \ell '\pi _{1}\\           &= m\ell \ell ''\pi _{2}\\           &= mbb^{*}(\ell )\pi _{2}\\           &= mbx     \end {align*}   ]]></fr:tex>
  <fr:p>Analogously, the subobject <fr:tex
display="inline"><![CDATA[a^{*}(k) \cap  b^{*}(k)]]></fr:tex> is also contained in <fr:tex
display="inline"><![CDATA[e]]></fr:tex>.
    Now, we show that <fr:tex
display="inline"><![CDATA[y := a^{*}(\ell ) \cap  b^{*}(k)]]></fr:tex> is contained in <fr:tex
display="inline"><![CDATA[e]]></fr:tex>.
    The proof for <fr:tex
display="inline"><![CDATA[a^{*}(k) \cap  b^{*}(\ell )]]></fr:tex> is analogous to this one.</fr:p>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[\nu _{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\nu _{2}]]></fr:tex> be the product projections of <fr:tex
display="inline"><![CDATA[y]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="31c25c3f94e14478aedd4d90c654f99a"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMS4zMjYxMDdwdCcgaGVpZ2h0PScxMDguMjczMDg2cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTM0LjIxNzQwNSA3Mi4xODIwNTcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOa0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQ3dBQUFBMktlTFM3MmhvWldFQUFBSThBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbHdBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDWkFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKc0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvUUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURWQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGlXdWs5b2ZIOE5sOFptRmtZUU9DeDlRbHVaSm9sbFBFT2tPSmdZQUx4QVB0K0NIUjQybU5nWkdCZzF2cGp5Y0RBRXNyUXg5RFBsTXdBRkVFQlRBQlNnQU5DQUFSVkFBQUM4Z0NPQUFBQUFBQlVBQUI0Mm1OZ1pHQmdZR0l3WlFEUkRGQVNDUUFBQmNvQU93QjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFDVWxZV0JpWldwQzJDRE1zUkJkb2dVcWVySTcrN2hldWdOcCtmOXVBTktmc2g0VHNacjNNL0pLVVQ5Y2NFTGI0bW5vaGFKU3o1WU1pSExaK0xNMlNUT0pmbEtYUERPSmZGVS9PL0VKWjg4dGwxN3UvZldxMzFuckhmbk5venJnL1doNlp4YTZTcnFuWFhXSDN0cjFHbFVabWpDY0cxVnJTdGRzNldqNWNhZEhvdEhzUmZIUkhhY0pRdU1yRGxFSjlCSTZxUzFRbFA5eTNlU3U5ZzV4azlHT2lkSmxOQWdWMEgyVmRxS09sNXE2bC92NlRCSEFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPd0FBb0FBQUFBQkJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVXgxQW1OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDRloyeDVaZ0FBQVdRQUFBRDBBQUFBOU51KytaSm9aV0ZrQUFBQ1dBQUFBQzBBQUFBMktOL1R2bWhvWldFQUFBS0lBQUFBSGdBQUFDUUZ1Z0t5YUcxMGVBQUFBcWdBQUFBS0FBQUFDZ1puQUpKc2IyTmhBQUFDdEFBQUFBZ0FBQUFJQURJQWVtMWhlSEFBQUFLOEFBQUFGd0FBQUNBQUJRQXRibUZ0WlFBQUF0UUFBQURLQUFBQk11c0lrZVp3YjNOMEFBQURvQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1lczA0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBRMFpEQmladmdQNURORHBKSFUvQWNLQXdEMnhBMCtlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aEcvLzhEU2NQLy8vOWZBUE1aQUZGWUJvNEFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FBQUVBWFFBQUFsc0NxZ0FyQUFBbEJ5RTFORDhDUGdFM0xnRW5JZ1lISGdFWERnRWpCaVluUGdFM01oWVhEZ0VIQmc4QkpUWTNQZ0UzQWxzaS9pUURDZm85VFFFQ2FFMDBVaFlZSVFFQkpoVU9MQUlDaEdwd213TUNhRWd2TldrQkFpb0tEUThDeHNZZkJRSUoxREZxUDB4VEFTb2pBaDhiSUIwQkdTZE5aUUpwWTFCcExpQW5UZ0VCQkF0QkVnQUFlTnBqWUdSZ1lBRGlSWThlK2NmejIzeGxZR1poQUlISDFpZTRrV25tSUtiVlFJcURnUW5FQXdBb2NBbE1BQUFBZU5wallHUmdZR2I0endBa2d4aGlHV0tab2htQUlpaUFDUUE5MFFKekFBQURVZ0FBQXJnQWtnQmRBQUFBQUFBQUFESUFlbmphWTJCa1lHQmdadEJoQU5FTVVCSUpBQUFGQkFBekFIamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU3ArYm00T1RxOFBickFuU29hbWt0ZWdpL25SdlEvQUdEdDg5NTl3QUdTOFNoa21ZQngwbWxUZVBQT2FIUmVTSitLdklHYitzR1pHa00zRlc3Q0tuVFBtUFBHWkpHWGtpL2lOeXhoL3ZmVlBmN3AzMTZ0Z1k2OTJsOXR1VDlXM1ZPTFhSK2JBZXJMUCszRm1qeXFjeWZkWDIxMW9WT3RjRmV4cHFidHpwc0hnVVIzRk1ZTWRGTXMrV1U5aGJLc21jZERabzhtOTZrTlNGeGpuOFlxUlI4aFExOUhMVGlsNmxxeWpDbmFiNEFGVXlMa01BQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUllBQW9BQUFBQUJOd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMFIyTnRZWEFBQUFFNEFBQUFOUUFBQUR3QVRRQitaMng1WmdBQUFYQUFBQUdGQUFBQnBEWVc4SVZvWldGa0FBQUMrQUFBQUM0QUFBQTJLR0hURkdob1pXRUFBQU1vQUFBQUh3QUFBQ1FGU0FJYWFHMTBlQUFBQTBnQUFBQVNBQUFBRWdqdEFTeHNiMk5oQUFBRFhBQUFBQXdBQUFBTUFMd0JNbTFoZUhBQUFBTm9BQUFBRndBQUFDQUFCd0FyYm1GdFpRQUFBNEFBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFFVEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtTW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNQmd4TS93SDhwa2gwa2hxL2dPRkFiRytESG9BZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLYWpJWS9mOFA1R3N3R1A3Ly8vL20vMHRnVlVBQUFJdHVDTVVBQUFCNDJpWFFUVXNiVVJRRzRQT2VxL2VTQ2M0a0pEUEJKTmdrZFdhSVg0WEd1WU1HbWlpb0RiVGFSWkpDcTZLVkt0cFF0SFVybEtxNEtQMFI3dHEvNExvVStqOTBYUkJCdW1qckRYTGdmR3dlWGc2QkR2OERud1JSbmdnNUw2dWtBNm1rWjFZSFFXZ3FEaHJRNkEwcE5UZXJaZ1M2MjVZYU9vM3NwTTg4YVd0QjRKU2M3cVVPZm43OXM1WklNZDRjbFV0SFd4K08vYytHcEtmR2I5LzdHYVBtUEpXVnlrWVFUemZ3QlBFVXdpRFM4ZXFKN29QVmluNWZnSERhcXhBSGl3bElRZmZhcS9QbTVoWmJZaUQ5N1BmNWo2dFpTeWFZcU8vdm0zYkozMm5ZekxUMDZuQWZ3VUZVZTZ6RHRJMHc4blNzUGJ3VXBWYTQ4MkovTVd5VnhFUTdXejZzdVVuKzh2ZFgzdlVGbUgwM3oxWTJnVkgycG1EMTNUa2lIdVJ2VkNYeVZUbldKaTJiYjBnMUFoUC9vUXhDazM0RU9SdjloOFU2TmljUFB2ajNHcXh1Qy9OaTVYblFIUTQ5b0pLeHhoZ2ZOOStlQ2U3VU8yUEwxMzdTc3ZuaW9pamxUV0g3WklNeEhySHZGQXR3ZzlZN2dkMzFwYjJKaGNvQ01HQTFNM1FIdmw5RWtRQUFBSGphWTJCa1lHQUE0cWRWNzAvSDg5dDhaV0JtWVFDQng5WW51QkgwZjBhbXk4d2dMZ2NERTRnQ0FFaHpDb1lBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dSd1ltSmxRRW9nZ0pZQUQ4MUFtZ0FBdE1BQUFISkFIUUJ5UUJJQWtjQWNBQkJBQUFBQUFBQUFEQUFZQUNNQU5KNDJtTmdaR0JnWUdYUVlnRFJERkFTQ1FBQUJRZ0FNd0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFQb0FBb0FBQUFBQkhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwMUdOdFlYQUFBQUU0QUFBQU1RQUFBRHdBZlFDSloyeDVaZ0FBQVd3QUFBRWRBQUFCT05lZVU0cG9aV0ZrQUFBQ2pBQUFBQzhBQUFBMktLSFQxV2hvWldFQUFBSzhBQUFBSFFBQUFDUUdPZ0ZHYUcxMGVBQUFBdHdBQUFBTUFBQUFEQWZMQUY1c2IyTmhBQUFDNkFBQUFBZ0FBQUFJQUZRQW5HMWhlSEFBQUFMd0FBQUFHQUFBQUNBQUJnQTBibUZ0WlFBQUF3Z0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUQzQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1tc2s0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpBaGpadmdQNURORHBKSFUvQWNLQXdEZS9nMGdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPaktFL2Y4UDVJUHAvd2YrcndHckFnSUFrbTBKQUFBQUFIamFIYzVCU3NOQUZNYngrZDZZbWNSbWttQ21FNVFHclMwSkJhWFFoZ1JjQkVHME8wRVI4UUxWcFJzUmR4WjA3OXFEaUJzUDRDVmNLTGp5REcyYzlpMS9pL2Y5R2JGKzA5QTNmYkVoR3pGV29heEdKb20xR1pkR0RDSHpMQy9LeEpUVkVGMHB0RW5LSklEMUpZOXJWR1AranFuUVNxQTIrMjM0enQzTWRhQmFjY0U5dVdoT1ZTZFdITXE1dWZMaGU3djE2MS8zbmk0amVPRjhaa0tlU25BT2NrTUorTW4xOGJQdVI2QXdFRXRlRHdWNm56aG45c0FPbWw4ZTB3Y2JNT1pCNUNMblJkWVRSYm1OeXFibW9oM2I5c3g2RFV1anRoUXlFL1MwZUhIMUJqL1RnMDBsYmg4VmhhM0pDWTdzLzcyQUkzQ21GNHJJU3c5cE1uL1RXT3ZRUXh6eGREVy9KVUhwL0lkSStUdEV3YXJKOTF4Q3l0Zy9sVE10TVFBQUFIamFZMkJrWUdBQVlxKzZkTk40ZnB1dkRNd3NEQ0R3MlBvRU40TCsvNVJabU9rdWtNdkJ3QVFTQlFBSjJBblNBSGphWTJCa1lHQm0rTThBSWhsVS9qc3hDek1BUlZBQU13QS9JQUtHQUFBQUFuWUFBQU1BQUNRQ1ZRQTZBQUFBQUFCVUFKeDQybU5nWkdCZ1lHWXdabUJpQUFGR0JqUUFBQVhLQUR0NDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQzBBQUFBMktSN1RUMmhvWldFQUFBSGNBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZndBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPTGRMQmRiNC9sdHZqSXdzekNBd0dQckU5eklOUE5FSmhzZ3hjSEFCT0lCQUFwOENId0FBQUI0Mm1OZ1pHQmdWdnhqQkNRbk1oZ3l5REthTUFCRlVBQVRBRUVhQW00QUFBT1JBQUFCVVFBeEFBQUFBQUFnQUFCNDJtTmdaR0JnWUdMZ1p3RFJERkFTQ1FBQUFoUUFGUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQWJZQUFvQUFBQUFDRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWdBQUFCZ2hmMWtsV050WVhBQUFBRThBQUFBUUFBQUFGUUVTT0cvWjJ4NVpnQUFBWHdBQUFQc0FBQUU4Rk9GRG5Cb1pXRmtBQUFGYUFBQUFDOEFBQUEyS0ZUVEUyaG9aV0VBQUFXWUFBQUFJQUFBQUNRRmRnRzlhRzEwZUFBQUJiZ0FBQUFjQUFBQUhCQTBBV0ZzYjJOaEFBQUYxQUFBQUJBQUFBQVFBN2dFL20xaGVIQUFBQVhrQUFBQUdBQUFBQ0FBQ2dCWWJtRnRaUUFBQmZ3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBR3pBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUNtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUdqQUlMTmtGSmNsZzZVVEh5UXdNendIOGhuWm1BRUNUTWlWUHdIQ2dNQUFHb09jWGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdjZ0RRUEF3ZFFqb1VoaVNHYm9aSjU3NE9FLy8rQm9va0kzdjhGLzJmODcvN2pJYjhNckE4T0FDQjJFZUY0MmxXVVMyL2pWQnpGZmE3ZmRtekh0V01uU3BxSG5kaHUycVJ0a3RwcHA1T1F0aW5UVHF0T3hURFFlWFVHQklnRmlBMGJLZ1FDSkRhellJbjRBQWl4bWcwTHhIYWsyU0h4Q1pCQTRoUEE3R2k1TnkxSStPL1Z2ZGZTK1oxenJqbkNqUzcrSW50NHhuVzRsemdPSS9RODN5SW1DcTduanpCR1dvUG51NUpNSjRwTnlGM0VhY2FtQ2o1TDR5aU9KSmt1VjVHTmtLVjRLczZYWGN3VlBGbTFuSHFvS0lLbVNYRHNjdXB2MmRXOTl2WnJFTWFXczMrM05WanR3eTMwL2QzUUNZQ2xhakJRSW56cE9YbjcxdUg5UXRmMEtpRFR1Q3lCRUUyYzFQczh5cDFxQWp3NGVPdlltZHZsRVp6LytuT3UxUlJJY2kzOHRKTjFRV3BLaGFNUDRiWXZYdUEzOHB3THVKUXk4VXlaNTBzV0pDWS9HdE9GS0F5aWVJUSszWkRaL2doclhZUUJSYUduS0R2TVhYOHJHVDdrK1Vsai8yUnlHNUE2WFUwaVZsTzFBVXZlV1dvaVM2Wk9jUjZMMWMyUnFRaFZaWUY4ZC82N1IyRmVPWG4zVnJqRDQrUW9IL3o0UTlzM05FR3pGRm5nYzMvZnhXYThjaFlPbG5jc3l6eExTdDBOS3BBN3ZIaEJwbFR2SGFZMnpWZ0lCUk1oTlRmTm9rdE5zdWV6Y1MxK0ZndzkwMmNMTEJlWm9rUTBDOHBtd1VRUXJXWE8vd2t4ZWJ2MmVuejhhb1NtRi9IdzY2YTdlQlJIZnJFK3NLd1ZnZkFpTERkYTFIaFpVeVVncjdtVjlYaWJRT1NCL1dGb0NYNWtpMThKakQ0UG1KUytCUXI3am5uUVdsc3FOeHFrYVRZVkU5aUlHaTZWSUtyZXVxWWFaY2VyUVRoc1docUxzRnV1ZElWK2FzNlpVaEtMVHpibWlvN2hrUjNEK3M4Y2xoMjRsWXRsTXFKOVBHSmVYQmFPVXREOFBPbXFaZlNWUXRyR0xyS0ltU1VIMUlTUVZuRndWVXlmaVlBc2VYNUtDOHppN3RQUHlmcmp5dGZIMlJZUXVkbzhpSjA0ZlhuaGVxRldWbnZYdldHcFlnQ2xwczZYNnBzT2JGMUNVYmZEY1R1RllCU3JJRjR2cSt0bCtMR3QrdHE4QUh4Mi92SGo5NEhWSkd6QTlvV09YTktBcEJpOTNPN0NjRXNiVnUzT1BXOGZvM0dlRU5WYzlRcGRFYXN0dzJoZGUzUEJIb3Rpa0F2RTAyODJUUTAxaVhMZnBNVzlSN25qcThiU2w0cG15Vk1VUmpjbTZTelRRZG9mb3dyWkJVNi8rS2toRlVvTlFvcDYvZlQyMDExYmwxSGQ0QzlybWpjZTFISWk4TzM1NSszbkgvZ0J2U0RpdEhEelpPK1FCZkxKSDdhc2lOUjZsU0JIbE5tOUtWNzhpV2ZrRjI2ZHU4RnhtV3lTYUREbUIrbnNhcy9tMzhZeFVRVlpZdjhHdHNmMEZKampOQzNxT0QwZkQyWm5aT21qV0pvM2RONk1XNEt1UklFZUdIWjdiVG1uRTNIWVhwa0Vta0FncWNaaU9HM29vaXlyL0NBLzdFMnViUTlieWJqQ054ZG9YNjNpazBBdUlxY0paaU5vVG52eGgxdkZuak8zSWdoaGFMMXhmenE4VVZNVUpiQTd0VVVCN2FwT0NBeFJUOVFtK0VmZnJ5ZkRSMmNhemZCZzZiM3NJZmNQWUppbjJYamFZMkJrWUdBQTR2cmRlenpqK1cyK01qQ3pNSURBWStzVDNBajZ2ejdUTWFhTFFDNEhBeE5JRkFBdDZncWRBSGphWTJCa1lHQm0rTS9Bd01CMGpFSGkvM3VtYUFhZ0NBcGdCd0Jrd1FRM0FzWUFBQUo2QUQ0Q0FnQkRBbTRBVFFKUkFEQUNTZ0JMQWVrQUdBQUFBQUFBYWdEQ0FVZ0J4QUlHQW5oNDJtTmdaR0JnWUdjSVoyQmlBQUZHQmpRQUFBbTZBR040MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02MS43Mzk4NjUsLTYyLjY0NzU2NClzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01Ljk5MzA3LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS43Mzk4NjUsLTYyLjY0NzU2NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuNzM5ODY1JyB5PSctNjIuNjQ3NTY0Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01NC4yNjc4NjYnIHk9Jy02Ni4yNjI5MjgnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTQuMjY3ODY2JyB5PSctNjAuMTc0NzM1Jz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUzLjE1NTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02MS43Mzk4NjUnIHk9Jy02Mi42NDc1NjQnPkE8L3RleHQ+CjxyZWN0IHg9Jy02MS43Mzk4NjUnIHk9Jy02MS40NTIxMTEnIGhlaWdodD0nLjM5ODQ4NCcgd2lkdGg9JzcuNDcxOTk1Jy8+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA3LjUwNTQ1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS43Mzk4NjUsLTYyLjY0NzU2NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuNzM5ODY1JyB5PSctNjIuNjQ3NTY0Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01NC4yNjc4NjYnIHk9Jy02Ni4yNjI5MjgnPu6AsO6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTQuMjY3ODY2JyB5PSctNjAuMTc0NzM1Jz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjg3NzczLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+VjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNDYuMzk5OTYgMEgxMS4wNDg2MScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni4xNDk5NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDEwLjc5ODYxLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuNjE4MjQsMy44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02MS43Mzk4NjUnIHk9Jy02Mi42NDc1NjQnPs69PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01Ny43NDU1NTMnIHk9Jy02MS42NTEzJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002Ny40MTEwNCAwSDEwMi40NDk5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDY3LjY2MTA0LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTAyLjY5OTksMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4MC4xMjQ0MiwzLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+zr08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTU3Ljc0NTU1MycgeT0nLTYxLjY1MTMnPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjQ0MzUtMTAuNDQ3Mkw0OC4zMTM2Ny00OC4zMDg5NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC43MDcxNywwLjcwNywtMC43MDcsLTAuNzA3MTcsMTAuNjIwMywtMTAuNjIzOTYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTcsLTAuNzA3LDAuNzA3LDAuNzA3MTcsNDguNDkwNDYsLTQ4LjQ4NTcyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3LjM5ODEsLTM2LjkzMzA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+YTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTcuNDE4NDIxJyB5PSctNjUuNjU0MDgxJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUzLjI1MzQ1MicgeT0nLTYyLjY0NzU2NCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTAuMTQwMTA5JyB5PSctNjIuNjQ3NTY0Jz7ugaA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ2LjgwNTM1NScgeT0nLTYyLjY0NzU2NCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS0xMC42MDk2Vi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTEwLjg1OTYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTTUxLjc1MjE0LTM0LjY0NzExSDYyLjA1ODg3Vi0yNC4yNzIxNEg1MS43NTIxNFonIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU0Ljc1MjE0LC0zMC4yODYwMyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02MS43Mzk4NjUnIHk9Jy02Mi42NDc1NjQnPnk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTAzLjM2NzUxLTEwLjQ0NzJMNjUuNDk3MzMtNDguMzA4OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNywwLjcwNywtMC43MDcsMC43MDcxNywxMDMuMTkwNywtMTAuNjIzOTYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjcwNzE3LC0wLjcwNywwLjcwNywtMC43MDcxNyw2NS4zMjA1NCwtNDguNDg1NzIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4LjI5NzQsLTM2LjkzMzA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+YjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTguMjM2MzI4JyB5PSctNjUuNjU0MDgxJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU0LjA3MTM1OCcgeT0nLTYyLjY0NzU2NCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTAuOTU4MDE1JyB5PSctNjIuNjQ3NTY0Jz5rPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ni41NTQzNjEnIHk9Jy02Mi42NDc1NjQnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$A_{1}'$};
      \node  [right = of 1] (2) {$\underline {A}$};
      \node  [right = of 2] (3) {$A_{2}''$};
      \node  [below = of 2] (4) {$V$};
      \draw  [>->,morphism] (2) to node[swap] {$\nu _{1}$} (1);
      \draw  [>->,morphism] (2) to node {$\nu _{2}$} (3);
      \draw  [>->,morphism] (1) to node[swap] {$a^{*}(\ell )$} (4);
      \draw  [>->,morphism] (2) to node[desc] {$y$} (4);
      \draw  [>->,morphism] (3) to node {$b^{*}(k)$} (4);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Then we have</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       u_{1}\ell '\nu _{1} &= n\ell \ell '\nu _{1}\\                    &= naa^{*}(\ell )\nu _{1} && \text {since $na = nb$}\\                    &= nba^{*}(\ell )\nu _{1}&& \text {since $a^{*}(\ell )\nu _{1} = y = b^{*}(k)\nu _{2}$}\\                    &= nbb^{*}(k)\nu _{2}\\                    &= nkk''\nu _{2}\\                    &= u_{2}k''\nu _{2}     \end {align*}   ]]></fr:tex>
  <fr:p>Thus, <fr:tex
display="inline"><![CDATA[\ell '\nu _{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[k''\nu _{2}]]></fr:tex> can be factored as follows:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="ab7bd6e464aaf23a4d07e3f3c94fb31c"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwNC4zNDE4NzNwdCcgaGVpZ2h0PScxNzIuMzY4NDAzcHQnIHZpZXdCb3g9Jy03MiAtNzIgMTM2LjIyNzkxNSAxMTQuOTEyMjY5Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUlBQW9BQUFBQUEyZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYUR4aWhHTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJFQUFBQVJCNWFqSGRvWldGa0FBQUJzQUFBQUMwQUFBQTJLZUxUTldob1pXRUFBQUhnQUFBQUh3QUFBQ1FGQmdEWmFHMTBlQUFBQWdBQUFBQUlBQUFBQ0FZWUFGOXNiMk5oQUFBQ0NBQUFBQVlBQUFBR0FDSUFBRzFoZUhBQUFBSVFBQUFBRndBQUFDQUFCQUFTYm1GdFpRQUFBaWdBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFDK0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtNW1HY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnEwL2xnd016RnJNeDRIQ2pBZ1YvLzh6TUFBQSt3TVBmd0I0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQUY4QUp3RjdBandBRUFBQUFRTUdJeWNtSnpjVFBnRTNNaFlYQmdjQmNkUUdEQllUQXdTZUF4a2VHU1lCQVFRQjNQNWNFUWNIRFJBQnV3NGdBU0FjREF3QWVOcGpZR1JnWUFCaWRyYmZCK1A1YmI0eU1MTXdnTUJqNitQL2tHbVdVQ1liSU1YQndBVGlBUUFrUmduWkFBQUFlTnBqWUdSZ1lOYjZZOG5Bd0JMS0VNL2d3VmpOQUJSQkFVd0FTaWdDNHdBRVZRQUFBY01BWHdBQUFBQUFJZ0FBZU5wallHUmdZR0JpRUdRQTBReFFFZ2tBQUFKR0FCY0FlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ2xKV0ZnWW1WcVF0Z2d6TEVRWGFJRktucXlPL3U0WHJvRGFmbi9iZ0RTbjdJZUU3R2E5elB5U2xFL1hIQkMyK0pwNklXaVVzK1dESWh5MmZpek5ra3ppWDVTbHp3emlYeFZQenZ4Q1dmUExaZGU3djMxcXQ5WjZ4MzV6YU02NFAxb2VtY1d1a3E2cDExMWg5N2E5UnBWR1pvd25CdFZhMHJYYk9sbytYR25SNkxSN0VYeDBSMm5DVUxqS3c1UkNmUVNPcWt0VUpUL2N0M2tydllPY1pQUmpvblNaVFFJRmRCOWxYYWlqcGVhdXBmNytrd1J3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPd0FBb0FBQUFBQkJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVXgxQW1OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDRloyeDVaZ0FBQVdRQUFBRDBBQUFBOU51KytaSm9aV0ZrQUFBQ1dBQUFBQzBBQUFBMktOL1RwR2hvWldFQUFBS0lBQUFBSGdBQUFDUUZ1Z0t5YUcxMGVBQUFBcWdBQUFBS0FBQUFDZ1puQUpKc2IyTmhBQUFDdEFBQUFBZ0FBQUFJQURJQWVtMWhlSEFBQUFLOEFBQUFGd0FBQUNBQUJRQXRibUZ0WlFBQUF0UUFBQURLQUFBQk11c0lrZVp3YjNOMEFBQURvQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1lczA0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBRMFpEQmladmdQNURORHBKSFUvQWNLQXdEMnhBMCtlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aEcvLzhEU2NQLy8vOWZBUE1aQUZGWUJvNEFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FBQUVBWFFBQUFsc0NxZ0FyQUFBbEJ5RTFORDhDUGdFM0xnRW5JZ1lISGdFWERnRWpCaVluUGdFM01oWVhEZ0VIQmc4QkpUWTNQZ0UzQWxzaS9pUURDZm85VFFFQ2FFMDBVaFlZSVFFQkpoVU9MQUlDaEdwd213TUNhRWd2TldrQkFpb0tEUThDeHNZZkJRSUoxREZxUDB4VEFTb2pBaDhiSUIwQkdTZE5aUUpwWTFCcExpQW5UZ0VCQkF0QkVnQUFlTnBqWUdSZ1lBRGlSWThlTmNmejIzeGxZR1poQUlISDFzZi9JZFBNUVV5cmdSUUhBeE9JQndCY3BndGtBQUFBZU5wallHUmdZR2I0endBa2d4aGlHV0tab2htQUlpaUFDUUE5MFFKekFBQURVZ0FBQXJnQWtnQmRBQUFBQUFBQUFESUFlbmphWTJCa1lHQmdadEJoQU5FTVVCSUpBQUFGQkFBekFIamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU3ArYm00T1RxOFBickFuU29hbWt0ZWdpL25SdlEvQUdEdDg5NTl3QUdTOFNoa21ZQngwbWxUZVBQT2FIUmVTSitLdklHYitzR1pHa00zRlc3Q0tuVFBtUFBHWkpHWGtpL2lOeXhoL3ZmVlBmN3AzMTZ0Z1k2OTJsOXR1VDlXM1ZPTFhSK2JBZXJMUCszRm1qeXFjeWZkWDIxMW9WT3RjRmV4cHFidHpwc0hnVVIzRk1ZTWRGTXMrV1U5aGJLc21jZERabzhtOTZrTlNGeGpuOFlxUlI4aFExOUhMVGlsNmxxeWpDbmFiNEFGVXlMa01BQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPY0FBb0FBQUFBQkRBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxblNVSW1OdFlYQUFBQUZBQUFBQU13QUFBRHdpUFNLRloyeDVaZ0FBQVhRQUFBRElBQUFBK0NjNlByNW9aV0ZrQUFBQ1BBQUFBQzhBQUFBMktLclRSbWhvWldFQUFBSnNBQUFBSGdBQUFDUUZ4ZjkvYUcxMGVBQUFBb3dBQUFBS0FBQUFDZ1g5QURkc2IyTmhBQUFDbUFBQUFBZ0FBQUFJQUQ0QWZHMWhlSEFBQUFLZ0FBQUFGd0FBQUNBQUJRQW1ibUZ0WlFBQUFyZ0FBQURUQUFBQlBxODNkZUZ3YjNOMEFBQURqQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm11c0E0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3BwSVdzOVFmVFFZR1ppbm02MEJoUm9UUy8vOFpHQUFYblE3SkFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lOSUEwRzVCbVpHQlMwbFRTK3YrZmdRRkMzNzF4OXdaWUZSQUFBSkxGQ1FBQWVOcGpZR1F3Ly8rS3FaZ3BoVUdGZ1lGUlVJeE5TYzFjMEV4TlhZK1JYWTJkRFFoaFF2YU1ac1pHNG1MaVlreEZqT3l5N0l4TWtoWmE0U3BHTGtxeTFpeGdBUlpmaWVERTZDQkJBVy9HMW4rZGZHSmlmSXhGNG9IcVVzS01qR0xjNHBwUi8zckJZaFdaNXZ6NjJwdzhaa0RyZ0hhL0JOcWRETEdialorUlRWbEpYUTBJQmRYTWpNVFlCZG5FeE9VWWpjWE16WUFRTE1SVWhMQ0ZCYXN6bU96L2RRSnRNTkRtNGpITFpDempGeFhsLzljdkhxUXVLY3dvRG5JRll4RlFpSUVCQUFoTktFTjQybU5nWkdCZ0FPS3ZyMFRENC9sdHZqSXdzekNBd0dQcjQvOFE5UCtYekRKTUtVQXVCd01UU0JRQVdpUU1NUUI0Mm1OZ1pHQmdsdnFqQ1NSbEdNd1p6Sm1LR1lBaUtJQUpBRHM4QWtrQUFBTWNBQUFDcWdBM0FEY0FBQUFBQUFBQVBnQjhlTnBqWUdSZ1lHQm1VR1VBMFF4UUVna0FBQVJWQUN3QWVOcE5qckZxd3pBUWhqOVR4MUFua0trZE9oUk5HWVdOOHdDRkRKbXlaaXdra1FnT1dBNlNZL0JTOGdCOTZGNFVEVDNCOGVtLzc0U0FraDh5SHBXeGpQMVJPWVhjbmp4anpsdmlRbzVLWFBMQmloZXkvRldTVDc0UzV5ejRUanpqblV2aVF2Sjc0cEkxdjV1K3U5NEc2OVd1TjlhN1V4ZW11dHBiSDlyZXFWcFh6MkJybmZXSHdScDFuSlFaMnpDZU85WG9TamRzNk9tNGNtUEE0dVZuTzBsTVpNZEpab0dKbW9wOXpBS3R6SjE0TlZyUy84WldEQmV0UTN6TmlIV1VtUklhWlM5SVA0dXZhT0t1cHZrRENWRXhFd0I0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBYm9BQW9BQUFBQUNIZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFZ0FBQUJnaGdWa2ltTnRZWEFBQUFFOEFBQUFSQUFBQUZ5K0VpaUJaMng1WmdBQUFZQUFBQVAzQUFBRkVBc0Y3eUZvWldGa0FBQUZlQUFBQUM4QUFBQTJLRlRUdm1ob1pXRUFBQVdvQUFBQUlBQUFBQ1FGbmdHOWFHMTBlQUFBQmNnQUFBQWNBQUFBSEEvbUFVNXNiMk5oQUFBRjVBQUFBQkFBQUFBUUE5SUZRbTFoZUhBQUFBWDBBQUFBR0FBQUFDQUFDZ0JZYm1GdFpRQUFCZ3dBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFHM0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtY21XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFR2pBSUxOa0ZKY2xnNlV6SHlRd016d0g4aG5abUFFQ1RNaVZQd0hDZ01BL1ZRT2JuamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzhnRFFmQXdkUWpvMGhreUdib1pTaGlubnZnNFQvLzRIaUtQei9NLzVQLzkvM3YrdVBoL3d5c0c0a0FBREQzeFJyZU5wZGxNdVAyMVFVeG4yTzdldllUdnlLbjVNMEQ5dXhNOGxnWnpLSm5jd2o2VXlib1RBenFwQUE4U2kwWWpHSUJSSWJOckFBcVd5UXV1Q2ZvRUtJQmF6WkZuWGRCZjhDRzdhbE96cmM2MUUzK0hyamM4K1Z6dmY5dm1zT3VjblZDN2pFeDV6Q0hYSWNhQ0JsTUYvQjFPWFhVTXhuVWtna0VxVkpPaXNMdWpyZ0VSMkpwSUUzcGQ5N1hnY2sya0RQcEFXY1E5KzNIWWpHOXJPYld5VG9ITnBncWdSODFZeFc0em1BR0FTV2J2RHQ3a0VUVFptQXExclJFZDFBL05idEEzaTYydy8rL2Z2SEU5dEkrWU1UQTFIV2RsMG5FMkVhbThieDhYRFUyOEQ2eUVMMEpwNmJDYkE3OERuZ0xxNWU0QWFmY3UvUzZmbWlaS003R2tSSm1oUmxRZ2ZWZ1VpdXg1YXQ4N2JycllEMjdMRkNOWGxJRzhzaXBRSjBLajVNNW1WekJVbEV5N1NyTEZ3SmppKzc3NlZ2dlpOQTdDWThlRDNOSHQ5TkU4L3Z6WFI5SWlBdmdtNG5ZNFdYRktvSkRNVnVMOU5iQ0NJUDhPWWkwZ1V2TWNVZkJOUmoyUURRcE5zN0E4Q2ZYbjZxblEvbU82MStIMk10cm1rQSswbmZwaU9Jc3J0VTVFYXI2WFpCdUloMUJWRVJzMVk3RS9ZS3pkTElNQlVmN1Z0K3MrSGk3WWF1Q0lwZWt3Uyt6dEVIS012bitCQ2VjT2NjTjJCT1VNbW9nVk9wcGppN1FFMWdva21TVXRBa3paQkIvVC9rcWVzeHdoS3B6Q3BLK0cxTzdLVkFJcGZJV3JNWDFXcUNxaEJvV3UxNS9YVTdPTXIzSjYwNldFTVRndTVoczJMdTFTbno0UUtnNFlXQTdsNiswbEY4L0djUWR5WHYrM3RPcGprM0FEZHBpd0NUZDdNL1EzVHpZQnN3Q3BhOXU1ZFJPSUQxcWtyQXhLTUptQXk5enVLejNGeUxlTERGMjVYVzFkVS82TUlmM0FYSHJZRXB1dzZrNjVCWFhMTXFtemxrd0dMQjNxb1lKYlFhcGdVMWhQS2xDUzdaeVM1MGdEQzNmdkczOGpST3p3emVvRUlpVmN0UC9jUnpBbVUyRXV1S0JGbldLQTlPUzlQc0RkV29xUi9vZkllSFNCZ2NtVW5ndFdRcjlnbDFCOHY4WkxXYWZ3QWdLNUFNVENwemEycHF1ZUI1bGd4NHFBS2dzY3EwM1d5NWEvR3lRRUFMREcxclJMWkZzQUpYZ1haWXB5MzJKdC9mbmVaTTd4bkg0WWVVYmNweWZpMkhacGlsbTZKaThOWllWTG1kRlh0cktrYXlBZTUvOTN1Zk9FRWYwVmQ3OTkvKzlkUlVKZWpzOHl5TUpoaU5qN3AxRWVEeHk0ZWpwMTh3VUYxeDQ1eTkvOFlGQzkwM2Y1bFNUYVR4a2hIcVdLT2VJK2RmUFljbitJeGJjbmM0cnBRMFRHWnJmbGE1VzFUcjFhMWlRemtTWVZqWUhwdkhZWW1pUDRwMVJTT2RTZGNaK3lvbE54b3FyNlVEUWEwbG9SbzJ6TkU4cjZzb0xrYVQ0MUFSRUlqY0dFZWJ2aXBLa3N6UGpNWDArT0RXWWpCY3QvbDRtOTVKM1g4VVNqN1VGVUhyaC9GbW1uNTU0aytiMWtRUW9rai81TjVtY2FkYnE5VkM4N1h1V0lCUlIwV0VocWdPNVJqNEJ6OHZoNHNIWHlzRkNPYzduNWNmYy84Qm91YWdxQUI0Mm1OZ1pHQmdBT0s1K2xtVjhmdzJYeG1ZV1JoQTRMSDE4WDhJK3Y4WHBtTk1GNEZjRGdZbWtDZ0FTNjhNdGdCNDJtTmdaR0JnWnZqUHdNREFkSXhCNHY5N3BtWUdvQWdLWUFjQVo3a0VYd0xHQUFBQm5nQXdBbTRBVFFLekFEQUNMZ0ErQWtvQVN3SHBBQmdBQUFBQUFHQUE1Z0ZjQWRRQ0ZnS0llTnBqWUdSZ1lHQm5DR2RnWWdBQlJnWTBBQUFKdWdCamVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT2dBQW9BQUFBQUJBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MGpHTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ0ZaMng1WmdBQUFXUUFBQURrQUFBQTVPdWJnaTlvWldGa0FBQUNTQUFBQUMwQUFBQTJLR0RUb21ob1pXRUFBQUo0QUFBQUh3QUFBQ1FGU0FJWWFHMTBlQUFBQXBnQUFBQUtBQUFBQ2dWYkFIQnNiMk5oQUFBQ3BBQUFBQWdBQUFBSUFDd0FjbTFoZUhBQUFBS3NBQUFBRndBQUFDQUFCUUFyYm1GdFpRQUFBc1FBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEa0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd4TS93SDhwa2gwa2hxL2dPRkFjdm1ETWdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhHLy84RFNjUC8vLzlmQVBNWkFGRllCbzRBQVFCd0FBQUI1QUtwQUJrQUFBRVJCaFk3QVJVdkFROEJOVE15TmljUkRnRW5OUlkyTnpZV0FWY0RJRWtuWjFCd1JpZEpJQU1zVkJRaGRETVZDd0tML2NrYUZTVURBUUlDSlJVYUFnb1VDUUVrQWhZdUFRb0FBQUVBUVFBQUFnVUNxQUFwQUFBbEJ5RTNOajhCUGdJbUp5WUdCeDRCQnc0Qkl3WW1KejRCTng0QkZ3NEJEd0VHQnpjMk56NEJOd0lGSC81YkFRSUg5eHRDQTA5TkpsWVpKeFlCQVNJVENpb0NBWE5oWlljREFsVTdWU3BPOGlVTENnNEN1cm9jQmdiMEcyYUVZQUlCS3pVQ0pROGNHd0VWSmtsckF3RnBYa2RxTEVVaVJRRUJCQXBBRXdCNDJtTmdaR0JnQU9KbTdTdTI4ZncyWHhtWVdSaEE0TEgxOFgvSU5OTmxwcFZBaW9PQkNjUURBQzhvQ3JnQUFBQjQybU5nWkdCZ1p2alB3TURBZEpuQmtjR0ppWlVCS0lJQ21BQS9Nd0ptQUFMVEFBQUNSd0J3QUVFQUFBQUFBQUFBTEFCeWVOcGpZR1JnWUdCbTBHSUEwUXhRRWdrQUFBVFNBREVBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktIN2k0T1RpNU9yek5taUFkbWtwYWl5N2lUL2MyQkcvZzhOMXp6ZzJROFNKaG1JUjUwR0ZTZWZQSVkzNVlSSjZJdjRxYzhjdWFFVWs2RTJmRkxuTEtsUC9JWTVhVWtTZmlQeUpuL1BIZU4vWHQzbG12am8yeDNsMXF2ejFaMzFhTlV4dWREK3ZCT3V2UG5UV3FmQ3JUVjIxL3JWV2hjMTJ3cDZIbXhwME9pMGR4Rk1jRWRsd2s4Mnc1aGIybGtzeEpaNE1tLzZZSFNWMW9uTU12UmhvbFQxRkRMemV0NkZXNmlpTGNhWW9QV0t3dVN3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5vQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDA0V050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNVWjJ4NVpnQUFBV1FBQUFDb0FBQUFxTC9zRGVWb1pXRmtBQUFDREFBQUFDOEFBQUEyS0cvVDFXaG9aV0VBQUFJOEFBQUFIUUFBQUNRR0J3SWlhRzEwZUFBQUFsd0FBQUFJQUFBQUNBVjJBQ1JzYjJOaEFBQUNaQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUpzQUFBQUZnQUFBQ0FBQlFBMGJtRnRaUUFBQW9RQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRFdBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTJzMDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCa1p2Z1A1RE5EcEpIVS9BY0tBd0RvOXcwdGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpTy8vOUR5UDhId0h3R0FGS1hCcDBBQUFBQUFnQWsvLzhDNFFMZEFDOEFNZ0FBTndFMk56SVdGeE1VRmpNMkZnWXZBUWNuSmljME5oY1dOamN2QVNFSEJoUVdGellYRGdFdkFRY21KelEyTXo0Qk56TUR0d0ZsQmhRTkJnRStGaTBWQVF3RmRJQUlCUUVOQ3hNMEF3a0gvdjlPRFJ3VERRTUJEUVZuV0F3QkRBa2lQcG5ySVhZQ1ZoQUJDUS85Z0JZUEF4MEhBUU1EQVFJSUR3Y0JBUXdYWmtXRUZDUVFBUUlQRGdZQkF3TUJDZzhHQVNQSUFWSUFBQUI0Mm1OZ1pHQmdBT0lHcSsveThmdzJYeG1ZV1JoQTRMSDE4WDhJK3Y5L3BvZE1kNEZjRGdZbWtDZ0FWQTROQ1FCNDJtTmdaR0JnWnZqUEFDSVpWQmprbVI0eUFFVlFBQk1BTll3Q01BQUFBQUoyQUFBREFBQWtBQUFBQUFCVUFBQjQybU5nWkdCZ1lHSXdCbUlRWUdSQUF3QUZyd0E2QUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTQuMjMwNTcxLC0yMy4xMzMwODQpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTcuNTQxNjYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE0LjIzMDU3MSwtMjMuMTMzMDg0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xNC4yMzA1NzEnIHk9Jy0yMy4xMzMwODQnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYuNzU4NTcyJyB5PSctMjEuNjM4NzAzJz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0uMDc1MzM2JyB5PSctMjMuMTMzMDg0Jz7iiKk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nOC43ODAzMTInIHk9Jy0yMy4xMzMwODQnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMTYuMjUyMzExJyB5PSctMjEuNjM4NzAzJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01Ljk5MzA3LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTQuMjMwNTcxLC0yMy4xMzMwODQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTE0LjIzMDU3MScgeT0nLTIzLjEzMzA4NCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNi43NTg1NzInIHk9Jy0yMS42Mzg3MDMnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtMTAuMTA5N1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwwLjAsLTEwLjM1OTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTkuOTk2LC0zMC4wMzYwNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE0LjIzMDU3MSwtMjMuMTMzMDg0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xNC4yMzA1NzEnIHk9Jy0yMy4xMzMwODQnPmk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTExLjQxMTg0NCcgeT0nLTIyLjEzNjgyJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUwLjkxMjQzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNC4yMzA1NzEsLTIzLjEzMzA4NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTQuMjMwNTcxJyB5PSctMjMuMTMzMDg0Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Ljc1ODU3MicgeT0nLTIxLjYzODcwMyc+MjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzOS4zNjM4NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE0LjIzMDU3MSwtMjMuMTMzMDg0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xNC4yMzA1NzEnIHk9Jy0yMy4xMzMwODQnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYuNzU4NTcyJyB5PSctMjEuNjM4NzAzJz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0uMDc1MzM2JyB5PSctMjMuMTMzMDg0Jz7iiKo8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nOC43ODAzMTInIHk9Jy0yMy4xMzMwODQnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMTYuMjUyMzExJyB5PSctMjEuNjM4NzAzJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00yNC4yOTcyIDBINDUuODU2ODknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMjQuNTQ3MiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjEwNjg5LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzAuODYwOTgsMy44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE0LjIzMDU3MSwtMjMuMTMzMDg0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xNC4yMzA1NzEnIHk9Jy0yMy4xMzMwODQnPmk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTExLjQxMTg0NCcgeT0nLTIyLjEzNjgyJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTEwLjEwOTdWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwtMTAuMzU5NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTMwLjAzNjA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTQuMjMwNTcxLC0yMy4xMzMwODQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTE0LjIzMDU3MScgeT0nLTIzLjEzMzA4NCc+dTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctOS41MjAxNzYnIHk9Jy0yMi4xMzY4Mic+MjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTIuNzQ4NjEtNTYuOTA1NUgzNC4zMDgzJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDEyLjk5ODYxLC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzNC41NTgzLC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxOC4zNjMsLTYyLjczMTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNC4yMzA1NzEsLTIzLjEzMzA4NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTQuMjMwNTcxJyB5PSctMjMuMTMzMDg0Jz51PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy05LjUyMDE3NicgeT0nLTIyLjEzNjgyJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00My45ODgzLDM3LjczODMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNC4yMzA1NzEsLTIzLjEzMzA4NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTQuMjMwNTcxJyB5PSctMjMuMTMzMDg0Jz5BPC90ZXh0Pgo8cmVjdCB4PSctMTQuMjMwNTcxJyB5PSctMjEuOTM3NjMxJyBoZWlnaHQ9Jy4zOTg0ODQnIHdpZHRoPSc3LjQ3MTk5NScvPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDEuMzQ0MTUgMzEuODI4NjlDLTQ2LjY3MDAzLTEuNDIzOTgtMzYuNjgzMjctMjcuNTc5MDQtMTAuOTM2NjMtNDguNTAyNDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43NzYwMywtMC42MzA2NSwwLjYzMDY1LDAuNzc2MDMsLTEwLjc0MjYzLC00OC42NjAxNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTU0Ljk3MjE4LC0yMS42MDcxNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE0LjIzMDU3MSwtMjMuMTMzMDg0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xNC4yMzA1NzEnIHk9Jy0yMy4xMzMwODQnPu6BoDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTAuODk1ODE3JyB5PSctMjYuMTM5NjAyJz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTguMjAxMDQyJyB5PSctMjMuMTMzMDg0Jz7OvTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNC4yMDY3MycgeT0nLTIyLjEzNjgyJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzMuMCwyLjAnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNLTMxLjkzMjc1IDMxLjkzNDA0TC04LjU5Mjk0IDguNTk2NTcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNCwtMC43MDcwNiwwLjcwNzA2LDAuNzA3MTQsLTguNDE2MTUsOC40MTk4MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNLTI1LjEzOTkxIDE1LjMzODU1SC0xNS4wMzIyNFYyNC4zNTI0NEgtMjUuMTM5OTFaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjIuMTM5OTEsMTguMzM4NTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNC4yMzA1NzEsLTIzLjEzMzA4NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTQuMjMwNTcxJyB5PSctMjMuMTMzMDg0Jz56PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTMxLjkzMjc1IDQxLjMzMDQ3QzIuNDYzNTggNDYuMjU3IDI5LjEyMDc0IDM1LjU2NzgzIDUwLjI3NjY0IDguNjM2MjInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC42MTc3LC0wLjc4NjM2LDAuNzg2MzYsMC42MTc3LDUwLjQzMTA2LDguNDM5NjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE3LjQzOTU4LDQwLjY5MjgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNC4yMzA1NzEsLTIzLjEzMzA4NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTQuMjMwNTcxJyB5PSctMjMuMTMzMDg0Jz5rPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy05LjgyNjkxNycgeT0nLTI2LjEzOTYwMic+7oCw7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00LjkzNTUnIHk9Jy0yMy4xMzMwODQnPs69PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0uOTQxMTg4JyB5PSctMjIuMTM2ODInPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw = {A_{1} \cap  A_{2}},
        nw/style = {pullback},
        ne = {A_{2}},
        sw = {A_{1}},
        se = {A_{1} \cup  A_{2}},
        north = {i_{2}},
        north/style = {>->},
        west = {i_{1}},
        west/style = {>->},
        south = {u_{1}},
        south/style = {>->},
        east = {u_{2}},
        east/style = {>->},
      }
      \node  [above left = of nw] (a) {$\underline {A}$};
      \draw  [->,morphism,bend right] (a) to node[swap] {$\ell '\nu _{1}$} (sw);
      \draw  [->,morphism,exists] (a) to node[desc] {$z$} (nw);
      \draw  [->,morphism,bend left] (a) to node {$k''\nu _{2}$} (ne);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>This yields</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       may &= maa^{*}(\ell )\nu _{1}\\           &= m\ell \ell '\nu _{1}\\           &= m\ell  i_{1}z\\           &= fi_{1}z && \text {since $fi_{i} = gi_{2}$}\\           &= gi_{2}z\\           &= mki_{2}z\\           &= mkk''\nu _{2}\\           &= mbb^{*}(k)\nu _{2}\\           &= mby     \end {align*}   ]]></fr:tex>
  <fr:p>We may now conclude that <fr:tex
display="inline"><![CDATA[n]]></fr:tex> is an isomorphism.
    Then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> can be factored as <fr:tex
display="inline"><![CDATA[mn^{-1} u_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> can be factored as <fr:tex
display="inline"><![CDATA[mn^{-1} u_{2}]]></fr:tex>.
    It remains to show uniqueness.</fr:p>
  <fr:p>Let any two factors <fr:tex
display="inline"><![CDATA[A_{1} \cup  A_{2} \rightrightarrows  B]]></fr:tex> be given.
    Consider the equalizer <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex> of these two factors.
    By definition, both <fr:tex
display="inline"><![CDATA[u_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[u_{2}]]></fr:tex> equalize these two factors, but this means that both <fr:tex
display="inline"><![CDATA[u_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[u_{2}]]></fr:tex> are contained in the subobject <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>.
    Thus, <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex> is an isomorphism, so the two factors are equal.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1568</fr:anchor><fr:addr
type="user">ct-000R</fr:addr><fr:route>ct-000R.xml</fr:route><fr:title
text="Frobenius reciprocity">Frobenius reciprocity</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be a morphism in a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>. Then for any two subobjects <fr:tex
display="inline"><![CDATA[A' \rightarrowtail  A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[B' \rightarrowtail  B]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[\exists _{f}(A' \cap  f^{*}(B')) \cong  \exists _{f}(A') \cap  B']]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\exists _{f}]]></fr:tex> is the left adjoint of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> constructed in <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>830</fr:anchor><fr:addr
type="machine">#295</fr:addr><fr:route>unstable-295.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By the construction of <fr:tex
display="inline"><![CDATA[\exists _{f}]]></fr:tex>, this is equivalent to showing the following isomorphism.
    <fr:tex
display="block"><![CDATA[       \mathsf {Img}(f \circ  (A' \cap  f^{*}(B'))) \cong  \mathsf {Img}(f \circ  A') \cap  B'     ]]></fr:tex></fr:p>

  <fr:p>Form the following diagram, where the front, left, and right faces are pullbacks.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="bf49bce97599e5b73ef05c076baf2bb8"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMyMy44MTk1MzdwdCcgaGVpZ2h0PScyNDIuODk0ODU0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMjE1Ljg3OTY5MSAxNjEuOTI5OTAzJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUklBQW9BQUFBQUJPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFZ4MXNtTnRZWEFBQUFFNEFBQUFNUUFBQUR3QW5RQjVaMng1WmdBQUFXd0FBQUdDQUFBQnNNRXdtL3hvWldGa0FBQUM4QUFBQUM4QUFBQTJLVlhURzJob1pXRUFBQU1nQUFBQUlBQUFBQ1FITXdNZ2FHMTBlQUFBQTBBQUFBQU1BQUFBREFvMUFPUnNiMk5oQUFBRFRBQUFBQWdBQUFBSUFHWUEyRzFoZUhBQUFBTlVBQUFBR0FBQUFDQUFCZ0JLYm1GdFpRQUFBMndBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFFUEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtVG1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwbzZNcVF4TS93SDhwa2gwa2hxL2dPRkFjOENEUDhBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pLay9mOFA1SVBwL3dmK3p3R3JBZ0lBbEQwSkVBQUFBSGphSFpETlR0dEFGSVhuM0RFelRqeittZGl4UTRDMHNaRlRFQ1JBZ2kwUVNnQ2hpQllodGN1eTZMNUliRnFwbTc0QkxDcjFDWGdJSlBaSUNJa3RhM1pJOEJJazJOeXp1VDluY2I3TGlQMmNUdmtkUGJJdHRzTVkvQmI2V1JpRnNnY1hhV2VJS016eUh0cFN1Q1JrQzNrVVJnN0tZNXgyMGl3ZklzY1FHNkhrYlhyNWc4YWE1UVBOM2YzUEJ6WEFWK2EyWWV2SnZXL3dJeVZBcVdsSlFJdmZnNjVoRWFTenZ0L0NmK25GNnVRSkNkMjhubXNiUXMwUkJ6aThlZ1dRZW53Q01zNENxMUtyZ3JncWxnYTRyTklzSWVuUzJGTHExK1NLRlFYMmQ3cEt0L1RBRG91QnV4RFNnUlFsUlQrTUFpSEREMFhXUEJzaHl4T1JiZzZ5cUYvMjd5cXhrbmVrdEllNHdDMy9FRWdoOGJ4bFYzU3p0cmNhSDNNczFaZDVVSGNkZjJGeFJ0Zm10ZlhkOWdQM2h5T01obWtuM3o1OUtTemhNb2RxZWE3ZmpLcXFjV1lISmpkd01ia2V4anRMelQ0aDdzWXg3K2gyVllJb3E0OU9MMCszSWV5Z2dxL3Rqd05QOXd3c3JwUVcwWEZNUXNNYi9ZT1l0VGdZZXdOejFqbGZBQUI0Mm1OZ1pHQmdBT0pkSnNueDhmdzJYeG1ZV1JoQTRMSDFDUzRFL1YrWCtUalRYU0NYZzRFSkpBb0FGWUlLR0FCNDJtTmdaR0JnWnZqUHdNREFvc3FRK2Y4NzgzRUdvQWdLWUFZQVpUOEVXZ05VQUFBRUpRQnBBcndBZXdBQUFBQUFaZ0RZZU5wallHUmdZR0JtOEdSZ1lnQUJSZ1kwQUFBSDhBQlJlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ3dOcUZnWW1WcVF0Z0YyV3dqWndRQ2FucTJOL2RoL0hRTjF5ZCsyRUROVDhVM0s5Z2x2UitKWlc0QjFkTW1XZWVpSHZMWExQZ25TZUs4bG1TVno0eWw5SjhacTU0NFN2elJQTHZ6RFVyZmpmQlhhNkRqV29YakkzKzVGeTMzdHZZZDhHcnBXNlMzMXB2NDJHd1JoMXZ5b3hkUDU2ZGFuV2pXellFSEJldURGZ2lpcDBrSnJIbkpKMmpZODArSmIxd2tGeXhSTlA4NjdmUys3UTVwSitNYkk3Y1JBMmpMSHJSczJ3VmJYcXBhZjhBeUJFdjd3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT01BQW9BQUFBQUJCd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncWs2VCsyTnRZWEFBQUFGQUFBQUFNd0FBQUR3aVlTSTZaMng1WmdBQUFYUUFBQUM4QUFBQTVFUEJQS3RvWldGa0FBQUNNQUFBQUM4QUFBQTJLS3JUdzJob1pXRUFBQUpnQUFBQUhnQUFBQ1FGeGYrQWFHMTBlQUFBQW9BQUFBQU1BQUFBREFmK0FIQnNiMk5oQUFBQ2pBQUFBQWdBQUFBSUFEUUFjbTFoZUhBQUFBS1VBQUFBRndBQUFDQUFCUUFtYm1GdFpRQUFBcXdBQUFEVEFBQUJQcTgzZGVGd2IzTjBBQUFEZ0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtV3NVNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1c1NzNUltczlRZlRRWUdaaW5tNjBCaFJvVFMvLzhaR0FBRkdBNThBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZTklBMEc1Qm1aR0JTWWxiUy9QK2ZnUUZDMy8xMzl5WllGUkFBQUk0T0NOa0FlTnBqWUdTdy9QK2ZpWkhwQklNc0F3T2pvQmlidWlLYm1vbVp1S0lnR20wbXhzVEF5Q3Z4cjRGWFRJeVhzZnJmWkY1UlVWN0czSCt0WUg2REJDL1Rvci9Oa3J5TWpPeXk3SXlNYWlnVUg5Qm9CdlAvcjVpS21WSVlWQ0QyS0ttWkM1cXBxZXN4c3F1eHN3RWhUTWllMGN6WVNGeE1YSXlwQ0t5WlNkSkNLMXpGeUVWSjFwb0ZMTURpS3hHY0dCMGtLT0ROMlBxdmswOU1qSSt4U0R4UVhVcVlrVkdNVzF3ejZsOHZXS3dpMDV4Zlg1dVR4NHdCQUl6TUpOTjQybU5nWkdCZ0FPSWRueVNYeC9QYmZHVmdabUVBZ2NmV0o3Z1E5UDlYekRKTUo0QmNEZ1lta0NnQU4ya0t6d0I0Mm1OZ1pHQmdsdnFqQ1NSbEdNd1p6Sm1LR1lBaUtJQVpBRHM5QWtvQUFBTWNBQUFDT0FBNUFxb0FOd0FBQUFBQU5BQnllTnBqWUdSZ1lHQm1VR1VBMFF4UUVna0FBQVJWQUN3QWVOcE5qckZxd3pBUWhqOVR4MUFua0trZE9oUk5HWVdOOHdDRkRKbXlaaXdra1FnT1dBNlNZL0JTOGdCOTZGNFVEVDNCOGVtLzc0U0FraDh5SHBXeGpQMVJPWVhjbmp4anpsdmlRbzVLWFBMQmloZXkvRldTVDc0UzV5ejRUanpqblV2aVF2Sjc0cEkxdjV1K3U5NEc2OVd1TjlhN1V4ZW11dHBiSDlyZXFWcFh6MkJybmZXSHdScDFuSlFaMnpDZU85WG9TamRzNk9tNGNtUEE0dVZuTzBsTVpNZEpab0dKbW9wOXpBS3R6SjE0TlZyUy84WldEQmV0UTN6TmlIV1VtUklhWlM5SVA0dXZhT0t1cHZrRENWRXhFd0I0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0dIVEVtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHVPeC85WGorVzIrTWpDek1JREFZK3NUWEFqNlB5UFRaV1lRbDRPQkNVUUJBQ1Q4Q2JVQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRQUFBb0FBQUFBQklnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUUwQUFBQmd5bU5pZDJOdFlYQUFBQUZFQUFBQU5BQUFBRVFsK3dLeFoyeDVaZ0FBQVhnQUFBRW1BQUFCU0JrODJ5cG9aV0ZrQUFBQ29BQUFBQzBBQUFBMktlTFRUV2hvWldFQUFBTFFBQUFBSHdBQUFDUUYvUURiYUcxMGVBQUFBdkFBQUFBUUFBQUFFQXY4QVcxc2IyTmhBQUFEQUFBQUFBb0FBQUFLQVBnQWdtMWhlSEFBQUFNTUFBQUFHQUFBQUNBQUJ3QTJibUZ0WlFBQUF5UUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUQ5QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0rczg0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFBQkJnVUhHRHVsdUN5ZGdVMUovSUVCczlZZlN3WUdaaTNtNDBCaFJvVHEvLzhaR0FCSjlBLzZBQUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FBdVdVeEZXZlBURDQveC9CdXZ2cWxvejhaYkJhTUFBQUc3Z016SGphTFkvUFNnSlJGTWJQZDY3Y2l6a3pPYzUxL2xDTk50TE1ybERNZ1FoN0JxRm9FMGtFQTRvdWN1dW1kV21QWU5DdVorZzFXclR3T1lJMjB1M1A1anZuZkI5OC9BNkJucWpGdDFoVGx3aDVyK05ydVEwLzhBTUg2UkVha09vUTNUTW9tU1dwbVdtV1puMTBHc2pTNDI0djl3T0ZoMmNyMHE1OHZiendHRG9xdjlpU0U5ZVQxdU9CdE91aDhUV2pIdG9yUzNwdXdoWHNETXM2Y2JpL3Q2L0Ntb2E4S1U1aWdWclFMczdyMEVuMVB5Z1BpL2FXWFFNM3JvbVk3a254REY5VW9jQ1FPakJjaGlTUElZeWEzVGd4ZUNhV28vRkNpTVY0dFB3Y1RKZ25nOEdVZVFvYUxZWEpmblh6OFdQL2hSTlRSa1BLTU9kVHFwcER5SmI1TWZkTWE4Y1BwTUxkdTdSOFQ1UldJb3FqRkNoaHZibHlsYktyZUhPYWFPNWFGbjBEeXhvME13QUFlTnBqWUdSZ1lBRGlqeHQ0cDhmejIzeGxZR1poQUlISDFpZTRrR21XVUNZYklNWEJ3QVRpQVFBUWxnaHZBQUFBZU5wallHUmdZTmI2WThuQXdCTEtFTS9nd1ZURUFCUkJBU3dBU1pNQzNRQUVWUUFBQXZJQWpnTHlBSUFCd3dCZkFBQUFBQUJVQUlJQXBBQUFlTnBqWUdSZ1lHQmhNR1ZnWWdBQlJnWTBBQUFHRndBK2VOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdvQUFvQUFBQUFCcEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hkeDRwR050WVhBQUFBRThBQUFBTlFBQUFFUUFld1IrWjJ4NVpnQUFBWFFBQUFMT0FBQURUUFBzVlRKb1pXRmtBQUFFUkFBQUFDOEFBQUEyS09mVEdtaG9aV0VBQUFSMEFBQUFIZ0FBQUNRR2pBSkthRzEwZUFBQUJKUUFBQUFVQUFBQUZBNm1BUDlzYjJOaEFBQUVxQUFBQUF3QUFBQU1BWFlDWG0xaGVIQUFBQVMwQUFBQUdBQUFBQ0FBQ1FCWWJtRnRaUUFBQk13QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRm5BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFIwWkw3SXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBbHR3NXpBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtuQmpTbUMvKy93OWtPVUpZL3cvOG4vdkhHS3dXREFENk53djJBQUFBZU5wRmtzMXJFMEVZeHVkOVp6T1RiT0xPNW11MlNkdHRONXZzK3BFbW1xUWJUZE8wVGF2MnczNVphYTFLZzZLQ0lpcUlJS2lJNEVFdmV2SGd3WXNIUWJ4NTk2Yi9nSHBTL0RlOGFlTnNRWnlCWWQ3M1llRDVQZk1TSksxK24wN2lEMUluQVNGTkNKbzFhYVV6c2w2VDJReXZBcS9BZUFlc0RqUjlSd0RMMmxDM3BHV0FVcGpmZ2JvU0hQb043dWs1STRybjVLR0VtV2xOUHRFWm1MRnlIbks3UDAvckROMW9uQUdJeUxXekNRb2lXcDU0QS96d2ZaeVhrRWorZVpZMnRIZ1dLR2lnMHlRSFNFYmZQMHJGWTVrNDBwaXFOUTFNd2VuQmo3QktDQ1dML2Q5MEd6OFNoNHlSWThweHVobDRWWENaRjFpT0Rjb1pWeWRUVnJrVDltU1FEajBHbnU5NmpOTi9kOHJrcDZjYXhNeWNNUUlwQSs1ZXZnWDBjZS8wQmNEbDFNYUQzVHREbU54M2JQamR1MnNQQWNlWFg0K1lrZHR2ZTQ4cGRPYS9MMEZpRFVjbFowQzFBZ2ZjYU05ZFRlbnJSNWRtakE3VlhFV1Fnamw2byt1YzFNQ1FmejdnamRYcUl1NSs1WlFRSUV2OUtsN0hMMlJhRlRTMHFSd1h2REJLYVVuRzVRaDBZSXJ1OFlSbVZiOFc1dTE2dmhjMEZhbUJBdXFCWkQ2OGFabWFtWS9OSE5uZkFpaG1QUlh0aUJDaTZORGhpamhsWTFxc2k2d2h1KzZCTm9BcmxXN2FRcVJTdGg3TjkwSVpYdTUrWGt4T056S3oxSFB0VVN3eVB4NUQwSmF5cjM1dFVZVzJ0VDNvZTZYaWZ3bHkzdGh6clJBRm9oYVN3LzFmK0VLeExKQk5SV1BKRFBjWjM5dWVIMHpSWUx6aCtRb3ZuSmFLbWl5Rm8vNG1JeWpMTW1uVjlocUtLSVJ2S25oTGNoVkFFUDZQZXFTQ2tMaFpzUGJWQjFzRGc4YzMyejBFUFMwNGlyUmRpRWU0cmtaS2lvUnZsNmRBRTl5SzRHamdUanBEeFVTbkhXMUY4RkwzaE0wakVvRHRERkFZTE5XV1VUdVNiOEJ0amdOYTlNckZrcjJtUVdQZWRWY25obU5HZGdoZ3VwS0pBNkk1T3lSSEFScGxQVG1UMjhtbjgrUFltYWpkYlpnbHRuOWw0U2JWMmdtajI0N05sODZjcjYwZzNXblBPR1pleGZFWFQ3MTVFUUFBZU5wallHUmdZQUJpYjZuTGIrUDViYjR5TUxNd2dNQmo2eE5jQ1BxL1BuTWsweTBnbDRPQkNTUUtBQ0ovQ2g0QWVOcGpZR1JnWUdiNHp3QWtTeGdNL2w5Z2ptUUFpcUFBVmdCY1lnUGNBQUFDeGdBQUEzQUFPZ04wQUVvQ09nQkxBc0lBTUFBQUFBQUFXQUM0QVI0QnBuamFZMkJrWUdCZ1pRaG5ZR1lBQVVZR05BQUFDWnNBWW5qYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzODtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUVlBQW9BQUFBQUJNd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFc5MG5HTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWV3RWdaMng1WmdBQUFXd0FBQUZNQUFBQmpQTndKSk5vWldGa0FBQUN1QUFBQUM4QUFBQTJLSnJUQjJob1pXRUFBQUxvQUFBQUhnQUFBQ1FHTndKMWFHMTBlQUFBQXdnQUFBQVFBQUFBRUFqOUFOWnNiMk5oQUFBREdBQUFBQW9BQUFBS0FOUUFpRzFoZUhBQUFBTWtBQUFBR0FBQUFDQUFDQUJOYm1GdFpRQUFBendBQUFET0FBQUJPQWQxS3Ixd2IzTjBBQUFFREFBQUFBd0FBQUFnQUFNQUFIamFZMkJtc21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcDZNdVF5Yy84SDhwbTVHZEhVL0FjS0F3REQ3d3o3ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVE4R2RJWmN2Ly9SN0QrNy9nLysvODBzRm93QUFEc2h3dVZBSGphVlZETFRzSlFFSjJaVzFvZ1dBU2xGZHRVYVdNTGlCQjV0TUJWRWhjU0l5cHE0a0lrU0dUamp4ZytEUk1TRXFJZjR0YUY0TVdObWtsT3ptTm1jUVlRUmdBd3BRa3dnSTJFazVnKzArU3JJVFFJeDFxV0tJN3ZVQUlPSFFEVVBVZFdkQzJsb2lKN3NtSmhVUEYxVFl5S3R1dTVmbEJFencvY1dnc0RYMjhoMDFhTzQ2NDJkWEVwNnhhV1JlNkpJUmFyY2xPU1RIeTYyRytFR0JYaWo4WlIzcTFLTko2TkdSbzVKWUZTMnFIaFpiRngvTEMwT1dFdDd3ajBlNlBtbXNwbzhESWdxUkJmTCtLOExTRUw1dzVQaDBTN3RPTW1pQ0poemJyaTNTN2Y1TnNSejJvYUIzV1JNbHVMTGo2d3lDdlZIM2hscHFsa3N0bE1WZzJSTENvRHdwMG9Ic00zMkJOQy9NTXZvZXVwcUtmKzBVcktGMTFFeGNCQ0ZyMW5xcFE4NDJYOEpiZnQzbmxUVHQ2YzlEbVdGblBNcHUyUXpWaS85dm1YempyWHhPcGJoazlzQ04vcnJEM3JlTnBqWUdSZ1lBQmlvN21oZStQNWJiNHlNTE13Z01CajZ4TmNDUHEvUGpNUDAzRWdsNE9CQ1NRS0FCS1dDWG9BZU5wallHUmdZT2IrendBazR4bmtHQVNaZVJpQUlpaUFCUUF1dndHMEFBQUNVQUFBQVM0QVl3SWdBQjREWHdCVkFBQUFBQUFPQUlnQXhnQUFlTnBqWUdSZ1lHQmg4R0ZnWmdBQlJnWTBBQUFJYlFCV2VOcE5qRDF2d2pBUWhwK29DVkxEd0lJNk1MUWVPbHRCWVdCaVlXQmlaV0lCN0tJTWNaQWRJaUZWSGZuZFBZd0h6dExwZVQvT1FNa2ZHWS9KbU1UOW1KeEMxSk1MeGt3VGowUjlKUzZaOGMwYldmNHV6aWVyeExrays4UUZIL3drSG9uL203aGt3WDNkdFpkcmI3M2Fkc1o2ZDJwRFdPNnNEMDNuMUZ4WFVXK3NzLzdRVzZPT04yV0dKZ3puVnRXNjBqVnJPbG91WE9teGVCUmJjVXhreDBteUlHL0pManFCUmxJbnJUbWE2aVhmU081aTV4Qi9NdEk1Y3BOdEdPUXF5RDVMVzFISFMwMzlEK3B0TURzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBzQUFvQUFBQUFCSVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRTBBQUFCZ3ltRmh6R050WVhBQUFBRkVBQUFBTkFBQUFFUWwrd0t4WjJ4NVpnQUFBWGdBQUFFVEFBQUJSTDU0NDJkb1pXRmtBQUFDakFBQUFDMEFBQUEyS1I3VFRXaG9aV0VBQUFLOEFBQUFIZ0FBQUNRRld2L2xhRzEwZUFBQUF0d0FBQUFRQUFBQUVBbVFBTnRzYjJOaEFBQUM3QUFBQUFvQUFBQUtBUFlBZ20xaGVIQUFBQUw0QUFBQUdBQUFBQ0FBQndBM2JtRnRaUUFBQXhBQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBRDRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVNtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBZzRJRGpKMVNYSmJPd0tZay9zQ0FXZkdQRVFNRHN5THpPYUF3STBMMS8vOE1EQUFQeXc5TkFBQUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUUF1V1V4RldmUFRENC94L0J1dnZxbG96OFpiQmFNQUFBRzdnTXpIamFOWTZ4U3NOUUZJYlBmOUxjcEdtOFNUQnBJdWd0V3RyZzBtSnRtMEZwY0pMcUlHNkNwaEg2QnE3cTdLQ2JpT0RzV3pqNUd1TG1Td2hDOVJKMStUam4rK0huSjlBcHRmR0ZkeG9SZFdLRlNGaWlqeFlrTnJwcDVuRTNIWTV6cEQyTXh0bWdoVDVQc0szZ0llZG1IQW9MaDArMlpDWEVnMnNpQ2lNRWQyNWRzZlR1SysrNHQ2YkRpSnpZWWY4ditkNHpHcDR5VUp0ZkRBSXBnK2ZDaHFHa0svTGZvRjdzSENlQnhLcjMrSjhRTVIxUmh5MjlzMEV4a1o1bjlaQk9rQ2tZbXZyV1JvRXR2cG9WMTF6eGJWb3l6dzRxZ3M2MHZTd3JMajY1bk82ZmMwVmRSbHVVWXNpN0pQVmpDRjJXTFZmVmNST2JyNWF2Mkx5cEpXdEpHNHlQeFVsb0xEaytYdVE2b0ZacytnSHdZUzljQUhqYVkyQmtZR0FBNG5WM0dHZkc4OXQ4WldCbVlRQ0J4OVludUpCcDVvbE1Oa0NLZzRFSnhBTUFEWXdJaVFBQUFIamFZMkJrWUdCVy9HTUVKQ2N5R0RMSU1yRXpBRVZRQUFzQVBka0NSQUFBQTVFQUFBSlhBRnNDVndCUEFWRUFNUUFBQUFBQVZBQ0NBS0lBQUhqYVkyQmtZR0JnWVRCallHSUFBVVlHTkFBQUJqQUFQM2phVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9GUmlZMkZnWW1YcUF0aWdESEdRSFNKRnFqcnl1M3U0SG5yRDZYay83b0NTSHpLZWsvRWE5M055Q2xGL1hQRENXK0twcUVYaWtnK1dUTWp5bVRoek5vbHpTYjRTRjd4elNUd1YvenR4eVNlUGJkZmU3cjMxYXQ4WjY5MjVEZVA2WUgxb09xZFd1b3A2WjUzMXg5NGFkUnFWR1pvd1hGdFY2MHJYYk9sb3VYR254K0pSN01VeGtSMW55UUlqYXc3UkNUU1NPbW10MEZULzhwM2tMbmFPOFpPUnpra1NKVFRJVlpCOWxiYWlqcGVhK2hmemVUQlBBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzBBQUFBMktBN1RFV2hvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaXo4eUYydkg4Tmw4Wm1Ga1lRT0N4OVFrdUJQMmZnYW1CR2NUbFlHQUNVUUFCRUFpcEFBQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTOEFBb0FBQUFBQld3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwNTJOdFlYQUFBQUU0QUFBQU1nQUFBRHdBblFCN1oyeDVaZ0FBQVd3QUFBSHFBQUFDTExsR1dXaG9aV0ZrQUFBRFdBQUFBQzhBQUFBMktKVFRIR2hvWldFQUFBT0lBQUFBSGdBQUFDUUdMUUhOYUcxMGVBQUFBNmdBQUFBUUFBQUFFQXB6QUlWc2IyTmhBQUFEdUFBQUFBb0FBQUFLQVdvQXNHMWhlSEFBQUFQRUFBQUFHQUFBQUNBQUNBQkNibUZ0WlFBQUE5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVzQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1tc000Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpFaGpadmdQNURORHBKSFUvQWNLQXdEaDVRMHplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPakdrL2Y4UDVEdUM2UDhIL3M4RnF3SUNBSlJmQ1JJQUFIamFOZEV4YjlOQUZBZncrOS9GNXlUWVBoUEhkcXZFU1J5bk5pb2lLWFd3MndvTWFtaEFyUklWS2xDSFNraEkwQTBoMUJiWU1uU0VDWUVFQ3dzYkg0QUJKaVkrQUNzRFl1UXpKT0ZjaVp2dS91OE52M2VQVU5LWnorbHYrb3YweUNvaEtaSjAxWEd0cWhNbkR1OUJqY0tvbjdoT2t2YmdxN3pxdUlsclFPWjVIR2RJWS9ZRmozaFY1OGljU3pZMDVXaFNWS0Nmcy9xc3BNN21ZNzF1NlF5NmNyaXZRU3Uxcy9kLy9STjYzMFJKVENlT1lKNEt4a0NMUWdVMDkvSFdhYlZqZ2dxRDUzRlpjQVEvY0pmSXc4akYrWlJ4K28wMHlESlprMUtySDBSYzJ2d0diQU5xQXk0WDRLclB6N3hXamt2Q0tBaTV5djdmbVd5SVA3MnVSWjRRMkQ5NHlDWjdPM3VndDh6UjhleE4zVEEyR2gvZlBUaWk2QTVPbTVieTVOWEJDYVVydDc4UEM0Q3hTOWZQVTFaWFFlOXNiQitLOG5oOVo5UElDdmtFc0xERm5nMDdOeW5FNHZRemV6NWUybVd6UHhWZUpnUWttWGZwRmZxVDNKQ1BIS0JLYkR1TU1zVHlveDB1NGFua1dVSHVqcThqZ3l0ekE0SHNDWk8wQzVXclhOQjhIUkZlWklZaVhPUHFjaXNCQWx2WW9HNWdlb1VvMUVZRHp4VERoZkxpdU9ZbkZHMWJPTUJDU3pRTHZsQ0ttbjJ2QmxQZ3crenJ3THAydWJsSk80SFhxbFQwc0NCWHg1Nk84Slo1SEM4dmJLL1FvSE5XV1ZMeVNsTVAxNDd6c1FuNUJ4a25WSUlBQUhqYVkyQmtZR0FBNHZwRndmWHgvRFpmR1poWkdFRGdzZlVKTGdUOVg0K1pqZWt1a012QndBUVNCUUFYSUFtYkFIamFZMkJrWUdCbStNOEFKRGtZVlA0ZllHWmpBSXFnQUJZQVNVZ0RBQUFBQW5ZQUFBTUFBQ1FEQ0FBckFmVUFOZ0FBQUFBQVZBQ3dBUllBQUhqYVkyQmtZR0JnWVhCa1lHWUFBVVlHTkFBQUIxb0FTM2phVFk2eGFzTXdFSVkvVThkUXA5Q3BIVG9VVFJtRmpmc0FnUXlac21Zc0pKRUlEa2dLc21QSUV2b0FmZWhlRkEwOXdmSGRkNytFZ0pvYkJmY3FlRTM5WGlXVlRBK2VNZWN0Y3lWSFphNzVZTUVUUmZrczVwTmw1cElYdmpQUGVPZVV1UkwvazdubWk5OVZjT2ZMYUtQYUJHT2pQempYdDgzV3hxRVBYclc2ZVlpMTlUYnVSbXZVL3FyTTFBL1QwYWxPTjdwalJjQng1c0tJSmNyUE5tSk1ZczlCZG82ZWxvWnRjb05NUVRaS25CYjdQN0dXaEUrcFhYck5TR3JQVmJwaGtzd2cvU2hwUlpmdWFyby8zL1F3dXdBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY4IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTQuNjE5ODMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00MS42MzM1MzInIHk9Jy0yMC44MzUxOTgnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTM1LjY4MzU4NScgeT0nLTI0LjQ1MDU2Mic+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0zMS4xMDM1MzEnIHk9Jy0yMC44MzUxOTgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTI3LjIyOTE1NycgeT0nLTIwLjgzNTE5OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTkuMTcyNTQ5JyB5PSctMjQuNDUwNTYyJz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTE2LjM3NzQ3MycgeT0nLTIwLjgzNTE5OCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtMTAyLjA4NDY0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC0xMS4xMDk3M1YtOTAuODQxNicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDAuMCwtMTEuMzU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC05MS4wOTE2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjcuNDY2NDYsLTUxLjg3NTY2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzYuOTY2OTQ4JyB5PSctMjMuODQxNzE1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTMyLjgwMTk3OCcgeT0nLTIwLjgzNTE5OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMjkuNjg4NjM1JyB5PSctMjAuODM1MTk4Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy4zMjk0NzMnIHk9Jy0yMy44NDE3MTUnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y4JyB4PSctMjAuNjM0Njk5JyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDk0LjEzODQ2LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zMy41NzY5MjQnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NS41NDEyNCwtMTAyLjA4NDY0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTkuMTc1MzcgMEg4OS4wODI5MicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OS4zMzI5MiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU0LjM3OTE0LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005OS41ODQ2NC04LjYwOTczVi05MC44NDE2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsOTkuNTg0NjQsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsOTkuNTg0NjQsLTkxLjA5MTYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwMi44NDg1MywtNTAuNjI1NjYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0LTk5LjU4NDY0SDkwLjQ4NTcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTAuNzM1NywtOTkuNTg0NjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ3LjMwMzU3LC0xMDcuMjU3NTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU2LjkwNTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzEuNTc3MzgsNDAuMTc5MTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zNC4xNjE1MzMnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMjkuMTUyNTkxJyB5PSctMjAuODM1MTk4Jz7iiKk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTIwLjI5Njk0MycgeT0nLTIwLjgzNTE5OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTQuMzQ2OTk2JyB5PSctMjQuNDUwNTYyJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTkuNzY2OTQyJyB5PSctMjAuODM1MTk4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01Ljg5MjU2OCcgeT0nLTIwLjgzNTE5OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScyLjE2NDA0JyB5PSctMjQuNDUwNTYyJz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nNC45NTkxMTYnIHk9Jy0yMC44MzUxOTgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTMxLjA3NjkzLDQwLjE3OTEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+4oiDPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0zNi4wOTg3MTUnIHk9Jy0xOS4zNDA4MTcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTMwLjkzNDAwMScgeT0nLTIwLjgzNTE5OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMjcuMDU5NjI3JyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xOS41ODc2MjgnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMTYuNzkyNTUyJyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xMC43MDQzMTInIHk9Jy0yMC44MzUxOTgnPuKIqTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMS44NDg2NjQnIHk9Jy0yMC44MzUxOTgnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNi4yMDc5NDQnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS43NTI3MiwtNTkuNDA1NTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zNC4xNjE1MzMnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNDIuMDc4NjMsLTU5LjQwNTUyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+4oiDPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0zNi4wOTg3MTUnIHk9Jy0xOS4zNDA4MTcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTMwLjkzNDAwMScgeT0nLTIwLjgzNTE5OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMjcuMDU5NjI3JyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xOS41ODc2MjgnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMTYuNzkyNTUyJyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1IDMxLjU2OTRWLTQ3LjQ3Nzk3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwzMS4zMTk0KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ3LjcyNzk3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNMTU2LjQ5MDE0IDMxLjIwODMxVi00Ny40Nzc5NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDE1Ni40OTAxNCwzMC45NTgzMSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwxNTYuNDkwMTQsLTQ3LjcyNzk3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNNjYuNjEzODMtNTYuOTA1NTJIMTMzLjc1MDk2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEzMy42MjU5NiwtNTYuOTA1NTIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J003MC44ODgzOC02NC40NjY2NEg5Ny43OTM5Vi01MC43OTQ0M0g3MC44ODgzOFonIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDczLjg4ODM4LC01OC42NTU1MiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00MS42MzM1MzInIHk9Jy0yMC44MzUxOTgnPs+RPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zNi44MjI1OTEnIHk9Jy0xOS4wMDMxNTUnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMyLjgyNzEyJyB5PSctMTkuMDAzMTU1Jz7il6Y8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTI5LjE2MDI3JyB5PSctMTkuMDAzMTU1Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy45OTg5ODknIHk9Jy0yMC40Njk4ODQnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J000Ni42MDM5LTY0LjYzNTIyTDguNzA1NTItOTMuMDU5MTcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43OTk5NywwLjU5OTk5LC0wLjU5OTk5LDAuNzk5OTcsNDYuNDAzOSwtNjQuNzg1MjIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjc5OTk3LC0wLjU5OTk5LDAuNTk5OTksLTAuNzk5OTcsOC41MDU1NCwtOTMuMjA5MTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J00xNDIuMzc1MjMtNjcuNDk2MjNMMTA4LjU4MzU3LTkyLjgzOTI4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzk5OTksMC41OTk5NiwtMC41OTk5NiwwLjc5OTk5LDE0Mi4xNzUyMywtNjcuNjQ2MjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjc5OTk5LC0wLjU5OTk2LDAuNTk5OTYsLTAuNzk5OTksMTA4LjM4MzU4LC05Mi45ODkyNiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTI5LjQyMzI4LC04OC4yNjUxNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy00MS42MzM1MzInIHk9Jy0yMC44MzUxOTgnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y4JyB4PSctMjkuODgzMTkzJyB5PSctMjAuODM1MTk4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0yNi43Njk4NDknIHk9Jy0yMC44MzUxOTgnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIwLjI4OTA4NScgeT0nLTIwLjgzNTE5OCc+4pemPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xNC4zOTI5NjgnIHk9Jy0yMC44MzUxOTgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTguNDAxNTA2JyB5PSctMjMuODQxNzE1Jz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTUuNzA2NzMyJyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004Ni43ODkxNyA0Mi42NzkxMkgxMjYuMDIxNCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMjYuMjcxNCw0Mi42NzkxMiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPHBhdGggZD0nTTQzLjI2OTA3IDMyLjQ0OTYzTDEyLjI5OTAxIDkuMjI3NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjgwMDA1LDAuNTk5OSwtMC41OTk5LDAuODAwMDUsNDMuMDY5MDYsMzIuMjk5NjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjgwMDA1LC0wLjU5OTksMC41OTk5LC0wLjgwMDA1LDEyLjA5OSw5LjA3NzUzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNMTQyLjM3NTggMzIuMDg4NDFMMTA5Ljk4NjM2IDcuNzk2ODMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43OTk5OSwwLjU5OTk2LC0wLjU5OTk2LDAuNzk5OTksMTQyLjE3NTgsMzEuOTM4NCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNzk5OTksLTAuNTk5OTYsMC41OTk5NiwtMC43OTk5OSwxMDkuNzg2MzYsNy42NDY4NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram,node distance = 3.5cm]
      \SpliceDiagramSquare {
        width = 3.5cm,
        height = 3.5cm,
        nw = f^{*}(B'),
        sw = A,
        ne = B',
        se = B,
        west = f^{*}(B'),
        west/style = {>->},
        south = f,
        east/style = {>->},
      }
      \node  [right = 2cm of nw] (ref1) {};
      \node  [above = 1.5cm of ref1] (nw') {$A' \cap  f^{*}(B')$};
      \node  [right = of nw'] (ne') {$\exists _{f}(A') \cap  B'$};
      \node  [below = of nw'] (sw') {$A'$};
      \node  [below = of ne'] (se') {$\exists _{f}(A')$};
      \draw  [>->,morphism] (nw') to (sw');
      \draw  [>->,morphism] (ne') to (se');
      \draw  [cover,morphism] (sw') to node[near start,desc] {$\vartheta _{f \circ  A'}$} (se');
      \draw  [>->,morphism] (sw') to (sw);
      \draw  [>->,morphism] (se') to node {$\mathsf {Img}(f \circ  A')$} (se);
      \draw  [->,morphism] (nw') to (ne');
      \draw  [>->,morphism] (nw') to (nw);
      \draw  [>->,morphism] (ne') to (ne);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By the <fr:link
type="local"
href="ct-0008.xml"
addr="ct-0008"
title="Pasting lemma of pullbacks">pasting lemma</fr:link>, the back square is also a pullback. Then since covers are stable under pullback in a regular category, the north edge of the back square is also a cover. The diagonal of the right face is <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f \circ  A') \cap  B']]></fr:tex>, which forms a cover-mono factorization of the composite <fr:tex
display="inline"><![CDATA[f \circ  (A' \cap  f^{*}(B'))]]></fr:tex>. Thus, by <fr:link
type="local"
href="ct-000Q.xml"
addr="ct-000Q"
title="Cover-mono factorization">uniqueness</fr:link>, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f \circ  (A' \cap  f^{*}(B'))) \cong  \mathsf {Img}(f \circ  A') \cap  B']]></fr:tex> as required.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Related">Related</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1569</fr:anchor><fr:addr
type="user">ct-000K</fr:addr><fr:route>ct-000K.xml</fr:route><fr:title
text="Image">Image</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is said to have <fr:em><fr:strong>images</fr:strong></fr:em> if the inclusion functor <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A) \hookrightarrow  {{\mathcal {C}}_{/{A}}}]]></fr:tex> admits a left adjoint <fr:tex
display="inline"><![CDATA[\mathsf {Img}\colon {{\mathcal {C}}_{/{A}}}\to \mathsf {Sub}(A)]]></fr:tex> for all objects <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1570</fr:anchor><fr:addr
type="user">ct-000J</fr:addr><fr:route>ct-000J.xml</fr:route><fr:title
text="Slice comparison functor of a locally cartesian category admits a right adjoint"><fr:link
type="local"
href="ct-000I.xml"
addr="ct-000I"
title="Slice comparison functor">Slice comparison functor</fr:link> of a <fr:link
type="local"
href="ct-000G.xml"
addr="ct-000G"
title="Locally cartesian category">locally cartesian category</fr:link> admits a right adjoint</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is locally cartesian iff for all morphisms <fr:tex
display="inline"><![CDATA[f]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the functor <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> constructed in <fr:ref
addr="ct-000I"
href="ct-000I.xml"
taxon="Lemma" /> admits a right adjoint <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>. Moreover, <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> is (isomorphic to) the pullback functor.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>812</fr:anchor><fr:addr
type="machine">#307</fr:addr><fr:route>unstable-307.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By <fr:ref
addr="ct-000H"
href="ct-000H.xml"
taxon="Lemma" />, locally cartesian categories are precisely those categories with pullbacks.</fr:p>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>813</fr:anchor><fr:addr
type="machine">#305</fr:addr><fr:route>unstable-305.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex> for any <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. We show that the following diagram</fr:p>
    
      
      <fr:figure><fr:resource
hash="3bdf29e3ca5a6afa1fb82198dbd9d32b"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNC43NjA3MDdwdCcgaGVpZ2h0PScxMTcuODQ5NjI0cHQnIHZpZXdCb3g9Jy03MiAtNzIgNzYuNTA3MTM4IDc4LjU2NjQxNic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9VQUFvQUFBQUFBL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFYR050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFEWUFBQUEyTlZxTFR0b1pXRmtBQUFDUEFBQUFDOEFBQUEyS09MUi9taG9aV0VBQUFKc0FBQUFIZ0FBQUNRRjhRS2FhRzEwZUFBQUFvd0FBQUFJQUFBQUNBWWhBR1ZzYjJOaEFBQUNsQUFBQUFZQUFBQUdBR3dBQUcxaGVIQUFBQUtjQUFBQUZnQUFBQ0FBQlFCRmJtRnRaUUFBQXJRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGhBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTZRek0vd0g4cGtoMGtocS9nT0ZBYlFlRE04QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOUR5UCt6d0h3R0FGVzFCc01BQUFBQUFnQmwveXdDaWdIRkFDNEFRd0FBQVFNT0FTTUdMd0VtSno0Qk1oWVZGQVlIRmg4QkZqNENQd0VPQVFjdUFTYzJOelkzTmpjeUZoYzJOeDRCRlFjM05pOEJKaWNPQVFjT0FSVWVBVGMrQVRjK0FRS0ZiQlNQYXk4MUN6TUVBU1V5RmdvUUFpSXRGejlIR0FZWUVrd3lTMllDQTBVUkVsQmhJa0FaRVNJVEU1WXRBUlVFRnp3cFNCWWRIQUk1SUNoRkhRNEpBWFgrVEV0SUFna0REQzhkSlJvUENCd1BCUUlCQVFvd01CeGhFQ1VDQVZ4U1kwd1REMElER3lJbkFRRVZEdnU0Q2lNR0lnUUJNQ012ZFNFN0xBRUJKeDBQRHdCNDJtTmdaR0JnQU9KNThuNnE4ZncyWHhtWVdSaEE0TEgxQ1E0RS9WK0hPWVR4S0pETHdjQUVFZ1VBK0FvSkJ3QjQybU5nWkdCZ1p2alBBQ1JER0ZJWm5KbTZHSUFpS0lBSkFFQVdBcElBQUFOVUFBQUN6UUJsQUFBQUFBQnNBQUI0Mm1OZ1pHQmdZR0p3QVdJUVlHUkFBd0FIV0FCTEFBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzRBQUFBMktHSFREbWhvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTR1T3gvL1hqK1cyK01qQ3pNSURBWStzVEhBajZQeVBUWldZUWw0T0JDVVFCQUNYNENia0FBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmtBQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUN3QUFBQTJLZUxTNldob1pXRUFBQUk4QUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQWx3QUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ1pBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSnNBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb1FBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEVkFBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpV3VrOWlmSDhObDhabUZrWVFPQ3g5UWtPWkpvbGxQRU9rT0pnWUFMeEFQejRDSHA0Mm1OZ1pHQmcxdnBqeWNEQUVzclF4OURQbE13QUZFRUJUQUJTZ0FOQ0FBUlZBQUFDOGdDT0FBQUFBQUJVQUFCNDJtTmdaR0JnWUdJd1pRRFJERkFTQ1FBQUJjb0FPd0I0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQ1VsWVdCaVpXcEMyQ0RNc1JCZG9nVXFlckk3KzdoZXVnTnArZjl1QU5LZnNoNFRzWnIzTS9KS1VUOWNjRUxiNG1ub2hhSlN6NVlNaUhMWitMTTJTVE9KZmxLWFBET0pmRlUvTy9FSlo4OHRsMTd1L2ZXcTMxbnJIZm5Ob3pyZy9XaDZaeGE2U3JxblhYV0gzdHIxR2xVWm1qQ2NHMVZyU3RkczZXajVjYWRIb3RIc1JmSFJIYWNKUXVNckRsRUo5Qkk2cVMxUWxQOXkzZVN1OWc1eGs5R09pZEpsTkFnVjBIMlZkcUtPbDVxNmwvdjZUQkhBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVR3QUFvQUFBQUFCYndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjM4bU50WVhBQUFBRThBQUFBTWdBQUFEd0hGZjEyWjJ4NVpnQUFBWEFBQUFJZUFBQUNoQkxGdkVab1pXRmtBQUFEa0FBQUFDOEFBQUEyS0ZUVEMyaG9aV0VBQUFQQUFBQUFJQUFBQUNRRm1RR2JhRzEwZUFBQUErQUFBQUFRQUFBQUVBbGlBS2RzYjJOaEFBQUQ4QUFBQUFvQUFBQUtBYWdBMUcxaGVIQUFBQVA4QUFBQUdBQUFBQ0FBQndCRmJtRnRaUUFBQkJRQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRTVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWltQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVc5bFp2Z1A1RE16TUlLRUdSRXEvZ09GQWZCNURlWUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5cVl6Yi8zL0g4aFBBOUgvWi8veEE2c0NBZ0NpSndtSkFBQjQya1hSUFcvVFFCd0djRDkzN2psdjl0bXhmVzZUMUhseGJJZlN4bW5jT2lpdDh0SldRbTBScFVLaUtrSWdoaTZka0JoQWZBZ0cxSUdWbFcvQTNoM3hIUmlSbUJoWVVzN3R3SjEwd3owMy9ILzNLRkNPYnhKeVNYNG9NMFVCNVdDYUFhMFR4Uk9rd2hOTUUwMU1NS1VCaXpJdm5XQWs3NGZDTXhCRWNaU05vZ1FHNFVnendXSjhHWnVxV1N2T04zdGpvT3RHRkx6Sk9lKzI2V3FmUC9LSnpVKzVhNGk5NE40dUVBaVptejduMWFwZkt0UmU1VEd1RnRkSDFtekwyYWRSNExkSWw4WGxJb0Y2N0g3K2MwWTdHczdPNjNFVWR2OUhXSWsyUHFxZEFoUzVpTEorczBGQ1hDdDlaVC9YU0FtN2xjaUpIYVo1SWhXWkJFd2xzbzg0RytYYmh5ZFY4Z0dkSW9zbGltbjVGd2h2bUQ4bDdUZkZ0KytUbDZxYzF4SXdxZzJyN2V3R0RhRjVvOFA1T2FGemJoMmU5N1oxV3F2cUxqNGxGSTY3VmR0dnVhYUZLUGIzR2hVTkh4Yno1RGtsN3ZwcTI3YkxmbW1Kb054WUdiUmVwQ3JPbmx3OHR2a0JSVmVZQXFhMStQdU5sOE5BUlc4N21zOU9SZ2hiWEwrMURXNSs0VGUrS3p1NWJXVEFZNTdzWm5objRIY2tLYms3TStGSm1DRkg2TXMyWllzUzZXVjViekdMeFpRa1lGL1RFTmhaYmFZbkQ2dHFRU2M5Yy9QeTJRWElneVlOaUhyMXVqSnNXMTNBRmFWZ3JKKytveVNNZGlydEFlaWtjYi9zTDRmTzhuTHlzejYxMStvbFF1cStCdFRqU3FUaWFEellxeUpzenA0Q3pHQ3VxZHRFYzByWVhPdllSZ0hRblVZWmFyZ2tVeFZFMHY0Qi8xQlVuQUFBZU5wallHUmdZQUJpWGhsRjIzaCttNjhNekN3TUlQRFkrZ1FIZ3Y2dnkzU002U0tReThIQUJCSUZBT0FjQ04wQWVOcGpZR1JnWUdiNHo4REF3SFNNUWVmL0JhWXNCcUFJQ21BQkFHVWNCRGdDeGdBQUFqb0FTd0k2QUN3Q0tBQXdBQUFBQUFCbUFOUUJRZ0FBZU5wallHUmdZR0JoY0dGZ1lnQUJSZ1kwQUFBSGpnQk5lTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQzBBQUFBMktSN1RTV2hvWldFQUFBSGNBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZndBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPTGRMQmNueHZQYmZHVmdabUVBZ2NmV0p6aVFhZWFKVERaQWlvT0JDY1FEQUF2MkNJSUFBQUI0Mm1OZ1pHQmdWdnhqQkNRbk1oZ3l5REthTUFCRlVBQVRBRUVhQW00QUFBT1JBQUFCVVFBeEFBQUFBQUFnQUFCNDJtTmdaR0JnWUdMZ1p3RFJERkFTQ1FBQUFoUUFGUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktKVFQ1MmhvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRqYlhGWHZqK1cyK01qQ3pNSURBWStzVEhBajYvMTltTnFhN1FDNEhBeE5JRkFBczFBcWpBSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4xNTI3OSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTUuMTA1MDEzJyB5PSctNjUuMjk0MzYxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuNjc4OTk3Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMy4yNjM4OSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuNjc4OTk3Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01Ny45MTA0MjgnIHk9Jy02NC42ODU1MTUnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNTMuNzQ1NDU5JyB5PSctNjEuNjc4OTk3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01MC42MzIxMTYnIHk9Jy02MS42Nzg5OTcnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQ2LjQ5NTE2NScgeT0nLTYxLjY3ODk5Nyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTQuNTIwNDA0JyB5PSctNjUuMjk0MzYxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg0Ni40MDM3OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni42NTM3OCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0LjMyNTgyLDQuNzg0MDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuNjc4OTk3Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTguODEyOTknIHk9Jy02MC42ODI3MzMnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NC01Ni45MDU1SDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNS45NjQsLTY0LjU3ODQxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        
    \SpliceDiagramSquare {
      sw = A,
      se = B,
      nw = A',
      ne = B',
      south = f,
      east = g,
      west = f^{*}(g),
      west/node/style = {right},
      north = \varepsilon _{g},
    }
  
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>is a pullback, where <fr:tex
display="inline"><![CDATA[\varepsilon _{g}]]></fr:tex> is the counit of the adjunction. Note that since <fr:tex
display="inline"><![CDATA[f \circ  f^{*}(g) = \Sigma _{f}(f^{*}(g))]]></fr:tex> by construction, the component <fr:tex
display="inline"><![CDATA[\varepsilon _{g}]]></fr:tex> makes the diagram commute.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[h'\colon C\to A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h\colon C\to B']]></fr:tex> be morphisms such that <fr:tex
display="inline"><![CDATA[fh' = gh]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="2eb932eee263ecd4d313f468c72b28ee"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3Ni40MjcyMjhwdCcgaGVpZ2h0PScxNzQuNDQ0ODM3cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE3LjYxODE1MiAxMTYuMjk2NTU4Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLT0xSNEdob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0o1OG42SjhmdzJYeG1ZV1JoQTRMSDE4WjhJK3I4T2N3ampVU0NYZzRFSkpBb0FMVXNMSXdCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0dIUzhHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHVPeC83UGorVzIrTWpDek1JREFZK3ZqUHhIMGYwYW15OHdnTGdjREU0Z0NBRnNxQzlVQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSc0FBb0FBQUFBQlF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUZFQUFBQmdxR3ppWldOdFlYQUFBQUZJQUFBQU5BQUFBRVFpTEFDNloyeDVaZ0FBQVh3QUFBR05BQUFCek1VV0kxZG9aV0ZrQUFBRERBQUFBQzhBQUFBMktlUFM1V2hvWldFQUFBTThBQUFBSHdBQUFDUUY3Z0RiYUcxMGVBQUFBMXdBQUFBUUFBQUFFQXUwQVd4c2IyTmhBQUFEYkFBQUFBb0FBQUFLQVZZQXhHMWhlSEFBQUFONEFBQUFGd0FBQUNBQUJnQktibUZ0WlFBQUE1QUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUVZQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc3M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lBR0lCWmdZSENBY2hsU2lzdlNHZGdVRkI0WU1HdjlzV1JnWU5aaVBnNFVabVNBZy8vL0dSZ0FXVUVRVHdBQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUFMbEZCU1V4QjhZL1ArUFlOMS9lUGUxL0dXd1dqQUFBUHpGREFGNDJqV1F3VzdUUUJDRzk1KzFkK3ZFanAxNGJjZHRhamRyWXplcVNHaEliSVFxNThxQkk0aExSWVNxNWs3VkV4eTRVNGxIS0JJM2VBVmVvOGMrQzdCRmNKblJQL09QOVAzRHdENzkxdlNZN3RnTHhwQWpReVI4Q1BsUTJtcUJxbDQxR3pSckh3TVVjNnlhZHBuemFrSFZ1a1BTeE1sZjh3WWRubVpRUW1wemdrdnVPUmFFTFRtWGJrSjh6NUt3K3oyZXpzSzVtZ2JCTkJyUGp2ZkpsbjJiU2lGS2doMEkydisvVmZOd2hoOVplM3lpUDF5OXZFajJDQmdGbDgrdWI4ckZreFBmNHozUm84TFhKQnpIbXVURm1UNG9BNktnUEN6Tzg0bmxDSWUwWDVCeE1ST0pmV0VGWGVDZXJZeG9tMldzREhLY3hNa0FoalUzOUNiVkJsTFV1aks5cXF1Nnd6SkhYYTFOMkRpUitQelZUZFZRZkgvek9pU28xUG5tQ2RMRFVMZzNqNFFYamMxY0VhS3hkK3VLY0tpcGo0T3RvL1NBdXNPcEhJOFV4THZkODR4amxKenVYa1ZRT3ZpM2NMYTcwNTQzQXVWdkh6aTNyTVpIT21PQkVWd1VocU1OTzdSTDgyT0o5M2ZDalVOdTNmSTBTeXZBd3Yydjg2R1VYb0NmZ3lNY1RWeVgvUUdZQWpjc0FBQUFlTnBqWUdSZ1lBRGlwMVcxb2ZIOE5sOFptRmtZUU9DeDlmR2ZDUHEvRWtzbzB4VWdsNE9CQ1NRS0FGQlNDL0FBZU5wallHUmdZTmI2WThuQXdCTEtFTS9nd1pUTUFCUkJBU3dBU0hZQ3pnQUVWUUFBQXFvQWZ3THlBSTRCd3dCZkFBQUFBQUJ3QU1RQTVnQUFlTnBqWUdSZ1lHQmg4R1FBMFF4UUVna0FBQWYwQUZFQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdzQUFvQUFBQUFCcWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjRBMk50WVhBQUFBRThBQUFBTWdBQUFEd0hGZjE0WjJ4NVpnQUFBWEFBQUFMV0FBQURiSHhIbEI5b1pXRmtBQUFFU0FBQUFDOEFBQUEyS0ZUUzdXaG9aV0VBQUFSNEFBQUFJQUFBQUNRRnFnR2NhRzEwZUFBQUJKZ0FBQUFVQUFBQUZBd09BUFJzYjJOaEFBQUVyQUFBQUF3QUFBQU1BYTRDaW0xaGVIQUFBQVM0QUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQk5BQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRm9BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXltU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVc5bFp2Z1A1RE16TUlLRUdSRXEvZ09GQWZhbURmY0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5bVl3Yi8zL0g4aFBBOUgvWi8veEI2c0NBZ0NpU1FtTEFBQjQya1dTUFcvYlZoU0crUjVTcEVTS3ZQd1FMeDFMcGtSUkpKWFVFU1ZUcGxKYmxTekxTQkc3elVjTDFIQVFKT2lRSlZPQkRpMWFvRCtoQ0lJTVdiTVYvUWZaQTJRTThoOHlGdWpVQWwzc1hsWkQ3d0h1Y004ZHpuT2VWNEowZHBYVE0vb2dIVWtTWkFaVnM2RDEwMnlCZ2dkYzFYZ1hDeXpsV0UzTG9GaGdKdDczZUdBaFRyTzBuS1U1TEdJb1NxNW1lSDFnSy9aMll6VVpIZ0FEUDVYQnVveXhRU1R2ak5nWElYbnNBZk10Zmh4Zm53TXhGMzA3Wk14MVE3MisvYVJxNCtYbDIxUG5hTnBheTJrYzltaWdaa2FEb0p6NXIvNDZsL3NhemkvYVdab00vbS9oV25yelY2VmZoeVFPU2J0WE55bkJXMmtrclNzYVFhTCtSeUltYnFsYXdBdGVDb0NsZ0J3aEsyZFZoUWdFbGZnZ0wxRm1Ba3JWcWhYd1lLLzZTdEYzamU5L3pCOHJZbDZIdzNJN1R0U2F4eDJ1QmJNN3F3dVNWOHk1Y3pIY04rVnQxL1R4SXBmUjhxZmI2NTV2TzBpejhMalQxUERUNVNwL0tKTy91eE41bmhIcU5ZTFJ1VGJ1UFNvVW5OOS9ldGRqSnpJRzNPYXduY3QvM2pBamlSVU05OVBWMGIwWmtoNHpCUnVrTDYvK3BwL3BuWFJXa1ltUlE5TFVqUzVmcllZdGl5QVV2S0tFdmFtQXFmRFNyTm9CVTRTdkVmWm4zZ0pwdkpFN0s3bUcxZDNPVjUvZW5qWkJMZkthcGk1M3VuT1hIRjFGWURqeFluZ0xzbWx4VHNTSDgvdGJyT2IxR25VOWFMaE83YmxDYk5Dd0FVczcyVTFBdjEyK2l3clU4cWs1bXF1SDdTaHkrclQ4ekNVS3hnRWZLZm4xcHRFYkhLOG4vb1JvUGVURzZTOXBteG53VEU0bkp0TVZuZFUxUlc0S2grT3JQL0FuM2t1SGxjT1poVUFOUkFiM05xN1lScDNBMzl3bEY5QWlqV2syRXFrVmFSVXlnN0xLWjZabWZFazUxTitMQkRqYzZSYjNQbmVWdWtsRGUvTHNtNmVnVzEwNUp1WGx0ODI5eUJrQVB0ZmpBL1BCRHpJbDZXRXpHb3NkZHo0eHdxMmt0YldWZjJ3dnZSdHRuYWdkYWtBN2E2WUtUZy9HeHk2Uzd0SFhnR3Fwdm0xNnBMVjBURzcwUGFzT21LMk9BU1dwaWE0Q0Vnci9CWUcxY1NJQUFIamFZMkJrWUdBQVlwTUphY2J4L0RaZkdaaFpHRURnc2ZYeG53ajZ2eTdUTWFhTFFDNEhBeE5JRkFBdzNRdVRBSGphWTJCa1lHQm0rTS9Bd01CMGpFSG4vd1dtYWdhZ0NBcGdCUUJtWUFSS0FzWUFBQUk2QUVzQ09nQXNBcXdBVFFJb0FEQUFBQUFBQUdZQTFBRklBYlo0Mm1OZ1pHQmdZR1h3WVdCaUFBRkdCalFBQUFoeEFGWjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS1I3VEsyaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZExCZlB4dlBiZkdWZ1ptRUFnY2ZXeDM4aTA4d1RtV3lBRkFjREU0Z0hBRUVvQ3A0QUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVMwQUFvQUFBQUFCVlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDAvbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNXWjJ4NVpnQUFBV1FBQUFIcUFBQUNIUFQvRXp0b1pXRmtBQUFEVUFBQUFDOEFBQUEyS0puVHRXaG9aV0VBQUFPQUFBQUFIZ0FBQUNRR01nSGRhRzEwZUFBQUE2QUFBQUFRQUFBQUVBdFpBSUpzYjJOaEFBQURzQUFBQUFvQUFBQUtBV0lBc0cxaGVIQUFBQU84QUFBQUdBQUFBQ0FBQ0FBNmJtRnRaUUFBQTlRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRXFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzWTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCbVp2Z1A1RE5EcEpIVS9BY0tBd0R6QUExS2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqTy8vOERTY2YvLy84ZkFQTVpBRks1QnA5NDJqWFF6Mm9UVVJRRzhQdmRrN25USkpPWjZLUXpsYVpUMHZ5WnRwS2tkSWFadG9zb2pZazF4YlEyVUlJRWdvSVdCQVUxUmhjdXNvZ0xRVmRDUVZ5NGNlY0R1SEhscWcvZzFvVzRFaDlCa25oSDZMbWJ3OGRkL0w3RE9Ddk1adnduLzhHcWJKT3hFRUc0YWRsbXh2SUNTMVNodWlYWEQyd3JDS3ZJcVNKajJZR3RRK1pSN05VUWV2UUY5MFFtSlZDenl2UFFsTUZvVGtFcWFmb1VWNmV6ZGlwcnBnZ3A1YVNyUVl1djFONy95UTM1Y1JweFl6S3lERnBTUVFRK1o2aUFadDl2akRPRk5MaWhpeWhPR0FMNU14d3hPY1F1enlZaytGZm1zSFcySmFXbW4zZUZ0T1Vjek90UUhkakNnRkJ6NHIvWGpIQkJ5YzJYaEVybk84a1AzcWUzaSs2U1lhRGJ1MHVqem40SC9IcjY1clBwdTZ5dTd6Z2ZUL3NEamtwOXZHd3FqOTcwaHB4djdIMXJ4Z0Q5a0c5ZjRKUlZ3Vy90dEU2TVJIdDdmMWV2eGFJR01OR2dKODNDTlE3ajB1UXpQVzhYRDJuNjY2SklNQWJtelg1VGtuK1B6Q0FkZVhuUksvQkxyalJIWU50QktNOGJDWmZoeUFJeXI4QU53dWhadG1XSHNnNGxycEpJeEJWd0hCODBYbTAwRjRXRjJNc2JxLzNBTDR0WVhGV28zRng3WEgveGdhamp0NTZPTzJ1cllrK0h4cyttZjNWcFZvM1M3UWRBZmF2YlgraVZoM2M0VnRZcnZZVWt3TFdIdTBVUGREcDZQV2o1UnhRckZQVURuUk5qL3dBZDBscitBQUI0Mm1OZ1pHQmdBR0wycHZ1TThmdzJYeG1ZV1JoQTRMSDE4WjhJK3Y5TFptNm11MEF1QndNVFNCUUFOTTRMclFCNDJtTmdaR0JnWnZqUEFDUTVHRlQrWDJEbVpnQ0tvQUFXQUVyM0F4VUFBQUoyQUFBREFBQWtBd2dBS3dMYkFETUFBQUFBQUZRQXNBRU9BQUI0Mm1OZ1pHQmdZR0d3WkdCbUFBRkdCalFBQUFhU0FFTjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTEzLjk5Mzk5NycgeT0nLTI3LjU2NDIyMSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTYuNzk5NDEyJyB5PSctMjYuOTU1Mzc1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTEyLjYzNDQ0MycgeT0nLTIzLjk0ODg1OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS41MjExJyB5PSctMjMuOTQ4ODU4Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01LjM4NDE0OScgeT0nLTIzLjk0ODg1OCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTMuNDA5Mzg4JyB5PSctMjcuNTY0MjIxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg0Ni40MDM3OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni42NTM3OCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0LjMyNTgyLDQuNzg0MDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTcuNzAxOTc0JyB5PSctMjIuOTUyNTk0Jz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ0LjE2OTU0LDM3LjczODMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDEuMDgxMTggMzMuODI4NTdDLTQ2LjQ3NDQ5LTEuMTM0MzUtMzUuODg3Ni0yOC4zODUzLTguNjk1MzYtNTAuMjI0NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjc3OTY1LC0wLjYyNjE2LDAuNjI2MTYsMC43Nzk2NSwtOC41MDA0NiwtNTAuMzgxMDQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00Ny43MDk2MywtMjEuNzY1ODUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xNi44MDE3MzgnIHk9Jy0yNi45NTUzNzUnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTMxLjc1MTUxIDQxLjM1NDMxQzIuMzI5ODYgNDYuMzc0MjggMjguNjcyNDkgMzUuOTMyODUgNDkuNzUwMjcgOS4zMTk0OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjYyMDgyLC0wLjc4Mzg3LDAuNzgzODcsMC42MjA4Miw0OS45MDU0Nyw5LjEyMzUyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNy4xNzg0LDM5Ljk2MjE5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+aDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2UtZGFzaGFycmF5PSczLjAsMi4wJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KPHBhdGggZD0nTS0zMy44MjgwOCAzMy44Mjg1N0wtOS4yNzcxNiA5LjI4MTA3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTQsLTAuNzA3MDUsMC43MDcwNSwwLjcwNzE0LC05LjEwMDM3LDkuMTA0MzEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTS0yOC42MzMzOSAxNi42MjgwN0gtMTQuMTE4MjlWMjkuMTE4MDZILTI4LjYzMzM5Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTI1LjYzMzM5LDE5LjYyODA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+aDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTYuODAxNzM4JyB5PSctMjYuOTU1Mzc1Jz7igKA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        
    \SpliceDiagramSquare {
      sw = A,
      se = B,
      nw = A',
      ne = B',
      south = f,
      east = g,
      west = f^{*}(g),
      west/node/style = {right},
      north = \varepsilon _{g},
    }
  
        \node  [above left = of nw] (c) {$C$};
        \draw  [->,morphism,bend right] (c) to node[swap] {$h'$} (sw);
        \draw  [->,morphism,bend left] (c) to node {$h$} (ne);
        \draw  [->,morphism,exists] (c) to node[desc] {$h^{\dag }$} (nw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Note that <fr:tex
display="inline"><![CDATA[h]]></fr:tex> is a morphism <fr:tex
display="inline"><![CDATA[h\colon \Sigma _{f}(h')\to g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. Thus, it corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[h^{\dag }\colon h'\to f^{*}(g)]]></fr:tex> under the adjunction.</fr:p><fr:p>The transpose of <fr:tex
display="inline"><![CDATA[h^{\dag }]]></fr:tex> can be computed as <fr:tex
display="inline"><![CDATA[\varepsilon _{g} \circ  \Sigma _{f}(h^{\dag })]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> is the identity on morphisms, we have
      <fr:tex
display="block"><![CDATA[         (h^{\dag })^{\dag } = \varepsilon _{g} \circ  \Sigma _{f}(h^{\dag }) = \varepsilon _{g} \circ  h^{\dag } = h       ]]></fr:tex>
      Thus, the top triangle also commutes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>814</fr:anchor><fr:addr
type="machine">#306</fr:addr><fr:route>unstable-306.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has pullbacks. Then we can take <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> to be the pullback functor. It remains to check that <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex>.</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
      
  <html:tr>
        
  <html:th>Unit</html:th>

        
  <html:th>Counit</html:th>

      </html:tr>

      
  <html:tr>
        
  <html:td>
          Let <fr:tex
display="inline"><![CDATA[h \in  {{\mathcal {C}}_{/{A}}}]]></fr:tex> be an object, we take <fr:tex
display="inline"><![CDATA[\eta _{h}\colon h\to f^{*}(\Sigma _{f}(h))]]></fr:tex> to be the unique morphism given by the following pullback:
          
    
      
      <fr:figure><fr:resource
hash="c09b8b07b92837716709f79f64e26dcc"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI0My4yNTI3NDdwdCcgaGVpZ2h0PScxODEuMzgwMTM0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTYyLjE2ODQ5OCAxMjAuOTIwMDknPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFRQUFvQUFBQUFCSlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hjTjRabU50WVhBQUFBRThBQUFBTWdBQUFEd0hMLzBNWjJ4NVpnQUFBWEFBQUFGQ0FBQUJZQm9QaUZGb1pXRmtBQUFDdEFBQUFDMEFBQUEyS1AvUzQyaG9aV0VBQUFMa0FBQUFIZ0FBQUNRRzFBTTlhRzEwZUFBQUF3UUFBQUFRQUFBQUVBdDdBVjVzYjJOaEFBQURGQUFBQUFvQUFBQUtBT1lBYUcxaGVIQUFBQU1nQUFBQUZ3QUFBQ0FBQmdBcWJtRnRaUUFBQXpnQUFBREtBQUFCTXVzSWtlWndiM04wQUFBRUJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFRVWUY3TXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBWHFnNGNBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5bW95TC83L0g4alhBTkgvYi81SkFLc0NBZ0NZbXdrNUFBQjQyaTJQUFV2RFVCU0c3NXViM0h6YUQ2MkpyYVEwS1NSQ3RZS21hVUZpNldoZFJLSFNRZ2NwaXFQRlJSMEY5ODcrZ3Y2SWpvS0xnL2dMQkFjM0YzRVFOZldhZXM1eTN1Vjl6a05BYnFjRTk1U1FJaUZJUVdhV21XeU91WDRWdnVlSDlXM1V3dzF6a2VGdS8wYWlycUt0WFNoZ2haYlRMa1dpR0pYYVRxdkFJTHlHSDVQKzVaSjFkU3hxb2hiWXZlaHNQQjVHWFR2UVJKWHdBUmx3MW9pemxubGc4aC9OVzBlUUFPWTkzK09IVllSbFl2VGZTZ1hKUC9ScU9EbVhLWjBCUVdhZGtCUkZ0QWVkYXhTKytyb3VJUUZ5eHRGMFNvZkNoS3dRb3NJeG0wZ0VOcW5EdkpwWFYxRkZMUWd0eHlwenV5ckt6b0lwbS9pTW4zQmdOUEpibFh5VXJyZy9nWkVUTWxpTkgyV2FUUXNQYnNWb2xPelRadno4cllOaU4zNERmeTJqN0hXNEVETVVIVmwwbWFwa1pMenZkRkp6UnZ4aXlCSlgvZ1ZyT0VIVkFBQjQybU5nWkdCZ0FHSk8xZ1BKOGZ3Mlh4bVlXUmhBNExIMThjOEkrajhEY3lFemlNdkJ3QVNpQUJkVENnb0FBQUI0Mm1OZ1pHQmdadmpQQUNTdk1pUXlKRE1YTWdCRlVBQUxBRTB1QXhrQUFBTlNBQUFDS2dDYUFpb0FZd1BWQUdFQUFBQUFBRFlBYUFDd0FBQjQybU5nWkdCZ1lHSFFaQURSREZBU0NRQUFCTlFBTVFCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRXFmbTV1RGs2dkQyNndKMHFHcHBMWG9JdjUwYjBQd0JnN2ZQZWZjQUJrdkVvWkptQWNkSnBVM2p6em1oMFhraWZpcnlCbS9yQm1ScEROeFZ1d2lwMHo1anp4bVNSbDVJdjRqY3NZZjczMVQzKzZkOWVyWUdPdmRwZmJiay9WdDFUaTEwZm13SHF5ei90eFpvOHFuTW4zVjl0ZGFGVHJYQlhzYWFtN2M2YkI0RkVkeFRHREhSVExQbGxQWVd5ckpuSFEyYVBKdmVwRFVoY1k1L0dLa1VmSVVOZlJ5MDRwZXBhc293cDJtK0FCVk1pNURBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSb0FBb0FBQUFBQlF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWUYxYkdOdFlYQUFBQUU0QUFBQU1RQUFBRHdBZkFEQloyeDVaZ0FBQVd3QUFBR2lBQUFCM1A1M2IwVm9aV0ZrQUFBREVBQUFBQzhBQUFBMktPTFM1V2hvWldFQUFBTkFBQUFBSGdBQUFDUUdjUUpQYUcxMGVBQUFBMkFBQUFBTUFBQUFEQWxmQVBwc2IyTmhBQUFEYkFBQUFBZ0FBQUFJQUhJQTdtMWhlSEFBQUFOMEFBQUFGd0FBQUNBQUJRQlJibUZ0WlFBQUE0d0FBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUVYQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1sbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBxbU1XUXdNL3dIOHBraDBraHEvZ09GQWJtUERONEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtwakZrL1A4UDVJUHAvN1AvendLckFnSUFtUElKTndBQUFIamFIZEJOVHR0QUZBZHd2emYyakJPUHgxOHp0b2xJU3V6SVRsSklpaEljMGFaSnF5Q0VRSHd0RVJJSFFPSUFWUmZkVnFyYVhvRmJkRitwNmdGNkNBNkF1Z1hHMGJ6RnpMeTNlTCsvQWNibjV4MzhnLytNSThNQTRnRmxBaGd0eWdWTTRrUlNGcitDQmN5cUpWU3puQlo3MHlxWjFQZjFpUk1CZVZFVzFhd1lROGFvQjVNcWxvd3llTmgzRzBFci9MaVRuUklZcUNHUnloTlJ1MmNGNFdiZ1hMbVI5RzRFTlZQYnpTLzd4M29rSGhMZ0hkK0xXa21UcDNldXRJa0ozNTUrTGJMNW9EVkJ5RVpaUnNxZzIyU0FXS25sN2YzdFc2Q3ViTUJGZDJ2cUIyTVRldHYxQ0MyRmpaRDZ5NTlBTnh3Q2htWVpYNTcvNHlQK05jNXJvK1owUU9sbDYxSTAwVytOVGJSV2IwN1pDTXFwRnRiSWFaSHJNQVI0dUhiT0l2MnBwVHFkYXAxSXJHTDRkQkhmbkp5ZFlHVEpwc2V3V3k2RWFYUGVnRFlQK3F2eEJ5QStWNmgwWTM2OUpVVXpZOWFtbjV2bWR4UEJGcmtUSWxKaS9lQVM4UDdwZDN0RllGVU4zL0g5dEpSK1R2QmcyMnNnT25KWGhwcjRac0Nkc3ZPZXprZFpIdzkzTy9ucnIybWtvSmZnWGtncEJkU1JjSTNtWUxubUM0KzFPLzBBQUhqYVkyQmtZR0FBWXVkNWV3WGorVzIrTWpDek1JREFZK3ZqWHhEMGYxM21FS2JMUUM0SEF4TklGQUE0dHd0c0FIamFZMkJrWUdCbStNOEFKRU1ZcXY5L1ovck1BQlJCQWN3QWJvb0V4UUFBQTFRQUFBSzhBSHNEVHdCL0FBQUFBQUJ5QU81NDJtTmdaR0JnWUdZSVlBRFJERkFTQ1FBQUNJZ0FWd0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVA0QUFvQUFBQUFCR3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hjTjM4bU50WVhBQUFBRThBQUFBTWdBQUFEd0hMLzBNWjJ4NVpnQUFBWEFBQUFFcEFBQUJPTkNXS2VGb1pXRmtBQUFDbkFBQUFDNEFBQUEyS0lqUzVtaG9aV0VBQUFMTUFBQUFIZ0FBQUNRR1F3S1JhRzEwZUFBQUF1d0FBQUFRQUFBQUVBbW9BUU5zYjJOaEFBQUMvQUFBQUFvQUFBQUtBTXdBWUcxaGVIQUFBQU1JQUFBQUZ3QUFBQ0FBQmdBaWJtRnRaUUFBQXlBQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRDdBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXltS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHBxTUM5bVp2Z1A1RE16TUlLRUdSRXEvZ09GQWUxM0RhZ0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5bW95TC83L0g4alhBTkgvYi81SkFLc0NBZ0NZbXdrNUFBQjQyaVhPdlU0Q1FSUUY0SHRtTmpQT3lzK0N1QnMxRVphVlJRdElGTmlORktLTldsQVNDNE9Ga2xpaENVYnRVT05QWStKRDBQb01sc1pIOEEwb2pJbTJhdUxxRUhKUGNhcnZYQUtkL2dGWG5HaVdDSTZka1NJSklZV3RheEorVVYvb054Q2dHNWR5b3k1WE9YWU9UUm0vcXlVbUM0eVZFZ0VuTUV0VXUxYnY1ZUY3VDFrTUIzMDMxKytjM0JTdU5VbmIybStOL1NtdE9yYk1DSm1BSDFZYldFTllSdEd2QldIN05oaUJTL25nZUE0ODJXcUQ5ellWQktleHRqdFkzKzh3a3h1cDV1ZmdlVmczaFdKRUkzK0xpUDJ3SjhvUktiajZWWjJ3SXQyOFh3c1YvTUJ4SGE4TTZlcHhpY2ZvQXl1bHhjcXlYYmE4N085OUxNVXdIYjBobG1ibldjKzY2RWZSME9CQU14cUNZOFphT1BzeXpBbk00eWl0OEg3Wk5LSlhvU1RSUDVMY08wUUFBQUI0Mm1OZ1pHQmdBT0s1OXhxNzQvbHR2akl3c3pDQXdHUHI0MThROUg5R3BsL01JQzRIQXhPSUFnQmJHQXZyQUFCNDJtTmdaR0JnWnZqUEFDU2RHZHdaUEpsK01RQkZVQUFMQUVTTEF0c0FBQUxUQUFBQnlRQjBBY2tBU0FOREFFY0FBQUFBQURBQVlBQ2NBQUI0Mm1OZ1pHQmdZR0ZRWkFEUkRGQVNDUUFBQkF3QUtRQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDArMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNWWjJ4NVpnQUFBV1FBQUFGTEFBQUJZRG1Tc1RKb1pXRmtBQUFDc0FBQUFDOEFBQUEyS0pUVHYyaG9aV0VBQUFMZ0FBQUFIZ0FBQUNRR0xBSU9hRzEwZUFBQUF3QUFBQUFNQUFBQURBaCtBRTlzYjJOaEFBQUREQUFBQUFnQUFBQUlBRlFBc0cxaGVIQUFBQU1VQUFBQUZnQUFBQ0FBQndBNmJtRnRaUUFBQXl3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaVp2Z1A1RE5EcEpIVS9BY0tBd0R5S1ExSGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoTy8vOERTY2YvLy84ZkFQTVpBRktvQnA1NDJqV1BNVS9DUUFDRjc5M0JIV0RiUTF2YUdBRlRRWnBvRkVOSkt3d01LbWcwRXBURU1KQ1ltQ2liZzBGY0dSaDFNakZ4Y25IekI3ZzRPZmtuSEl5anZ3R3dOZkZOTDEvZThEMUNTWDQ2cFYvMGt4UkppUkFmbmw4eUxkMHdYYy9rUlFpbjRKUTl5L1Q4SW16QkRkUHlMQTBCRDdGYmcrK3lWNXh6UStXb21Xc3BLTkgrTUJhRk9xT1hXVnhNcGswMXJhc01hclRYVWFERWwycVBQL2FBbmlRUmwrT2hLVmxHZ0RIUW1CU0FZbDNVUjBZK0NTbzFIdUtFNU1oOTRKZ0VZV1IxT21hY3ZwRXNXU0diZ2FsZXpqazhjTE96U0drUVdWaGNnZ3ViLy9ucW9aeFhjSElGTHRoL1o4SEFmYjViY0RKU290TTlZOFAyUVJ0ME4zbDRQYmxQYTFvMSsvUncycWRZM3g0dDZ0SEwyKzZBMG8yOTkwWUUwRnEwTWt0WldvQWVWZmQ3TXRHc0hHeHB0VWo0QURycTdLcVIzNkdROCtNWGR0TmNickhKOXh4UGtGK3p2VHVEQUhqYVkyQmtZR0FBNGpiWGxiengvRFpmR1poWkdFRGdzZlh4THdqNi8xOW1OcWE3UUM0SEF4TklGQUE1cUF2S0FIamFZMkJrWUdCbStNOEFKRGtZVkJpWW1Oa1lnQ0lvZ0JrQUk4Y0JRZ0FBQW5ZQUFBTUFBQ1FEQ0FBckFBQUFBQUJVQUxCNDJtTmdaR0JnWUdhd0JHSVFZR1JBQXdBR2R3QkNBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5vQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDMEFBQUEyS2VMU3dXaG9aV0VBQUFKQUFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFtQUFBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNhQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUp3QUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9nQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFdBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaVd1azlHK1A1YmI0eU1MTXdnTUJqNitOZmtHbVdVTVk3UUlxRGdRbkVBd0EwcndxZ0FBQUFlTnBqWUdSZ1lOYjZZOG5Bd0JMSzBNZlF6NVRNQUJSQkFVd0FVb0FEUWdBRVZRQUFBdklBamdBQUFBQUFWQUFBZU5wallHUmdZR0JpTUdVQTBReFFFZ2tBQUFYS0FEc0FlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ2xKV0ZnWW1WcVF0Z2d6TEVRWGFJRktucXlPL3U0WHJvRGFmbi9iZ0RTbjdJZUU3R2E5elB5U2xFL1hIQkMyK0pwNklXaVVzK1dESWh5MmZpek5ra3ppWDVTbHp3emlYeFZQenZ4Q1dmUExaZGU3djMxcXQ5WjZ4MzV6YU02NFAxb2VtY1d1a3E2cDExMWg5N2E5UnBWR1pvd25CdFZhMHJYYk9sbytYR25SNkxSN0VYeDBSMm5DVUxqS3c1UkNmUVNPcWt0VUpUL2N0M2tydllPY1pQUmpvblNaVFFJRmRCOWxYYWlqcGVhdXBmNytrd1J3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV1lBQW9BQUFBQUJxQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGNEMyTnRZWEFBQUFFOEFBQUFPd0FBQUV3RVBRU05aMng1WmdBQUFYZ0FBQUs3QUFBRFZPTFQzemhvWldGa0FBQUVOQUFBQUM4QUFBQTJLRlRTMjJob1pXRUFBQVJrQUFBQUlBQUFBQ1FGcmdHY2FHMTBlQUFBQklRQUFBQVVBQUFBRkF3dUFQaHNiMk5oQUFBRW1BQUFBQXdBQUFBTUFhNENoRzFoZUhBQUFBU2tBQUFBR0FBQUFDQUFDQUJOYm1GdFpRQUFCTHdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGakFBQUFBd0FBQUFnQUFNQUFIamFZMkJteW1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzluWnZnUDVETXpNSUtFR1JFcS9nT0ZBZmtPRGY4QUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ3NnRFFYQXdkUWpva2hqU0dEZVN2ejl2Ly9nV0p3OXYvWi8yZjk4ZnZqQzlZQkJRQjViUTdIQUhqYVJaSTliOXRXRkliNUhsS1hFcjh1SlpLWGlpVlRIeFJKMlVrcHlWTEkyRklreHdvUzFHNmJqd0lOMmlYSWtDVkxsaFFaQXZRbkZCMHlkTTBXZE9tZkNKSWxRTkgvMExGQXAzYTBlMlVGeUQzQUhjNjduT2M4UjRGeWRqR2laL1NuY3F3b1VEbVk3a0R2cDlrU1V4RUtwb3NPbGxpcE1VdUxjTHBFS2ZzSEluUVFwMWxhbE9rSURuRk1DOEV5dkRseU5YZW5kbXN5UEFJR1FhcUNkempuZzU2Nm0vT3ZJdkw0QXg0NDRpVGVXd0N4a0xrYmNkNW9SRVoxNS9FbXh1dnpkNmYxNDVtL1Z0TTQ2dEtBWldhTm9KMEZ2Lzc3U08zcmVQUjlLMHVUd2VjSVY5SXZmdGI2VlNqeVFmbjY0ajk2UlIrVXN3MkxIRFlpblcyUkFoWWVGR1V4RFNQb1RKWWtuSzBnTzJXUlpwS1ljVTB5NWJoZWVrdWs4WFlCWlNGMDNQcW0vZkR3enN3QytlUlp0cUcyTzRzRzFRMkcwS3pIeStFTnFMWWpCSkVZTHU0M2VjWHIxcXBHV0d2VUs3OW94QWMxRjNEMDI5Y1MwTnZ6RDcwcEtxT1puUy9Zdk5YcjFmdTB1dGtnQ3NlaHlMWFJubVYyQnlmclNUQWhXZytGZWZwVDJ1SW1QRnZRYlpzYm1zR3J1cVphQ2luamk3L3hELzVRNXNwYVVVb0hJUXVscHcxZ0dXRURuRVBPWDI3L1FraG9hU3pOY21sV0dnMlhDSXVOdzR4bFlrVWpzTittQ1REZjdVenYzVzFvVlp1Rzd1VFpkMDlCTnpwcVROcnJKOVpCcno0QUFtSEVSL2FEbHlvbDZkenFqZVdPMjFmTnFKbjR6ZWJvcjliSzIyOFpSSzFJQjFxWmxXbzRQUnFmTkpCMGpyOEZtTU1DMS9aSTl3MU05dnVlVXdWc3YyMUNTeW95MVVCYmgrT0xoTzdndlhKejQzQjdpOUlKWFZweXdNbFIwMnlsRnRkbm56b2o1Tkxqa2k2eElubU10SGhPd1k3alEzdWhxU1QyNXRLS29lLzZsVnJROW1GY3RVekd2YWh2Vm5URFpCRGN5ZzYvckU1LzZONlZqb0h3ZkdYRjVOWURmTFNidzBzVHdVNzA0MzJmTzNEcis3K1A4OUFOMnNCeDdwc2djdGR0MGFYa2NENmdqZGlXUlBnZkY2Um9nUUI0Mm1OZ1pHQmdBT0tjaDRmazQvbHR2akl3c3pDQXdHUHI0MThROUg5VnBtTk1GNEZjRGdZbWtDZ0FWRUFNVWdCNDJtTmdaR0JnWnZqUHdNREFkSXpCNFA4RnBtb0dvQWdLWUFVQVpyd0VUZ0xHQUFBQ09nQkxBcXdBVFFJb0FEQUNXZ0F3QUFBQUFBQm1BTm9CU0FHcWVOcGpZR1JnWUdCbDhHRmdZZ0FCUmdZMEFBQUljUUJXZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLUjdUSVdob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0xkTEJjZnh2UGJmR1ZnWm1FQWdjZld4NzhnMDh3VG1XeUFGQWNERTRnSEFFT2VDcWdBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjE1Mjc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0xNC43MjQ3NDcnIHk9Jy0yMi45NDA2OTEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzLjI2Mzg5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE3LjUzMDE2MScgeT0nLTIyLjMzMTg0NCc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xMy4zNjUxOTInIHk9Jy0xOS4zMjUzMjcnPijOozwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNC41NjQ4MTQnIHk9Jy0xOC4yNjgxOCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctLjA3MTIxMycgeT0nLTE5LjMyNTMyNyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczLjA0MjEzJyB5PSctMTkuMzI1MzI3Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzcuNzA2Mzg5JyB5PSctMTkuMzI1MzI3Jz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3OS45MTIwOCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTQuMTQwMTM3JyB5PSctMjIuOTQwNjkxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODEuMzE0ODcsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINzQuODU2NTQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzUuMTA2NTQsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzMC45NjUwMSw2Ljg3MjkxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+zrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTE4LjQzMjcyNCcgeT0nLTE3Ljk5MTQzMSc+zqM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTEzLjY1ODg3OScgeT0nLTE2LjI0Nzk2OSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctOS4xNjUyNzgnIHk9Jy0xNy45OTE0MzEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYuNDY3MDIzJyB5PSctMTcuOTkxNDMxJz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yLjM0NDY5NCcgeT0nLTE3Ljk5MTQzMSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNODUuMzU4MjYtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw4NS4zNTgyNiwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4LjYyMjE1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPs6jPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xNi41MDk3MScgeT0nLTE4LjI2ODE4Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xMi4wMTYxMDknIHk9Jy0xOS4zMjUzMjcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTguOTAyNzY2JyB5PSctMTkuMzI1MzI3Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00LjIzODUwOCcgeT0nLTE5LjMyNTMyNyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NC01Ni45MDU1SDc2LjI1OTMyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDc2LjUwOTMyLC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MC4xOTAzOCwtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00NS42ODQ0OCwzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTQuMTQwMTM3JyB5PSctMjIuOTQwNjkxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC42OTUzNi01MC4yMjQ1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzc5NjUsLTAuNjI2MTYsMC42MjYxNiwwLjc3OTY1LC04LjUwMDQ2LC01MC4zODEwNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ1LjAwNDczLC0yMC44MzEzOCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPmg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScxLjYnPgo8cGF0aCBkPSdNLTMwLjIzNjU3IDQyLjQwNTI2QzEyLjY1NzEyIDUyLjA3MjIgNDcuNDM2MzcgNDEuMjQxMDEgNzcuMjU1MTQgOC45Mjc1NScgZmlsbD0nbm9uZScvPgo8ZyBzdHJva2Utd2lkdGg9JzAuNic+CjxnIHN0cm9rZT0nI2ZmZic+CjxwYXRoIGQ9J00tMzAuMjM2NTcgNDIuNDA1MjZDMTIuNjU3MTIgNTIuMDcyMiA0Ny40MzYzNyA0MS4yNDEwMSA3Ny4yNTUxNCA4LjkyNzU1JyBmaWxsPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzMuMCwyLjAnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNLTMzLjgyODA4IDMzLjgyODU3TC05LjI3NzE2IDkuMjgxMDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNCwtMC43MDcwNSwwLjcwNzA1LDAuNzA3MTQsLTkuMTAwMzcsOS4xMDQzMSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNLTI4Ljc1NDgyIDE1LjI2Njk4SC0xMy45OTY4NVYyNS42NDE5NUgtMjguNzU0ODJaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjUuNzU0ODIsMTkuNjI4MDcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz7OtzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTguMDkxOTU4JyB5PSctMTguMjY4MTgnPmg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                width = 3cm,
                sw = A,
                nw/style = pullback,
                se = B,
                nw = A',
                ne = B',
                south = f,
                east = \Sigma _{f}(h),
                west = f^{*}(\Sigma _{f}(h)),
                west/node/style = {right},
                north = \varepsilon _{\Sigma _{f}(h)},
              }
              \node  [above left of = nw] (c) {$B'$};
              \draw  [->,morphism,bend right] (c) to node[swap] {$h$} (sw);
              \draw  [double,morphism,bend left] (c) to (ne);
              \draw  [->,morphism,exists] (c) to node[desc] {$\eta _{h}$} (nw);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          <fr:p>where <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> is the counit defined on the right. Then naturality is a consequence of uniqueness.</fr:p>
        </html:td>

        
  <html:td>Let <fr:tex
display="inline"><![CDATA[g \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex> be an object. We take <fr:tex
display="inline"><![CDATA[\varepsilon _{g}\colon \Sigma _{f}(f^{*}(g))\to g]]></fr:tex> to be the following morphism.
          
    
      
      <fr:figure><fr:resource
hash="713a053a883955433c0f73df139f72b9"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzOC44MDA0NDNwdCcgaGVpZ2h0PScxMTcuODQ5NjI0cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTIuNTMzNjI5IDc4LjU2NjQxNic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5rQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDd0FBQUEyS2VMUzYyaG9aV0VBQUFJOEFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFsd0FBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNaQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUpzQUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9RQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFZBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaVd1azlzZkg4Tmw4Wm1Ga1lRT0N4OVFsT1pKb2xsUEVPa09KZ1lBTHhBUHg2Q0hoNDJtTmdaR0JnMXZwanljREFFc3JReDlEUGxNd0FGRUVCVEFCU2dBTkNBQVJWQUFBQzhnQ09BQUFBQUFCVUFBQjQybU5nWkdCZ1lHSXdaUURSREZBU0NRQUFCY29BT3dCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUNVbFlXQmlaV3BDMkNETXNSQmRvZ1VxZXJJNys3aGV1Z05wK2Y5dUFOS2ZzaDRUc1pyM00vSktVVDljY0VMYjRtbm9oYUpTejVZTWlITForTE0yU1RPSmZsS1hQRE9KZkZVL08vRUpaODh0bDE3dS9mV3EzMW5ySGZuTm96cmcvV2g2WnhhNlNycW5YWFdIM3RyMUdsVVptakNjRzFWclN0ZHM2V2o1Y2FkSG90SHNSZkhSSGFjSlF1TXJEbEVKOUJJNnFTMVFsUDl5M2VTdTlnNXhrOUdPaWRKbE5BZ1YwSDJWZHFLT2w1cTZsL3Y2VEJIQUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0dIVEVHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHVPeC83WGorVzIrTWpDek1JREFZK3NUbkFqNlB5UFRaV1lRbDRPQkNVUUJBQ1Y2Q2JjQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPVUFBb0FBQUFBQS93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWUoxWEdOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDNloyeDVaZ0FBQVdRQUFBRFlBQUFBMk5WcUxUdG9aV0ZrQUFBQ1BBQUFBQzhBQUFBMktPTFNBR2hvWldFQUFBSnNBQUFBSGdBQUFDUUY4UUthYUcxMGVBQUFBb3dBQUFBSUFBQUFDQVloQUdWc2IyTmhBQUFDbEFBQUFBWUFBQUFHQUd3QUFHMWhlSEFBQUFLY0FBQUFGZ0FBQUNBQUJRQkZibUZ0WlFBQUFyUUFBQUROQUFBQk9QTmJLcDl3YjNOMEFBQURoQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1GbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBxbU02UXpNL3dIOHBraDBraHEvZ09GQWJRZURNOEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2anAvLzlEeVArendId0dBRlcxQnNNQUFBQUFBZ0JsL3l3Q2lnSEZBQzRBUXdBQUFRTU9BU01HTHdFbUp6NEJNaFlWRkFZSEZoOEJGajRDUHdFT0FRY3VBU2MyTnpZM05qY3lGaGMyTng0QkZRYzNOaThCSmljT0FRY09BUlVlQVRjK0FUYytBUUtGYkJTUGF5ODFDek1FQVNVeUZnb1FBaUl0Rno5SEdBWVlFa3d5UzJZQ0EwVVJFbEJoSWtBWkVTSVRFNVl0QVJVRUZ6d3BTQllkSEFJNUlDaEZIUTRKQVhYK1RFdElBZ2tEREM4ZEpSb1BDQndQQlFJQkFRb3dNQnhoRUNVQ0FWeFNZMHdURDBJREd5SW5BUUVWRHZ1NENpTUdJZ1FCTUNNdmRTRTdMQUVCSngwUER3QjQybU5nWkdCZ0FPSjU4bjZLOGZ3Mlh4bVlXUmhBNExIMUNVNEUvVitIT1lUeEtKREx3Y0FFRWdVQTk0d0pCUUI0Mm1OZ1pHQmdadmpQQUNSREdGSVpuSm02R0lBaUtJQUpBRUFXQXBJQUFBTlVBQUFDelFCbEFBQUFBQUJzQUFCNDJtTmdaR0JnWUdKd0FXSVFZR1JBQXdBSFdBQkxBQUI0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVR3QUFvQUFBQUFCYndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjM4bU50WVhBQUFBRThBQUFBTWdBQUFEd0hGZjEyWjJ4NVpnQUFBWEFBQUFJZUFBQUNoQkxGdkVab1pXRmtBQUFEa0FBQUFDOEFBQUEyS0ZUVERXaG9aV0VBQUFQQUFBQUFJQUFBQUNRRm1RR2JhRzEwZUFBQUErQUFBQUFRQUFBQUVBbGlBS2RzYjJOaEFBQUQ4QUFBQUFvQUFBQUtBYWdBMUcxaGVIQUFBQVA4QUFBQUdBQUFBQ0FBQndCRmJtRnRaUUFBQkJRQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRTVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWltQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVc5bFp2Z1A1RE16TUlLRUdSRXEvZ09GQWZCNURlWUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5cVl6Yi8zL0g4aFBBOUgvWi8veEE2c0NBZ0NpSndtSkFBQjQya1hSUFcvVFFCd0djRDkzN2psdjl0bXhmVzZUMUhseGJJZlN4bW5jT2lpdDh0SldRbTBScFVLaUtrSWdoaTZka0JoQWZBZ0cxSUdWbFcvQTNoM3hIUmlSbUJoWVVzN3R3SjEwd3owMy9ILzNLRkNPYnhKeVNYNG9NMFVCNVdDYUFhMFR4Uk9rd2hOTUUwMU1NS1VCaXpJdm5XQWs3NGZDTXhCRWNaU05vZ1FHNFVnendXSjhHWnVxV1N2T04zdGpvT3RHRkx6Sk9lKzI2V3FmUC9LSnpVKzVhNGk5NE40dUVBaVptejduMWFwZkt0UmU1VEd1RnRkSDFtekwyYWRSNExkSWw4WGxJb0Y2N0g3K2MwWTdHczdPNjNFVWR2OUhXSWsyUHFxZEFoUzVpTEorczBGQ1hDdDlaVC9YU0FtN2xjaUpIYVo1SWhXWkJFd2xzbzg0RytYYmh5ZFY4Z0dkSW9zbGltbjVGd2h2bUQ4bDdUZkZ0KytUbDZxYzF4SXdxZzJyN2V3R0RhRjVvOFA1T2FGemJoMmU5N1oxV3F2cUxqNGxGSTY3VmR0dnVhYUZLUGIzR2hVTkh4Yno1RGtsN3ZwcTI3YkxmbW1Kb054WUdiUmVwQ3JPbmx3OHR2a0JSVmVZQXFhMStQdU5sOE5BUlc4N21zOU9SZ2hiWEwrMURXNSs0VGUrS3p1NWJXVEFZNTdzWm5objRIY2tLYms3TStGSm1DRkg2TXMyWllzUzZXVjViekdMeFpRa1lGL1RFTmhaYmFZbkQ2dHFRU2M5Yy9QeTJRWElneVlOaUhyMXVqSnNXMTNBRmFWZ3JKKytveVNNZGlydEFlaWtjYi9zTDRmTzhuTHlzejYxMStvbFF1cStCdFRqU3FUaWFEellxeUpzenA0Q3pHQ3VxZHRFYzByWVhPdllSZ0hRblVZWmFyZ2tVeFZFMHY0Qi8xQlVuQUFBZU5wallHUmdZQUJpWGhsRnkzaCttNjhNekN3TUlQRFkrZ1FuZ3Y2dnkzU002U0tReThIQUJCSUZBTitlQ05zQWVOcGpZR1JnWUdiNHo4REF3SFNNUWVmL0JhWXNCcUFJQ21BQkFHVWNCRGdDeGdBQUFqb0FTd0k2QUN3Q0tBQXdBQUFBQUFCbUFOUUJRZ0FBZU5wallHUmdZR0JoY0dGZ1lnQUJSZ1kwQUFBSGpnQk5lTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQzBBQUFBMktSN1RTMmhvWldFQUFBSGNBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZndBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPTGRMQmQ3NC9sdHZqSXdzekNBd0dQckU1eklOUE5FSmhzZ3hjSEFCT0lCQUF0NENJQUFBQUI0Mm1OZ1pHQmdWdnhqQkNRbk1oZ3l5REthTUFCRlVBQVRBRUVhQW00QUFBT1JBQUFCVVFBeEFBQUFBQUFnQUFCNDJtTmdaR0JnWUdMZ1p3RFJERkFTQ1FBQUFoUUFGUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktKVFQ2V2hvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRqYlhGVHZqK1cyK01qQ3pNSURBWStzVG5BajYvMTltTnFhN1FDNEhBeE5JRkFBc1ZncWhBSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4xNTI3OSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzkuMDc4NTE5JyB5PSctNjUuMjk0MzYxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ni41NTA1MTgsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDYuNTUwNTE4JyB5PSctNjEuNjc4OTk3Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIyLjUzMTA0LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Ni41NTA1MTgnIHk9Jy02MS42Nzg5OTcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQxLjg4MzkzNCcgeT0nLTY0LjY4NTUxNSc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0zNy43MTg5NjUnIHk9Jy02MS42Nzg5OTcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTM0LjYwNTYyMScgeT0nLTYxLjY3ODk5Nyc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzAuNDY4NjcxJyB5PSctNjEuNjc4OTk3Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjQ1OTMyLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ni41NTA1MTgsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDYuNTUwNTE4JyB5PSctNjEuNjc4OTk3Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zOC40OTM5MScgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjg2MjEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ni41NTA1MTgsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDYuNTUwNTE4JyB5PSctNjEuNjc4OTk3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINDYuNDAzNzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNjUzNzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4zMjU4Miw0Ljc4NDAxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+zrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQyLjc4NjQ5NicgeT0nLTYwLjY4MjczMyc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ni41NTA1MTgsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDYuNTUwNTE4JyB5PSctNjEuNjc4OTk3Jz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0LTU2LjkwNTVINDcuODA2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMDU2NTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1Ljk2NCwtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ni41NTA1MTgsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDYuNTUwNTE4JyB5PSctNjEuNjc4OTk3Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \DiagramSquare {
              sw = A,
              nw/style = pullback,
              se = B,
              nw = A',
              ne = B',
              south = f,
              east = g,
              west = f^{*}(g),
              north = \varepsilon _{g},
            }
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          Let <fr:tex
display="inline"><![CDATA[\alpha \colon g\to g']]></fr:tex> be a morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. By the construction of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>, we have the following commutative diagram.
          
    
      
      <fr:figure><fr:resource
hash="1ee8ae6f4500f08dd08da5314907b5d1"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5OC4yMjM2MjFwdCcgaGVpZ2h0PScxNzUuNDY3NzY2cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTMyLjE0OTA4MSAxMTYuOTc4NTExJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLT0xSNEdob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0o1OG42SjhmdzJYeG1ZV1JoQTRMSDE4WjhJK3I4T2N3ampVU0NYZzRFSkpBb0FMVXNMSXdCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPc0FBb0FBQUFBQkJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUUwQUFBQmdxbU5pZTJOdFlYQUFBQUZFQUFBQU13QUFBRHllV21SYloyeDVaZ0FBQVhnQUFBRGdBQUFBN0QwTlFsdG9aV0ZrQUFBQ1dBQUFBQ3NBQUFBMktlTFRLMmhvWldFQUFBS0VBQUFBSHdBQUFDUUY3Z0RhYUcxMGVBQUFBcVFBQUFBTUFBQUFEQWtLQU8xc2IyTmhBQUFDc0FBQUFBZ0FBQUFJQUZRQWRtMWhlSEFBQUFLNEFBQUFGd0FBQUNBQUJRQTJibUZ0WlFBQUF0QUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1abWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUE0TURqSjFTWEpiT3dLWWsvc0NBV2V1UEpRTURzeGJ6Y2FBd0kwTDEvLzhNREFEb3R3N2ZBQUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFabVJnVWhKL1lQRC9Qd01EaEw3N1N2NFNXQlVRQUFDbmlRbXlBSGphTFk1UFNzUXdIRWJ6cGNNdlZOUGFQMm5Tb2s3SERLYTdrU2wxQ2lMMUVvb2JzWWpRdld0dm9PQVJSbkRuR2J5R3l6bUxtTVdzSHQvN05vK0JmYkFsZjhhT2RZeWgzN1JhMFJHMDBTYUd1MEFORWl0ME54RFVXT2ZwR3RjTWFHczA3ckxiOU5vSXZIM0tTcVgwZlgrWGM2Z3EvSXFJMnpRbitYNU9VVkY2cnppS010cEt5bFBMRDNFOGhzckdmRGc5RTJXbVFFL1QxVHhBWnRiVGJRRmxrLzBSanRQNklNckE2MGVmeGtiVzRKVmZzOFNQZ0phK284OEg5SzAySlBEeVMxTG53V3diVlBQS0FUUHMvaDVTSWFJRVAvRUNpeE1wMlQ5dWZCL1FlTnBqWUdSZ1lBRGhlUTJOOGZ3Mlh4bVlXUmhBNExIMThaL0lORXNva3cyUTRtQmdBdkVBSFBJSnBRQjQybU5nWkdCZzF2cGp5Y0RBRXNvUXorREJsTXdBRkVFQnpBQklkUUxOQUFSVkFBQUM4Z0NPQWNNQVh3QUFBQUFBVkFCMmVOcGpZR1JnWUdCbU1HVUEwUXhRRWdrQUFBWGxBRHdBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV1FBQW9BQUFBQUJwZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGNEVtTnRZWEFBQUFFOEFBQUFOUUFBQUVRRHhnU0haMng1WmdBQUFYUUFBQUs0QUFBRFZLVWdxMlJvWldGa0FBQUVMQUFBQUM4QUFBQTJLRlRTN1dob1pXRUFBQVJjQUFBQUlBQUFBQ1FGNHdIT2FHMTBlQUFBQkh3QUFBQVVBQUFBRkF4YUFPWnNiMk5oQUFBRWtBQUFBQXdBQUFBTUFhSUNmbTFoZUhBQUFBU2NBQUFBR0FBQUFDQUFDQUJGYm1GdFpRQUFCTFFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGaEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZndaRGdZQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUlMazBwazNNbS85L3gvSVNvT3cvcy8rRS9USEg2d1dEQUFJREF4TkFBQUFlTnBOMHMxUDAyQWNCL0IrZnkzdDZGNzZzdllwYktOajY5cE9CRFpXNkFqZ3hzQ2d2QWdTaldURStKWWdFUzhtSmtxOCtROFlRemg0OWVyWmkzZnV4di9CbzRrWFBYZ0JuNDZEdGtrUHorOUordjA4MzBlQXNIblJvQ1A2Sml3TEFrUU5zcEtEVWczQ0RpTG1NRmxoWlhUUUZUMDVpSjJvZ3paZmJ6RW5CeThJZzdnZE5KQWpEVkhNNUJBZkYzUkpMd3ozWnVvTFFNME9SR2hsVGROcUZYRnNXdHR5S2EvdGFuYU9yWGhYbGdDUDhibnVhcHBwdW1xcThEQVo0L1Q4Yk1OWW5yVld4Y0J6eDZrbWgrbGhnclJwZi9pOUoxWVY3UFdMWWVEWC9vMHdHa3k5azZvcENQd2hZZkppaW55Y0NkUENhcUxoRW5rZzRZa3RXWEZZeEdJTzZITGtOTUs0bmJ3dUhLN2lHOFF1NHBDalpDVTVBdWEwa3ExVWVUSDg4cmp4UU9KNURZYWNXVElxMXBKWFlvclRYdS8xU2V4cHhucS9QcGNWQzJiV3hrbERoR1hQRmxiSGJkMUFFTG9ycFl5Q04rZTl4cjVJOXVSWUpaOVB1K29RSVYwYWJZN2ZqeVRzM1Q3WXptdlhSZFNZenFBYjUzKythR25mazFDZkMzckxPMjM0NDFwMllPdGUvS0xQQXh0dnluZlI1cGJaeUJuSXVKSmIvemZ4MnBMOFpiaElPdVV3UGcwU21XUHhYbU5xU2l5dDFqS21LaU9hR3UxWWs4YzM5eCtSdEdaWXU0ZmJ6eklFV2kwTktTb2ZGNGJMSnhLa29lYTE0aTAvNUQrT3lxL2U3OWNsbUtVMFNEVWpJaS8ySXREaCtwTWRTK2VXL2ExMHBYWDNxYTZDeUY0ejFwLzNHMTZyTDhLYm1uOWJuTDBHcW5KUDgrSUhmdUtyc0poMDFlYTU1Q1IwNnpLL2Rsa1JiK2J5R3pPSG8zSklHRXFWMzBwZW1oTW45ekNVUTlhbEJ1UlBrUThzanBXam5SdW1sTXBTWFo4NXVuY0FtaStMSGttbmp6T3RpbEVEYktaNkM5bmQxeUw1d1dLbTBvVFlLVjFOdXlPK05UTFMrRjdzNWllS0tsSFJWWUJpbUFra2JDdzBWMHo0NWVVN2dKeVRiVDJiSjhWU01UTlJ6ZWRTUU5iaXh5RDVRM3dxZ1hoVmZ3RyszbktBZU5wallHUmdZQURpRnoyYVIrUDViYjR5TUxNd2dNQmo2K00vRWZSL1hhWmpUQmVCWEE0R0pwQW9BRjZMREpnQWVOcGpZR1JnWUdiNHo4REF3UFNEUWVmL0JhWXRERUFSRk1BS0FHOTlCTFVDeGdBQUFqb0FTd0k2QUN3QytBQS9BaWdBTUFBQUFBQUFaZ0RVQVR3QnFuamFZMkJrWUdCZ1pYQmhZR0lBQVVZR05BQUFCNmtBVG5qYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLUjdUSzJob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0xkTEJmUHh2UGJmR1ZnWm1FQWdjZld4MzhpMDh3VG1XeUFGQWNERTRnSEFFRW9DcDRBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0dIUzhHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHVPeC83UGorVzIrTWpDek1JREFZK3ZqUHhIMGYwYW15OHdnTGdjREU0Z0NBRnNxQzlVQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLSlRUeVdob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0amJYRlQvaitXMitNakN6TUlEQVkrdmpQeEgwLzcvTWJFeDNnVndPQmlhUUtBQmlCZ3kvQUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNi4zMDU1NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIuMTU3ODU5JyB5PSctMjYuODgyMjY5Jz7ugLDugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC05LjYyOTg1OCwtMjMuMjY2OTA2KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy05LjYyOTg1OCcgeT0nLTIzLjI2NjkwNic+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQuOTYzMjc0JyB5PSctMjYuMjczNDIzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS43OTgzMDQnIHk9Jy0yMy4yNjY5MDYnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMi4zMTUwMzknIHk9Jy0yMy4yNjY5MDYnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNi40NTE5ODknIHk9Jy0yNi4yNzM0MjMnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc5LjE0Njc2MycgeT0nLTIzLjI2NjkwNic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MC4zMDY1NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTEuNTczMjUnIHk9Jy0yNi44ODIyNjknPu6AsO6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjg2MTEgMEg0NS4yNTEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDUuNTAxLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjIuOTczMzksNS42MjI5NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS44NjU4MzYnIHk9Jy0yMS40MzQ4NjMnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTIuMTk3Mjc5JyB5PSctMjIuOTAxNTkyJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNDkyOTA4JyB5PSctMjYuMjczNDIzJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00NS4zOTEwOCwzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIuMTU3ODU5JyB5PSctMjYuODgyMjY5Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC42OTUzNi01MC4yMjQ1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzc5NjUsLTAuNjI2MTYsMC42MjYxNiwwLjc3OTY1LC04LjUwMDQ2LC01MC4zODEwNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTU5LjU5MDE1LC0yMS4zMTQ0NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00Ljk2MzI3NCcgeT0nLTI2LjI3MzQyMyc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0uNzk4MzA0JyB5PSctMjMuMjY2OTA2Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzIuMzE1MDM5JyB5PSctMjMuMjY2OTA2Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzYuNDUxOTg5JyB5PSctMjMuMjY2OTA2Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tMzAuNTI5OTcgNDEuNTE0OTRDMy4wNzcyOSA0Ni4yMjg4OCAyOS4xNzQ1OSAzNS42NzUyNSA0OS43NTI5OCA5LjMyMTYyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNjE1NDMsLTAuNzg4MTYsMC43ODgxNiwwLjYxNTQzLDQ5LjkwNjgzLDkuMTI0NTkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE3Ljc5OTY1LDQxLjgwMzM0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPs6xzrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLS42ODY0OTQnIHk9Jy0yMi4yNzA2NDInPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00tMzMuODI4MDggMzMuODI4NTdMLTkuMjc3MTYgOS4yODEwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE0LC0wLjcwNzA1LDAuNzA3MDUsMC43MDcxNCwtOS4xMDAzNyw5LjEwNDMxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00tMzQuNTMyNTYgMTQuODc4MDdILTguMjE5MTFWMjcuOTcyMjJILTM0LjUzMjU2Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMxLjUzMjU2LDE5LjYyODA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQuOTYzMjc0JyB5PSctMjYuMjczNDIzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS43OTgzMDQnIHk9Jy0yMy4yNjY5MDYnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMi4zMTUwMzknIHk9Jy0yMy4yNjY5MDYnPs6xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzcuNDk0MzgnIHk9Jy0yMy4yNjY5MDYnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                nw = A'',
                nw/style = pullback,
                ne = B'',
                sw = A,
                se = B,
                north = \varepsilon _{g'},
                west = f^{*}(g'),
                west/node/style = {right},
                south = f,
                east = g',
              }
              \node  [above left of = nw] (a') {$A'$};
              \draw  [->,morphism,bend right] (a') to node[swap] {$f^{*}(g)$} (sw);
              \draw  [->,morphism,bend left] (a') to node {$\alpha \varepsilon _{g}$} (ne);
              \draw  [->,morphism,exists] (a') to node[desc] {$f^{*}(\alpha )$} (nw);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          Thus, <fr:tex
display="inline"><![CDATA[\varepsilon _{g'}\Sigma _{f}(f^{*}(\alpha )) = \varepsilon _{g'}f^{*}(\alpha ) = \alpha \varepsilon _{g}]]></fr:tex> as required.
        </html:td>

      </html:tr>

    </html:table>
<fr:p>By construction, <fr:tex
display="inline"><![CDATA[\varepsilon _{\Sigma _{f}}\eta  = \mathsf {id}_{\Sigma _{f}}]]></fr:tex>. Thus, it remains to verify the other triangle equality.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[g \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex> be an object. We need to show that <fr:tex
display="inline"><![CDATA[f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} = \mathsf {id}_{f^{*}(g)}]]></fr:tex>. Note that <fr:tex
display="inline"><![CDATA[f^{*}(g)f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} = f^{*}(g)]]></fr:tex> by the construction of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>. Moreover, we also have the following equation.</fr:p><fr:tex
display="block"><![CDATA[       \begin {align*}         \varepsilon _{g}f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} &= \varepsilon _{g}\varepsilon _{f \circ  f^{*}(g)}\eta _{f^{*}(g)} && \text {by the construction of } f^{*}\\                                                     &= \varepsilon _{g}\mathsf {id} && \text {by the construction of } \eta \\                                                     &= \varepsilon _{g}       \end {align*}     ]]></fr:tex><fr:p>Thus, <fr:tex
display="inline"><![CDATA[f^{*}(\varepsilon _{g})\eta _{f^{*}(g)}]]></fr:tex> corresponds to the same cone over <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> as <fr:tex
display="inline"><![CDATA[\mathsf {id}_{f^{*}(g)}]]></fr:tex>. Then uniqueness implies that they are equal.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>