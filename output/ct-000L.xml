<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1342</fr:anchor><fr:addr
type="user">ct-000L</fr:addr><fr:route>ct-000L.xml</fr:route><fr:title
text="Equivalent condition for the existence of images">Equivalent condition for the existence of <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">images</fr:link></fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with pullbacks. Then <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has images iff for each morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex>, the pullback functor <fr:tex
display="inline"><![CDATA[f^{*}\colon \mathsf {Sub}(B)\to \mathsf {Sub}(A)]]></fr:tex> admits a left adjoint <fr:tex
display="inline"><![CDATA[\exists _{f}\colon \mathsf {Sub}(A)\to \mathsf {Sub}(B)]]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>619</fr:anchor><fr:addr
type="machine">#278</fr:addr><fr:route>unstable-278.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By <fr:ref
addr="ct-000J"
href="ct-000J.xml"
taxon="Lemma" />, the pullback functor <fr:tex
display="inline"><![CDATA[f^{*}\colon {{\mathcal {C}}_{/{B}}}\to {{\mathcal {C}}_{/{A}}}]]></fr:tex> admits <fr:tex
display="inline"><![CDATA[\Sigma _{f}\colon {{\mathcal {C}}_{/{A}}}\to {{\mathcal {C}}_{/{B}}}]]></fr:tex> as a left adjoint.</fr:p>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>620</fr:anchor><fr:addr
type="machine">#276</fr:addr><fr:route>unstable-276.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[g\colon B'\rightarrowtail B]]></fr:tex> be an arbitrary object in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. We need to construct a functor <fr:tex
display="inline"><![CDATA[\mathsf {Img}\colon {{\mathcal {C}}_{/{B}}}\to \mathsf {Sub}(B)]]></fr:tex> so that each morphism <fr:tex
display="inline"><![CDATA[f \to  g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f) \to  g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[f \to  g]]></fr:tex> be an arbitrary morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. Then this corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A} \to  f^{*}(g)]]></fr:tex> as follows:</fr:p>
    
      
      <fr:figure><fr:resource
hash="b9735f1b362427f7dc4b29962af32897"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3Mi43OTYzMzlwdCcgaGVpZ2h0PScxNzQuNDQ0ODM3cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE1LjE5NzU1OSAxMTYuMjk2NTU4Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLSXgvdG1ob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0o1cHo5dGplZTMrY3JBek1JQUFvOEY1ajFCMFA5MW1FTVlqd0s1SEF4TUlGRUFZZmNMOVFCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0F1QXhtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhOY2kvZkg4OXQ4WldCbVlRQ0J4d0x6bmlEby80eE1sNWxCWEE0R0poQUZBRGN4Q3FrQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQzBBQUFBMktZeUFvV2hvWldFQUFBSkFBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbUFBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDYUFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKd0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGkyaE1KSCtQNWJiNHlNTE13Z01CamdYbFBrR21XVU1ZN1FJcURnUW5FQXdBN0VncHBBQUFBZU5wallHUmdZTmI2WThuQXdCTEswTWZRejVUTUFCUkJBVXdBVW9BRFFnQUVWUUFBQXZJQWpnQUFBQUFBVkFBQWVOcGpZR1JnWUdCaU1HVUEwUXhRRWdrQUFBWEtBRHNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVR3QUFvQUFBQUFCYndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjM4bU50WVhBQUFBRThBQUFBTWdBQUFEd0hGZjEyWjJ4NVpnQUFBWEFBQUFJZUFBQUNoQkxGdkVab1pXRmtBQUFEa0FBQUFDOEFBQUEySi82QXcyaG9aV0VBQUFQQUFBQUFJQUFBQUNRRm1RR2JhRzEwZUFBQUErQUFBQUFRQUFBQUVBbGlBS2RzYjJOaEFBQUQ4QUFBQUFvQUFBQUtBYWdBMUcxaGVIQUFBQVA4QUFBQUdBQUFBQ0FBQndCRmJtRnRaUUFBQkJRQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRTVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWltQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVc5bFp2Z1A1RE16TUlLRUdSRXEvZ09GQWZCNURlWUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5cVl6Yi8zL0g4aFBBOUgvWi8veEE2c0NBZ0NpSndtSkFBQjQya1hSUFcvVFFCd0djRDkzN2psdjl0bXhmVzZUMUhseGJJZlN4bW5jT2lpdDh0SldRbTBScFVLaUtrSWdoaTZka0JoQWZBZ0cxSUdWbFcvQTNoM3hIUmlSbUJoWVVzN3R3SjEwd3owMy9ILzNLRkNPYnhKeVNYNG9NMFVCNVdDYUFhMFR4Uk9rd2hOTUUwMU1NS1VCaXpJdm5XQWs3NGZDTXhCRWNaU05vZ1FHNFVnendXSjhHWnVxV1N2T04zdGpvT3RHRkx6Sk9lKzI2V3FmUC9LSnpVKzVhNGk5NE40dUVBaVptejduMWFwZkt0UmU1VEd1RnRkSDFtekwyYWRSNExkSWw4WGxJb0Y2N0g3K2MwWTdHczdPNjNFVWR2OUhXSWsyUHFxZEFoUzVpTEorczBGQ1hDdDlaVC9YU0FtN2xjaUpIYVo1SWhXWkJFd2xzbzg0RytYYmh5ZFY4Z0dkSW9zbGltbjVGd2h2bUQ4bDdUZkZ0KytUbDZxYzF4SXdxZzJyN2V3R0RhRjVvOFA1T2FGemJoMmU5N1oxV3F2cUxqNGxGSTY3VmR0dnVhYUZLUGIzR2hVTkh4Yno1RGtsN3ZwcTI3YkxmbW1Kb054WUdiUmVwQ3JPbmx3OHR2a0JSVmVZQXFhMStQdU5sOE5BUlc4N21zOU9SZ2hiWEwrMURXNSs0VGUrS3p1NWJXVEFZNTdzWm5objRIY2tLYms3TStGSm1DRkg2TXMyWllzUzZXVjViekdMeFpRa1lGL1RFTmhaYmFZbkQ2dHFRU2M5Yy9QeTJRWElneVlOaUhyMXVqSnNXMTNBRmFWZ3JKKytveVNNZGlydEFlaWtjYi9zTDRmTzhuTHlzejYxMStvbFF1cStCdFRqU3FUaWFEellxeUpzenA0Q3pHQ3VxZHRFYzByWVhPdllSZ0hRblVZWmFyZ2tVeFZFMHY0Qi8xQlVuQUFBZU5wallHUmdZQUJpM2hOSHo4YnoyM3hsWUdaaEFJSEhBdk9lSU9qL3VrekhtQzRDdVJ3TVRDQlJBRW9KQzhzQWVOcGpZR1JnWUdiNHo4REF3SFNNUWVmL0JhWXNCcUFJQ21BQkFHVWNCRGdDeGdBQUFqb0FTd0k2QUN3Q0tBQXdBQUFBQUFCbUFOUUJRZ0FBZU5wallHUmdZR0JoY0dGZ1lnQUJSZ1kwQUFBSGpnQk5lTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQzBBQUFBMktNaUJBV2hvWldFQUFBSGNBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZndBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPTGRHOHNVNC9sdHZqSXdzekNBd0dPQmVVK1FhZWFKVERaQWlvT0JDY1FEQUI4dENYSUFBQUI0Mm1OZ1pHQmdWdnhqQkNRbk1oZ3l5REthTUFCRlVBQVRBRUVhQW00QUFBT1JBQUFCVVFBeEFBQUFBQUFnQUFCNDJtTmdaR0JnWUdMZ1p3RFJERkFTQ1FBQUFoUUFGUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktENkJuMmhvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRyWlB2cjd4L0RaZkdaaFpHRURnc2NDOEp3ajYvMTltTnFhN1FDNEhBeE5JRkFCQUN3dVRBSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjMuODg2NTkxLC0yMy45NDg4NTgpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4xNTI3OSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjMuODg2NTkxLC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIzLjg4NjU5MScgeT0nLTIzLjk0ODg1OCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTYuNDE0NTkyJyB5PSctMjcuNTY0MjIxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTguNjA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsMC4wLC04Ljg1OTczKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMi41MzEwNCwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xOS4yMjAwMDcnIHk9Jy0yNi45NTUzNzUnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMTUuMDU1MDM4JyB5PSctMjMuOTQ4ODU4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xMS45NDE2OTUnIHk9Jy0yMy45NDg4NTgnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTcuODA0NzQ0JyB5PSctMjMuOTQ4ODU4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjQ1OTMyLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0xNS44Mjk5ODMnIHk9Jy0yNy41NjQyMjEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjMuODg2NTkxLC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIzLjg4NjU5MScgeT0nLTIzLjk0ODg1OCc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOS43MDgzMyAwSDQ2LjQwMzc4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjY1Mzc4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjQuMzI1ODIsNC43ODQwMSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPs61PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0yMC4xMjI1NjknIHk9Jy0yMi45NTI1OTQnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtOC42MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCw1Ni45MDU1LC04Ljg1OTczKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0LTU2LjkwNTVINDcuODA2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMDU2NTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1Ljk2NCwtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00My45ODgzLDM3LjczODMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tMzEuOTMyNzUgNDEuMzMwNDdDMi4wNzYxMSA0Ni4zNzQ1MyAyOC42ODc5IDM1Ljg1ODAyIDQ5Ljc0OTg4IDkuMzE5MTgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC42MjE2MSwtMC43ODMyNiwwLjc4MzI2LDAuNjIxNjEsNDkuOTA1MjcsOS4xMjMzNyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTcuMDY2MzYsMzkuOTMxMjMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMS42Jz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC4zMDU1NC01MC41Mzc1OCcgZmlsbD0nbm9uZScvPgo8ZyBzdHJva2Utd2lkdGg9JzAuNic+CjxnIHN0cm9rZT0nI2ZmZic+CjxwYXRoIGQ9J00tNDEuMDgxMTggMzMuODI4NTdDLTQ2LjQ3NDQ5LTEuMTM0MzUtMzUuODg3Ni0yOC4zODUzLTguMzA1NTQtNTAuNTM3NTgnIGZpbGw9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMzLjc5NTIzLC0xMC4zNDY2NiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00tMzMuODI4MDggMzMuODI4NTdMLTkuMjc3MTYgOS4yODEwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE0LC0wLjcwNzA1LDAuNzA3MDUsMC43MDcxNCwtOS4xMDAzNyw5LjEwNDMxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTguMTExOTUsMjQuMTg5ODgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \SpliceDiagramSquare {
          ne = B',
          se = B,
          nw = A',
          nw/style = pullback,
          sw = A,
          east = g,
          east/style = {>->},
          west = f^{*}(g),
          west/style = {>->},
          south = f,
          north = \varepsilon _{g},
        }
        \node  [above left of = nw] (a) {$A$};
        \draw  [->,morphism,bend left] (a) to node {} (ne);
        \draw  [double,morphism,bend right] (a) to node {} (sw);
        \draw  [->,morphism,exists] (a) to node {} (nw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>This then corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\exists _{f}(\mathsf {id}_{A}) \to  g]]></fr:tex> under the adjunction <fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex>. Thus, we define <fr:tex
display="inline"><![CDATA[\mathsf {Img}]]></fr:tex> by the assignment <fr:tex
display="inline"><![CDATA[f \mapsto  \exists _{f}(\mathsf {id}_{A})]]></fr:tex>. This assignment can be trivially extended to a functor: since the category <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex> is a preorder, every morphism <fr:tex
display="inline"><![CDATA[f \to  f']]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex> has to be mapped to the unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f) \to  \mathsf {Img}(f')]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. This morphism must exist. Indeed, it is the lifting of <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)]]></fr:tex> against <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f')}]]></fr:tex> depicted in the following diagram.</fr:p>
    
      
      <fr:figure><fr:resource
hash="65873719b08cc2e6f763d49b27a8cbd5"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0Ni41NjI4NTlwdCcgaGVpZ2h0PScxMjAuNjgwNzU3cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTcuNzA4NTczIDgwLjQ1MzgzOCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUM0QUFBQTJLQXVBdW1ob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0aE5jaTYvSDg5dDhaV0JtWVFDQnh3THo3aUhvLzR4TWw1bEJYQTRHSmhBRkFEb2xDclVBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9nQUFvQUFBQUFCQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjFVMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM1WjJ4NVpnQUFBV1FBQUFEaUFBQUE1SXZLUWdSb1pXRmtBQUFDU0FBQUFDOEFBQUEyS0l5QXVXaG9aV0VBQUFKNEFBQUFIZ0FBQUNRR1F3Sk9hRzEwZUFBQUFwZ0FBQUFJQUFBQUNBWVFBSHRzYjJOaEFBQUNvQUFBQUFZQUFBQUdBSElBQUcxaGVIQUFBQUtvQUFBQUZ3QUFBQ0FBQkFCS2JtRnRaUUFBQXNBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTWFReE0vd0g4cGtoMGtocS9nT0ZBYkQ2RE1VQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZocC8vOUR5UCt6d1h3R0FGV2dCc0lBQUFCNDJoM0t5VTNEUUJpRzRmbG16RC9PNGhrN0hpOVliQmxITm9rSU9UaU1CVUsydUNFa0pEaHlvWUJJVkVBSkhHaUJMcWlBQ2lpQ0xsaUMzc3Q3ZUJqWTg4K1NmL0JQZHMwWWhBWkpCVWxWM2FGSk0wTXlQVVNIMXZWd2JVblYyZHBsemZiL1N6T0ZzcW9yMTFZcldFa2FqVXVOSkltdjgyQVFGWk9ycGIwVm1DY0xZUkt0NHYzWlRqVFppMFlQUVd6MG95SXY5NFB5L3ZqbWo2UUxnZkZCcU9NaUc0N3pwOEQ0d3NQTDkzdG5MK2RGdzJGUHJSVjFOQjFLY082U2Z2TzJ1UUFGWm9DNzZkRTZqRlllWmlkYlFyWHlPZkt3ZndYdGpnUVkrd1hVZVIySEFBQjQybU5nWkdCZ0FHTER4dVBHOGZ3Mlh4bVlXUmhBNExIQXZIc0krcjh1Y3dqVFpTQ1hnNEVKSkFvQUk4WUtsUUI0Mm1OZ1pHQmdadmpQQUNSREdLci9mMmM2eWdBVVFRRk1BR3NmQkpZQUFBTlVBQUFDdkFCN0FBQUFBQUJ5QUFCNDJtTmdaR0JnWUdMd1pBRFJERkFTQ1FBQUI3NEFUd0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXOTBuR050WVhBQUFBRTRBQUFBTXdBQUFFUUFld0VnWjJ4NVpnQUFBV3dBQUFGTUFBQUJqUE53SkpOb1pXRmtBQUFDdUFBQUFDOEFBQUEyS0VTQXIyaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR053SjFhRzEwZUFBQUF3Z0FBQUFRQUFBQUVBajlBTlpzYjJOaEFBQURHQUFBQUFvQUFBQUtBTlFBaUcxaGVIQUFBQU1rQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQXp3QUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TXVReWMvOEg4cG01R2RIVS9BY0tBd0REN3d6N2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VROEdkSVpjdi8vUjdEKzcvZy8rLzgwc0Zvd0FBRHNod3VWQUhqYVZWRExUc0pRRUoyWlcxb2dXQVNsRmR0VWFXTUxpQkI1dE1CVkVoY1NJeXBxNGtJa1NHVGpqeGcrRFJNU0VxSWY0dGFGNE1XTm1rbE96bU5tY1FZUVJnQXdwUWt3Z0kyRWs1ZyswK1NySVRRSXgxcVdLSTd2VUFJT0hRRFVQVWRXZEMybG9pSjdzbUpoVVBGMVRZeUt0dXU1ZmxCRXp3L2NXZ3NEWDI4aDAxYU80NjQyZFhFcDZ4YVdSZTZKSVJhcmNsT1NUSHk2MkcrRUdCWGlqOFpSM3ExS05KNk5HUm81SllGUzJxSGhaYkZ4L0xDME9XRXQ3d2owZTZQbW1zcG84RElncVJCZkwrSzhMU0VMNXc1UGgwUzd0T01taUNKaHpicmkzUzdmNU5zUnoyb2FCM1dSTWx1TExqNnd5Q3ZWSDNobHBxbGtzdGxNVmcyUkxDb0R3cDBvSHNNMzJCTkMvTU12b2V1cHFLZiswVXJLRjExRXhjQkNGcjFucXBRODQyWDhKYmZ0M25sVFR0NmM5RG1XRm5QTXB1MlF6VmkvOXZtWHpqclh4T3BiaGs5c0NOL3JyRDNyZU5wallHUmdZQUJpWTg5ZnVmSDhObDhabUZrWVFPQ3h3THg3Q1BxL1BqTVAwM0VnbDRPQkNTUUtBQ2krQ25vQWVOcGpZR1JnWU9iK3p3QWs0eG5rR0FTWmVSaUFJaWlBQlFBdXZ3RzBBQUFDVUFBQUFTNEFZd0lnQUI0RFh3QlZBQUFBQUFBT0FJZ0F4Z0FBZU5wallHUmdZR0JoOEdGZ1pnQUJSZ1kwQUFBSWJRQldlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSQUFBb0FBQUFBQk5nQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0YzL0dOdFlYQUFBQUU4QUFBQU1RQUFBRHdIRmYxMFoyeDVaZ0FBQVhBQUFBRjNBQUFCcUpWMkIydG9aV0ZrQUFBQzZBQUFBQzhBQUFBMkovNkF1V2hvWldFQUFBTVlBQUFBSUFBQUFDUUZuUUdhYUcxMGVBQUFBemdBQUFBTUFBQUFEQWNvQUh0c2IyTmhBQUFEUkFBQUFBZ0FBQUFJQUdZQTFHMWhlSEFBQUFOTUFBQUFHQUFBQUNBQUJnQkZibUZ0WlFBQUEyUUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUVOQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1TbUtjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1XOWxadmdQNURNek1JS0VHUkVxL2dPRkFmUWJEZkFBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZeGIvMy9IOGdIMC85bi8vRUZxd0lDQUtJRkNZY0FBQUI0MmtYUHUwN2NRQlRHOGZsbXpIalppOGQ3OFhqQllHZlg5Z3dYWlc5R050cEYzb1V0a0NCU2hDS0JxS0lVTlBzQ3ZBVVZCVzNhUEFjOTRoMVNScUpLR3pLckZEbkZLYzYvT1Q4Q2N2aytwQ3Y2U2hhRWdBbHcyNEhkVjdwRUpuM0piUm1oeEp6RlhPVitWcUl3OTRuMEhjUktxN3hRUXpoVUlNc2wxL2crZFMxM2UvTjB2RGNGRWs4eGlFZ0lrZlRZN2tCOENtbGJYQW5Qa1dmeC9na1FTOVBkVUloV0s2eFd0cit1TXg3L1BGODBGMGVkSlZOeCtJRW1YTmMyS2F4TDcrbjNEZXZidUxrTnRFcVQvd2xiNnVPRDFhK0FtS0ZrOVA0TGIzZ2hNN0lrcEhEZ2M5LzhQOG1MdkFpeHRnMWdZTVcvblVzL2hKRW9QVEJpSS9WTCtQbmFwcm1XY3pvRS81R2x3R3czeWo2ZnQ2eEtnKzY1NDlYMUhlaHh4R0pxUFg2clQzck5CUEJrTlo0MnJ1NFpUZFdzM2h1QmxUdUh0YkNiZHJyZDRjOWczajRJcXBRR29RMEV1cTRzWEV4SFp5MmswZUlMd0IzdXVZMDJ0VHRWakEvNmJhY0NORG83TlZqcGhxa1dxS0g5Qlk2dE5WZ0FlTnBqWUdSZ1lBQmkvaWl6eC9IOE5sOFptRmtZUU9DeHdMeDdDUHEvUHRNeHBvdEFMZ2NERTBnVUFDRTNDdHdBZU5wallHUmdZR2I0ejhEQXdIU013ZUQvQmFZc0JxQUlDbUFHQUdWM0JEc0N4Z0FBQWpvQVN3SW9BREFBQUFBQUFHWUExSGphWTJCa1lHQmdabkJoWUdJQUFVWUdOQUFBQjNNQVRIamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b0NDeGRXRmdZbVhxQXRoRkdXd2pKMFJDcWpyMmQvZGhQUFFOVitkKzJFRE5Ed1gzSzVnbHZWOUpKZTdCRlZQbW1TZmkzakxYTEhqbmlhSjhsdVNWajh5bE5KK1pLMTc0eWp5Ui9EdHp6WXJmVFhDWDYyQ2oyZ1Zqb3o4NTE2MzNOdlpkOEdxcG0rUzMxdHQ0R0t4Ung1c3lZOWVQWjZkYTNlaVdEUUhIaFNzRGxvaGlKNGxKN0RsSjUraFlzMDlKTHh3a1Z5elJOUC82cmZRK2JRN3BKeU9iSXpkUnd5aUxYdlFzVzBXYlhtcmFQOHVoTC9jQUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUEvUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMG1tTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM4QUFBQTBFOE96SDFvWldGa0FBQUNJQUFBQUM0QUFBQTJLSXFBdVdob1pXRUFBQUpRQUFBQUhnQUFBQ1FGTEFLNGFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dYZkFKcHNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEWUFhRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFnYm1GdFpRQUFBcHdBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNm1HY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFkSWxETTBBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pKajFuNEh4T0RNRGd4d0RBeU1mSXp1YnVCZ1lpckFwcWVzeHFxdXBtNW5iTVpxYkdZbUpzakVlQ1dwbFpWYmk0Tkt0NEdCa2szSlU5Rkt3WldHeFZmQlNkSlJpWTJSNmJ2WjFUMnlsaEhoVktnc1hDNWVKYkpSdHdZb1ZoYmFSc2laY0xKd01RTURJa0F5MGF3TFFMbWtnaDQwZFpKdWFQcU1KMkFJaE5YVTFJRU5jamxGY2pIRUMxRlJtSmxiMWNEVlR4clJpZG1abWlJV01EQkF6R1ZrNU9GaGtrOE9hR0tWK3gzSnpzektDTFFRQUVhTWpqM2phWTJCa1lHQUE0djNLVDViSDg5dDhaV0JtWVFDQnh3THo3aUhvL3d6TVFjd2dMZ2NERTRnQ0FEbDZDbFVBQUhqYVkyQmtZR0JtK004QUpJTVlraG1TR1k4ekFFVlFBQk1BUnNrQzZnQUFBMUlBQUFJcUFKb0FZd0FBQUFBQUFBQTJBR2g0Mm1OZ1pHQmdZR2FRWndEUkRGQVNDUUFBQTc4QUpnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVxZm01dURrNnZEMjZ3SjBxR3BwTFhvSXY1MGIwUHdCZzdmUGVmY0FCa3ZFb1pKbUFjZEpwVTNqenptaDBYa2lmaXJ5Qm0vckJtUnBETnhWdXdpcDB6NWp6eG1TUmw1SXY0amNzWWY3MzFUMys2ZDllcllHT3ZkcGZiYmsvVnQxVGkxMGZtd0hxeXovdHhabzhxbk1uM1Y5dGRhRlRyWEJYc2FhbTdjNmJCNEZFZHhUR0RIUlRMUGxsUFlXeXJKbkhRMmFQSnZlcERVaGNZNS9HS2tVZklVTmZSeTA0cGVwYXNvd3AybStBQlZNaTVEQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1JQUFvQUFBQUFBMmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEeGloR050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCRUFBQUFSQjVhakhkb1pXRmtBQUFCc0FBQUFDMEFBQUEyS1l5QTlXaG9aV0VBQUFIZ0FBQUFId0FBQUNRRkJnRFphRzEwZUFBQUFnQUFBQUFJQUFBQUNBWVlBRjlzYjJOaEFBQUNDQUFBQUFZQUFBQUdBQ0lBQUcxaGVIQUFBQUlRQUFBQUZ3QUFBQ0FBQkFBU2JtRnRaUUFBQWlnQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBQytBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpxMC9sZ3dNekZyTXg0SENqQWdWLy84ek1BQUErd01QZndCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFGOEFKd0Y3QWp3QUVBQUFBUU1HSXljbUp6Y1RQZ0UzTWhZWEJnY0JjZFFHREJZVEF3U2VBeGtlR1NZQkFRUUIzUDVjRVFjSERSQUJ1dzRnQVNBY0RBd0FlTnBqWUdSZ1lBQmk5czBMSE9QNWJiNHlNTE13Z01CamdYbjNrR21XVUNZYklNWEJ3QVRpQVFBSHRRakRBQUFBZU5wallHUmdZTmI2WThuQXdCTEtFTS9nd1ZqTkFCUkJBVXdBU2lnQzR3QUVWUUFBQWNNQVh3QUFBQUFBSWdBQWVOcGpZR1JnWUdCaUVHUUEwUXhRRWdrQUFBSkdBQmNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS01pQTlXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZEc4c3M0L2x0dmpJd3N6Q0F3R09CZWZlUWFlYUpURFpBaW9PQkNjUURBQ0loQ1g0QUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDArMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNWWjJ4NVpnQUFBV1FBQUFGTEFBQUJZRG1Tc1RKb1pXRmtBQUFDc0FBQUFDOEFBQUEyS0Q2QmsyaG9aV0VBQUFMZ0FBQUFIZ0FBQUNRR0xBSU9hRzEwZUFBQUF3QUFBQUFNQUFBQURBaCtBRTlzYjJOaEFBQUREQUFBQUFnQUFBQUlBRlFBc0cxaGVIQUFBQU1VQUFBQUZnQUFBQ0FBQndBNmJtRnRaUUFBQXl3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaVp2Z1A1RE5EcEpIVS9BY0tBd0R5S1ExSGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoTy8vOERTY2YvLy84ZkFQTVpBRktvQnA1NDJqV1BNVS9DUUFDRjc5M0JIV0RiUTF2YUdBRlRRWnBvRkVOSkt3d01LbWcwRXBURU1KQ1ltQ2liZzBGY0dSaDFNakZ4Y25IekI3ZzRPZmtuSEl5anZ3R3dOZkZOTDEvZThEMUNTWDQ2cFYvMGt4UkppUkFmbmw4eUxkMHdYYy9rUlFpbjRKUTl5L1Q4SW16QkRkUHlMQTBCRDdGYmcrK3lWNXh6UStXb21Xc3BLTkgrTUJhRk9xT1hXVnhNcGswMXJhc01hclRYVWFERWwycVBQL2FBbmlRUmwrT2hLVmxHZ0RIUW1CU0FZbDNVUjBZK0NTbzFIdUtFNU1oOTRKZ0VZV1IxT21hY3ZwRXNXU0diZ2FsZXpqazhjTE96U0drUVdWaGNnZ3ViLy9ucW9aeFhjSElGTHRoL1o4SEFmYjViY0RKU290TTlZOFAyUVJ0ME4zbDRQYmxQYTFvMSsvUncycWRZM3g0dDZ0SEwyKzZBMG8yOTkwWUUwRnEwTWt0WldvQWVWZmQ3TXRHc0hHeHB0VWo0QURycTdLcVIzNkdROCtNWGR0TmNickhKOXh4UGtGK3p2VHVEQUhqYVkyQmtZR0FBNHJaUHZxbngvRFpmR1poWkdFRGdzY0M4ZXdqNi8xOW1OcWE3UUM0SEF4TklGQUJDL3d1ZkFIamFZMkJrWUdCbStNOEFKRGtZVkJpWW1Oa1lnQ0lvZ0JrQUk4Y0JRZ0FBQW5ZQUFBTUFBQ1FEQ0FBckFBQUFBQUJVQUxCNDJtTmdaR0JnWUdhd0JHSVFZR1JBQXdBR2R3QkNBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY4IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi41NzcwMTIsLTYwLjU2NjQ3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01NS4xMDUwMTMnIHk9Jy02NC4xODE4MzQnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MC41NjY0NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjQ1OTMyLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYwLjU2NjQ3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy02MC41NjY0Nyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTQuNTIwNDA0JyB5PSctNjQuMTgxODM0Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINDYuNDAzNzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNjUzNzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNS44ODg2Nyw1LjkwMDcxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MC41NjY0NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNjIuNTc3MDEyJyB5PSctNjAuNTY2NDcnPs61PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01OC44MTI5OScgeT0nLTU4LjczNDQyNyc+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjgnIHg9Jy01MC40MTk5MDQnIHk9Jy01OC43MzQ0MjcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTQ3LjcyMTY0OScgeT0nLTU4LjczNDQyNyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDMuNzI2MTc5JyB5PSctNjAuMjAxMTU2Jz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTQxLjAzMTQwNCcgeT0nLTU4LjczNDQyNyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS04LjYwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTUwLjgyNjY3MycgeT0nLTYwLjU2NjQ3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny43MTMzMycgeT0nLTYwLjU2NjQ3Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00My4wNDY3NDYnIHk9Jy02My41NzI5ODcnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNDAuMzUxOTcxJyB5PSctNjAuNTY2NDcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjUwNTU0LTU2LjkwNTVINDcuODA2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTAuNzU1NTQsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNi45NDE3OSwtNjQuOTY3MzIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYwLjU2NjQ3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Mi41NzcwMTInIHk9Jy02MC41NjY0Nyc+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy01MC44MjY2NzMnIHk9Jy02MC41NjY0Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuNzEzMzMnIHk9Jy02MC41NjY0Nyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNDMuMDQ2NzQ2JyB5PSctNjAuNTY2NDcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J004LjIzODEzLTQ4LjY2MjQ2TDUwLjE0NTkyLTYuNzYzMjMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNywwLjcwNzAyLC0wLjcwNzAyLDAuNzA3MTcsNTAuMzIyNzEsLTYuNTg2NDkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \SpliceDiagramSquare {
          nw = A',
          nw/style = pullback,
          sw = A,
          ne = B',
          se = B,
          north = \varepsilon _{\mathsf {Img}(f')},
          east = \mathsf {Img}(f'),
          east/style = {>->},
          south = \mathsf {Img}(f),
          south/style = {>->},
        }
        \draw  [->,morphism,exists] (sw) to (ne);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>We can now extract the components of the unit and the counit from this correspondence.</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
      
  <html:tr>
        
  <html:th>Unit (<fr:tex
display="inline"><![CDATA[\vartheta ]]></fr:tex>)</html:th>

        
  <html:th>Counit (<fr:tex
display="inline"><![CDATA[\zeta ]]></fr:tex>)</html:th>

      </html:tr>

      
  <html:tr>
        
  <html:td>
          <fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be an object in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. The identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}\colon \mathsf {Img}(f)\to \mathsf {Img}(f)]]></fr:tex> is, by definition, the identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}\colon \exists _{f}(\mathsf {id}_{A})\to \mathsf {Img}(f)]]></fr:tex>, which corresponds to the unit <fr:tex
display="inline"><![CDATA[\eta _{\mathsf {id}_{A}}\colon \mathsf {id}_{A}\to f^{*}(\mathsf {Img}(f))]]></fr:tex> of the adjunction <html:span
style="white-space: nowrap"><fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex></html:span>.</fr:p>
          <fr:p>Then since <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)]]></fr:tex> is monic, <fr:tex
display="inline"><![CDATA[\eta _{\mathsf {id}_{A}}]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f)}\eta _{\mathsf {id}_{A}}\colon f\to \mathsf {Img}(f)]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> is the counit of the adjunction <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex>. This defines the component of <fr:tex
display="inline"><![CDATA[\vartheta ]]></fr:tex> at <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. This is precisely the lifting of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> against <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f)}]]></fr:tex>.</fr:p>
          
    
      
      <fr:figure><fr:resource
hash="7e883808b7d5854b7864b81c7cbb3522"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0Mi41MjA3MjdwdCcgaGVpZ2h0PScxMTguNzcxMjE4cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTUuMDEzODE4IDc5LjE4MDgxMic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUM0QUFBQTJLQXVBeEdob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0aE5jaXcvSDg5dDhaV0JtWVFDQnh3THpIaVBvLzR4TWw1bEJYQTRHSmhBRkFEZXZDcXNBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9nQUFvQUFBQUFCQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjFVMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM1WjJ4NVpnQUFBV1FBQUFEaUFBQUE1SXZLUWdSb1pXRmtBQUFDU0FBQUFDOEFBQUEyS0l5QXcyaG9aV0VBQUFKNEFBQUFIZ0FBQUNRR1F3Sk9hRzEwZUFBQUFwZ0FBQUFJQUFBQUNBWVFBSHRzYjJOaEFBQUNvQUFBQUFZQUFBQUdBSElBQUcxaGVIQUFBQUtvQUFBQUZ3QUFBQ0FBQkFCS2JtRnRaUUFBQXNBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTWFReE0vd0g4cGtoMGtocS9nT0ZBYkQ2RE1VQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZocC8vOUR5UCt6d1h3R0FGV2dCc0lBQUFCNDJoM0t5VTNEUUJpRzRmbG16RC9PNGhrN0hpOVliQmxITm9rSU9UaU1CVUsydUNFa0pEaHlvWUJJVkVBSkhHaUJMcWlBQ2lpQ0xsaUMzc3Q3ZUJqWTg4K1NmL0JQZHMwWWhBWkpCVWxWM2FGSk0wTXlQVVNIMXZWd2JVblYyZHBsemZiL1N6T0ZzcW9yMTFZcldFa2FqVXVOSkltdjgyQVFGWk9ycGIwVm1DY0xZUkt0NHYzWlRqVFppMFlQUVd6MG95SXY5NFB5L3ZqbWo2UUxnZkZCcU9NaUc0N3pwOEQ0d3NQTDkzdG5MK2RGdzJGUHJSVjFOQjFLY082U2Z2TzJ1UUFGWm9DNzZkRTZqRlllWmlkYlFyWHlPZkt3ZndYdGpnUVkrd1hVZVIySEFBQjQybU5nWkdCZ0FHTER4dVB5OGZ3Mlh4bVlXUmhBNExIQXZNY0krcjh1Y3dqVFpTQ1hnNEVKSkFvQUlWQUtpd0I0Mm1OZ1pHQmdadmpQQUNSREdLci9mMmM2eWdBVVFRRk1BR3NmQkpZQUFBTlVBQUFDdkFCN0FBQUFBQUJ5QUFCNDJtTmdaR0JnWUdMd1pBRFJERkFTQ1FBQUI3NEFUd0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktENkJuV2hvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRyWlB2b0h4L0RaZkdaaFpHRURnc2NDOHh3ajYvMTltTnFhN1FDNEhBeE5JRkFCQWlRdVZBSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBL1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBtbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDOEFBQUEwRThPekgxb1pXRmtBQUFDSUFBQUFDNEFBQUEyS0lxQXcyaG9aV0VBQUFKUUFBQUFIZ0FBQUNRRkxBSzRhRzEwZUFBQUFuQUFBQUFLQUFBQUNnWGZBSnBzYjJOaEFBQUNmQUFBQUFnQUFBQUlBRFlBYUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBZ2JtRnRaUUFBQXB3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBZElsRE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaSmoxbjRIeE9ETURneHdEQXlNZkl6dWJ1QmdZaXJBcHFlc3hxcXVwbTVuYk1acWJHWW1Kc2pFZUNXcGxaVmJpNE5LdDRHQmtrM0pVOUZLd1pXR3hWZkJTZEpSaVkyUjZidloxVDJ5bGhIaFZLZ3NYQzVlSmJKUnR3WW9WaGJhUnNpWmNMSndNUU1ESWtBeTBhd0xRTG1rZ2g0MGRaSnVhUHFNSjJBSWhOWFUxSUVOY2psRmNqSEVDMUZSbUpsYjFjRFZUeHJSaWRtWm1pSVdNREJBekdWazVPRmhrazhPYUdLVit4M0p6c3pLQ0xRUUFFYU1qajNqYVkyQmtZR0FBNHYzS1R5Ykg4OXQ4WldCbVlRQ0J4d0x6SGlQby93ek1RY3dnTGdjREU0Z0NBRGNFQ2tzQUFIamFZMkJrWUdCbStNOEFKSU1Za2htU0dZOHpBRVZRQUJNQVJza0M2Z0FBQTFJQUFBSXFBSm9BWXdBQUFBQUFBQUEyQUdoNDJtTmdaR0JnWUdhUVp3RFJERkFTQ1FBQUE3OEFKZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQzBBQUFBMktNaUEvMmhvWldFQUFBSGNBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZndBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPTGRHOHRVNC9sdHZqSXdzekNBd0dPQmVZK1JhZWFKVERaQWlvT0JDY1FEQUIrckNYUUFBQUI0Mm1OZ1pHQmdWdnhqQkNRbk1oZ3l5REthTUFCRlVBQVRBRUVhQW00QUFBT1JBQUFCVVFBeEFBQUFBQUFnQUFCNDJtTmdaR0JnWUdMZ1p3RFJERkFTQ1FBQUFoUUFGUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXOTBuR050WVhBQUFBRTRBQUFBTXdBQUFFUUFld0VnWjJ4NVpnQUFBV3dBQUFGTUFBQUJqUE53SkpOb1pXRmtBQUFDdUFBQUFDOEFBQUEyS0VTQXVXaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR053SjFhRzEwZUFBQUF3Z0FBQUFRQUFBQUVBajlBTlpzYjJOaEFBQURHQUFBQUFvQUFBQUtBTlFBaUcxaGVIQUFBQU1rQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQXp3QUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TXVReWMvOEg4cG01R2RIVS9BY0tBd0REN3d6N2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VROEdkSVpjdi8vUjdEKzcvZy8rLzgwc0Zvd0FBRHNod3VWQUhqYVZWRExUc0pRRUoyWlcxb2dXQVNsRmR0VWFXTUxpQkI1dE1CVkVoY1NJeXBxNGtJa1NHVGpqeGcrRFJNU0VxSWY0dGFGNE1XTm1rbE96bU5tY1FZUVJnQXdwUWt3Z0kyRWs1ZyswK1NySVRRSXgxcVdLSTd2VUFJT0hRRFVQVWRXZEMybG9pSjdzbUpoVVBGMVRZeUt0dXU1ZmxCRXp3L2NXZ3NEWDI4aDAxYU80NjQyZFhFcDZ4YVdSZTZKSVJhcmNsT1NUSHk2MkcrRUdCWGlqOFpSM3ExS05KNk5HUm81SllGUzJxSGhaYkZ4L0xDME9XRXQ3d2owZTZQbW1zcG84RElncVJCZkwrSzhMU0VMNXc1UGgwUzd0T01taUNKaHpicmkzUzdmNU5zUnoyb2FCM1dSTWx1TExqNnd5Q3ZWSDNobHBxbGtzdGxNVmcyUkxDb0R3cDBvSHNNMzJCTkMvTU12b2V1cHFLZiswVXJLRjExRXhjQkNGcjFucXBRODQyWDhKYmZ0M25sVFR0NmM5RG1XRm5QTXB1MlF6VmkvOXZtWHpqclh4T3BiaGs5c0NOL3JyRDNyZU5wallHUmdZQUJpWTg5ZmtmSDhObDhabUZrWVFPQ3h3THpIQ1BxL1BqTVAwM0VnbDRPQkNTUUtBQ1pJQ25BQWVOcGpZR1JnWU9iK3p3QWs0eG5rR0FTWmVSaUFJaWlBQlFBdXZ3RzBBQUFDVUFBQUFTNEFZd0lnQUI0RFh3QlZBQUFBQUFBT0FJZ0F4Z0FBZU5wallHUmdZR0JoOEdGZ1pnQUJSZ1kwQUFBSWJRQldlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVY0FBb0FBQUFBQmZnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0TUdOdFlYQUFBQUU4QUFBQU13QUFBRVFEeVFTaFoyeDVaZ0FBQVhBQUFBSkpBQUFDdUhOeUdvWm9aV0ZrQUFBRHZBQUFBQzhBQUFBMkovNkF3MmhvWldFQUFBUHNBQUFBSUFBQUFDUUZ3Z0diYUcxMGVBQUFCQXdBQUFBUUFBQUFFQW5xQUt0c2IyTmhBQUFFSEFBQUFBb0FBQUFLQWNJQTFHMWhlSEFBQUFRb0FBQUFHQUFBQUNBQUJ3QllibUZ0WlFBQUJFQUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZFQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbUtjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1WOWtadmdQNURNek1JS0VHUkVxL2dPRkFRQU9EaVFBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnTWdEUUhFSUxrMHBpM01sLzgveC9CK2ovN2orOGZJN0JhTUFBQURIc01hZ0I0MmtXUlAyL1RRQmpHL1p5ZGMrSWtQamUyejJtY09rMGMyNldVcEhGU0d5WEJTVk1CL1FNdEZTZ1ZRbXBWcEM0ZEVBdmlXOERTZ1pXVno4R08rQTZNU0V4ZEtaY2l4SjEwdy92b3BQZjMvQ1JJQnpkZGNrbStTMU5KZ3N4QVZSMXFLNHd5OUxuRHFjb2J5RENSZlJvbVRqOURLdVl4ZDNUNFlSUW1hZGlGVGhqNkNhY1JQZzhOeGFnVnRudHJRNkJ0aHpKWWd6SFdic29ySGZiRUl5WTdacmJPWi82ZE1lQnprUnNlWTVXS3ArVnJaNHNZVjcrLzdpOU5COWFPSFByZUttblRxRmdnVUE3c1Q5Y25ja3ZGeVVzM0NvUDIvd2pMNGIwUFNpc1BTUndpYmQ3OHhDOThrMGJTamlTbE9oenFpUDNqSkUxU0R3dTJEZ1JZK3ZkTnVPTkJrSVJSUnhBTFVpZURreXpZSWhyeENlbUNmdWtId0dpbDBUOTZYRkh5WmJKbTlDN25GeUQzRzdKUGxLdnpVdHhjYWdNMjEveGgrZmk5VElKd1ZHcHVRczdxZDR0ZU5iQ3ExZTRQZDJLdXV4b2hycWNDYmxRS0Zld1BOMmNWQkkzcGM0RHExRGJLSmxFdERiMzFscW5uZ2JKVkwwSUpjaUpWUVA2eFhaT1B3dE9lTkJlbUhHNnBFVlZ2YnhnbEV6blpHb1NSVUtlaml3NFM0VWtnT3hhVHFVMjVFOThPaEsyRjJGU0lkYmdxNUlwaWJqK0pramladDV4eTN4MVczWWZ6OFJtQlpqS1ZNTk5yRlhPcVZxVGdyQlI1R3hNb1RIVnlaRFh4SHpUcjdWSTJ6Zzl6NVBYc2thZm11RmozdENyRERlS25ST25WQm5pcmtxcVN2emdQdkdjS0JydStmelJhS2VoMkhaaDJyQ0lJTVhicWZCVVliR2hMMjh1bk5iTzJSYkpSL0c1Z0JIVHRjTytOckl4TCtteGMyQTFldklvUGlYdzYzbTRhTlZISEg2TE9XRVlBQUFCNDJtTmdaR0JnQU9MQTRoK3A4ZncyWHhtWVdSaEE0TEhBdk1jSStyOCswekdtaTBBdUJ3TVRTQlFBUG93TGhRQjQybU5nWkdCZ1p2alB3TURBZEl6QjRQOEZwbjRHb0FnS1lBRUFhRGNFWVFMR0FBQUNPZ0JMQWlnQU1BTENBREFBQUFBQUFHWUExQUZjQUFCNDJtTmdaR0JnWUdFSVoyQmlBQUZHQmpRQUFBbHBBR0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNyB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4xNTI3OSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjA2NDYwMic+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTUuMTA1MDEzJyB5PSctNjQuNjc5OTY2Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuMDY0NjAyJz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjA2NDYwMic+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTQuNTIwNDA0JyB5PSctNjQuNjc5OTY2Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg0Ni40MDM3OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni42NTM3OCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE3LjI0MTEyLDUuNDAwNzEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctNjEuMDY0NjAyJz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTguODEyOTknIHk9Jy01OS43MzA3MDcnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNTAuNDE5OTA0JyB5PSctNTkuNzMwNzA3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny43MjE2NDknIHk9Jy01OS43MzA3MDcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTQzLjcyNjE3OScgeT0nLTU5LjczMDcwNyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS04LjYwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTAuODI2NjczJyB5PSctNjEuMDY0NjAyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny43MTMzMycgeT0nLTYxLjA2NDYwMic+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNDMuMDQ2NzQ2JyB5PSctNjEuMDY0NjAyJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0LTU2LjkwNTVINDcuODA2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMDU2NTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1Ljk2NCwtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctNjEuMDY0NjAyJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzMuMCwyLjAnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNOC4yMzgxMy00OC42NjI0Nkw1MC4xNDU5Mi02Ljc2MzIzJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTcsMC43MDcwMiwtMC43MDcwMiwwLjcwNzE3LDUwLjMyMjcxLC02LjU4NjQ5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00yMS42OTkxLTM0LjMxOTQzSDM3LjAzODUyVi0yMS40MjUwMkgyMS42OTkxWicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjQuNjk5MSwtMjkuMjg2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPs+RPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01Ny43NjYwNzEnIHk9Jy02MC4wMDc0NTUnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                nw = A',
                nw/style = pullback,
                sw = A,
                ne = B',
                se = B,
                north = \varepsilon _{\mathsf {Img}(f)},
                east = \mathsf {Img}(f),
                east/style = {>->},
                south = f,
              }
              \draw  [->,morphism,exists] (sw) to node[desc] {$\vartheta _{f}$} (ne);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
        </html:td>

        
  <html:td>
          <fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A\rightarrowtail B]]></fr:tex> be an object in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. Then the identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}_{f}\colon f\to f]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[s\colon \mathsf {id}_{A}\to f^{*}(f)]]></fr:tex> by the universal property of pullbacks.</fr:p>
          <fr:p>This morphism corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\exists _{f}(\mathsf {id}_{A}) \to  f]]></fr:tex> under the adjunction <fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex>, which we take as the component of <fr:tex
display="inline"><![CDATA[\zeta ]]></fr:tex> at <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p>
        </html:td>

      </html:tr>

    </html:table>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>621</fr:anchor><fr:addr
type="machine">#277</fr:addr><fr:route>unstable-277.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has images, then we may define <fr:tex
display="inline"><![CDATA[\exists _{f}\colon \mathsf {Sub}(A)\to \mathsf {Sub}(B)]]></fr:tex> as the following composite:</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Sub}(A) \hookrightarrow  {{\mathcal {C}}_{/{A}}} \xrightarrow {\Sigma _{f}} {{\mathcal {C}}_{/{B}}} \xrightarrow {\mathsf {Img}} \mathsf {Sub}(B)     ]]></fr:tex><fr:p>Let <fr:tex
display="inline"><![CDATA[i_{A}\colon \mathsf {Sub}(A)\hookrightarrow {{\mathcal {C}}_{/{A}}}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[i_{B}\colon \mathsf {Sub}(B)\hookrightarrow {{\mathcal {C}}_{/{B}}}]]></fr:tex> be the inclusion functors. Note that</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Img}\Sigma _{f} \dashv  f^{*}i_{B}     ]]></fr:tex><fr:p>Since <fr:tex
display="inline"><![CDATA[f^{*}i_{B} \cong  i_{A}f^{*}]]></fr:tex> by construction, we have</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Img}\Sigma _{f} \dashv  i_{A}f^{*}     ]]></fr:tex><fr:p>Let <fr:tex
display="inline"><![CDATA[\eta ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> be the unit and counit of this adjunction respectively. Since <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> is a full subcategory of <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>, there is a natural isomorphism <fr:tex
display="inline"><![CDATA[\iota \colon \mathsf {id}_{{{\mathcal {C}}_{/{A}}}}\stackrel {\sim }{\smash {\longrightarrow }\rule {0pt}{0.4ex}}i_{A}]]></fr:tex>. Then we can define <fr:tex
display="inline"><![CDATA[\eta ']]></fr:tex> as follows:</fr:p><fr:tex
display="block"><![CDATA[       \eta ' := \mathsf {id}_{{{\mathcal {C}}_{/{A}}}} \xrightarrow {\eta } i_{A}f^{*}\mathsf {Img}\Sigma _{f}       \xrightarrow {\iota _{f^{*}\mathsf {Img}\Sigma _{f}}} f^{*}\mathsf {Img}\Sigma _{f}       \xrightarrow {f^{*}\mathsf {Img}\Sigma _{f}(\iota )} f^{*}\mathsf {Img}\Sigma _{f}i_{A}     ]]></fr:tex><fr:p>Then <fr:tex
display="inline"><![CDATA[\eta ']]></fr:tex> and <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> form the unit and counit of the adjunction <fr:tex
display="inline"><![CDATA[\mathsf {Img}\Sigma _{f}i_{A} \dashv  f^{*}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1343</fr:anchor><fr:addr
type="user">fnd-0008</fr:addr><fr:route>fnd-0008.xml</fr:route><fr:title
text="Regular category">Regular category</fr:title><fr:taxon>Section</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="frankndrssn.xml"
addr="frankndrssn"
title="Frank Tsai">Frank Tsai</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>616</fr:anchor><fr:addr
type="user">ct-000K</fr:addr><fr:route>ct-000K.xml</fr:route><fr:title
text="Image">Image</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is said to have <fr:em><fr:strong>images</fr:strong></fr:em> if the inclusion functor <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A) \hookrightarrow  {{\mathcal {C}}_{/{A}}}]]></fr:tex> admits a left adjoint <fr:tex
display="inline"><![CDATA[\mathsf {Img}\colon {{\mathcal {C}}_{/{A}}}\to \mathsf {Sub}(A)]]></fr:tex> for all objects <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>617</fr:anchor><fr:addr
type="user">ct-000O</fr:addr><fr:route>ct-000O.xml</fr:route><fr:title
text="Regular category">Regular category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is said to be <fr:em><fr:strong>regular</fr:strong></fr:em> if it is cartesian, has <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">images</fr:link>, and <fr:link
type="local"
href="ct-000M.xml"
addr="ct-000M"
title="Extremal epimorphism">covers</fr:link> are stable under pullback.
  A functor <fr:tex
display="inline"><![CDATA[F\colon \mathcal {C}\to \mathcal {D}]]></fr:tex> between regular categories is said to be <fr:em><fr:strong>regular</fr:strong></fr:em> if it is cartesian and preserves covers.
  Note that since cartesian functors preserve monomorphisms, every regular functor automatically preserves images.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>472</fr:anchor><fr:addr
type="machine">#274</fr:addr><fr:route>unstable-274.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[F\colon \mathcal {C}\to \mathcal {D}]]></fr:tex> be a regular functor and <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be a morphism in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
    By <fr:ref
addr="ct-000Q"
href="ct-000Q.xml"
taxon="Lemma" />, <fr:tex
display="inline"><![CDATA[f]]></fr:tex> admits a cover-mono factorization <fr:tex
display="inline"><![CDATA[f = \mathsf {Img}(f)\vartheta _{f}]]></fr:tex>.
    Then since <fr:tex
display="inline"><![CDATA[F]]></fr:tex> preserves monomorphisms and covers, <fr:tex
display="inline"><![CDATA[F(\mathsf {Img}(f))F(\vartheta _{f})]]></fr:tex> forms a cover-mono factorization of <fr:tex
display="inline"><![CDATA[F(f)]]></fr:tex>.
    Then by uniqueness, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(Ff) \cong  F(\mathsf {Img}(f))]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>618</fr:anchor><fr:addr
type="user">ct-000L</fr:addr><fr:route>ct-000L.xml</fr:route><fr:title
text="Equivalent condition for the existence of images">Equivalent condition for the existence of <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">images</fr:link></fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with pullbacks. Then <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has images iff for each morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex>, the pullback functor <fr:tex
display="inline"><![CDATA[f^{*}\colon \mathsf {Sub}(B)\to \mathsf {Sub}(A)]]></fr:tex> admits a left adjoint <fr:tex
display="inline"><![CDATA[\exists _{f}\colon \mathsf {Sub}(A)\to \mathsf {Sub}(B)]]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>619</fr:anchor><fr:addr
type="machine">#278</fr:addr><fr:route>unstable-278.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By <fr:ref
addr="ct-000J"
href="ct-000J.xml"
taxon="Lemma" />, the pullback functor <fr:tex
display="inline"><![CDATA[f^{*}\colon {{\mathcal {C}}_{/{B}}}\to {{\mathcal {C}}_{/{A}}}]]></fr:tex> admits <fr:tex
display="inline"><![CDATA[\Sigma _{f}\colon {{\mathcal {C}}_{/{A}}}\to {{\mathcal {C}}_{/{B}}}]]></fr:tex> as a left adjoint.</fr:p>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>620</fr:anchor><fr:addr
type="machine">#276</fr:addr><fr:route>unstable-276.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[g\colon B'\rightarrowtail B]]></fr:tex> be an arbitrary object in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. We need to construct a functor <fr:tex
display="inline"><![CDATA[\mathsf {Img}\colon {{\mathcal {C}}_{/{B}}}\to \mathsf {Sub}(B)]]></fr:tex> so that each morphism <fr:tex
display="inline"><![CDATA[f \to  g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f) \to  g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[f \to  g]]></fr:tex> be an arbitrary morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. Then this corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A} \to  f^{*}(g)]]></fr:tex> as follows:</fr:p>
    
      
      <fr:figure><fr:resource
hash="b9735f1b362427f7dc4b29962af32897"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3Mi43OTYzMzlwdCcgaGVpZ2h0PScxNzQuNDQ0ODM3cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE1LjE5NzU1OSAxMTYuMjk2NTU4Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLSXgvdG1ob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0o1cHo5dGplZTMrY3JBek1JQUFvOEY1ajFCMFA5MW1FTVlqd0s1SEF4TUlGRUFZZmNMOVFCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0F1QXhtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhOY2kvZkg4OXQ4WldCbVlRQ0J4d0x6bmlEby80eE1sNWxCWEE0R0poQUZBRGN4Q3FrQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQzBBQUFBMktZeUFvV2hvWldFQUFBSkFBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbUFBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDYUFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKd0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGkyaE1KSCtQNWJiNHlNTE13Z01CamdYbFBrR21XVU1ZN1FJcURnUW5FQXdBN0VncHBBQUFBZU5wallHUmdZTmI2WThuQXdCTEswTWZRejVUTUFCUkJBVXdBVW9BRFFnQUVWUUFBQXZJQWpnQUFBQUFBVkFBQWVOcGpZR1JnWUdCaU1HVUEwUXhRRWdrQUFBWEtBRHNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVR3QUFvQUFBQUFCYndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjM4bU50WVhBQUFBRThBQUFBTWdBQUFEd0hGZjEyWjJ4NVpnQUFBWEFBQUFJZUFBQUNoQkxGdkVab1pXRmtBQUFEa0FBQUFDOEFBQUEySi82QXcyaG9aV0VBQUFQQUFBQUFJQUFBQUNRRm1RR2JhRzEwZUFBQUErQUFBQUFRQUFBQUVBbGlBS2RzYjJOaEFBQUQ4QUFBQUFvQUFBQUtBYWdBMUcxaGVIQUFBQVA4QUFBQUdBQUFBQ0FBQndCRmJtRnRaUUFBQkJRQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRTVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWltQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVc5bFp2Z1A1RE16TUlLRUdSRXEvZ09GQWZCNURlWUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5cVl6Yi8zL0g4aFBBOUgvWi8veEE2c0NBZ0NpSndtSkFBQjQya1hSUFcvVFFCd0djRDkzN2psdjl0bXhmVzZUMUhseGJJZlN4bW5jT2lpdDh0SldRbTBScFVLaUtrSWdoaTZka0JoQWZBZ0cxSUdWbFcvQTNoM3hIUmlSbUJoWVVzN3R3SjEwd3owMy9ILzNLRkNPYnhKeVNYNG9NMFVCNVdDYUFhMFR4Uk9rd2hOTUUwMU1NS1VCaXpJdm5XQWs3NGZDTXhCRWNaU05vZ1FHNFVnendXSjhHWnVxV1N2T04zdGpvT3RHRkx6Sk9lKzI2V3FmUC9LSnpVKzVhNGk5NE40dUVBaVptejduMWFwZkt0UmU1VEd1RnRkSDFtekwyYWRSNExkSWw4WGxJb0Y2N0g3K2MwWTdHczdPNjNFVWR2OUhXSWsyUHFxZEFoUzVpTEorczBGQ1hDdDlaVC9YU0FtN2xjaUpIYVo1SWhXWkJFd2xzbzg0RytYYmh5ZFY4Z0dkSW9zbGltbjVGd2h2bUQ4bDdUZkZ0KytUbDZxYzF4SXdxZzJyN2V3R0RhRjVvOFA1T2FGemJoMmU5N1oxV3F2cUxqNGxGSTY3VmR0dnVhYUZLUGIzR2hVTkh4Yno1RGtsN3ZwcTI3YkxmbW1Kb054WUdiUmVwQ3JPbmx3OHR2a0JSVmVZQXFhMStQdU5sOE5BUlc4N21zOU9SZ2hiWEwrMURXNSs0VGUrS3p1NWJXVEFZNTdzWm5objRIY2tLYms3TStGSm1DRkg2TXMyWllzUzZXVjViekdMeFpRa1lGL1RFTmhaYmFZbkQ2dHFRU2M5Yy9QeTJRWElneVlOaUhyMXVqSnNXMTNBRmFWZ3JKKytveVNNZGlydEFlaWtjYi9zTDRmTzhuTHlzejYxMStvbFF1cStCdFRqU3FUaWFEellxeUpzenA0Q3pHQ3VxZHRFYzByWVhPdllSZ0hRblVZWmFyZ2tVeFZFMHY0Qi8xQlVuQUFBZU5wallHUmdZQUJpM2hOSHo4YnoyM3hsWUdaaEFJSEhBdk9lSU9qL3VrekhtQzRDdVJ3TVRDQlJBRW9KQzhzQWVOcGpZR1JnWUdiNHo4REF3SFNNUWVmL0JhWXNCcUFJQ21BQkFHVWNCRGdDeGdBQUFqb0FTd0k2QUN3Q0tBQXdBQUFBQUFCbUFOUUJRZ0FBZU5wallHUmdZR0JoY0dGZ1lnQUJSZ1kwQUFBSGpnQk5lTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQzBBQUFBMktNaUJBV2hvWldFQUFBSGNBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZndBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPTGRHOHNVNC9sdHZqSXdzekNBd0dPQmVVK1FhZWFKVERaQWlvT0JDY1FEQUI4dENYSUFBQUI0Mm1OZ1pHQmdWdnhqQkNRbk1oZ3l5REthTUFCRlVBQVRBRUVhQW00QUFBT1JBQUFCVVFBeEFBQUFBQUFnQUFCNDJtTmdaR0JnWUdMZ1p3RFJERkFTQ1FBQUFoUUFGUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktENkJuMmhvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRyWlB2cjd4L0RaZkdaaFpHRURnc2NDOEp3ajYvMTltTnFhN1FDNEhBeE5JRkFCQUN3dVRBSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjMuODg2NTkxLC0yMy45NDg4NTgpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4xNTI3OSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjMuODg2NTkxLC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIzLjg4NjU5MScgeT0nLTIzLjk0ODg1OCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTYuNDE0NTkyJyB5PSctMjcuNTY0MjIxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTguNjA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsMC4wLC04Ljg1OTczKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMi41MzEwNCwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xOS4yMjAwMDcnIHk9Jy0yNi45NTUzNzUnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMTUuMDU1MDM4JyB5PSctMjMuOTQ4ODU4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xMS45NDE2OTUnIHk9Jy0yMy45NDg4NTgnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTcuODA0NzQ0JyB5PSctMjMuOTQ4ODU4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjQ1OTMyLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0xNS44Mjk5ODMnIHk9Jy0yNy41NjQyMjEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjMuODg2NTkxLC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIzLjg4NjU5MScgeT0nLTIzLjk0ODg1OCc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOS43MDgzMyAwSDQ2LjQwMzc4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjY1Mzc4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjQuMzI1ODIsNC43ODQwMSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPs61PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0yMC4xMjI1NjknIHk9Jy0yMi45NTI1OTQnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtOC42MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCw1Ni45MDU1LC04Ljg1OTczKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0LTU2LjkwNTVINDcuODA2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMDU2NTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1Ljk2NCwtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00My45ODgzLDM3LjczODMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tMzEuOTMyNzUgNDEuMzMwNDdDMi4wNzYxMSA0Ni4zNzQ1MyAyOC42ODc5IDM1Ljg1ODAyIDQ5Ljc0OTg4IDkuMzE5MTgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC42MjE2MSwtMC43ODMyNiwwLjc4MzI2LDAuNjIxNjEsNDkuOTA1MjcsOS4xMjMzNyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTcuMDY2MzYsMzkuOTMxMjMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS13aWR0aD0nMS42Jz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC4zMDU1NC01MC41Mzc1OCcgZmlsbD0nbm9uZScvPgo8ZyBzdHJva2Utd2lkdGg9JzAuNic+CjxnIHN0cm9rZT0nI2ZmZic+CjxwYXRoIGQ9J00tNDEuMDgxMTggMzMuODI4NTdDLTQ2LjQ3NDQ5LTEuMTM0MzUtMzUuODg3Ni0yOC4zODUzLTguMzA1NTQtNTAuNTM3NTgnIGZpbGw9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMzLjc5NTIzLC0xMC4zNDY2NiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00tMzMuODI4MDggMzMuODI4NTdMLTkuMjc3MTYgOS4yODEwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE0LC0wLjcwNzA1LDAuNzA3MDUsMC43MDcxNCwtOS4xMDAzNyw5LjEwNDMxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTguMTExOTUsMjQuMTg5ODgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \SpliceDiagramSquare {
          ne = B',
          se = B,
          nw = A',
          nw/style = pullback,
          sw = A,
          east = g,
          east/style = {>->},
          west = f^{*}(g),
          west/style = {>->},
          south = f,
          north = \varepsilon _{g},
        }
        \node  [above left of = nw] (a) {$A$};
        \draw  [->,morphism,bend left] (a) to node {} (ne);
        \draw  [double,morphism,bend right] (a) to node {} (sw);
        \draw  [->,morphism,exists] (a) to node {} (nw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>This then corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\exists _{f}(\mathsf {id}_{A}) \to  g]]></fr:tex> under the adjunction <fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex>. Thus, we define <fr:tex
display="inline"><![CDATA[\mathsf {Img}]]></fr:tex> by the assignment <fr:tex
display="inline"><![CDATA[f \mapsto  \exists _{f}(\mathsf {id}_{A})]]></fr:tex>. This assignment can be trivially extended to a functor: since the category <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex> is a preorder, every morphism <fr:tex
display="inline"><![CDATA[f \to  f']]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex> has to be mapped to the unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f) \to  \mathsf {Img}(f')]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. This morphism must exist. Indeed, it is the lifting of <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)]]></fr:tex> against <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f')}]]></fr:tex> depicted in the following diagram.</fr:p>
    
      
      <fr:figure><fr:resource
hash="65873719b08cc2e6f763d49b27a8cbd5"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0Ni41NjI4NTlwdCcgaGVpZ2h0PScxMjAuNjgwNzU3cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTcuNzA4NTczIDgwLjQ1MzgzOCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUM0QUFBQTJLQXVBdW1ob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0aE5jaTYvSDg5dDhaV0JtWVFDQnh3THo3aUhvLzR4TWw1bEJYQTRHSmhBRkFEb2xDclVBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9nQUFvQUFBQUFCQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjFVMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM1WjJ4NVpnQUFBV1FBQUFEaUFBQUE1SXZLUWdSb1pXRmtBQUFDU0FBQUFDOEFBQUEyS0l5QXVXaG9aV0VBQUFKNEFBQUFIZ0FBQUNRR1F3Sk9hRzEwZUFBQUFwZ0FBQUFJQUFBQUNBWVFBSHRzYjJOaEFBQUNvQUFBQUFZQUFBQUdBSElBQUcxaGVIQUFBQUtvQUFBQUZ3QUFBQ0FBQkFCS2JtRnRaUUFBQXNBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTWFReE0vd0g4cGtoMGtocS9nT0ZBYkQ2RE1VQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZocC8vOUR5UCt6d1h3R0FGV2dCc0lBQUFCNDJoM0t5VTNEUUJpRzRmbG16RC9PNGhrN0hpOVliQmxITm9rSU9UaU1CVUsydUNFa0pEaHlvWUJJVkVBSkhHaUJMcWlBQ2lpQ0xsaUMzc3Q3ZUJqWTg4K1NmL0JQZHMwWWhBWkpCVWxWM2FGSk0wTXlQVVNIMXZWd2JVblYyZHBsemZiL1N6T0ZzcW9yMTFZcldFa2FqVXVOSkltdjgyQVFGWk9ycGIwVm1DY0xZUkt0NHYzWlRqVFppMFlQUVd6MG95SXY5NFB5L3ZqbWo2UUxnZkZCcU9NaUc0N3pwOEQ0d3NQTDkzdG5MK2RGdzJGUHJSVjFOQjFLY082U2Z2TzJ1UUFGWm9DNzZkRTZqRlllWmlkYlFyWHlPZkt3ZndYdGpnUVkrd1hVZVIySEFBQjQybU5nWkdCZ0FHTER4dVBHOGZ3Mlh4bVlXUmhBNExIQXZIc0krcjh1Y3dqVFpTQ1hnNEVKSkFvQUk4WUtsUUI0Mm1OZ1pHQmdadmpQQUNSREdLci9mMmM2eWdBVVFRRk1BR3NmQkpZQUFBTlVBQUFDdkFCN0FBQUFBQUJ5QUFCNDJtTmdaR0JnWUdMd1pBRFJERkFTQ1FBQUI3NEFUd0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXOTBuR050WVhBQUFBRTRBQUFBTXdBQUFFUUFld0VnWjJ4NVpnQUFBV3dBQUFGTUFBQUJqUE53SkpOb1pXRmtBQUFDdUFBQUFDOEFBQUEyS0VTQXIyaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR053SjFhRzEwZUFBQUF3Z0FBQUFRQUFBQUVBajlBTlpzYjJOaEFBQURHQUFBQUFvQUFBQUtBTlFBaUcxaGVIQUFBQU1rQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQXp3QUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TXVReWMvOEg4cG01R2RIVS9BY0tBd0REN3d6N2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VROEdkSVpjdi8vUjdEKzcvZy8rLzgwc0Zvd0FBRHNod3VWQUhqYVZWRExUc0pRRUoyWlcxb2dXQVNsRmR0VWFXTUxpQkI1dE1CVkVoY1NJeXBxNGtJa1NHVGpqeGcrRFJNU0VxSWY0dGFGNE1XTm1rbE96bU5tY1FZUVJnQXdwUWt3Z0kyRWs1ZyswK1NySVRRSXgxcVdLSTd2VUFJT0hRRFVQVWRXZEMybG9pSjdzbUpoVVBGMVRZeUt0dXU1ZmxCRXp3L2NXZ3NEWDI4aDAxYU80NjQyZFhFcDZ4YVdSZTZKSVJhcmNsT1NUSHk2MkcrRUdCWGlqOFpSM3ExS05KNk5HUm81SllGUzJxSGhaYkZ4L0xDME9XRXQ3d2owZTZQbW1zcG84RElncVJCZkwrSzhMU0VMNXc1UGgwUzd0T01taUNKaHpicmkzUzdmNU5zUnoyb2FCM1dSTWx1TExqNnd5Q3ZWSDNobHBxbGtzdGxNVmcyUkxDb0R3cDBvSHNNMzJCTkMvTU12b2V1cHFLZiswVXJLRjExRXhjQkNGcjFucXBRODQyWDhKYmZ0M25sVFR0NmM5RG1XRm5QTXB1MlF6VmkvOXZtWHpqclh4T3BiaGs5c0NOL3JyRDNyZU5wallHUmdZQUJpWTg5ZnVmSDhObDhabUZrWVFPQ3h3THg3Q1BxL1BqTVAwM0VnbDRPQkNTUUtBQ2krQ25vQWVOcGpZR1JnWU9iK3p3QWs0eG5rR0FTWmVSaUFJaWlBQlFBdXZ3RzBBQUFDVUFBQUFTNEFZd0lnQUI0RFh3QlZBQUFBQUFBT0FJZ0F4Z0FBZU5wallHUmdZR0JoOEdGZ1pnQUJSZ1kwQUFBSWJRQldlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSQUFBb0FBQUFBQk5nQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0YzL0dOdFlYQUFBQUU4QUFBQU1RQUFBRHdIRmYxMFoyeDVaZ0FBQVhBQUFBRjNBQUFCcUpWMkIydG9aV0ZrQUFBQzZBQUFBQzhBQUFBMkovNkF1V2hvWldFQUFBTVlBQUFBSUFBQUFDUUZuUUdhYUcxMGVBQUFBemdBQUFBTUFBQUFEQWNvQUh0c2IyTmhBQUFEUkFBQUFBZ0FBQUFJQUdZQTFHMWhlSEFBQUFOTUFBQUFHQUFBQUNBQUJnQkZibUZ0WlFBQUEyUUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUVOQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1TbUtjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1XOWxadmdQNURNek1JS0VHUkVxL2dPRkFmUWJEZkFBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZeGIvMy9IOGdIMC85bi8vRUZxd0lDQUtJRkNZY0FBQUI0MmtYUHUwN2NRQlRHOGZsbXpIalppOGQ3OFhqQllHZlg5Z3dYWlc5R050cEYzb1V0a0NCU2hDS0JxS0lVTlBzQ3ZBVVZCVzNhUEFjOTRoMVNScUpLR3pLckZEbkZLYzYvT1Q4Q2N2aytwQ3Y2U2hhRWdBbHcyNEhkVjdwRUpuM0piUm1oeEp6RlhPVitWcUl3OTRuMEhjUktxN3hRUXpoVUlNc2wxL2crZFMxM2UvTjB2RGNGRWs4eGlFZ0lrZlRZN2tCOENtbGJYQW5Qa1dmeC9na1FTOVBkVUloV0s2eFd0cit1TXg3L1BGODBGMGVkSlZOeCtJRW1YTmMyS2F4TDcrbjNEZXZidUxrTnRFcVQvd2xiNnVPRDFhK0FtS0ZrOVA0TGIzZ2hNN0lrcEhEZ2M5LzhQOG1MdkFpeHRnMWdZTVcvblVzL2hKRW9QVEJpSS9WTCtQbmFwcm1XY3pvRS81R2x3R3czeWo2ZnQ2eEtnKzY1NDlYMUhlaHh4R0pxUFg2clQzck5CUEJrTlo0MnJ1NFpUZFdzM2h1QmxUdUh0YkNiZHJyZDRjOWczajRJcXBRR29RMEV1cTRzWEV4SFp5MmswZUlMd0IzdXVZMDJ0VHRWakEvNmJhY0NORG83TlZqcGhxa1dxS0g5Qlk2dE5WZ0FlTnBqWUdSZ1lBQmkvaWl6eC9IOE5sOFptRmtZUU9DeHdMeDdDUHEvUHRNeHBvdEFMZ2NERTBnVUFDRTNDdHdBZU5wallHUmdZR2I0ejhEQXdIU013ZUQvQmFZc0JxQUlDbUFHQUdWM0JEc0N4Z0FBQWpvQVN3SW9BREFBQUFBQUFHWUExSGphWTJCa1lHQmdabkJoWUdJQUFVWUdOQUFBQjNNQVRIamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b0NDeGRXRmdZbVhxQXRoRkdXd2pKMFJDcWpyMmQvZGhQUFFOVitkKzJFRE5Ed1gzSzVnbHZWOUpKZTdCRlZQbW1TZmkzakxYTEhqbmlhSjhsdVNWajh5bE5KK1pLMTc0eWp5Ui9EdHp6WXJmVFhDWDYyQ2oyZ1Zqb3o4NTE2MzNOdlpkOEdxcG0rUzMxdHQ0R0t4Ung1c3lZOWVQWjZkYTNlaVdEUUhIaFNzRGxvaGlKNGxKN0RsSjUraFlzMDlKTHh3a1Z5elJOUC82cmZRK2JRN3BKeU9iSXpkUnd5aUxYdlFzVzBXYlhtcmFQOHVoTC9jQUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUEvUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMG1tTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM4QUFBQTBFOE96SDFvWldGa0FBQUNJQUFBQUM0QUFBQTJLSXFBdVdob1pXRUFBQUpRQUFBQUhnQUFBQ1FGTEFLNGFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dYZkFKcHNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEWUFhRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFnYm1GdFpRQUFBcHdBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNm1HY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFkSWxETTBBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pKajFuNEh4T0RNRGd4d0RBeU1mSXp1YnVCZ1lpckFwcWVzeHFxdXBtNW5iTVpxYkdZbUpzakVlQ1dwbFpWYmk0Tkt0NEdCa2szSlU5Rkt3WldHeFZmQlNkSlJpWTJSNmJ2WjFUMnlsaEhoVktnc1hDNWVKYkpSdHdZb1ZoYmFSc2laY0xKd01RTURJa0F5MGF3TFFMbWtnaDQwZFpKdWFQcU1KMkFJaE5YVTFJRU5jamxGY2pIRUMxRlJtSmxiMWNEVlR4clJpZG1abWlJV01EQkF6R1ZrNU9GaGtrOE9hR0tWK3gzSnpzektDTFFRQUVhTWpqM2phWTJCa1lHQUE0djNLVDViSDg5dDhaV0JtWVFDQnh3THo3aUhvL3d6TVFjd2dMZ2NERTRnQ0FEbDZDbFVBQUhqYVkyQmtZR0JtK004QUpJTVlraG1TR1k4ekFFVlFBQk1BUnNrQzZnQUFBMUlBQUFJcUFKb0FZd0FBQUFBQUFBQTJBR2g0Mm1OZ1pHQmdZR2FRWndEUkRGQVNDUUFBQTc4QUpnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVxZm01dURrNnZEMjZ3SjBxR3BwTFhvSXY1MGIwUHdCZzdmUGVmY0FCa3ZFb1pKbUFjZEpwVTNqenptaDBYa2lmaXJ5Qm0vckJtUnBETnhWdXdpcDB6NWp6eG1TUmw1SXY0amNzWWY3MzFUMys2ZDllcllHT3ZkcGZiYmsvVnQxVGkxMGZtd0hxeXovdHhabzhxbk1uM1Y5dGRhRlRyWEJYc2FhbTdjNmJCNEZFZHhUR0RIUlRMUGxsUFlXeXJKbkhRMmFQSnZlcERVaGNZNS9HS2tVZklVTmZSeTA0cGVwYXNvd3AybStBQlZNaTVEQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1JQUFvQUFBQUFBMmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEeGloR050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCRUFBQUFSQjVhakhkb1pXRmtBQUFCc0FBQUFDMEFBQUEyS1l5QTlXaG9aV0VBQUFIZ0FBQUFId0FBQUNRRkJnRFphRzEwZUFBQUFnQUFBQUFJQUFBQUNBWVlBRjlzYjJOaEFBQUNDQUFBQUFZQUFBQUdBQ0lBQUcxaGVIQUFBQUlRQUFBQUZ3QUFBQ0FBQkFBU2JtRnRaUUFBQWlnQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBQytBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpxMC9sZ3dNekZyTXg0SENqQWdWLy84ek1BQUErd01QZndCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFGOEFKd0Y3QWp3QUVBQUFBUU1HSXljbUp6Y1RQZ0UzTWhZWEJnY0JjZFFHREJZVEF3U2VBeGtlR1NZQkFRUUIzUDVjRVFjSERSQUJ1dzRnQVNBY0RBd0FlTnBqWUdSZ1lBQmk5czBMSE9QNWJiNHlNTE13Z01CamdYbjNrR21XVUNZYklNWEJ3QVRpQVFBSHRRakRBQUFBZU5wallHUmdZTmI2WThuQXdCTEtFTS9nd1ZqTkFCUkJBVXdBU2lnQzR3QUVWUUFBQWNNQVh3QUFBQUFBSWdBQWVOcGpZR1JnWUdCaUVHUUEwUXhRRWdrQUFBSkdBQmNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS01pQTlXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZEc4c3M0L2x0dmpJd3N6Q0F3R09CZWZlUWFlYUpURFpBaW9PQkNjUURBQ0loQ1g0QUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDArMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNWWjJ4NVpnQUFBV1FBQUFGTEFBQUJZRG1Tc1RKb1pXRmtBQUFDc0FBQUFDOEFBQUEyS0Q2QmsyaG9aV0VBQUFMZ0FBQUFIZ0FBQUNRR0xBSU9hRzEwZUFBQUF3QUFBQUFNQUFBQURBaCtBRTlzYjJOaEFBQUREQUFBQUFnQUFBQUlBRlFBc0cxaGVIQUFBQU1VQUFBQUZnQUFBQ0FBQndBNmJtRnRaUUFBQXl3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaVp2Z1A1RE5EcEpIVS9BY0tBd0R5S1ExSGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoTy8vOERTY2YvLy84ZkFQTVpBRktvQnA1NDJqV1BNVS9DUUFDRjc5M0JIV0RiUTF2YUdBRlRRWnBvRkVOSkt3d01LbWcwRXBURU1KQ1ltQ2liZzBGY0dSaDFNakZ4Y25IekI3ZzRPZmtuSEl5anZ3R3dOZkZOTDEvZThEMUNTWDQ2cFYvMGt4UkppUkFmbmw4eUxkMHdYYy9rUlFpbjRKUTl5L1Q4SW16QkRkUHlMQTBCRDdGYmcrK3lWNXh6UStXb21Xc3BLTkgrTUJhRk9xT1hXVnhNcGswMXJhc01hclRYVWFERWwycVBQL2FBbmlRUmwrT2hLVmxHZ0RIUW1CU0FZbDNVUjBZK0NTbzFIdUtFNU1oOTRKZ0VZV1IxT21hY3ZwRXNXU0diZ2FsZXpqazhjTE96U0drUVdWaGNnZ3ViLy9ucW9aeFhjSElGTHRoL1o4SEFmYjViY0RKU290TTlZOFAyUVJ0ME4zbDRQYmxQYTFvMSsvUncycWRZM3g0dDZ0SEwyKzZBMG8yOTkwWUUwRnEwTWt0WldvQWVWZmQ3TXRHc0hHeHB0VWo0QURycTdLcVIzNkdROCtNWGR0TmNickhKOXh4UGtGK3p2VHVEQUhqYVkyQmtZR0FBNHJaUHZxbngvRFpmR1poWkdFRGdzY0M4ZXdqNi8xOW1OcWE3UUM0SEF4TklGQUJDL3d1ZkFIamFZMkJrWUdCbStNOEFKRGtZVkJpWW1Oa1lnQ0lvZ0JrQUk4Y0JRZ0FBQW5ZQUFBTUFBQ1FEQ0FBckFBQUFBQUJVQUxCNDJtTmdaR0JnWUdhd0JHSVFZR1JBQXdBR2R3QkNBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY4IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi41NzcwMTIsLTYwLjU2NjQ3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01NS4xMDUwMTMnIHk9Jy02NC4xODE4MzQnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MC41NjY0NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUxLjQ1OTMyLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYwLjU2NjQ3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy02MC41NjY0Nyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTQuNTIwNDA0JyB5PSctNjQuMTgxODM0Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINDYuNDAzNzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNjUzNzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNS44ODg2Nyw1LjkwMDcxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MC41NjY0NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNjIuNTc3MDEyJyB5PSctNjAuNTY2NDcnPs61PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01OC44MTI5OScgeT0nLTU4LjczNDQyNyc+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjgnIHg9Jy01MC40MTk5MDQnIHk9Jy01OC43MzQ0MjcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTQ3LjcyMTY0OScgeT0nLTU4LjczNDQyNyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDMuNzI2MTc5JyB5PSctNjAuMjAxMTU2Jz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTQxLjAzMTQwNCcgeT0nLTU4LjczNDQyNyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS04LjYwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTUwLjgyNjY3MycgeT0nLTYwLjU2NjQ3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny43MTMzMycgeT0nLTYwLjU2NjQ3Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00My4wNDY3NDYnIHk9Jy02My41NzI5ODcnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNDAuMzUxOTcxJyB5PSctNjAuNTY2NDcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjUwNTU0LTU2LjkwNTVINDcuODA2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTAuNzU1NTQsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNi45NDE3OSwtNjQuOTY3MzIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYwLjU2NjQ3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Mi41NzcwMTInIHk9Jy02MC41NjY0Nyc+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy01MC44MjY2NzMnIHk9Jy02MC41NjY0Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuNzEzMzMnIHk9Jy02MC41NjY0Nyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNDMuMDQ2NzQ2JyB5PSctNjAuNTY2NDcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J004LjIzODEzLTQ4LjY2MjQ2TDUwLjE0NTkyLTYuNzYzMjMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNywwLjcwNzAyLC0wLjcwNzAyLDAuNzA3MTcsNTAuMzIyNzEsLTYuNTg2NDkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \SpliceDiagramSquare {
          nw = A',
          nw/style = pullback,
          sw = A,
          ne = B',
          se = B,
          north = \varepsilon _{\mathsf {Img}(f')},
          east = \mathsf {Img}(f'),
          east/style = {>->},
          south = \mathsf {Img}(f),
          south/style = {>->},
        }
        \draw  [->,morphism,exists] (sw) to (ne);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>We can now extract the components of the unit and the counit from this correspondence.</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
      
  <html:tr>
        
  <html:th>Unit (<fr:tex
display="inline"><![CDATA[\vartheta ]]></fr:tex>)</html:th>

        
  <html:th>Counit (<fr:tex
display="inline"><![CDATA[\zeta ]]></fr:tex>)</html:th>

      </html:tr>

      
  <html:tr>
        
  <html:td>
          <fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be an object in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. The identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}\colon \mathsf {Img}(f)\to \mathsf {Img}(f)]]></fr:tex> is, by definition, the identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}\colon \exists _{f}(\mathsf {id}_{A})\to \mathsf {Img}(f)]]></fr:tex>, which corresponds to the unit <fr:tex
display="inline"><![CDATA[\eta _{\mathsf {id}_{A}}\colon \mathsf {id}_{A}\to f^{*}(\mathsf {Img}(f))]]></fr:tex> of the adjunction <html:span
style="white-space: nowrap"><fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex></html:span>.</fr:p>
          <fr:p>Then since <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)]]></fr:tex> is monic, <fr:tex
display="inline"><![CDATA[\eta _{\mathsf {id}_{A}}]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f)}\eta _{\mathsf {id}_{A}}\colon f\to \mathsf {Img}(f)]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> is the counit of the adjunction <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex>. This defines the component of <fr:tex
display="inline"><![CDATA[\vartheta ]]></fr:tex> at <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. This is precisely the lifting of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> against <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f)}]]></fr:tex>.</fr:p>
          
    
      
      <fr:figure><fr:resource
hash="7e883808b7d5854b7864b81c7cbb3522"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0Mi41MjA3MjdwdCcgaGVpZ2h0PScxMTguNzcxMjE4cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTUuMDEzODE4IDc5LjE4MDgxMic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUM0QUFBQTJLQXVBeEdob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0aE5jaXcvSDg5dDhaV0JtWVFDQnh3THpIaVBvLzR4TWw1bEJYQTRHSmhBRkFEZXZDcXNBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9nQUFvQUFBQUFCQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjFVMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM1WjJ4NVpnQUFBV1FBQUFEaUFBQUE1SXZLUWdSb1pXRmtBQUFDU0FBQUFDOEFBQUEyS0l5QXcyaG9aV0VBQUFKNEFBQUFIZ0FBQUNRR1F3Sk9hRzEwZUFBQUFwZ0FBQUFJQUFBQUNBWVFBSHRzYjJOaEFBQUNvQUFBQUFZQUFBQUdBSElBQUcxaGVIQUFBQUtvQUFBQUZ3QUFBQ0FBQkFCS2JtRnRaUUFBQXNBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTWFReE0vd0g4cGtoMGtocS9nT0ZBYkQ2RE1VQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZocC8vOUR5UCt6d1h3R0FGV2dCc0lBQUFCNDJoM0t5VTNEUUJpRzRmbG16RC9PNGhrN0hpOVliQmxITm9rSU9UaU1CVUsydUNFa0pEaHlvWUJJVkVBSkhHaUJMcWlBQ2lpQ0xsaUMzc3Q3ZUJqWTg4K1NmL0JQZHMwWWhBWkpCVWxWM2FGSk0wTXlQVVNIMXZWd2JVblYyZHBsemZiL1N6T0ZzcW9yMTFZcldFa2FqVXVOSkltdjgyQVFGWk9ycGIwVm1DY0xZUkt0NHYzWlRqVFppMFlQUVd6MG95SXY5NFB5L3ZqbWo2UUxnZkZCcU9NaUc0N3pwOEQ0d3NQTDkzdG5MK2RGdzJGUHJSVjFOQjFLY082U2Z2TzJ1UUFGWm9DNzZkRTZqRlllWmlkYlFyWHlPZkt3ZndYdGpnUVkrd1hVZVIySEFBQjQybU5nWkdCZ0FHTER4dVB5OGZ3Mlh4bVlXUmhBNExIQXZNY0krcjh1Y3dqVFpTQ1hnNEVKSkFvQUlWQUtpd0I0Mm1OZ1pHQmdadmpQQUNSREdLci9mMmM2eWdBVVFRRk1BR3NmQkpZQUFBTlVBQUFDdkFCN0FBQUFBQUJ5QUFCNDJtTmdaR0JnWUdMd1pBRFJERkFTQ1FBQUI3NEFUd0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktENkJuV2hvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRyWlB2b0h4L0RaZkdaaFpHRURnc2NDOHh3ajYvMTltTnFhN1FDNEhBeE5JRkFCQWlRdVZBSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBL1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBtbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDOEFBQUEwRThPekgxb1pXRmtBQUFDSUFBQUFDNEFBQUEyS0lxQXcyaG9aV0VBQUFKUUFBQUFIZ0FBQUNRRkxBSzRhRzEwZUFBQUFuQUFBQUFLQUFBQUNnWGZBSnBzYjJOaEFBQUNmQUFBQUFnQUFBQUlBRFlBYUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBZ2JtRnRaUUFBQXB3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBZElsRE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaSmoxbjRIeE9ETURneHdEQXlNZkl6dWJ1QmdZaXJBcHFlc3hxcXVwbTVuYk1acWJHWW1Kc2pFZUNXcGxaVmJpNE5LdDRHQmtrM0pVOUZLd1pXR3hWZkJTZEpSaVkyUjZidloxVDJ5bGhIaFZLZ3NYQzVlSmJKUnR3WW9WaGJhUnNpWmNMSndNUU1ESWtBeTBhd0xRTG1rZ2g0MGRaSnVhUHFNSjJBSWhOWFUxSUVOY2psRmNqSEVDMUZSbUpsYjFjRFZUeHJSaWRtWm1pSVdNREJBekdWazVPRmhrazhPYUdLVit4M0p6c3pLQ0xRUUFFYU1qajNqYVkyQmtZR0FBNHYzS1R5Ykg4OXQ4WldCbVlRQ0J4d0x6SGlQby93ek1RY3dnTGdjREU0Z0NBRGNFQ2tzQUFIamFZMkJrWUdCbStNOEFKSU1Za2htU0dZOHpBRVZRQUJNQVJza0M2Z0FBQTFJQUFBSXFBSm9BWXdBQUFBQUFBQUEyQUdoNDJtTmdaR0JnWUdhUVp3RFJERkFTQ1FBQUE3OEFKZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQzBBQUFBMktNaUEvMmhvWldFQUFBSGNBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZndBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPTGRHOHRVNC9sdHZqSXdzekNBd0dPQmVZK1JhZWFKVERaQWlvT0JDY1FEQUIrckNYUUFBQUI0Mm1OZ1pHQmdWdnhqQkNRbk1oZ3l5REthTUFCRlVBQVRBRUVhQW00QUFBT1JBQUFCVVFBeEFBQUFBQUFnQUFCNDJtTmdaR0JnWUdMZ1p3RFJERkFTQ1FBQUFoUUFGUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXOTBuR050WVhBQUFBRTRBQUFBTXdBQUFFUUFld0VnWjJ4NVpnQUFBV3dBQUFGTUFBQUJqUE53SkpOb1pXRmtBQUFDdUFBQUFDOEFBQUEyS0VTQXVXaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR053SjFhRzEwZUFBQUF3Z0FBQUFRQUFBQUVBajlBTlpzYjJOaEFBQURHQUFBQUFvQUFBQUtBTlFBaUcxaGVIQUFBQU1rQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQXp3QUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TXVReWMvOEg4cG01R2RIVS9BY0tBd0REN3d6N2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VROEdkSVpjdi8vUjdEKzcvZy8rLzgwc0Zvd0FBRHNod3VWQUhqYVZWRExUc0pRRUoyWlcxb2dXQVNsRmR0VWFXTUxpQkI1dE1CVkVoY1NJeXBxNGtJa1NHVGpqeGcrRFJNU0VxSWY0dGFGNE1XTm1rbE96bU5tY1FZUVJnQXdwUWt3Z0kyRWs1ZyswK1NySVRRSXgxcVdLSTd2VUFJT0hRRFVQVWRXZEMybG9pSjdzbUpoVVBGMVRZeUt0dXU1ZmxCRXp3L2NXZ3NEWDI4aDAxYU80NjQyZFhFcDZ4YVdSZTZKSVJhcmNsT1NUSHk2MkcrRUdCWGlqOFpSM3ExS05KNk5HUm81SllGUzJxSGhaYkZ4L0xDME9XRXQ3d2owZTZQbW1zcG84RElncVJCZkwrSzhMU0VMNXc1UGgwUzd0T01taUNKaHpicmkzUzdmNU5zUnoyb2FCM1dSTWx1TExqNnd5Q3ZWSDNobHBxbGtzdGxNVmcyUkxDb0R3cDBvSHNNMzJCTkMvTU12b2V1cHFLZiswVXJLRjExRXhjQkNGcjFucXBRODQyWDhKYmZ0M25sVFR0NmM5RG1XRm5QTXB1MlF6VmkvOXZtWHpqclh4T3BiaGs5c0NOL3JyRDNyZU5wallHUmdZQUJpWTg5ZmtmSDhObDhabUZrWVFPQ3h3THpIQ1BxL1BqTVAwM0VnbDRPQkNTUUtBQ1pJQ25BQWVOcGpZR1JnWU9iK3p3QWs0eG5rR0FTWmVSaUFJaWlBQlFBdXZ3RzBBQUFDVUFBQUFTNEFZd0lnQUI0RFh3QlZBQUFBQUFBT0FJZ0F4Z0FBZU5wallHUmdZR0JoOEdGZ1pnQUJSZ1kwQUFBSWJRQldlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVY0FBb0FBQUFBQmZnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0TUdOdFlYQUFBQUU4QUFBQU13QUFBRVFEeVFTaFoyeDVaZ0FBQVhBQUFBSkpBQUFDdUhOeUdvWm9aV0ZrQUFBRHZBQUFBQzhBQUFBMkovNkF3MmhvWldFQUFBUHNBQUFBSUFBQUFDUUZ3Z0diYUcxMGVBQUFCQXdBQUFBUUFBQUFFQW5xQUt0c2IyTmhBQUFFSEFBQUFBb0FBQUFLQWNJQTFHMWhlSEFBQUFRb0FBQUFHQUFBQUNBQUJ3QllibUZ0WlFBQUJFQUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZFQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbUtjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1WOWtadmdQNURNek1JS0VHUkVxL2dPRkFRQU9EaVFBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnTWdEUUhFSUxrMHBpM01sLzgveC9CK2ovN2orOGZJN0JhTUFBQURIc01hZ0I0MmtXUlAyL1RRQmpHL1p5ZGMrSWtQamUyejJtY09rMGMyNldVcEhGU0d5WEJTVk1CL1FNdEZTZ1ZRbXBWcEM0ZEVBdmlXOERTZ1pXVno4R08rQTZNU0V4ZEtaY2l4SjEwdy92b3BQZjMvQ1JJQnpkZGNrbStTMU5KZ3N4QVZSMXFLNHd5OUxuRHFjb2J5RENSZlJvbVRqOURLdVl4ZDNUNFlSUW1hZGlGVGhqNkNhY1JQZzhOeGFnVnRudHJRNkJ0aHpKWWd6SFdic29ySGZiRUl5WTdacmJPWi82ZE1lQnprUnNlWTVXS3ArVnJaNHNZVjcrLzdpOU5COWFPSFByZUttblRxRmdnVUE3c1Q5Y25ja3ZGeVVzM0NvUDIvd2pMNGIwUFNpc1BTUndpYmQ3OHhDOThrMGJTamlTbE9oenFpUDNqSkUxU0R3dTJEZ1JZK3ZkTnVPTkJrSVJSUnhBTFVpZURreXpZSWhyeENlbUNmdWtId0dpbDBUOTZYRkh5WmJKbTlDN25GeUQzRzdKUGxLdnpVdHhjYWdNMjEveGgrZmk5VElKd1ZHcHVRczdxZDR0ZU5iQ3ExZTRQZDJLdXV4b2hycWNDYmxRS0Zld1BOMmNWQkkzcGM0RHExRGJLSmxFdERiMzFscW5uZ2JKVkwwSUpjaUpWUVA2eFhaT1B3dE9lTkJlbUhHNnBFVlZ2YnhnbEV6blpHb1NSVUtlaml3NFM0VWtnT3hhVHFVMjVFOThPaEsyRjJGU0lkYmdxNUlwaWJqK0pramladDV4eTN4MVczWWZ6OFJtQlpqS1ZNTk5yRlhPcVZxVGdyQlI1R3hNb1RIVnlaRFh4SHpUcjdWSTJ6Zzl6NVBYc2thZm11RmozdENyRERlS25ST25WQm5pcmtxcVN2emdQdkdjS0JydStmelJhS2VoMkhaaDJyQ0lJTVhicWZCVVliR2hMMjh1bk5iTzJSYkpSL0c1Z0JIVHRjTytOckl4TCtteGMyQTFldklvUGlYdzYzbTRhTlZISEg2TE9XRVlBQUFCNDJtTmdaR0JnQU9MQTRoK3A4ZncyWHhtWVdSaEE0TEhBdk1jSStyOCswekdtaTBBdUJ3TVRTQlFBUG93TGhRQjQybU5nWkdCZ1p2alB3TURBZEl6QjRQOEZwbjRHb0FnS1lBRUFhRGNFWVFMR0FBQUNPZ0JMQWlnQU1BTENBREFBQUFBQUFHWUExQUZjQUFCNDJtTmdaR0JnWUdFSVoyQmlBQUZHQmpRQUFBbHBBR0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNyB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4xNTI3OSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjA2NDYwMic+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTUuMTA1MDEzJyB5PSctNjQuNjc5OTY2Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuMDY0NjAyJz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjA2NDYwMic+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTQuNTIwNDA0JyB5PSctNjQuNjc5OTY2Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg0Ni40MDM3OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni42NTM3OCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE3LjI0MTEyLDUuNDAwNzEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctNjEuMDY0NjAyJz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTguODEyOTknIHk9Jy01OS43MzA3MDcnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNTAuNDE5OTA0JyB5PSctNTkuNzMwNzA3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny43MjE2NDknIHk9Jy01OS43MzA3MDcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTQzLjcyNjE3OScgeT0nLTU5LjczMDcwNyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS04LjYwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTAuODI2NjczJyB5PSctNjEuMDY0NjAyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny43MTMzMycgeT0nLTYxLjA2NDYwMic+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNDMuMDQ2NzQ2JyB5PSctNjEuMDY0NjAyJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0LTU2LjkwNTVINDcuODA2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMDU2NTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1Ljk2NCwtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctNjEuMDY0NjAyJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzMuMCwyLjAnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNOC4yMzgxMy00OC42NjI0Nkw1MC4xNDU5Mi02Ljc2MzIzJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTcsMC43MDcwMiwtMC43MDcwMiwwLjcwNzE3LDUwLjMyMjcxLC02LjU4NjQ5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00yMS42OTkxLTM0LjMxOTQzSDM3LjAzODUyVi0yMS40MjUwMkgyMS42OTkxWicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjQuNjk5MSwtMjkuMjg2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPs+RPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01Ny43NjYwNzEnIHk9Jy02MC4wMDc0NTUnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                nw = A',
                nw/style = pullback,
                sw = A,
                ne = B',
                se = B,
                north = \varepsilon _{\mathsf {Img}(f)},
                east = \mathsf {Img}(f),
                east/style = {>->},
                south = f,
              }
              \draw  [->,morphism,exists] (sw) to node[desc] {$\vartheta _{f}$} (ne);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
        </html:td>

        
  <html:td>
          <fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A\rightarrowtail B]]></fr:tex> be an object in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. Then the identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}_{f}\colon f\to f]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[s\colon \mathsf {id}_{A}\to f^{*}(f)]]></fr:tex> by the universal property of pullbacks.</fr:p>
          <fr:p>This morphism corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\exists _{f}(\mathsf {id}_{A}) \to  f]]></fr:tex> under the adjunction <fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex>, which we take as the component of <fr:tex
display="inline"><![CDATA[\zeta ]]></fr:tex> at <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p>
        </html:td>

      </html:tr>

    </html:table>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>621</fr:anchor><fr:addr
type="machine">#277</fr:addr><fr:route>unstable-277.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has images, then we may define <fr:tex
display="inline"><![CDATA[\exists _{f}\colon \mathsf {Sub}(A)\to \mathsf {Sub}(B)]]></fr:tex> as the following composite:</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Sub}(A) \hookrightarrow  {{\mathcal {C}}_{/{A}}} \xrightarrow {\Sigma _{f}} {{\mathcal {C}}_{/{B}}} \xrightarrow {\mathsf {Img}} \mathsf {Sub}(B)     ]]></fr:tex><fr:p>Let <fr:tex
display="inline"><![CDATA[i_{A}\colon \mathsf {Sub}(A)\hookrightarrow {{\mathcal {C}}_{/{A}}}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[i_{B}\colon \mathsf {Sub}(B)\hookrightarrow {{\mathcal {C}}_{/{B}}}]]></fr:tex> be the inclusion functors. Note that</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Img}\Sigma _{f} \dashv  f^{*}i_{B}     ]]></fr:tex><fr:p>Since <fr:tex
display="inline"><![CDATA[f^{*}i_{B} \cong  i_{A}f^{*}]]></fr:tex> by construction, we have</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Img}\Sigma _{f} \dashv  i_{A}f^{*}     ]]></fr:tex><fr:p>Let <fr:tex
display="inline"><![CDATA[\eta ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> be the unit and counit of this adjunction respectively. Since <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> is a full subcategory of <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>, there is a natural isomorphism <fr:tex
display="inline"><![CDATA[\iota \colon \mathsf {id}_{{{\mathcal {C}}_{/{A}}}}\stackrel {\sim }{\smash {\longrightarrow }\rule {0pt}{0.4ex}}i_{A}]]></fr:tex>. Then we can define <fr:tex
display="inline"><![CDATA[\eta ']]></fr:tex> as follows:</fr:p><fr:tex
display="block"><![CDATA[       \eta ' := \mathsf {id}_{{{\mathcal {C}}_{/{A}}}} \xrightarrow {\eta } i_{A}f^{*}\mathsf {Img}\Sigma _{f}       \xrightarrow {\iota _{f^{*}\mathsf {Img}\Sigma _{f}}} f^{*}\mathsf {Img}\Sigma _{f}       \xrightarrow {f^{*}\mathsf {Img}\Sigma _{f}(\iota )} f^{*}\mathsf {Img}\Sigma _{f}i_{A}     ]]></fr:tex><fr:p>Then <fr:tex
display="inline"><![CDATA[\eta ']]></fr:tex> and <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> form the unit and counit of the adjunction <fr:tex
display="inline"><![CDATA[\mathsf {Img}\Sigma _{f}i_{A} \dashv  f^{*}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>622</fr:anchor><fr:addr
type="user">ct-000Q</fr:addr><fr:route>ct-000Q.xml</fr:route><fr:title
text="Cover-mono factorization"><fr:link
type="local"
href="ct-000M.xml"
addr="ct-000M"
title="Extremal epimorphism">Cover</fr:link>-mono factorization</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">images</fr:link> and equalizers. Then every morphism of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> can be factored as a cover followed by a monomorphism. Moreover, this factorization is unique up to isomorphism in the sense that if <fr:tex
display="inline"><![CDATA[A \twoheadrightarrow  C \rightarrowtail  B]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A \twoheadrightarrow  C' \rightarrowtail  B]]></fr:tex> are both cover-mono factorizations of the same morphism, then <fr:tex
display="inline"><![CDATA[C \cong  C']]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>623</fr:anchor><fr:addr
type="machine">#270</fr:addr><fr:route>unstable-270.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By the construction of images, every morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> can be factored as <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)\vartheta _{f}]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\vartheta ]]></fr:tex> is the unit of the image adjunction. <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)]]></fr:tex> is monic by construction and <fr:tex
display="inline"><![CDATA[\vartheta _{f}]]></fr:tex> is a cover by <fr:ref
addr="ct-000N"
href="ct-000N.xml"
taxon="Lemma" />.</fr:p>

  <fr:p>To show the second half of the lemma, it suffices to show that every cover-mono factorization of a morphism <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is isomorphic to <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)\vartheta _{f}]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[hg]]></fr:tex> be a cover-mono factorization of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. Then by the universal property of adjunction, there is a morphism <fr:tex
display="inline"><![CDATA[s]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[s\vartheta _{f} = g]]></fr:tex>. By the definition of <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>, we also have <fr:tex
display="inline"><![CDATA[hs = \mathsf {Img}(f)]]></fr:tex>. Then, it follows that <fr:tex
display="inline"><![CDATA[s]]></fr:tex> is monic.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="4039b2f764ac8d806447c6240c03f761"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE1Mi4wNzM4MzNwdCcgaGVpZ2h0PScxNTQuMDkyODIycHQnIHZpZXdCb3g9Jy03MiAtNzIgMTAxLjM4MjU1NSAxMDIuNzI4NTQ4Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT2dBQW9BQUFBQUJBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMVUyTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzVaMng1WmdBQUFXUUFBQURpQUFBQTVJdktRZ1JvWldGa0FBQUNTQUFBQUM4QUFBQTJLSXlBejJob1pXRUFBQUo0QUFBQUhnQUFBQ1FHUXdKT2FHMTBlQUFBQXBnQUFBQUlBQUFBQ0FZUUFIdHNiMk5oQUFBQ29BQUFBQVlBQUFBR0FISUFBRzFoZUhBQUFBS29BQUFBRndBQUFDQUFCQUJLYm1GdFpRQUFBc0FBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEa0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtNW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NYVF4TS93SDhwa2gwa2hxL2dPRkFiRDZETVVBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhwLy85RHlQK3p3WHdHQUZXZ0JzSUFBQUI0MmgzS3lVM0RRQmlHNGZsbXpEL080aGs3SGk5WWJCbEhOb2tJT1RpTUJVSzJ1Q0VrSkRoeW9ZQklWRUFKSEdpQkxxaUFDaWlDTGxpQzNzdDdlQmpZODgrU2YvQlBkczBZaEFaSkJVbFYzYUZKTTBNeVBVU0gxdlZ3YlVuVjJkcGx6ZmIvU3pPRnNxb3IxMVlyV0VrYWpVdU5KSW12ODJBUUZaT3JwYjBWbUNjTFlSS3Q0djNaVGpUWmkwWVBRV3owb3lJdjk0UHkvdmptajZRTGdmRkJxT01pRzQ3enA4RDR3c1BMOTN0bkwrZEZ3MkZQclJWMU5CMUtjTzZTZnZPMnVRQUZab0M3NmRFNmpGWWVaaWRiUXJYeU9mS3dmd1h0amdRWSt3WFVlUjJIQUFCNDJtTmdaR0JnQUdMRHh1UHM4ZncyWHhtWVdSaEE0TEhBdkpjSStyOHVjd2pUWlNDWGc0RUpKQW9BSGx3S2Z3QjQybU5nWkdCZ1p2alBBQ1JER0tyL2YyYzZ5Z0FVUVFGTUFHc2ZCSllBQUFOVUFBQUN2QUI3QUFBQUFBQnlBQUI0Mm1OZ1pHQmdZR0x3WkFEUkRGQVNDUUFBQjc0QVR3QjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzRBQUFBMktBdUEwR2hvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRoTmNpMWZIODl0OFpXQm1ZUUNCeHdMelhpTG8vNHhNbDVsQlhBNEdKaEFGQURTN0NwOEFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWndBQW9BQUFBQUI4QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGNExtTnRZWEFBQUFFOEFBQUFOUUFBQUVRQWlRU2xaMng1WmdBQUFYUUFBQU9RQUFBRWRGZnZxRnhvWldGa0FBQUZCQUFBQUM4QUFBQTJKLzZBeldob1pXRUFBQVUwQUFBQUlBQUFBQ1FGdmdHZGFHMTBlQUFBQlZRQUFBQVlBQUFBR0E3UUFUMXNiMk5oQUFBRmJBQUFBQTRBQUFBT0ErZ0NobTFoZUhBQUFBVjhBQUFBR0FBQUFDQUFDUUJZYm1GdFpRQUFCWlFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFHWkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVjlrWnZnUDVETXpNSUtFR1JFcS9nT0ZBZjlGRGlJQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUlMa01oaUttUy8rL3c5a3BVRlkvMmYvbi9qSEJLd1dEQUFDWnd3ckFBQUFlTnBGazB0dkcxVVV4K2VjTzU2eFp6eHo1M25Ic1ozeFkxNk9jTWFKSDJPYVRPdzREcVZwMmpTdHFvUUFTZ1dvR3hhb0NDRWhrSkQ0QW9BUUM3YnMrQXJkRjNYTlIrQkR0QktiaERzT0VYTm5kYzlkbk4vNS9ZOEF3dkgxQUQvSHY0UjlRUUJDUVpKMWtMdHhNb01SODVna3N4Yk1ZRTRDS2M2ODBReW0vSDdJUEIyQ09JbXphVHdBSFNtTU1pWWw4UHVPSVJyMXltSzd0d01RdWpFQjJxS1VoaDJ5bnRJSFB0cjBNWFYxZGhCczVBQUI0M1hEcDlTeWZLVmNmMWFVNGRlclYvZk4vYkd6SkhIZ3R6R1VFcldDSUI2N3Y3MDVKMTBaemk4YVNSeUYvNWRnTGQ3OFVleVdRZUFmQ3YzclRZemdsWkFLeTRLR2swZ3JFdDZ4SThrZUc3R01BOHc1WkFwSk5pMk9EeDZuNGcvSUhMS0VRMGx5TVFMbURZdW4ySGxSK2VxYndhWEkrelVaNkZiVDdEaDUwR1N5TnoxYVhDQlpVUFBvb2pmUlNOM1NYUGhsUU1CeHgvVmwyelZNaUJQL29GbVY0ZHVyeGVCRGdtNS92V1BicXErVUVOVG0ybGI3NDVFSTU2ZlBUMng2U0NCa0JnUER2UHJuSlZXalFJVGVKRjdzUDVwQzFLWWFad1BoNGZWYi9BNWZDOGNGR1cvWlIxbTYwZVZLUmJQWnlQTTVMei9jM3BqREZIaHhVc3lBaXR4WENwT3BQWU00dUpFN3paZ01pNVBta3p0M3gxVkFCKzJxcHBCbUs3ZlFWQ1R3VkRPWTlkNEZvdW1NSWJKZWZscWpKYnRkS1N0ZXhUSkxQNHRJdzRvQm9NdUgvUWp3ajZ2WG5SR1VCbU10emFYZFJxZGpkbkcrWnlGNld4NUx4Y0ZHVlcySEI4dHRkeHR4MldQcS9lL2pCbFhCMWhnZWFsUVJGVnFXUlZMbG5FZlhiK0Z2K0hObE1PVlJYQkU2TGVCQjVJRzhCU3lrRms1OXVIR2FwTGQvdk5LYUZSbE5NWU9YMXA2bGJ6S3pkcWZuRDh5K2lFM04yL3J5d1FjOGdWNG90dGJzOXp0SzNtNTdRUGFkVVdwVlBjQ2FZdlkrMjM1S01ISVplUEJEWFFOWlUwTXIwc3VpWGFuUDFvZk1Tc1ZKMmcxaXIxV3EyVkEybkMwOWJtQkYxNVZ3dlRZdzZEc2wyQmhHREdpM1VlUnk2L29OL3NSMzdFZzQ0MVFlYytSRVdwSHdlR1p6a2szR0sxRTZERGh5Z1ZQRTBxRkVjcVgvZ2xoc1drRTk1VFBnVStDTGVXdTNtQXVlZFQxdDFOaXBOZDQ3eTU4aEtEYVZrZHArVnkzSmlpb0JvOVhFNzg5QnBMSlh3bllXN0hXYVlYV1dsM2RLK09uQlhWOHVNUURwc2thZ0VRMGZvcmhkSDhNTEdXdGkrZmtua1g4cXd2aGVFRHphWGEvb2JoTmdQM1ZVUURTV1RkWUdHUGNWYzdGMldiZnJFNXp0RHI4ZUc1SFVPem42Z29oNVZUL0lLL2VpcHg4TlQ1QmM1b3VPVWVkUi9oZXF5SkxlZU5wallHUmdZQURpaGljbi84YnoyM3hsWUdaaEFJSEhBdk5lSXVqL3VrekhtQzRDdVJ3TVRDQlJBRzFGREpnQWVOcGpZR1JnWUdiNHo4REF3SFNNUWVmL0JhWitCcUFJQ21BREFHZmRCRjhDeGdBQUFqb0FTd0k2QUN3Q3JBQk5BaWdBU1FMQ0FEQUFBQUFBQUdZQTFBRklBYklDT2dBQWVOcGpZR1JnWUdCakNHZGdZZ0FCUmdZMEFBQUpud0JpZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzODtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUVlBQW9BQUFBQUJNd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFc5MG5HTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWV3RWdaMng1WmdBQUFXd0FBQUZNQUFBQmpQTndKSk5vWldGa0FBQUN1QUFBQUM4QUFBQTJLRVNBeFdob1pXRUFBQUxvQUFBQUhnQUFBQ1FHTndKMWFHMTBlQUFBQXdnQUFBQVFBQUFBRUFqOUFOWnNiMk5oQUFBREdBQUFBQW9BQUFBS0FOUUFpRzFoZUhBQUFBTWtBQUFBR0FBQUFDQUFDQUJOYm1GdFpRQUFBendBQUFET0FBQUJPQWQxS3Ixd2IzTjBBQUFFREFBQUFBd0FBQUFnQUFNQUFIamFZMkJtc21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcDZNdVF5Yy84SDhwbTVHZEhVL0FjS0F3REQ3d3o3ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVE4R2RJWmN2Ly9SN0QrNy9nLysvODBzRm93QUFEc2h3dVZBSGphVlZETFRzSlFFSjJaVzFvZ1dBU2xGZHRVYVdNTGlCQjV0TUJWRWhjU0l5cHE0a0lrU0dUamp4ZytEUk1TRXFJZjR0YUY0TVdObWtsT3ptTm1jUVlRUmdBd3BRa3dnSTJFazVnKzArU3JJVFFJeDFxV0tJN3ZVQUlPSFFEVVBVZFdkQzJsb2lKN3NtSmhVUEYxVFl5S3R1dTVmbEJFencvY1dnc0RYMjhoMDFhTzQ2NDJkWEVwNnhhV1JlNkpJUmFyY2xPU1RIeTYyRytFR0JYaWo4WlIzcTFLTko2TkdSbzVKWUZTMnFIaFpiRngvTEMwT1dFdDd3ajBlNlBtbXNwbzhESWdxUkJmTCtLOExTRUw1dzVQaDBTN3RPTW1pQ0poemJyaTNTN2Y1TnNSejJvYUIzV1JNbHVMTGo2d3lDdlZIM2hscHFsa3N0bE1WZzJSTENvRHdwMG9Ic00zMkJOQy9NTXZvZXVwcUtmKzBVcktGMTFFeGNCQ0ZyMW5xcFE4NDJYOEpiZnQzbmxUVHQ2YzlEbVdGblBNcHUyUXpWaS85dm1YempyWHhPcGJoazlzQ04vcnJEM3JlTnBqWUdSZ1lBQmlZODlmanZIOE5sOFptRmtZUU9DeHdMeVhDUHEvUGpNUDAzRWdsNE9CQ1NRS0FDTlVDbVFBZU5wallHUmdZT2IrendBazR4bmtHQVNaZVJpQUlpaUFCUUF1dndHMEFBQUNVQUFBQVM0QVl3SWdBQjREWHdCVkFBQUFBQUFPQUlnQXhnQUFlTnBqWUdSZ1lHQmg4R0ZnWmdBQlJnWTBBQUFJYlFCV2VOcE5qRDF2d2pBUWhwK29DVkxEd0lJNk1MUWVPbHRCWVdCaVlXQmlaV0lCN0tJTWNaQWRJaUZWSGZuZFBZd0h6dExwZVQvT1FNa2ZHWS9KbU1UOW1KeEMxSk1MeGt3VGowUjlKUzZaOGMwYldmNHV6aWVyeExrays4UUZIL3drSG9uL203aGt3WDNkdFpkcmI3M2Fkc1o2ZDJwRFdPNnNEMDNuMUZ4WFVXK3NzLzdRVzZPT04yV0dKZ3puVnRXNjBqVnJPbG91WE9teGVCUmJjVXhreDBteUlHL0pManFCUmxJbnJUbWE2aVhmU081aTV4Qi9NdEk1Y3BOdEdPUXF5RDVMVzFISFMwMzlEK3B0TURzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTMEFBb0FBQUFBQlZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwL21OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDV1oyeDVaZ0FBQVdRQUFBSHFBQUFDSFBUL0V6dG9aV0ZrQUFBRFVBQUFBQzhBQUFBMktFT0JsV2hvWldFQUFBT0FBQUFBSGdBQUFDUUdNZ0hkYUcxMGVBQUFBNkFBQUFBUUFBQUFFQXRaQUlKc2IyTmhBQUFEc0FBQUFBb0FBQUFLQVdJQXNHMWhlSEFBQUFPOEFBQUFHQUFBQUNBQUNBQTZibUZ0WlFBQUE5UUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVxQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c1k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQm1admdQNURORHBKSFUvQWNLQXdEekFBMUtlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2ak8vLzhEU2NmLy8vOGZBUE1aQUZLNUJwOTQyalhRejJvVFVSUUc4UHZkazduVEpKT1o2S1F6bGFaVDB2eVp0cEtrZElhWnRvc29qWWsxeGJRMlVJSUVnb0lXQkFVMVJoY3Vzb2dMUVZkQ1FWeTRjZWNEdUhIbHFnL2cxb1c0RWg5QmtuaEg2TG1idzhkZC9MN0RPQ3ZNWnZ3bi84R3FiSk94RUVHNGFkbG14dklDUzFTaHVpWFhEMndyQ0t2SXFTSmoyWUd0UStaUjdOVVFldlFGOTBRbUpWQ3p5dlBRbE1Gb1RrRXFhZm9VVjZlemRpcHJwZ2dwNWFTclFZdXYxTjcveVEzNWNScHhZekt5REZwU1FRUStaNmlBWnQ5dmpET0ZOTGloaXloT0dBTDVNeHd4T2NRdXp5WWsrRmZtc0hXMkphV21uM2VGdE9VY3pPdFFIZGpDZ0ZCejRyL1hqSEJCeWMyWGhFcm5POGtQM3FlM2krNlNZYURidTB1anpuNEgvSHI2NXJQcHU2eXU3emdmVC9zRGprcDl2R3dxajk3MGhweHY3SDFyeGdEOWtHOWY0SlJWd1cvdHRFNk1SSHQ3ZjFldnhhSUdNTkdnSjgzQ05RN2owdVF6UFc4WEQybjY2NkpJTUFibXpYNVRrbitQekNBZGVYblJLL0JMcmpSSFlOdEJLTThiQ1pmaHlBSXlyOEFOd3VoWnRtV0hzZzRscnBKSXhCVndIQjgwWG0wMEY0V0YyTXNicS8zQUw0dFlYRldvM0Z4N1hIL3hnYWpqdDU2T08ydXJZaytIeHMrbWYzVnBWbzNTN1FkQWZhdmJYK2lWaDNjNFZ0WXJ2WVVrd0xXSHUwVVBkRHA2UFdqNVJ4UXJGUFVEblJOai93QWQwbHIrQUFCNDJtTmdaR0JnQUdJTy9XYkhlSDZicnd6TUxBd2c4RmhnM2tzRS9mOGxNemZUWFNDWGc0RUpKQW9BRGw4S2R3QjQybU5nWkdCZ1p2alBBQ1E1R0ZUK1gyRG1aZ0NLb0FBV0FFcjNBeFVBQUFKMkFBQURBQUFrQXdnQUt3TGJBRE1BQUFBQUFGUUFzQUVPQUFCNDJtTmdaR0JnWUdHd1pHQm1BQUZHQmpRQUFBYVNBRU40MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02My45NzQ1NTgsLTYwLjQ0NzUwMSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuOTc0NTU4JyB5PSctNjAuNDQ3NTAxJz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDgxLjMxNDg3LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuOTc0NTU4JyB5PSctNjAuNDQ3NTAxJz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDAuMCwtNDUuMTc5MTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg1LjM1ODI2LC00NS4xNzkxMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguOTI5MTIsLTQ1LjE3OTExKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYzLjk3NDU1OCcgeT0nLTYwLjQ0NzUwMSc+QTwvdGV4dD4KPHJlY3QgeD0nLTYzLjk3NDU1OCcgeT0nLTU5LjI1MjA0OCcgaGVpZ2h0PScuMzk4NDg0JyB3aWR0aD0nNy40NzE5OTUnLz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzOC43NDc4OCwtODcuODU4MjMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuOTc0NTU4JyB5PSctNjAuNDQ3NTAxJz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0IDBINzYuMjU5MzInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzYuNTA5MzIsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MC4xOTAzOCw0LjE3MjkxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjk3NDU1OCcgeT0nLTYwLjQ0NzUwMSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNi40MDk4Mi02LjQwOTczTDMxLjc3MTctMzEuNzY4OTUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNCwtMC43MDcwNiwwLjcwNzA2LDAuNzA3MTQsMzEuNjgzMywtMzEuNjgwNTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00xMi43NTQ3NS0yNy4yMDYyMkgyOC4wOTQxN1YtMTQuMzExODFIMTIuNzU0NzVaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNS43NTQ3NSwtMjIuMTcyOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My45NzQ1NTgnIHk9Jy02MC40NDc1MDEnPs+RPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01OS4xNjM2MTYnIHk9Jy01OS4zOTAzNTQnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLS4zODQxNy02LjQwOTczQy0zLjAxNDQzLTM3Ljk4NjAyIDguMTYxNjUtNjEuNjk0ODQgMzEuMDkzNTQtNzcuNjEwMzUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC44MjE1LC0wLjU3MDEzLDAuNTcwMTMsMC44MjE1LDMwLjk5MDg0LC03Ny41MzkwOCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lam9pbj0nbWl0ZXInPgogPHBhdGggZD0nTTMuMzk3MTMgMEwuMjUgMS44NzQ5NFYwVi0xLjg3NDk0WicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xLjI2MDEsLTUzLjk3NzM0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjk3NDU1OCcgeT0nLTYwLjQ0NzUwMSc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTIuNDc0MTQtMzIuODgwNjhMNzguNTk3My02Ljc2MzIzJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjcwNzE3LC0wLjcwNywwLjcwNywtMC43MDcxNyw1Mi42NTA5NCwtMzIuNzAzOTIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTcsMC43MDcwMiwtMC43MDcwMiwwLjcwNzE3LDc4Ljc3NDEsLTYuNTg2NDkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTTUwLjU3MDM3LTI2LjkyMjlINzkuMjk4ODlWLTEzLjkyMjlINTAuNTcwMzdaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1My41NzAzNywtMjIuMTcyOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02My45NzQ1NTgnIHk9Jy02MC40NDc1MDEnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTIuMjI0MjE4JyB5PSctNjAuNDQ3NTAxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00OS4xMTA4NzUnIHk9Jy02MC40NDc1MDEnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ0LjQ0NDI5MScgeT0nLTYwLjQ0NzUwMSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Mi45NzMyLTc4LjUwNjY3Qzc3LjE5NjYtNjEuNjk0ODQgODguMzcyNy0zNy45ODYwMiA4NS43ODM5NC02LjkwNzk3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjgyMTUsLTAuNTcwMTMsMC41NzAxMywtMC44MjE1LDUzLjE3ODU5LC03OC4zNjQxNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuMDgzMDEsMC45OTY0OSwtMC45OTY0OSwtMC4wODMwMSw4NS43NjMxOCwtNi42NTg4NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODIuNDY1OSwtNTUuODI0NTQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjMuOTc0NTU4JyB5PSctNjAuNDQ3NTAxJz5oPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J000Mi42NzkxMi01My4yODg3MVYtNzYuNjE1MTknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCw0Mi42NzkxMiwtNTMuNTM4NzEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNDIuNjc5MTIsLTc2Ljg2NTE5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00zNy43OTE5Ni02OC44NTE5NEg0Ny41NjYyOFYtNTkuODM4MDVIMzcuNzkxOTZaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MC43OTE5NiwtNjUuODUxOTQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjMuOTc0NTU4JyB5PSctNjAuNDQ3NTAxJz5zPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    
    \begin {tikzpicture}[diagram,node distance = 3cm]
      \node  (1) {$A$};
      \node  [right = of 1] (2) {$B$};
      \node  [below = 1.5cm of 1] (1') {};
      \node  [below = 1.5cm of 2] (2') {};
      \node  [between = 1' and 2'] (3) {$\underline {A}$};
      \node  [below = 1.5cm of 3] (4) {$C$};
      \draw  [->,morphism] (1) to node {$f$} (2);
      \draw  [cover,morphism] (1) to node[desc] {$\vartheta _{f}$} (3);
      \draw  [cover,morphism,bend right] (1) to node[swap] {$g$} (4);
      \draw  [>->,morphism] (3) to node[desc] {$\mathsf {Img}(f)$} (2);
      \draw  [>->,morphism,bend right] (4) to node[swap] {$h$} (2);
      \draw  [>->,morphism] (3) to node[desc] {$s$} (4);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Since <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is extremal, <fr:tex
display="inline"><![CDATA[s]]></fr:tex> must be an isomorphism.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>624</fr:anchor><fr:addr
type="user">ct-000P</fr:addr><fr:route>ct-000P.xml</fr:route><fr:title
text="Equivalent condition for regular categories">Equivalent condition for <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular categories</fr:link></fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is regular iff it is cartesian and has <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">images</fr:link> that commute with pullbacks, i.e., the following diagram commutes up to isomorphism for any object <fr:tex
display="inline"><![CDATA[f \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="9892d173d9d5f1f32fe03188b157d0e5"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzNy44Mjg0NzNwdCcgaGVpZ2h0PScxMTkuNjk2ODYycHQnIHZpZXdCb3g9Jy03MiAtNzIgOTEuODg1NjQ5IDc5Ljc5NzkwOCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXOTBuR050WVhBQUFBRTRBQUFBTXdBQUFFUUFld0VnWjJ4NVpnQUFBV3dBQUFGTUFBQUJqUE53SkpOb1pXRmtBQUFDdUFBQUFDOEFBQUEyS0VTQXNXaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR053SjFhRzEwZUFBQUF3Z0FBQUFRQUFBQUVBajlBTlpzYjJOaEFBQURHQUFBQUFvQUFBQUtBTlFBaUcxaGVIQUFBQU1rQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQXp3QUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TXVReWMvOEg4cG01R2RIVS9BY0tBd0REN3d6N2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VROEdkSVpjdi8vUjdEKzcvZy8rLzgwc0Zvd0FBRHNod3VWQUhqYVZWRExUc0pRRUoyWlcxb2dXQVNsRmR0VWFXTUxpQkI1dE1CVkVoY1NJeXBxNGtJa1NHVGpqeGcrRFJNU0VxSWY0dGFGNE1XTm1rbE96bU5tY1FZUVJnQXdwUWt3Z0kyRWs1ZyswK1NySVRRSXgxcVdLSTd2VUFJT0hRRFVQVWRXZEMybG9pSjdzbUpoVVBGMVRZeUt0dXU1ZmxCRXp3L2NXZ3NEWDI4aDAxYU80NjQyZFhFcDZ4YVdSZTZKSVJhcmNsT1NUSHk2MkcrRUdCWGlqOFpSM3ExS05KNk5HUm81SllGUzJxSGhaYkZ4L0xDME9XRXQ3d2owZTZQbW1zcG84RElncVJCZkwrSzhMU0VMNXc1UGgwUzd0T01taUNKaHpicmkzUzdmNU5zUnoyb2FCM1dSTWx1TExqNnd5Q3ZWSDNobHBxbGtzdGxNVmcyUkxDb0R3cDBvSHNNMzJCTkMvTU12b2V1cHFLZiswVXJLRjExRXhjQkNGcjFucXBRODQyWDhKYmZ0M25sVFR0NmM5RG1XRm5QTXB1MlF6VmkvOXZtWHpqclh4T3BiaGs5c0NOL3JyRDNyZU5wallHUmdZQUJpWTg5Zm1mSDhObDhabUZrWVFPQ3h3THo3Q1BxL1BqTVAwM0VnbDRPQkNTUUtBQ2hBQ25nQWVOcGpZR1JnWU9iK3p3QWs0eG5rR0FTWmVSaUFJaWlBQlFBdXZ3RzBBQUFDVUFBQUFTNEFZd0lnQUI0RFh3QlZBQUFBQUFBT0FJZ0F4Z0FBZU5wallHUmdZR0JoOEdGZ1pnQUJSZ1kwQUFBSWJRQldlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3MxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFhkMGcyTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWRnRXlaMng1WmdBQUFXd0FBQUU2QUFBQlVDaUNiMmRvWldGa0FBQUNxQUFBQUM4QUFBQTJKMktCZ0dob1pXRUFBQUxZQUFBQUh3QUFBQ1FGTndGZ2FHMTBlQUFBQXZnQUFBQU9BQUFBRGdiRUFJRnNiMk5oQUFBRENBQUFBQW9BQUFBS0FQb0FobTFoZUhBQUFBTVVBQUFBR0FBQUFDQUFCd0F5Ym1GdFpRQUFBeXdBQUFEVEFBQUJQcWtyZGR0d2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtVW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb0dNNVF5Yy80SDhwazVHZEhVL0FjS0F3QzZhZ3pxZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVNDR1pJWVN2Ly9SN0Qrci91LzRIOGZXQzBZQUFEdWhndWlBSGphUFk2eFRzSlFBRVhmZlZVYUhRcXZEVFVJRmd0Q29RWXFKZkNDR2dpeEVURUdHalRCNktJNHFJbk9hdFROd2RGZmNEWHhFNWc3K2dPNk9EbTR1b0xQR0UzdWN1NGQ3aUVnaGZFSHh2U05MQkVDdVFoTGdXeGc1ajhDUTFtTEcrQjFjREgvSnZ0RHJvN1hjS0xYYUhWQTQ3SnVMM3FiS1RVTmVuUHNYbmpodFN0enZRUE1SdFJDbzdDUlhKRndmY2IzNkZNdmxnTnRPeWw3VW90TU15T2p0ZHpkMndrazg5dVZlVXI5aWxsU1ZCYWVNc3htczNzcHhRZ2hsT3lNdi9CSkF4SWhDVUkwVnY4ekV5YlJOTk9pT3RlclFrNVc4T2owaysxOUtwMTN5NTdxKzlhcWV5QkovWkxOYVRCNldZaEJ1ajg2dmFPd1ZFY1VEKzhlaFQ4WUNNMmMrQUhwaVo4aEFxSUtZT21LZ25RUm5KVlpTSGVybkdHNFpSM2FkUWMrblR0cEFjR29WakxqYU5iUUh6Mm5NbndaK1crbmRFQlNBQUI0Mm1OZ1pHQmdBT0xlZVJldngvUGJmR1ZnWm1FQWdjY0M4KzRqNlA4dm1MU1k3Z0s1SEF4TUlGRUFZQXdNV0FCNDJtTmdaR0JnNXZ6UHdNREFaTUdneTZEQytKOEJLSUlDbUFFL1lBS2NBQUlxQUFBQ09BQXRBaEFBVkFCU0FBQUFBQUFBQUZJQWhnQ29BQUI0Mm1OZ1pHQmdZR0V3WkdCaUFBRkdCalFBQUFXekFEcDQyazJPc1dyRE1CQ0dQMVBiVUxmUXFSMDZGRTBaaFkzN0FJVU1tYkptTENTUk1DNVlEcEpqOEZMNkFIbm9YQlFOdllPZlQvLzlkd2lvK0NYalZoa3ZVVytWVThycnpnVlB2Q1l1cFZYaWluZFdQSkRsaitKODhKVTQ1NW52eEFWdi9DUXV4ZjlMWFBISlpUME9wL05rdmRxT3hucDNIRUpvNnAzMW9SK2RhblI5TnpiV1diK2ZyRkdIUlptNUQzTTNxRmJYdW1YTnlNQ0pNeE1XTHovYmltTWlPNDR5QzlJTk5idm9CWHFaTzhrMWFISC9KemFTY0RHMWo5ZU1wQTRzb29aWjlvSm9KM2xGRzNjMTdSWCtDREQ3QUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWXlBbDJob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMmhPSnJQSDhObDhabUZrWVFPQ3h3THo3eURSTEtPTWRJTVhCd0FUaUFRQVN0QWwwQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUOEFBb0FBQUFBQmJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVXAxSTJOdFlYQUFBQUU0QUFBQU5RQUFBRVFBVndEL1oyeDVaZ0FBQVhBQUFBSW5BQUFDZUlZdzdoaG9aV0ZrQUFBRG1BQUFBQzBBQUFBMktKR0F1MmhvWldFQUFBUElBQUFBSGdBQUFDUUdsZ0pLYUcxMGVBQUFBK2dBQUFBVUFBQUFGQTQ3QVIxc2IyTmhBQUFEL0FBQUFBd0FBQUFNQVBRQnNtMWhlSEFBQUFRSUFBQUFHQUFBQUNBQUNRQkNibUZ0WlFBQUJDQUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUU4QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0U0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVowaGpadmdQNURORHBKSFUvQWNLQXdEMWd3MWRlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1VDBHWndZMHY3L0I3TWNRYXovbC80Zi9EOFByQllNQU9HNkMxQUFBQUI0MmtXU3pXc1RRUmpHNTVtWnptU1R1THZaSkxNbTJxU2JqYnRxUDZLSjNkall4cllXV2hKcmJYdW9GU0VYRVNvRkJSRUV2Nmg0MElzbkR4Njg5Q0FVYng2RjN2UWYwSjRVL3cxdmJlS3NJRjVtNW4wZmVQazl6N3dFNU5xQVVJTVJraWJFZ0pDVk1HaWlEVmRSOUYvdzR6a09pV2REbzV6U2c4TkZseFdaelQ3SEZ5R0VrdFpnd0dib1Q5SWdFU0ZOUk0yNmNyTTUxYWlyZkU3V0lDY3dxVWUxMFF3OUN5SmZRc05WcmdtdGlMQ05oaFk4ZG9CSHlZS1pvRGZWYU5yT3RXWmVKZ1ZzWTZ5SVF2L1hXbEpRUDVFU2dEVzBkU1BOWUNYR0x1MUNubnRNbHhUU21hUFhXWk9uOG1EZ1NMS01CREtKajgrZGxKRkxVV2JvbW5QWWxtUm45N0ZDQ0NPZHdTSGJwUHZFSStOa1NoTm5tMUZRZ3krQ3lQVkswR1JTbjBLalNpL3VxU2diTTBaQjZBZENzbjl2SnRTWFZ4eUdYVERMY0V3OHZIMFBiS2UzZGd0MDJWbC8wbjl3a21hT1RRM3Y3VzA5QloxY2ZsKzJoKzUvNk8wd3RKZCtkSkcrVGtlVUZHQzhJa0hYcHhmdU9NblZpOTA1czgyNHJ4MDRXR0RiODk0aWg2bU9QdEh0bFZxSDlyOUxIVGhJZDFDamQrazNNcXNMRm1OcTRrb1FSNmxjSmFRcTY1Kzd6UDc2aVdGMXZ4N243UWRoRURXMVU1TmFhRVJLaE5odDJkd3VHblBuVDdlQWFqN1EwWll0eTZwNmJIakN1bHFpV1d2VnlwdHEzajh6RGZoSzYzYkpzaHlubEV3VWU3R010LzJ2bmN6c2hkd1ZGdmlsRVZvVlljcWc0TjM4dTk4YlRGdmIyRHdSQnFlcS95VVVndkUzdkpLQVhwMC84UHhlZXdCNDJtTmdaR0JnQUdLdGdwamo4ZncyWHhtWVdSaEE0TEhBdlBzSStqOERjeVF6aU12QndBU2lBQnJHQ2E0QUFBQjQybU5nWkdCZ1p2alBBQ1JMR0t6K1gyQ09aQUNLb0FCV0FGMUlBK1lBQUFMR0FBQUNWd0JPQTNBQU9nTjBBRW9DT2dCTEFBQUFBQUFlQUhZQTFnRThlTnBqWUdSZ1lHQmxjR1JnWmdBQlJnWTBBQUFIZFFCTWVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktENkJsV2hvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRyWlB2b254L0RaZkdaaFpHRURnc2NDOCt3ajYvMTltTnFhN1FDNEhBeE5JRkFCQ2dRdWRBSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMko3aUF1MmhvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaXp4dEVyOGZ6MjN4bFlHWmhBSUhIQXZQdUkrai9ERXdOekNBdUJ3TVRpQUlBUW8wS3BnQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVjQUFBQmdpRTl5Qm1OdFlYQUFBQUU4QUFBQUtRQUFBRFFBREFDV1oyeDVaZ0FBQVdnQUFBQ3lBQUFBdUxXMVQ1Vm9aV0ZrQUFBQ0hBQUFBQzhBQUFBMktGU0JkV2hvWldFQUFBSk1BQUFBSGdBQUFDUUZTUDlBYUcxMGVBQUFBbXdBQUFBSUFBQUFDQVUzQUFsc2IyTmhBQUFDZEFBQUFBWUFBQUFHQUZ3QUFHMWhlSEFBQUFKOEFBQUFGd0FBQUNBQUJBQTVibUZ0WlFBQUFwUUFBQURUQUFBQlBxODNkZUZ3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1tczA0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpuQm1sdnFqeWNEQUxNVjhIVlhOLy84TURBRDJmdzVFQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnVWdEUUxFSUw0enYvL1E4ai8rOEI4QmdCU3dRYWZBQUFBZU5wallHVGcvUCtjU1pucE1vTTVBNE1xR3pzSUtxbXBxOWt6bXBtYmdRa3hjVForUmo1R2RqWjFjenRHY3pWMklCT0k1QmlCUEtBOFdBbmpIMFlUQlgyditLZ01SbVp4RnNsUWxVRDI0SHc1WXlabWNSVXVIUUZ1Um5adVZTWW1PNzk0UlEwalJxWTBkMk5YQ1g1MmZuNWVmczZGd2lZS3NvYXNGWVZhOFh6SnVYb216RVlzakpLYTZnYXVmQktNVEp6OHdvR3k1a3lNTGtiMkN6eUtzeGdaZFZWRk9MZzQyQmdaR1JnQTVVd2JQQUFBZU5wallHUmdZQURpbEpuS21mSDhObDhabUZrWVFPQ3h3THo3Q1ByL2MyWVpwc3RBTGdjREUwZ1VBQ1pHQ3ZZQWVOcGpZR1JnWUpiNm93a2taUmc0Ly85Z1VtWUFpcUFBSmdCVzZRT0xBQUFESEFBQUFoc0FDUUFBQUFBQVhBQUFlTnBqWUdSZ1lHQmlzR0FBMFF4UUVna0FBQVlWQUQ0QWVOcE5qckZxd3pBUWhqOVR4MUFua0trZE9oUk5HWVdOOHdDRkRKbXlaaXdra1FnT1dBNlNZL0JTOGdCOTZGNFVEVDNCOGVtLzc0U0FraDh5SHBXeGpQMVJPWVhjbmp4anpsdmlRbzVLWFBMQmloZXkvRldTVDc0UzV5ejRUanpqblV2aVF2Sjc0cEkxdjV1K3U5NEc2OVd1TjlhN1V4ZW11dHBiSDlyZXFWcFh6MkJybmZXSHdScDFuSlFaMnpDZU85WG9TamRzNk9tNGNtUEE0dVZuTzBsTVpNZEpab0dKbW9wOXpBS3R6SjE0TlZyUy84WldEQmV0UTN6TmlIV1VtUklhWlM5SVA0dXZhT0t1cHZrRENWRXhFd0I0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3MxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5MTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTYuOTE0MTUxLC02MC40NDc1MDEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOC4xMjI3NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTYuOTE0MTUxLC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU2LjkxNDE1MScgeT0nLTYwLjQ0NzUwMSc+QzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNTEuNjY4NTI5JyB5PSctNTguNjQ4Njc0Jz4vQjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNy43MjI5MywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01Ni45MTQxNTEnIHk9Jy02MC40NDc1MDEnPkM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUxLjY2ODUyOScgeT0nLTU4LjY0ODY3NCc+Lzx0c3BhbiB4PSctNDguMDE1NTQxJz5BPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOS45NjUzVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMi4xMjg1NCwtMzEuMDYzODcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ni45MTQxNTEsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNTYuOTE0MTUxJyB5PSctNjAuNDQ3NTAxJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01Mi4yNDc1NjYnIHk9Jy02My40NTQwMTgnPuKIlzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MS4wMjg3NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTYuOTE0MTUxLC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU2LjkxNDE1MScgeT0nLTYwLjQ0NzUwMSc+U3ViPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy00MS4wODQ1OTUnIHk9Jy02MC40NDc1MDEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM3LjIxMDIyMicgeT0nLTYwLjQ0NzUwMSc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjkuMTUzNjEzJyB5PSctNjAuNDQ3NTAxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQxLjMyMjE0LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTYuOTE0MTUxLC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU2LjkxNDE1MScgeT0nLTYwLjQ0NzUwMSc+U3ViPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy00MS4wODQ1OTUnIHk9Jy02MC40NDc1MDEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM3LjIxMDIyMicgeT0nLTYwLjQ0NzUwMSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjkuNzM4MjIzJyB5PSctNjAuNDQ3NTAxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMi42NzgzIDBIMzUuOTczMicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzNi4yMjMyLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTguNjc4NTQsNC4xNzI5MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01Ni45MTQxNTEnIHk9Jy02MC40NDc1MDEnPkltZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS04LjkwOTczVi00Ny40OTU3NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ3Ljc0NTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMzAuMjAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ni45MTQxNTEsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNTYuOTE0MTUxJyB5PSctNjAuNDQ3NTAxJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01Mi4yNDc1NjYnIHk9Jy02My40NTQwMTgnPuKIlzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTIuMjc4NDctNTYuOTA1NUgzNi4yNjY2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM2LjUxNjYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE4LjYyNTM0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01Ni45MTQxNTEnIHk9Jy02MC40NDc1MDEnPkltZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = {{\mathcal {C}}_{/{B}}},
    sw = {{\mathcal {C}}_{/{A}}},
    ne = \mathsf {Sub}(B),
    se = \mathsf {Sub}(A),
    north = \mathsf {Img},
    south = \mathsf {Img},
    west = f^{*},
    east = f^{*},
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>625</fr:anchor><fr:addr
type="machine">#273</fr:addr><fr:route>unstable-273.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>626</fr:anchor><fr:addr
type="machine">#271</fr:addr><fr:route>unstable-271.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a cartesian category with images that commute with pullbacks.
      Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be a morphism and <fr:tex
display="inline"><![CDATA[g\colon B'\twoheadrightarrow B]]></fr:tex> be a cover.
      Then note that <fr:tex
display="inline"><![CDATA[\mathsf {Img}(g)]]></fr:tex> is an isomorphism.
      Since images commute with pullbacks by hypothesis, we can form the following diagram.</fr:p>
    
      
      <fr:figure><fr:resource
hash="4e5db82e019319cb38e7835be65c8ff7"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIxMC4zODc1MjdwdCcgaGVpZ2h0PSc5Ny45OTk5NXB0JyB2aWV3Qm94PSctNzIgLTcyIDE0MC4yNTgzNTEgNjUuMzMzMyc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXOTBuR050WVhBQUFBRTRBQUFBTXdBQUFFUUFld0VnWjJ4NVpnQUFBV3dBQUFGTUFBQUJqUE53SkpOb1pXRmtBQUFDdUFBQUFDOEFBQUEyS0VTQXhXaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR053SjFhRzEwZUFBQUF3Z0FBQUFRQUFBQUVBajlBTlpzYjJOaEFBQURHQUFBQUFvQUFBQUtBTlFBaUcxaGVIQUFBQU1rQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQXp3QUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TXVReWMvOEg4cG01R2RIVS9BY0tBd0REN3d6N2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VROEdkSVpjdi8vUjdEKzcvZy8rLzgwc0Zvd0FBRHNod3VWQUhqYVZWRExUc0pRRUoyWlcxb2dXQVNsRmR0VWFXTUxpQkI1dE1CVkVoY1NJeXBxNGtJa1NHVGpqeGcrRFJNU0VxSWY0dGFGNE1XTm1rbE96bU5tY1FZUVJnQXdwUWt3Z0kyRWs1ZyswK1NySVRRSXgxcVdLSTd2VUFJT0hRRFVQVWRXZEMybG9pSjdzbUpoVVBGMVRZeUt0dXU1ZmxCRXp3L2NXZ3NEWDI4aDAxYU80NjQyZFhFcDZ4YVdSZTZKSVJhcmNsT1NUSHk2MkcrRUdCWGlqOFpSM3ExS05KNk5HUm81SllGUzJxSGhaYkZ4L0xDME9XRXQ3d2owZTZQbW1zcG84RElncVJCZkwrSzhMU0VMNXc1UGgwUzd0T01taUNKaHpicmkzUzdmNU5zUnoyb2FCM1dSTWx1TExqNnd5Q3ZWSDNobHBxbGtzdGxNVmcyUkxDb0R3cDBvSHNNMzJCTkMvTU12b2V1cHFLZiswVXJLRjExRXhjQkNGcjFucXBRODQyWDhKYmZ0M25sVFR0NmM5RG1XRm5QTXB1MlF6VmkvOXZtWHpqclh4T3BiaGs5c0NOL3JyRDNyZU5wallHUmdZQUJpWTg5Zmp2SDhObDhabUZrWVFPQ3h3THlYQ1BxL1BqTVAwM0VnbDRPQkNTUUtBQ05VQ21RQWVOcGpZR1JnWU9iK3p3QWs0eG5rR0FTWmVSaUFJaWlBQlFBdXZ3RzBBQUFDVUFBQUFTNEFZd0lnQUI0RFh3QlZBQUFBQUFBT0FJZ0F4Z0FBZU5wallHUmdZR0JoOEdGZ1pnQUJSZ1kwQUFBSWJRQldlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBL1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBtbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDOEFBQUEwRThPekgxb1pXRmtBQUFDSUFBQUFDNEFBQUEyS0lxQXoyaG9aV0VBQUFKUUFBQUFIZ0FBQUNRRkxBSzRhRzEwZUFBQUFuQUFBQUFLQUFBQUNnWGZBSnBzYjJOaEFBQUNmQUFBQUFnQUFBQUlBRFlBYUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBZ2JtRnRaUUFBQXB3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBZElsRE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaSmoxbjRIeE9ETURneHdEQXlNZkl6dWJ1QmdZaXJBcHFlc3hxcXVwbTVuYk1acWJHWW1Kc2pFZUNXcGxaVmJpNE5LdDRHQmtrM0pVOUZLd1pXR3hWZkJTZEpSaVkyUjZidloxVDJ5bGhIaFZLZ3NYQzVlSmJKUnR3WW9WaGJhUnNpWmNMSndNUU1ESWtBeTBhd0xRTG1rZ2g0MGRaSnVhUHFNSjJBSWhOWFUxSUVOY2psRmNqSEVDMUZSbUpsYjFjRFZUeHJSaWRtWm1pSVdNREJBekdWazVPRmhrazhPYUdLVit4M0p6c3pLQ0xRUUFFYU1qajNqYVkyQmtZR0FBNHYzS1Q2cmorVzIrTWpDek1JREFZNEY1THhIMGZ3Ym1JR1lRbDRPQkNVUUJBRFFRQ2o4QUFIamFZMkJrWUdCbStNOEFKSU1Za2htU0dZOHpBRVZRQUJNQVJza0M2Z0FBQTFJQUFBSXFBSm9BWXdBQUFBQUFBQUEyQUdoNDJtTmdaR0JnWUdhUVp3RFJERkFTQ1FBQUE3OEFKZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSUUFBb0FBQUFBQk9RQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoWUYxUUdOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDNloyeDVaZ0FBQVdRQUFBR1NBQUFCdkdFMGJ6OW9aV0ZrQUFBQytBQUFBQzhBQUFBMktJeUF6bWhvWldFQUFBTW9BQUFBSGdBQUFDUUdMUUpQYUcxMGVBQUFBMGdBQUFBTUFBQUFEQWpkQU9Cc2IyTmhBQUFEVkFBQUFBZ0FBQUFJQUhJQTNtMWhlSEFBQUFOY0FBQUFHQUFBQUNBQUJnQktibUZ0WlFBQUEzUUFBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUVSQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0rc0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSTVkwaG5admdQNURORHBKSFUvQWNLQXdBR2hBMnhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2anAvLzhEeWJULy8vL1BCdk1aQUZXeEJzTjQyaVdQUVc3VFFCaUY1ODI0NDhTSlBYWnNqOTJRaEdiYzJFMlZ4RkhjMmlwVU5sQlZSRFJJYlhkSUNLbENzQ2l3N0lvMUcxaDB4NXBid0FWNkFnN0JJWkJhWXFyL0xYN3BmWXYzRVpEUGQxTjZRMytUSlNGZ0FseTNvUE00S1pISndPTzZmSWdTUlY0aEx5SWU3Ky9sUVZiLy8wOEdGcUk0aWZNaVRxRjBMcERsMHRPNWpqOEhadFBwZHA1TzFVdUdzYi9MUEY5WWJuOTd3K24wbk5ZcjAvWEVHNHRyWWNPTXpuWmVyQkc1eTlBZTJNTHRCa1k3L0dSNkRhYmgyKzNQVWgyT3V4bUZtaW5GRW1kbzZLQTA5NnZMSDVlUHdFMnZpZFBoMXA3dHBCcTJKelhDRTZ0QkVkclZOZmhtaTRFUVFzbTd1d245aWhzeUkwZTE1WG8xVDFFN0xxUi83eWhMV21GdFBrTnlMN2VRUVY0TTRPdEZYcVByeW9JL1FGSFdvVjgrZXRjZjB2MVdwbUcwa0laTjFUU29ub2M4N0t3V0orOHBPM1k2cHhmcXlhYWpYUGY3Rkw0V0hJNlhzdCtqQjFzN3gzMnJpYXZiMWNtU05sazc3WSs2b3RFVEd4UXc1dlBlaFQyaWVIMytkdVdLWit5QlNnRGYrdnZMaUxqU01JL1NxK0hqQ1pEMGhTRC9BTmRmUFJnQUFIamFZMkJrWUdBQTRrYnI1T2g0ZnB1dkRNd3NEQ0R3V0dEZVN3VDlYNGM1aE9reWtNdkJ3QVFTQlFBZFN3cDRBSGphWTJCa1lHQm0rTThBSkVNWVV2OS9aenJLQUJSQkFjd0FhU1lFZ1FBQUExUUFBQUs4QUhzQ3pRQmxBQUFBQUFCeUFONTQybU5nWkdCZ1lHYndaR0JpQUFGR0JqUUFBQWZ3QUZGNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFQQUFBb0FBQUFBQkV3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wbTJOdFlYQUFBQUU0QUFBQU1nQUFBRHdBWkFCeVoyeDVaZ0FBQVd3QUFBRDRBQUFCR0pKQnA3Vm9aV0ZrQUFBQ1pBQUFBQzBBQUFBMktIQ0EwR2hvWldFQUFBS1VBQUFBSGdBQUFDUUdnZ0xRYUcxMGVBQUFBclFBQUFBUUFBQUFFQW5uQVFWc2IyTmhBQUFDeEFBQUFBb0FBQUFLQUx3QVlHMWhlSEFBQUFMUUFBQUFHQUFBQUNBQUJ3QWNibUZ0WlFBQUF1Z0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQUR0QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1OZ3lNL3dIOHBraDBraHEvZ09GQWMyQ0RNNEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEthakxZL3Y4UDVHdUE2UDgzL3g4RHF3SUNBSXl6Q05BQUFIamFZMkJrS1BuUHlOakF6TUFneGNEQUtDNG13czdHejhqR3ppWUdaUEl6cXFrRG9ibWFQYU1aWXc0dk83dWpGYnNsTTJOWUdoYzdiNnNwSDdjcUU1TXVueGt6QXlPVEFKdEpqa0Roc2Q2ZnNad0NUSXhKdFlvS3RjbEZ6YXBOUUNNWlBJRG1oMERNRndhYUtpN0dMc0xHenNlb1ptNWl6MmpIYUs3SHFLNW1hbVllMDJJR01sQlR5U3hQbXBHWlB5U0drYm5RalpPUmpaa0JZbHJVUW9mRVpDWXVaaFpCbi9jTGp6eTE0bUxqWkdJQUFpWUdUNFl5Wmd2R2JnWnVCbkdnZFlwc2FpWm00b3BtWWtCTGtOak1RbjlqZVNVbGVaaVc4Z0RKdjlGQWtwZHBNVkNFTVlLUlE0V0RFVVE4Z0xNWUdBQU5NQ3dSZU5wallHUmdZQUJpalNLdDZuaCttNjhNekN3TUlQQllZTjVMQlAyZmtkbUNHY1RsWUdBQ1VRQUZsZ2trQUFBQWVOcGpZR1JnWUdiNHp3QWtteGc4R0R5WkxSaUFJaWlBQlFBOGR3SmFBQUFDMHdBQUFja0FkQUhKQUVnRGdnQkpBQUFBQUFBd0FHQUFqQUFBZU5wallHUmdZR0Joa0daZ1lnQUJSZ1kwQUFBRGpRQWtlTm85akRHcndqQVVoYjlpRmUwYkhBU0hOMGp3QjRSS0g3aTRPVGk1T3J6Tm1pQWRta3BhaXk3aVQvYzJCRy9nOE4xenpnMlE4U0pobUlSNTBHRlNlZlBJWTM1WVJKNkl2NHFjOGN1YUVVazZFMmZGTG5MS2xQL0lZNWFVa1NmaVB5Sm4vUEhlTi9YdDNsbXZqbzJ4M2wxcXZ6MVozMWFOVXh1ZEQrdkJPdXZQblRXcWZDclRWMjEvclZXaGMxMndwNkhteHAwT2kwZHhGTWNFZGx3azgydzVoYjJsa3N4Slo0TW0vNllIU1Yxb25NTXZSaG9sVDFGREx6ZXQ2Rlc2aWlMY2FZb1BXS3d1U3dBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWXlBcTJob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMmhNSmQrUDViYjR5TUxNd2dNQmpnWGt2a1dtV1VNWTdRSXFEZ1FuRUF3QTRuQXBmQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVWUFBb0FBQUFBQmZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0TldOdFlYQUFBQUU4QUFBQU1nQUFBRHdIVGYxYVoyeDVaZ0FBQVhBQUFBSklBQUFDdVBPMnY1Tm9aV0ZrQUFBRHVBQUFBQzhBQUFBMkovNkF6V2hvWldFQUFBUG9BQUFBSUFBQUFDUUZ2Z0diYUcxMGVBQUFCQWdBQUFBUUFBQUFFQW44QUtkc2IyTmhBQUFFR0FBQUFBb0FBQUFLQWNJQTFHMWhlSEFBQUFRa0FBQUFHQUFBQUNBQUJ3QllibUZ0WlFBQUJEd0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1WOWtadmdQNURNek1JS0VHUkVxL2dPRkFRSGZEaWtBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZelgvei9IOGhQQTlIL1ovOHhBcXNDQWdDbFV3bWxBQUI0MmtXUndXN1RRQlJGL1dhY21TUk9QSFpzajF2SGRaTTR0b09VSm0zaU9GSXdTWndBYWlpMFJVS3RDaWdWU04yd1FKVVFFdUlqUUVJczJQSVo3UHNEZkV3WGJGckdGUkx6ZG5QZmsrNjVWd0xwNExhUDNxSGYwbHlTQURNZ1ZBWGFDcU1wRExuTkNlWGJNSVVaOWttWTJNTXBqTVgvZ05zcStHRVVKdU93RHlwaU1FdzRpZURuUkpNMXA1VHRkU1lBYlN2RXdMWVpZKzBtM3VxeHB4NHkySE5tcVh6aDMwc0JmQzUweldPc1Z2UEtSZWM4bCtIN3pkVVRmUjZiU3h6NlhnTzFTYVNVRU1nSDFvL3JVOXlpY0hwV2o4S2cvVitDelhEbmk5d3FnaVFla3JxM095aUFLNmtuTFhNYVFVTHVTSVJqazFDYkQza2lBR1lDc2dkUk1zN0hBMXRRaVFVOGd5UVNVSVRtRVhCN2tLK2k1bVhwdzZmK1doWitkUTVxemRXYlp1cTduTnJqVlhhR2NNYjAxVmxuVk1WT3JXckJ0ejRHMDRxZFpjUFNkQWdqYitGV0tIeSt5Zm92TWJLNlcwM0RVTHh5QVlIaWJ1NDJYZzlsT0QyK09EVFlRd3h0cm5IUTlKcy92NWdTK0RKMFJtRTJQeHBEMEdEVk83YmQyMnYwVmZTMGtrNEVtODFOR3VWV1NZNll6SEF5aXNOSUFLdlFoeDdrM25NMGsyRmlrWDh3ZVZ0NUhHTlJyTTJwS0ZjRWNIY2tTdWJvcEdWWGgvWEpSdjNSU1hxT29Hd3dpcGpodFpRQ0xTc0VPS3RFWG5jR01xTjJBVFVTLzBIVGJWZW1hWEZTUUc4WGp6MWE0QUJrdllHaEhneWVJWG5QaWVHU29nMjVlUEVtOEk1bGlQZDkvK2orVmttMVhJQjV6MVFBSVczcDhnWkEzQzNyMmViYU1ad1JtdDRmZkl5MWdIUU9WKyt4bkZiVVJWcmFEMTY4R2h3aXZFNnpwdWFJT1A0QzByVmN1SGphWTJCa1lHQUFZczhqZTduaitXMitNakN6TUlEQVk0RjVMeEgwZjEybVkwd1hnVndPQmlhUUtBQXpEUXREQUhqYVkyQmtZR0JtK00vQXdNQjBqRUhuL3dXbWZnYWdDQXBnQVFCbjJ3UmRBc1lBQUFJNkFFc0NPZ0FzQXNJQU1BQUFBQUFBWmdEVUFWd0FBSGphWTJCa1lHQmdZUWhuWUdJQUFVWUdOQUFBQ1drQVlIamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b0NDeGRXRmdZbVhxQXRoRkdXd2pKMFJDcWpyMmQvZGhQUFFOVitkKzJFRE5Ed1gzSzVnbHZWOUpKZTdCRlZQbW1TZmkzakxYTEhqbmlhSjhsdVNWajh5bE5KK1pLMTc0eWp5Ui9EdHp6WXJmVFhDWDYyQ2oyZ1Zqb3o4NTE2MzNOdlpkOEdxcG0rUzMxdHQ0R0t4Ung1c3lZOWVQWjZkYTNlaVdEUUhIaFNzRGxvaGlKNGxKN0RsSjUraFlzMDlKTHh3a1Z5elJOUC82cmZRK2JRN3BKeU9iSXpkUnd5aUxYdlFzVzBXYlhtcmFQOHVoTC9jQUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRTBBQUFCZ3FvWmlPV050WVhBQUFBRkVBQUFBTXdBQUFEeWVOV1NsWjJ4NVpnQUFBWGdBQUFDb0FBQUFzTkZjOEl0b1pXRmtBQUFDSUFBQUFDMEFBQUEyS01pQkMyaG9aV0VBQUFKUUFBQUFIZ0FBQUNRR2x2L2thRzEwZUFBQUFuQUFBQUFNQUFBQURBaHpBSUJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBRGdBV0cxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBamJtRnRaUUFBQXB3QUFBRE9BQUFCT0JOL0tydHdiM04wQUFBRGJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzZzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUFCQmdZSEdEdWx1Q3lkZ1UzSjVvRUJzK0lmSXdZR1prWG1jMEJoUm9UcS8vOFpHQUExM3crL0FBQUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVptUmdVcko1WVBEL1B3TURoTDU3VlA0U1dCVVFBQUNzQkFuWEFIamFZMkJrOEdjb1ozWm03R1JRWkdCZzVHTmsxMk5XQjVJaWJPeHNhdXAyak9aeXpPSkEwc1RNM0V3TXFDbzF3am94SU16Y3c1K1pqWWVabDVFeEpjSW1JU2pNMUNPQW1ZMmJtWTh4SWJLSGhjbmUzNXFSSmNtYVI1YVJrVmNHU1lCYkRpakF3TWhneUtET2FNSmt3OEFIdEkrWlRZOVIzVndZWkEranVCaWo1a0YyQVRrbTFuWVdDVmtKWlVZbXhzZi9Ja1NZZWJrRUdIZnpLVEl5eWtseU1BQUFZL0VZbUhqYVkyQmtZR0FBNGx2T1p3UGorVzIrTWpDek1JREFZNEY1TDVGcDVvbE1Oa0NLZzRFSnhBTUFLVk1KdEFBQUFIamFZMkJrWUdCVy9HTUVKQ2N5R0RMSU1qc3pBRVZRQURNQVFtQUNnQUFBQTVFQUFBT1JBRThCVVFBeEFBQUFBQUE0QUZoNDJtTmdaR0JnWUdaUVlnRFJERkFTQ1FBQUJBb0FLUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE5UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MDRXTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ1VaMng1WmdBQUFXUUFBQUNvQUFBQXFML3NEZVZvWldGa0FBQUNEQUFBQUM4QUFBQTJLQm1CcTJob1pXRUFBQUk4QUFBQUhRQUFBQ1FHQndJaWFHMTBlQUFBQWx3QUFBQUlBQUFBQ0FWMkFDUnNiMk5oQUFBQ1pBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSnNBQUFBRmdBQUFDQUFCUUEwYm1GdFpRQUFBb1FBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtMnMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJrWnZnUDVETkRwSkhVL0FjS0F3RG85dzB0ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlPLy85RHlQOEh3SHdHQUZLWEJwMEFBQUFBQWdBay8vOEM0UUxkQUM4QU1nQUFOd0UyTnpJV0Z4TVVGak0yRmdZdkFRY25KaWMwTmhjV05qY3ZBU0VIQmhRV0Z6WVhEZ0V2QVFjbUp6UTJNejRCTnpNRHR3RmxCaFFOQmdFK0ZpMFZBUXdGZElBSUJRRU5DeE0wQXdrSC92OU9EUndURFFNQkRRVm5XQXdCREFraVBwbnJJWFlDVmhBQkNRLzlnQllQQXgwSEFRTURBUUlJRHdjQkFRd1haa1dFRkNRUUFRSVBEZ1lCQXdNQkNnOEdBU1BJQVZJQUFBQjQybU5nWkdCZ0FPS0c1N09MNC9sdHZqSXdzekNBd0dPQmVTOFI5UC8vVEErWjdnSzVIQXhNSUZFQVhPY00zQUI0Mm1OZ1pHQmdadmpQQUNJWlZCamttUjR5QUVWUUFCTUFOWXdDTUFBQUFBSjJBQUFEQUFBa0FBQUFBQUJVQUFCNDJtTmdaR0JnWUdJd0JtSVFZR1JBQXdBRnJ3QTZBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNyB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjIuNTc3MDEyLC01OS4xNzU4NzIpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4xNTI3OSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC01OS4xNzU4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTU5LjE3NTg3Mic+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTUuMTA1MDEzJyB5PSctNjIuNzkxMjM2Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzYuNDg4MywtNDIuNzM4MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNTkuMTc1ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy01OS4xNzU4NzInPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzUuMzIzOCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC01OS4xNzU4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTU5LjE3NTg3Mic+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTUuMTA1MDEzJyB5PSctNjIuNzkxMjM2Jz7ugLA8L3RleHQ+CjxyZWN0IHg9Jy02Mi41NzcwMTInIHk9Jy01Ny45ODA0MTknIGhlaWdodD0nLjM5ODQ4NCcgd2lkdGg9JzEwLjI2NzA3MScvPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDExNC40MDkzMywtNDIuNzM4MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNTkuMTc1ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy01OS4xNzU4NzInPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU1LjEwNTAxMycgeT0nLTYyLjc5MTIzNic+7oCw7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002LjQwOTQyLTYuNDA5NzNMMzEuNjQ1MzYtMzEuNjQxNzQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNCwtMC43MDcwMywwLjcwNzAzLDAuNzA3MTQsMzEuODIyMTQsLTMxLjgxODUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjMyNjg3LC0yNy4zNTg0NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNTkuMTc1ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy01OS4xNzU4NzInPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU3LjkxMDQyOCcgeT0nLTYyLjE4MjM4OSc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy01My43NDU0NTknIHk9Jy01OS4xNzU4NzInPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUwLjYzMjExNicgeT0nLTU5LjE3NTg3Mic+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNDYuNDk1MTY1JyB5PSctNTkuMTc1ODcyJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINjYuOTk2MTQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjYuODcxMTQsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjguOTI4NzcsNS40NDkzMSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNTkuMTc1ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy01OS4xNzU4NzInPs+RPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01Ny43NjYwNzEnIHk9Jy01Ny43OTM1NTknPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTUzLjc3MDYwMScgeT0nLTU5LjI2MDI4Nyc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy00OS42MDU2MzInIHk9Jy01Ny43OTM1NTknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQ2LjkwNzM3NycgeT0nLTU3Ljc5MzU1OSc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNDMuMjM4ODInIHk9Jy01Ny43OTM1NTknPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTcwLjUxMTY2LTkuOTY1MDdMNDguODMxMjUtMzEuNjQxNzQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNSwwLjcwNzAzLC0wLjcwNzAzLDAuNzA3MTUsNzAuMzM0ODcsLTEwLjE0MTgzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC43MDcxNSwtMC43MDcwMywwLjcwNzAzLC0wLjcwNzE1LDQ4LjY1NDQ2LC0zMS44MTg1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00zOC42MTY3NC0yNi43MDI0Mkg4MS45MjgzMlYtMTMuNjA4MjdIMzguNjE2NzRaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MS42MTY3NCwtMjEuOTUyNDIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTU5LjE3NTg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNjIuNTc3MDEyJyB5PSctNTkuMTc1ODcyJz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTUwLjgyNjY3MycgeT0nLTU5LjE3NTg3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDcuNzEzMzMnIHk9Jy01OS4xNzU4NzInPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQzLjA0Njc0NicgeT0nLTYyLjE4MjM4OSc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zOC44ODE3NzYnIHk9Jy01OS4xNzU4NzInPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM1Ljc2ODQzMycgeT0nLTU5LjE3NTg3Mic+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzEuNjMxNDgzJyB5PSctNTkuMTc1ODcyJz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004OC44ODY4NC04LjQwOTZMMTExLjQzNzczLTMwLjk1NzIzJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTQsLTAuNzA3MDMsMC43MDcwMywwLjcwNzE0LDExMS42MTQ1MiwtMzEuMTMzOTkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTTk0LjIxNDA3LTI1LjExMDE3SDEwNi40NjQwN1YtMTQuMjMzMDdIOTQuMjE0MDdaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5Ny4yMTQwNywtMjEuNjEwMTcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTU5LjE3NTg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjIuNTc3MDEyJyB5PSctNjAuODU4MTE2Jz7iiLw8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTYyLjUyMTY2MycgeT0nLTU4LjY3Nzc0Jz49PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwNy42NTM4LTQwLjIzODNINDkuMDQzODQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA3LjQwMzgsLTQwLjIzODMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDQ4Ljc5Mzg0LC00MC4yMzgzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC41NDMwMywtNDguMzk0MjYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTU5LjE3NTg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctNTkuMTc1ODcyJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01Ny45MTA0MjgnIHk9Jy02Mi4xODIzODknPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTMuNzQ1NDU5JyB5PSctNTkuMTc1ODcyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01MC42MzIxMTYnIHk9Jy01OS4xNzU4NzInPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzguODgxNzc2JyB5PSctNTkuMTc1ODcyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0zNS43Njg0MzMnIHk9Jy01OS4xNzU4NzInPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTMxLjYzMTQ4MycgeT0nLTU5LjE3NTg3Mic+KSk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \node  (1) {$A'$};
        \node  [below right = of 1] (3) {$A$};
        \node  [above right = of 3] (2) {$\underline {A'}$};
        \node  [below right = of 2] (4) {$A''$};
        \draw  [->,morphism] (1) to node[swap] {$f^{*}(g)$} (3);
        \draw  [cover,morphism] (1) to node {$\vartheta _{f^{*}(g)}$} (2);
        \draw  [>->,morphism] (2) to node[desc] {$\mathsf {Img}(f^{*}(g))$} (3);
        \draw  [->,morphism] (2) to node[desc] {$\cong $} (4);
        \draw  [>->,morphism] (4) to node {$f^{*}(\mathsf {Img}(g))$} (3);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Since isomorphisms are stable under pullback, <fr:tex
display="inline"><![CDATA[f^{*}(\mathsf {Img}(g))]]></fr:tex> is also an isomorphism.
      Thus, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f^{*}(g))]]></fr:tex> is an isomorphism.
      Then since <fr:tex
display="inline"><![CDATA[f^{*}(g)]]></fr:tex> is the composite of two covers, it is itself a cover.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>627</fr:anchor><fr:addr
type="machine">#272</fr:addr><fr:route>unstable-272.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is regular, then by <fr:ref
addr="ct-000N"
href="ct-000N.xml"
taxon="Lemma" />, the unit <fr:tex
display="inline"><![CDATA[\vartheta \colon \mathsf {id}\to \mathsf {Img}]]></fr:tex> consists of <fr:link
type="local"
href="ct-000M.xml"
addr="ct-000M"
title="Extremal epimorphism">covers</fr:link>.
      Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be any morphism in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g\colon B'\to B]]></fr:tex> be an object in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>.
      By <fr:ref
addr="ct-000Q"
href="ct-000Q.xml"
taxon="Lemma" />, <fr:tex
display="inline"><![CDATA[g]]></fr:tex> can be factored as <fr:tex
display="inline"><![CDATA[\vartheta _{g}\mathsf {Img}(g)]]></fr:tex>.
      Form the following pullbacks.
      Note that since covers are stable under pullback by hypothesis, <fr:tex
display="inline"><![CDATA[\widehat {\vartheta _{g}}]]></fr:tex> is also a cover.
      Then by the <fr:link
type="local"
href="ct-0008.xml"
addr="ct-0008"
title="Pasting lemma of pullbacks">pasting lemma</fr:link>, the composite <fr:tex
display="inline"><![CDATA[f^{*}(\mathsf {Img}(g)) \circ  \widehat {\vartheta _{g}}]]></fr:tex> is isomorphic to <fr:tex
display="inline"><![CDATA[f^{*}(g)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="b264147c53835e0b04e90f58d96a76a1"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMS4wMzI5OTZwdCcgaGVpZ2h0PScxMjUuMTE0MDkycHQnIHZpZXdCb3g9Jy03MiAtNzIgMTM0LjAyMTk5OCA4My40MDkzOTUnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPVUFBb0FBQUFBQS93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWUoxWEdOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDNloyeDVaZ0FBQVdRQUFBRFlBQUFBMk5WcUxUdG9aV0ZrQUFBQ1BBQUFBQzhBQUFBMktJeC9xbWhvWldFQUFBSnNBQUFBSGdBQUFDUUY4UUthYUcxMGVBQUFBb3dBQUFBSUFBQUFDQVloQUdWc2IyTmhBQUFDbEFBQUFBWUFBQUFHQUd3QUFHMWhlSEFBQUFLY0FBQUFGZ0FBQUNBQUJRQkZibUZ0WlFBQUFyUUFBQUROQUFBQk9QTmJLcDl3YjNOMEFBQURoQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1GbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBxbU02UXpNL3dIOHBraDBraHEvZ09GQWJRZURNOEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2anAvLzlEeVArendId0dBRlcxQnNNQUFBQUFBZ0JsL3l3Q2lnSEZBQzRBUXdBQUFRTU9BU01HTHdFbUp6NEJNaFlWRkFZSEZoOEJGajRDUHdFT0FRY3VBU2MyTnpZM05qY3lGaGMyTng0QkZRYzNOaThCSmljT0FRY09BUlVlQVRjK0FUYytBUUtGYkJTUGF5ODFDek1FQVNVeUZnb1FBaUl0Rno5SEdBWVlFa3d5UzJZQ0EwVVJFbEJoSWtBWkVTSVRFNVl0QVJVRUZ6d3BTQllkSEFJNUlDaEZIUTRKQVhYK1RFdElBZ2tEREM4ZEpSb1BDQndQQlFJQkFRb3dNQnhoRUNVQ0FWeFNZMHdURDBJREd5SW5BUUVWRHZ1NENpTUdJZ1FCTUNNdmRTRTdMQUVCSngwUER3QjQybU5nWkdCZ0FPSjVweitkamVlMytjckF6TUlBQW84RjV0MUQwUDkxbUVNWWp3SzVIQXhNSUZFQVpPc01BUUI0Mm1OZ1pHQmdadmpQQUNSREdGSVpuSm02R0lBaUtJQUpBRUFXQXBJQUFBTlVBQUFDelFCbEFBQUFBQUJzQUFCNDJtTmdaR0JnWUdKd0FXSVFZR1JBQXdBSFdBQkxBQUI0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21leDc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQUxvQUFvQUFBQUFBMHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2NHQmE2R050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0MyWjJ4NVpnQUFBV3dBQUFBb0FBQUFLTFR0YTVab1pXRmtBQUFCbEFBQUFDd0FBQUEyS2JtQnpXaG9aV0VBQUFIQUFBQUFId0FBQUNRSG8vak5hRzEwZUFBQUFlQUFBQUFJQUFBQUNBYTFBQXhzYjJOaEFBQUI2QUFBQUFZQUFBQUdBQlFBQUcxaGVIQUFBQUh3QUFBQUZ3QUFBQ0FBQkFBSGJtRnRaUUFBQWdnQUFBRFBBQUFCT0JGOUtvTndiM04wQUFBQzJBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWptS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTFCOG9Oa1pwRXZSZ3dNekNMYzU0RENqQWdWLy84ek1BQUFIdUlRQndCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1ErUy8vK0hrUEx6d1BJTUFHaWhCNThBQUFBQkFBd0NSZ1NDQXhRQUJRQUFBUVVISlFVbkFrY0NPd3I5ei8zTkNBTVVyaUNMaXlBQUFBQjQybU5nWkdCZ0FPTGpmWXlPOGZ3Mlh4bVlXUmhBNExIQXZIdklORXNUc3dpUTRtQmdBdkVBQ1AwSXhYamFZMkJrWUdBVytXTEV3TURTeThERHdNM1N4QUFVUVFGTUFEK0dBbkFBQWlnQUFBU05BQXdBQUFBQUFCUUFBSGphWTJCa1lHQmdZbUJqQU5FTVVCSUpBQUFCTXdBTUFIamFUWXc5YjhJd0VJYWZxQWxTMDZGTDFhRUQ5ZERaQ2tvbE5oWUdKbFltRnNCWGxDRU9ja0lFRXVyWTM5M0Q5ZEFienMvN2NRWkt2c200VDhaejNQZkpLVlQ5Y2NFVEw0a25xdDRUbDd6eHdRTlovcWpPbEVYaVhKTnQ0b0pYdmhKUDFMOGxMdm5rWjltMXAvTWd3YXc3SjhFZldybk1OeEw2cHZObVpxdW9WK0lsN0FaeFpuODFibXo2OGRpYTJsYTJaa2xIeTRrekEwTEFzRmJIUmZZY05CTXV6TmxFcDZmUjFHdHJocVg2bDYvMDliR3ppejg1N2V5NTZuYU1ldFhyUG1yYlVNZExTLzBMMkJNd0V3QjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktFU0FyMmhvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaVk4OWZ1Zkg4Tmw4Wm1Ga1lRT0N4d0x4N0NQcS9Qak1QMDNFZ2w0T0JDU1FLQUNpK0Nub0FlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzRBQUFBMktBdUF1bWhvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRoTmNpNi9IODl0OFpXQm1ZUUNCeHdMejdpSG8vNHhNbDVsQlhBNEdKaEFGQURvbENyVUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVVlBQW9BQUFBQUJmQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGNE5XTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SFRmMWFaMng1WmdBQUFYQUFBQUpJQUFBQ3VQTzJ2NU5vWldGa0FBQUR1QUFBQUM4QUFBQTJKLzZBdDJob1pXRUFBQVBvQUFBQUlBQUFBQ1FGdmdHYmFHMTBlQUFBQkFnQUFBQVFBQUFBRUFuOEFLZHNiMk5oQUFBRUdBQUFBQW9BQUFBS0FjSUExRzFoZUhBQUFBUWtBQUFBR0FBQUFDQUFCd0JZYm1GdFpRQUFCRHdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGREFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVjlrWnZnUDVETXpNSUtFR1JFcS9nT0ZBUUhmRGlrQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlxWXpYL3ovSDhoUEE5SC9aLzh4QXFzQ0FnQ2xVd21sQUFCNDJrV1J3VzdUUUJSRi9XYWNtU1JPUEhac2oxdkhkWk00dG9PVUptM2lPRkl3U1p3QWFpaTBSVUt0Q2lnVlNOMndRSlVRRXVJalFFSXMyUElaN1BzRGZFd1hiRnJHRlJMemRuUGZrKzY1VndMcDRMYVAzcUhmMGx5U0FETWdWQVhhQ3FNcERMbk5DZVhiTUlVWjlrbVkyTU1wak1YL2dOc3ErR0VVSnVPd0R5cGlNRXc0aWVEblJKTTFwNVR0ZFNZQWJTdkV3TFlaWSswbTN1cXhweDR5MkhObXFYemgzMHNCZkM1MHpXT3NWdlBLUmVjOGwrSDd6ZFVUZlI2YlN4ejZYZ08xU2FTVUVNZ0gxby9yVTl5aWNIcFdqOEtnL1YrQ3pYRG5pOXdxZ2lRZWtycTNPeWlBSzZrbkxYTWFRVUx1U0lSamsxQ2JEM2tpQUdZQ3NnZFJNczdIQTF0UWlRVThneVFTVUlUbUVYQjdrSytpNW1YcHc2ZitXaForZFE1cXpkV2JadXE3bk5yalZYYUdjTWIwMVZsblZNVk9yV3JCdHo0RzA0cWRaY1BTZEFnamIrRldLSHkreWZvdk1iSzZXMDNEVUx4eUFZSGlidTQyWGc5bE9EMitPRFRZUXd4dHJuSFE5SnMvdjVnUytESjBSbUUyUHhwRDBHRFZPN2JkMjJ2MFZmUzBrazRFbTgxTkd1VldTWTZZekhBeWlzTklBS3ZRaHg3azNuTTBrMkZpa1g4d2VWdDVIR05Sck0ycEtGY0VjSGNrU3Vib3BHVlhoL1hKUnYzUlNYcU9vR3d3aXBqaHRaUUNMU3NFT0t0RVhuY0dNcU4yQVRVUy8wSFRiVmVtYVhGU1FHOFhqejFhNEFCa3ZZR2hIZ3llSVhuUGllR1NvZzI1ZVBFbThJNWxpUGQ5LytqK1ZrbTFYSUI1ejFRQUlXM3A4Z1pBM0MzcjJlYmFNWndSbXQ0ZmZJeTFnSFFPVisreG5GYlVSVnJhRDE2OEdod2l2RTZ6cHVhSU9QNEMwclZjdUhqYVkyQmtZR0FBWXM4amU4M2orVzIrTWpDek1JREFZNEY1OXhEMGYxMm1ZMHdYZ1Z3T0JpYVFLQUE0ZHd0WkFIamFZMkJrWUdCbStNL0F3TUIwakVIbi93V21mZ2FnQ0FwZ0FRQm4yd1JkQXNZQUFBSTZBRXNDT2dBc0FzSUFNQUFBQUFBQVpnRFVBVndBQUhqYVkyQmtZR0JnWVFobllHSUFBVVlHTkFBQUNXa0FZSGphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9DQ3hkV0ZnWW1YcUF0aEZHV3dqSjBSQ3FqcjJkL2RoUFBRTlYrZCsyRURORHdYM0s1Z2x2VjlKSmU3QkZWUG1tU2ZpM2pMWExIam5pYUo4bHVTVmo4eWxOSitaSzE3NHlqeVIvRHR6ellyZlRYQ1g2MkNqMmdWam96ODUxNjMzTnZaZDhHcXBtK1MzMXR0NEdLeFJ4NXN5WTllUFo2ZGEzZWlXRFFISGhTc0Rsb2hpSjRsSjdEbEo1K2hZczA5Skx4d2tWeXpSTlAvNnJmUStiUTdwSnlPYkl6ZFJ3eWlMWHZRc1cwV2JYbXJhUDh1aEwvY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQzBBQUFBMktZeUFsV2hvWldFQUFBSkFBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbUFBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDYUFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKd0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGkyaE9KblBIOE5sOFptRmtZUU9DeHdMeDd5RFJMS09NZElNWEJ3QVRpQVFBVE1nbDJBQUFBZU5wallHUmdZTmI2WThuQXdCTEswTWZRejVUTUFCUkJBVXdBVW9BRFFnQUVWUUFBQXZJQWpnQUFBQUFBVkFBQWVOcGpZR1JnWUdCaU1HVUEwUXhRRWdrQUFBWEtBRHNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS01pQTlXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZEc4c3M0L2x0dmpJd3N6Q0F3R09CZWZlUWFlYUpURFpBaW9PQkNjUURBQ0loQ1g0QUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVrQUFvQUFBQUFCZlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDFGMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNYWjJ4NVpnQUFBV1FBQUFKWUFBQUN1SkhqY2Nsb1pXRmtBQUFEdkFBQUFDOEFBQUEyS0crQmYyaG9aV0VBQUFQc0FBQUFIZ0FBQUNRR1hnSWxhRzEwZUFBQUJBd0FBQUFVQUFBQUZBNm9BS3RzYjJOaEFBQUVJQUFBQUF3QUFBQU1BV0lDREcxaGVIQUFBQVFzQUFBQUdBQUFBQ0FBQ1FBNmJtRnRaUUFBQkVRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRkdBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaFp2Z1A1RE5EcEpIVS9BY0tBd0Q3MVExamVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZndS8vOERTY2YvLy84ZkFQTVpBRkxLQnFCNDJqWFJ2MDhUWVJ6SDhlZnpmTnZuYUdudktsZnVhcURYbEpZZVlGb0l2ZHdCaWNWUXFRaXgvS2hCZ28xRUV5U1NpRDlBWkdEb2dERWFHSXdKaVhGdzBNMDR1emc1TVRtNU9xaVQ4VTh3YlgyT2hPZFpubnh6dy92N09zWlp0dDNtUC9rUE5zeEdHZlBnZXFPR3FjZU5vbXVJWVNoMnpuWmMwM0M5WWFRVkVUZE0xMVFoNS82NFdJSlhwTTlZRi9Hb1FNbklkeU1TM0dsMEJCSHQxQjBLS2ExMk5kcXJSd25SNE1aS0JKRlFYK25OMy9RdVg0NGhwRFViaGtaSkJVVGdIWm9DUk15NzB3ZnhiQXhjVTRVL0Rtc0NtUk1zTVhtSVhXZzNTZkF2ekdKRGJFeVc2azdHRnJJdGJhRmJoV0xCRkJxRWtoYW52Ym9mNStic1RFNG9kUFltK1VIeHcxR1BuZFEwck5UdlVLTTJWd08vRXJ2MnBQVzZWMVVuckhmSGF6c2NoZkpCU2c5dUhkWjNPUitaK1ZvSkFPb0NIei9IcVZjQlg1eVkzZERDMWZHNUtiVVU4RGVBam1sNlhNbGU1dERPTnovUzAyci9BclYrZDRrd1kyREY5aC9xNU4vOVpwQ0tqQlNkaEpPelpiTWZiRnJ3Sks5Zm1JSWxGNUR6QW16WDg2OWhHcVluMTZId0pSTGhVQkFjeS9QVHowWXFQY0pBWVAvcXdKcnI1RVVncEFRcFh4bDhWTjU3UzFSelpyY1Bhb01EWWtaRmhKKzAvcW15V2RGeXE1dEFlV3hsTFZIUDc5N202QnNxMUJPZEFJL2NuK292Z280YkwzWm1uU1VLWlB2VmVaV1ROT2RzVUpwNzBqekI4cjY0ZXdadUNzVy9aOWFucnFhL3dpUmN1d0JGcXI4L1F0bUtTZWJ0ZmREODBOaG1vL1VwcVVuaVg0Yys1OHRiZStaRW9xTUwvRjUxSzZWTDNSaFJVdjcyVncrZVA3eVl2MDVrQ1FuTHk4MXYwaEdCaGRUaXpmUU5lMzBWMEdUYWYvUUJkMWQ0Mm1OZ1pHQmdBT0xqWW50NzQvbHR2akl3c3pDQXdHT0JlZmNROVArWHpPWk1kNEZjRGdZbWtDZ0FRMG9MdVFCNDJtTmdaR0JnWnZqUEFDVDlHVlQrWDJBMlp3Q0tvQUJXQUZVckE0a0FBQUoyQUFBREFBQWtBd2dBS3dMYkFETURUd0FwQUFBQUFBQlVBTEFCRGdGY2VOcGpZR1JnWUdCbHNHUmdaZ0FCUmdZMEFBQUdyUUJFZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbWV4Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNyB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy45MzEyNCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPkM8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuNDQ2MTgsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScyLjQ2NDgnIHk9Jy02MS4yMjYyNzMnPu6AsDwvdGV4dD4KPHJlY3QgeD0nLTUuNTkxODA4JyB5PSctNTYuNDE1NDU2JyBoZWlnaHQ9Jy4zOTg0ODQnIHdpZHRoPScxMC44NTE2NzEnLz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00Ny40Nzc5NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDcuNzI3OTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjI2Mzg5LC0yOC45NDM4MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1My4xNTU1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjY4Njc4IDBINDguMDk5OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTAuOTM2NzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4zNDk5NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDkuODg3NTcsNC41NjE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUuNTkxODA4JyB5PSctNTcuNjEwOTA5Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0uOTI1MjI0JyB5PSctNjAuNjE3NDI2Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nMy4yMzk3NDUnIHk9Jy01Ny42MTA5MDknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nNi4zNTMwODgnIHk9Jy01Ny42MTA5MDknPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PScxOC4xMDM0MjcnIHk9Jy01Ny42MTA5MDknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMjEuMjE2NzcnIHk9Jy01Ny42MTA5MDknPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nMjUuMzUzNzIxJyB5PSctNTcuNjEwOTA5Jz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTIuMjAxNzItNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMi40NTE3MiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMDU2NTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE4LjA1NTcxLC02NC45NjczMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUuNTkxODA4JyB5PSctNTcuNjEwOTA5Jz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nNi4xNTg1MzEnIHk9Jy01Ny42MTA5MDknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nOS4yNzE4NzQnIHk9Jy01Ny42MTA5MDknPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nMTMuNDA4ODI0JyB5PSctNTcuNjEwOTA5Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNTEuMjE1MDQtMTQuMjI2MzZILTQyLjY3OTE0Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02MS4xODM5OCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPkQ8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjM1MTY4LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS41OTE4MDgsLTU3LjYxMDkwOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS41OTE4MDgnIHk9Jy01Ny42MTA5MDknPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMi40NjQ4JyB5PSctNjEuMjI2MjczJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00OC4wNzE0OSAwSC0xMi4yNTg5MScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTIuMzgzOTEsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMyLjc4NDc5LDQuNzg0MDMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjU5MTgwOCwtNTcuNjEwOTA5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01LjA3NDIxOCcgeT0nLTU5LjQ1MTIyMic+7oGjPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01LjU5MTgwOCcgeT0nLTU3LjYxMDkwOSc+z5E8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLS43ODA4NjcnIHk9Jy01Ni42MTQ2NDUnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS01Ni45MDU1LTYuNDA5NzNWLTQ3LjQ3Nzk1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsLTU2LjkwNTUsLTQ3LjcyNzk1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNLTQ2LjkwMzc4LTU2LjkwNTVILTEzLjc3Mzg1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMy44OTg4NSwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lam9pbj0nbWl0ZXInPgogPHBhdGggZD0nTTMuMzk3MTMgMEwuMjUgMS44NzQ5NFYwVi0xLjg3NDk0WicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMi45NTg0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNTkxODA4LC01Ny42MTA5MDkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUuNTkxODA4JyB5PSctNTcuNjEwOTA5Jz7PkTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctLjc4MDg2NycgeT0nLTU2LjYxNDY0NSc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \SpliceDiagramSquare {
          nw = C,
          ne = A,
          sw = \underline {B'},
          se = B,
          north = f^{*}(\mathsf {Img}(g)),
          east = f,
          south = \mathsf {Img}(g),
          north/style = {>->},
          south/style = {>->},
          nw/style = pullback,
        }
        \node  [left = of nw,pullback] (1) {$D$};
        \node  [left = of sw] (2) {$B'$};
        \draw  [cover,morphism] (1) to node {$\widehat {\vartheta _{g}}$} (nw);
        \draw  [->,morphism] (1) to (2);
        \draw  [cover,morphism] (2) to node[swap] {$\vartheta _{g}$} (sw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Thus, <fr:tex
display="inline"><![CDATA[f^{*}(g)]]></fr:tex> admits another cover-mono factorization.</fr:p>
    
      
      <fr:figure><fr:resource
hash="8484fd2521bcaf6e740dd1b8d8e01e81"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIyNy4xODE0cHQnIGhlaWdodD0nMTUxLjY5NzQ4NHB0JyB2aWV3Qm94PSctNzIgLTcyIDE1MS40NTQyNjcgMTAxLjEzMTY1Nic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUEvUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMG1tTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM4QUFBQTBFOE96SDFvWldGa0FBQUNJQUFBQUM0QUFBQTJLSXFBejJob1pXRUFBQUpRQUFBQUhnQUFBQ1FGTEFLNGFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dYZkFKcHNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEWUFhRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFnYm1GdFpRQUFBcHdBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNm1HY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFkSWxETTBBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pKajFuNEh4T0RNRGd4d0RBeU1mSXp1YnVCZ1lpckFwcWVzeHFxdXBtNW5iTVpxYkdZbUpzakVlQ1dwbFpWYmk0Tkt0NEdCa2szSlU5Rkt3WldHeFZmQlNkSlJpWTJSNmJ2WjFUMnlsaEhoVktnc1hDNWVKYkpSdHdZb1ZoYmFSc2laY0xKd01RTURJa0F5MGF3TFFMbWtnaDQwZFpKdWFQcU1KMkFJaE5YVTFJRU5jamxGY2pIRUMxRlJtSmxiMWNEVlR4clJpZG1abWlJV01EQkF6R1ZrNU9GaGtrOE9hR0tWK3gzSnpzektDTFFRQUVhTWpqM2phWTJCa1lHQUE0djNLVDZyaitXMitNakN6TUlEQVk0RjVMeEgwZndibUlHWVFsNE9CQ1VRQkFEUVFDajhBQUhqYVkyQmtZR0JtK004QUpJTVlraG1TR1k4ekFFVlFBQk1BUnNrQzZnQUFBMUlBQUFJcUFKb0FZd0FBQUFBQUFBQTJBR2g0Mm1OZ1pHQmdZR2FRWndEUkRGQVNDUUFBQTc4QUpnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVxZm01dURrNnZEMjZ3SjBxR3BwTFhvSXY1MGIwUHdCZzdmUGVmY0FCa3ZFb1pKbUFjZEpwVTNqenptaDBYa2lmaXJ5Qm0vckJtUnBETnhWdXdpcDB6NWp6eG1TUmw1SXY0amNzWWY3MzFUMys2ZDllcllHT3ZkcGZiYmsvVnQxVGkxMGZtd0hxeXovdHhabzhxbk1uM1Y5dGRhRlRyWEJYc2FhbTdjNmJCNEZFZHhUR0RIUlRMUGxsUFlXeXJKbkhRMmFQSnZlcERVaGNZNS9HS2tVZklVTmZSeTA0cGVwYXNvd3AybStBQlZNaTVEQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJRQUFvQUFBQUFCT1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZRjFRR050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFHU0FBQUJ2R0UwYno5b1pXRmtBQUFDK0FBQUFDOEFBQUEyS0l5QXptaG9aV0VBQUFNb0FBQUFIZ0FBQUNRR0xRSlBhRzEwZUFBQUEwZ0FBQUFNQUFBQURBamRBT0JzYjJOaEFBQURWQUFBQUFnQUFBQUlBSElBM20xaGVIQUFBQU5jQUFBQUdBQUFBQ0FBQmdCS2JtRnRaUUFBQTNRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRVJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbStzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWTBoblp2Z1A1RE5EcEpIVS9BY0tBd0FHaEEyeGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOER5YlQvLy8vUEJ2TVpBRld4QnNONDJpV1BRVzdUUUJpRjU4MjQ0OFNKUFhac2o5MlFoR2JjMkUyVnhGSGMyaXBVTmxCVlJEUkliWGRJQ0tsQ3NDaXc3SW8xRzFoMHg1cGJ3QVY2QWc3QklaQmFZcXIvTFg3cGZZdjNFWkRQZDFONlEzK1RKU0ZnQWx5M29QTTRLWkhKd09PNmZJZ1NSVjRoTHlJZTcrL2xRVmIvLzA4R0ZxSTRpZk1pVHFGMExwRGwwdE81amo4SFp0UHBkcDVPMVV1R3NiL0xQRjlZYm45N3crbjBuTllyMC9YRUc0dHJZY09Nem5aZXJCRzV5OUFlMk1MdEJrWTcvR1I2RGFiaDIrM1BVaDJPdXhtRm1pbkZFbWRvNktBMDk2dkxINWVQd0UydmlkUGgxcDd0cEJxMkp6WENFNnRCRWRyVk5maG1pNEVRUXNtN3V3bjlpaHN5STBlMTVYbzFUMUU3THFSLzd5aExXbUZ0UGtOeUw3ZVFRVjRNNE90RlhxUHJ5b0kvUUZIV29WOCtldGNmMHYxV3BtRzBrSVpOMVRTb25vYzg3S3dXSis4cE8zWTZweGZxeWFhalhQZjdGTDRXSEk2WHN0K2pCMXM3eDMycmlhdmIxY21TTmxrNzdZKzZvdEVUR3hRdzV2UGVoVDJpZUgzK2R1V0taK3lCU2dEZit2dkxpTGpTTUkvU3ErSGpDWkQwaFNEL0FOZGZQUmdBQUhqYVkyQmtZR0FBNGticjVPaDRmcHV2RE13c0RDRHdXR0RlU3dUOVg0YzVoT2t5a012QndBUVNCUUFkU3dwNEFIamFZMkJrWUdCbStNOEFKRU1ZVXY5L1p6cktBQlJCQWN3QWFTWUVnUUFBQTFRQUFBSzhBSHNDelFCbEFBQUFBQUJ5QU41NDJtTmdaR0JnWUdid1pHQmlBQUZHQmpRQUFBZndBRkY0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktFU0F4V2hvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaVk4OWZqdkg4Tmw4Wm1Ga1lRT0N4d0x5WENQcS9Qak1QMDNFZ2w0T0JDU1FLQUNOVUNtUUFlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWXlBcTJob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMmhNSmQrUDViYjR5TUxNd2dNQmpnWGt2a1dtV1VNWTdRSXFEZ1FuRUF3QTRuQXBmQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBBQUFvQUFBQUFCRXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBtMk50WVhBQUFBRTRBQUFBTWdBQUFEd0FaQUJ5WjJ4NVpnQUFBV3dBQUFENEFBQUJHSkpCcDdWb1pXRmtBQUFDWkFBQUFDMEFBQUEyS0hDQTBHaG9aV0VBQUFLVUFBQUFIZ0FBQUNRR2dnTFFhRzEwZUFBQUFyUUFBQUFRQUFBQUVBbm5BUVZzYjJOaEFBQUN4QUFBQUFvQUFBQUtBTHdBWUcxaGVIQUFBQUxRQUFBQUdBQUFBQ0FBQndBY2JtRnRaUUFBQXVnQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRHRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXFtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTU5neU0vd0g4cGtoMGtocS9nT0ZBYzJDRE00QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS2FqTFkvdjhQNUd1QTZQODMveDhEcXdJQ0FJeXpDTkFBQUhqYVkyQmtLUG5QeU5qQXpNQWd4Y0RBS0M0bXdzN0d6OGpHemlZR1pQSXpxcWtEb2JtYVBhTVpZdzR2Tzd1akZic2xNMk5ZR2hjN2I2c3BIN2NxRTVNdW54a3pBeU9UQUp0SmprRGhzZDZmc1p3Q1RJeEp0WW9LdGNsRnphcE5RQ01aUElEbWgwRE1Gd2FhS2k3R0xzTEd6c2VvWm01aXoyakhhSzdIcUs1bWFtWWUwMklHTWxCVHlTeFBtcEdaUHlTR2tiblFqWk9SalprQllsclVRb2ZFWkNZdVpoWkJuL2NManp5MTRtTGpaR0lBQWlZR1Q0WXlaZ3ZHYmdadUJuR2dkWXBzYWlabTRvcG1Za0JMa05qTVFuOWplU1VsZVppVzhnREp2OUZBa3BkcE1WQ0VNWUtSUTRXREVVUThnTE1ZR0FBTk1Dd1JlTnBqWUdSZ1lBQmlqU0t0Nm5oK202OE16Q3dNSVBCWVlONUxCUDJma2RtQ0djVGxZR0FDVVFBRmxna2tBQUFBZU5wallHUmdZR2I0endBa214ZzhHRHlaTFJpQUlpaUFCUUE4ZHdKYUFBQUMwd0FBQWNrQWRBSEpBRWdEZ2dCSkFBQUFBQUF3QUdBQWpBQUFlTnBqWUdSZ1lHQmhrR1pnWWdBQlJnWTBBQUFEalFBa2VObzlqREdyd2pBVWhiOWlGZTBiSEFTSE4wandCNFJLSDdpNE9UaTVPcnpObWlBZG1rcGFpeTdpVC9jMkJHL2c4TjF6emcyUThTSmhtSVI1MEdGU2VmUElZMzVZUko2SXY0cWM4Y3VhRVVrNkUyZkZMbkxLbFAvSVk1YVVrU2ZpUHlKbi9QSGVOL1h0M2xtdmpvMngzbDFxdnoxWjMxYU5VeHVkRCt2Qk91dlBuVFdxZkNyVFYyMS9yVldoYzEyd3A2SG14cDBPaTBkeEZNY0VkbHdrODJ3NWhiMmxrc3hKWjRNbS82WUhTVjFvbk1NdlJob2xUMUZETHpldDZGVzZpaUxjYVlvUFdLd3VTd0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVWUFBb0FBQUFBQmZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0TldOdFlYQUFBQUU4QUFBQU1nQUFBRHdIVGYxYVoyeDVaZ0FBQVhBQUFBSklBQUFDdVBPMnY1Tm9aV0ZrQUFBRHVBQUFBQzhBQUFBMkovNkF6V2hvWldFQUFBUG9BQUFBSUFBQUFDUUZ2Z0diYUcxMGVBQUFCQWdBQUFBUUFBQUFFQW44QUtkc2IyTmhBQUFFR0FBQUFBb0FBQUFLQWNJQTFHMWhlSEFBQUFRa0FBQUFHQUFBQUNBQUJ3QllibUZ0WlFBQUJEd0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1WOWtadmdQNURNek1JS0VHUkVxL2dPRkFRSGZEaWtBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZelgvei9IOGhQQTlIL1ovOHhBcXNDQWdDbFV3bWxBQUI0MmtXUndXN1RRQlJGL1dhY21TUk9QSFpzajF2SGRaTTR0b09VSm0zaU9GSXdTWndBYWlpMFJVS3RDaWdWU04yd1FKVVFFdUlqUUVJczJQSVo3UHNEZkV3WGJGckdGUkx6ZG5QZmsrNjVWd0xwNExhUDNxSGYwbHlTQURNZ1ZBWGFDcU1wRExuTkNlWGJNSVVaOWttWTJNTXBqTVgvZ05zcStHRVVKdU93RHlwaU1FdzRpZURuUkpNMXA1VHRkU1lBYlN2RXdMWVpZKzBtM3VxeHB4NHkySE5tcVh6aDMwc0JmQzUweldPc1Z2UEtSZWM4bCtIN3pkVVRmUjZiU3h6NlhnTzFTYVNVRU1nSDFvL3JVOXlpY0hwV2o4S2cvVitDelhEbmk5d3FnaVFla3JxM095aUFLNmtuTFhNYVFVTHVTSVJqazFDYkQza2lBR1lDc2dkUk1zN0hBMXRRaVFVOGd5UVNVSVRtRVhCN2tLK2k1bVhwdzZmK1doWitkUTVxemRXYlp1cTduTnJqVlhhR2NNYjAxVmxuVk1WT3JXckJ0ejRHMDRxZFpjUFNkQWdqYitGV0tIeSt5Zm92TWJLNlcwM0RVTHh5QVlIaWJ1NDJYZzlsT0QyK09EVFlRd3h0cm5IUTlKcy92NWdTK0RKMFJtRTJQeHBEMEdEVk83YmQyMnYwVmZTMGtrNEVtODFOR3VWV1NZNll6SEF5aXNOSUFLdlFoeDdrM25NMGsyRmlrWDh3ZVZ0NUhHTlJyTTJwS0ZjRWNIY2tTdWJvcEdWWGgvWEpSdjNSU1hxT29Hd3dpcGpodFpRQ0xTc0VPS3RFWG5jR01xTjJBVFVTLzBIVGJWZW1hWEZTUUc4WGp6MWE0QUJrdllHaEhneWVJWG5QaWVHU29nMjVlUEVtOEk1bGlQZDkvK2orVmttMVhJQjV6MVFBSVczcDhnWkEzQzNyMmViYU1ad1JtdDRmZkl5MWdIUU9WKyt4bkZiVVJWcmFEMTY4R2h3aXZFNnpwdWFJT1A0QzByVmN1SGphWTJCa1lHQUFZczhqZTduaitXMitNakN6TUlEQVk0RjVMeEgwZjEybVkwd1hnVndPQmlhUUtBQXpEUXREQUhqYVkyQmtZR0JtK00vQXdNQjBqRUhuL3dXbWZnYWdDQXBnQVFCbjJ3UmRBc1lBQUFJNkFFc0NPZ0FzQXNJQU1BQUFBQUFBWmdEVUFWd0FBSGphWTJCa1lHQmdZUWhuWUdJQUFVWUdOQUFBQ1drQVlIamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b0NDeGRXRmdZbVhxQXRoRkdXd2pKMFJDcWpyMmQvZGhQUFFOVitkKzJFRE5Ed1gzSzVnbHZWOUpKZTdCRlZQbW1TZmkzakxYTEhqbmlhSjhsdVNWajh5bE5KK1pLMTc0eWp5Ui9EdHp6WXJmVFhDWDYyQ2oyZ1Zqb3o4NTE2MzNOdlpkOEdxcG0rUzMxdHQ0R0t4Ung1c3lZOWVQWjZkYTNlaVdEUUhIaFNzRGxvaGlKNGxKN0RsSjUraFlzMDlKTHh3a1Z5elJOUC82cmZRK2JRN3BKeU9iSXpkUnd5aUxYdlFzVzBXYlhtcmFQOHVoTC9jQUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRTBBQUFCZ3FvWmlPV050WVhBQUFBRkVBQUFBTXdBQUFEeWVOV1NsWjJ4NVpnQUFBWGdBQUFDb0FBQUFzTkZjOEl0b1pXRmtBQUFDSUFBQUFDMEFBQUEyS01pQkMyaG9aV0VBQUFKUUFBQUFIZ0FBQUNRR2x2L2thRzEwZUFBQUFuQUFBQUFNQUFBQURBaHpBSUJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBRGdBV0cxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBamJtRnRaUUFBQXB3QUFBRE9BQUFCT0JOL0tydHdiM04wQUFBRGJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzZzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUFCQmdZSEdEdWx1Q3lkZ1UzSjVvRUJzK0lmSXdZR1prWG1jMEJoUm9UcS8vOFpHQUExM3crL0FBQUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVptUmdVcko1WVBEL1B3TURoTDU3VlA0U1dCVVFBQUNzQkFuWEFIamFZMkJrOEdjb1ozWm03R1JRWkdCZzVHTmsxMk5XQjVJaWJPeHNhdXAyak9aeXpPSkEwc1RNM0V3TXFDbzF3am94SU16Y3c1K1pqWWVabDVFeEpjSW1JU2pNMUNPQW1ZMmJtWTh4SWJLSGhjbmUzNXFSSmNtYVI1YVJrVmNHU1lCYkRpakF3TWhneUtET2FNSmt3OEFIdEkrWlRZOVIzVndZWkEranVCaWo1a0YyQVRrbTFuWVdDVmtKWlVZbXhzZi9Ja1NZZWJrRUdIZnpLVEl5eWtseU1BQUFZL0VZbUhqYVkyQmtZR0FBNGx2T1p3UGorVzIrTWpDek1JREFZNEY1TDVGcDVvbE1Oa0NLZzRFSnhBTUFLVk1KdEFBQUFIamFZMkJrWUdCVy9HTUVKQ2N5R0RMSU1qc3pBRVZRQURNQVFtQUNnQUFBQTVFQUFBT1JBRThCVVFBeEFBQUFBQUE0QUZoNDJtTmdaR0JnWUdaUVlnRFJERkFTQ1FBQUJBb0FLUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNOEFBb0FBQUFBQTZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwNW1OdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDVVoyeDVaZ0FBQVdRQUFBQ0FBQUFBZ0FHUVZ6Tm9aV0ZrQUFBQjVBQUFBQzBBQUFBMktCV0JyV2hvWldFQUFBSVVBQUFBSFFBQUFDUUdBUUlsYUcxMGVBQUFBalFBQUFBSUFBQUFDQVdBQUNGc2IyTmhBQUFDUEFBQUFBWUFBQUFHQUVBQUFHMWhlSEFBQUFKRUFBQUFGZ0FBQUNBQUJRQW9ibUZ0WlFBQUFsd0FBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURMQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Pc0E0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmtadmdQNURORHBKSFUvQWNLQXdEcXlBMHllTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aU8vLzlEeVA4SHdId0dBRktYQnAwQUFBQUFBZ0FoQUFBQzNnTGVBQ01BSmdBQUFSTWVBVGN6RlNZckFRYzFGalkzTHdFakJ3WVZGQllYRlNjSE5USTJOeE0yRnpJV0J3TXpBWmpkQnlNdEVrSkVTMGdYT3dNRE4vMHZBaWNtZG1ncU9nN1VCUlFMQ1ROeTVnTEovWUFaRVFFZ0F3TWdBUWtXRDV5R0J3Z1ZIZ0VnQXdNZ0hTY0NaUlVCQ24zK3N3QUFBSGphWTJCa1lHQUFZaTMxQmVueC9EWmZHWmhaR0VEZ3NjQzhsOGcwMHoybWUwQ0tnNEVKeEFNQUM0NEp2d0FBQUhqYVkyQmtZR0JtK004QUloa1VHWlNZN2pFQVJWQUFFd0ExVFFJdEFBQUFBb0FBQUFNQUFDRUFBQUFBQUVBQUFIamFZMkJrWUdCZ1lsQUhZaEJnWkVBREFBU0RBQzRBQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTa0FBb0FBQUFBQlVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxRVdOdFlYQUFBQUU0QUFBQU13QUFBRHdBV0FDY1oyeDVaZ0FBQVd3QUFBSFRBQUFDQUJnOHpueG9aV0ZrQUFBRFFBQUFBQzhBQUFBMktHK0JsV2hvWldFQUFBTndBQUFBSGdBQUFDUUdYZ0lrYUcxMGVBQUFBNUFBQUFBUUFBQUFFQXVnQUlCc2IyTmhBQUFEb0FBQUFBb0FBQUFLQVZRQXNtMWhlSEFBQUFPc0FBQUFHQUFBQUNBQUJ3QTZibUZ0WlFBQUE4UUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVtQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc0U0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmhadmdQNURORHBKSFUvQWNLQXdENXB3MWRlTm9kaW9FSkFDQVFBdThybXFBaFd1T3B2V3N6a3dROVJJRUNWSHM0NDdNeHpXNkcxMlJMN3NtU2RIWCt5M3FRWFFqdUFIamFIWkE5YjlOUUdJWHZ1Vzk4Yno0Y082cURieVNJb3pScDNGUnlnbXJMRHBWSUVWRXI2TkNVRnBXb1ZGUU1CVkdKTDdXcU9uVElVSVJBTUxBZ0lVWm1aaForUUNjbVZnYllFRDhCSmVHRzkwenZNejNuTU03cWt3bi95WCt3Tmx0a0xFR2NMTHJLS2JwaDdJbzJwTi93bzFpNWNkSkdWWXFpcTJKbFFmTXBEcnRJUXZxQ2ZWSE1DM1RkNEFKTTQyaVlOcERQT1JGbDVIaXluci9rNUFsNTQrSEFoSm1aN1g3NFV6M20yd1ZrN05IUXRha3NRUVNldGlWZ3FnY3JaOFY2QWR5MnhCUm5iWUhhT1RhWlByQnc4cHR5L0R2cjZJY3MxTFRaTXFLR2IwRUtHMEo1U0xTbVZvb3I4Q0NrNWkzNGNUS05xMXlWNkJxVXZVWWltekhBc2QxZmVYRjU5YUp3a1RxOU9iOFhSNEZJWmFSQndXcnplZS9rSTlGV3RIWjR0dFdjRnpjc21QeDgvTmVTNE5KdTdCd0F2YzVncjdRYkhOL25tRjFvN1paeUFEY2ZYNThMUWUrSHI0N1dvazFLMWVlc3ZzVkp1M1BXbkl3bzRWOVppUVY2WXlmMmhSNjE2a0VKT1UxVi9OL1lJZDBqVk5NS3k0ajlGbVN0SVQ2OVJjOHIyQmdjbm9MNkM1MkQ0Zmh6MmJhV3ZGOXZVb0QxK3Q2SldpcWxaOEFmclQrcE9CdjhTb0dvck9kNzkvVGxzNnZCYlNKUEFBN3ZqYjdOaUN4U0c1VmJkNnQzL1AwZHdOWnEvd0M2ejFWZ0FIamFZMkJrWUdBQTR2MS9lS2JIODl0OFpXQm1ZUUNCeHdMelhpTG8veStaelpudUFya2NERXdnVVFCUGhBd0dBSGphWTJCa1lHQm0rTThBSlAwWlZQNWZZRFpuQUlxZ0FCWUFWU29EaUFBQUFuWUFBQU1BQUNRQzJ3QXpBMDhBS1FBQUFBQUFWQUN5QVFBQUFIamFZMkJrWUdCZ1liQmtZR0lBQVVZR05BQUFCbnNBUW5qYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY4IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTIxLjUxNzE1Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01NS4xMDUwMTMnIHk9Jy0yNS4xMzI1MTQnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyOC40NTI3NCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0LjE3NDI3LDQwLjE3OTEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctMjEuNTE3MTUnPkQ8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODEuNDI3LDQwLjE3OTEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctMjEuNTE3MTUnPkM8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTEwLjA2MTAyLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy02Mi41NzcwMTInIHk9Jy0yMS41MTcxNSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Ni45MDU1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTEuNzUyNzIsLTQ1LjE3OTEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctMjEuNTE3MTUnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU1LjEwNTAxMycgeT0nLTI1LjEzMjUxNCc+7oCwPC90ZXh0Pgo8cmVjdCB4PSctNjIuNTc3MDEyJyB5PSctMjAuMzIxNjk3JyBoZWlnaHQ9Jy4zOTg0ODQnIHdpZHRoPScxMC4yNjcwNzEnLz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNS45NDkwMiA4LjkyNzU1TDIzLjkwMzg1IDM1Ljg1MzQyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNTU0NzYsMC44MzE5NSwtMC44MzE5NSwwLjU1NDc2LDI0LjA0MjU0LDM2LjA2MTQyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J004Ljk0MDEyIDE3LjM0ODQ2SDIxLjE5MDEyVjI4LjIyNTU2SDguOTQwMTJaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMS45NDAxMiwyMC44NDg0NiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYyLjU3NzAxMicgeT0nLTIzLjE5OTM5NCc+4oi8PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy02Mi41MjE2NjMnIHk9Jy0yMS4wMTkwMTgnPj08L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMzcuMjg2NzYgNDIuNjc5MTJINzMuMDk5MzMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzIuOTc0MzMsNDIuNjc5MTIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNOTAuODUxNzYgMzQuNDM5MDRMMTA4LjA0MDMgOC42NTkwMycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC41NTQ3LDAuODMxOTksLTAuODMxOTksLTAuNTU0Nyw5MC45OTA0MywzNC4yMzEwMyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC41NTQ3LC0wLjgzMTk5LDAuODMxOTksMC41NTQ3LDEwOC4xNzg5Nyw4LjQ1MTAzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDIuMjM4NDIsMjYuODE4MDQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTIxLjUxNzE1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy0yMS41MTcxNSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTcuOTEwNDI4JyB5PSctMjQuNTIzNjY3Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTUzLjc0NTQ1OScgeT0nLTIxLjUxNzE1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01MC42MzIxMTYnIHk9Jy0yMS41MTcxNSc+SW1nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0zOC44ODE3NzYnIHk9Jy0yMS41MTcxNSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMzUuNzY4NDMzJyB5PSctMjEuNTE3MTUnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTMxLjYzMTQ4MycgeT0nLTIxLjUxNzE1Jz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOS43MDgzMyAwSDEwNS4wMDU0OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDUuMjU1NDgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J000NC45NzMzMy02LjVINzAuMjQwNDhWNi41OTQxNUg0NC45NzMzM1onIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ3Ljk3MzMzLC0xLjc1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctMjEuNTE3MTUnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU3LjkxMDQyOCcgeT0nLTI0LjUyMzY2Nyc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy01My43NDU0NTknIHk9Jy0yMS41MTcxNSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTAuNjMyMTE2JyB5PSctMjEuNTE3MTUnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTQ2LjQ5NTE2NScgeT0nLTIxLjUxNzE1Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguNTQ0MzEtNi40MDk3M0w0NC4xNzk2NC0zMy4xMzg4MicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjc5OTk2LC0wLjYwMDAyLDAuNjAwMDIsMC43OTk5Niw0NC4wNzk2NSwtMzMuMDYzODMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxLjk4NzgxLC0yOC41Nzg4NiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtMjEuNTE3MTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTIxLjUxNzE1Jz7PkTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNTcuNzY2MDcxJyB5PSctMjAuMTM0ODM3Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01My43NzA2MDEnIHk9Jy0yMS42MDE1NjYnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y4JyB4PSctNDkuNjA1NjMyJyB5PSctMjAuMTM0ODM3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ni45MDczNzcnIHk9Jy0yMC4xMzQ4MzcnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTQzLjIzODgyJyB5PSctMjAuMTM0ODM3Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002OC4zNzM2Ni0zNC4wNzk3MUwxMDUuMTA1NTEtNi41MjU1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjc5OTkzLC0wLjYwMDA1LDAuNjAwMDUsLTAuNzk5OTMsNjguNTczNjQsLTMzLjkyOTY5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjc5OTkzLDAuNjAwMDUsLTAuNjAwMDUsMC43OTk5MywxMDUuMzA1NSwtNi4zNzU0OSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODkuMzIzNTMsLTI4Ljk2ODYxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC0yMS41MTcxNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNjIuNTc3MDEyJyB5PSctMjEuNTE3MTUnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNTAuODI2NjczJyB5PSctMjEuNTE3MTUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ3LjcxMzMzJyB5PSctMjEuNTE3MTUnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQzLjA0Njc0NicgeT0nLTI0LjUyMzY2Nyc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0zOC44ODE3NzYnIHk9Jy0yMS41MTcxNSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMzUuNzY4NDMzJyB5PSctMjEuNTE3MTUnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTMxLjYzMTQ4MycgeT0nLTIxLjUxNzE1Jz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram, node distance = 4cm,baseline = (2.base)]
        \node  (1) {$A'$};
        \node  [right = 1cm of 1] (ref1) {};
        \node  [above = 1.5cm of ref1] (2) {$D$};
        \node  [right = 2cm of 2] (3) {$C$};
        \node  [right = of 1] (4) {A};
        \node  [between = 1 and 4] (ref2) {};
        \node  [below = 1.5cm of ref2] (5) {$\underline {A'}$};
        \draw  [->,morphism] (1) to node[desc] {$\cong $} (2);
        \draw  [cover,morphism] (2) to (3);
        \draw  [>->,morphism] (3) to node {$f^{*}(\mathsf {Img}(g))$} (4);
        \draw  [->,morphism] (1) to node[desc] {$f^{*}(g)$} (4);
        \draw  [cover,morphism] (1) to node[swap] {$\vartheta _{f^{*}(g)}$} (5);
        \draw  [>->,morphism] (5) to node[swap] {$\mathsf {Img}(f^{*}(g))$} (4);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Then by uniqueness, <fr:tex
display="inline"><![CDATA[C \cong  \underline {A'}]]></fr:tex>.
      Thus, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f^{*}(g)) \cong  f^{*}(\mathsf {Img}(g))]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>  
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>628</fr:anchor><fr:addr
type="user">ct-000R</fr:addr><fr:route>ct-000R.xml</fr:route><fr:title
text="Frobenius reciprocity">Frobenius reciprocity</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be a morphism in a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>. Then for any two subobjects <fr:tex
display="inline"><![CDATA[A' \rightarrowtail  A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[B' \rightarrowtail  B]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[\exists _{f}(A' \cap  f^{*}(B')) \cong  \exists _{f}(A') \cap  B']]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\exists _{f}]]></fr:tex> is the left adjoint of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> constructed in <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>629</fr:anchor><fr:addr
type="machine">#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By the construction of <fr:tex
display="inline"><![CDATA[\exists _{f}]]></fr:tex>, this is equivalent to showing the following isomorphism.
    <fr:tex
display="block"><![CDATA[       \mathsf {Img}(f \circ  (A' \cap  f^{*}(B'))) \cong  \mathsf {Img}(f \circ  A') \cap  B'     ]]></fr:tex></fr:p>

  <fr:p>Form the following diagram, where the front, left, and right faces are pullbacks.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="362c7fd0304540d388463e26df581e23"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMyMy44MTk1MzdwdCcgaGVpZ2h0PScyNDIuODk0ODU0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMjE1Ljg3OTY5MSAxNjEuOTI5OTAzJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzODtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUVlBQW9BQUFBQUJNd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFc5MG5HTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWV3RWdaMng1WmdBQUFXd0FBQUZNQUFBQmpQTndKSk5vWldGa0FBQUN1QUFBQUM4QUFBQTJLRVNBdVdob1pXRUFBQUxvQUFBQUhnQUFBQ1FHTndKMWFHMTBlQUFBQXdnQUFBQVFBQUFBRUFqOUFOWnNiMk5oQUFBREdBQUFBQW9BQUFBS0FOUUFpRzFoZUhBQUFBTWtBQUFBR0FBQUFDQUFDQUJOYm1GdFpRQUFBendBQUFET0FBQUJPQWQxS3Ixd2IzTjBBQUFFREFBQUFBd0FBQUFnQUFNQUFIamFZMkJtc21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcDZNdVF5Yy84SDhwbTVHZEhVL0FjS0F3REQ3d3o3ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVE4R2RJWmN2Ly9SN0QrNy9nLysvODBzRm93QUFEc2h3dVZBSGphVlZETFRzSlFFSjJaVzFvZ1dBU2xGZHRVYVdNTGlCQjV0TUJWRWhjU0l5cHE0a0lrU0dUamp4ZytEUk1TRXFJZjR0YUY0TVdObWtsT3ptTm1jUVlRUmdBd3BRa3dnSTJFazVnKzArU3JJVFFJeDFxV0tJN3ZVQUlPSFFEVVBVZFdkQzJsb2lKN3NtSmhVUEYxVFl5S3R1dTVmbEJFencvY1dnc0RYMjhoMDFhTzQ2NDJkWEVwNnhhV1JlNkpJUmFyY2xPU1RIeTYyRytFR0JYaWo4WlIzcTFLTko2TkdSbzVKWUZTMnFIaFpiRngvTEMwT1dFdDd3ajBlNlBtbXNwbzhESWdxUkJmTCtLOExTRUw1dzVQaDBTN3RPTW1pQ0poemJyaTNTN2Y1TnNSejJvYUIzV1JNbHVMTGo2d3lDdlZIM2hscHFsa3N0bE1WZzJSTENvRHdwMG9Ic00zMkJOQy9NTXZvZXVwcUtmKzBVcktGMTFFeGNCQ0ZyMW5xcFE4NDJYOEpiZnQzbmxUVHQ2YzlEbVdGblBNcHUyUXpWaS85dm1YempyWHhPcGJoazlzQ04vcnJEM3JlTnBqWUdSZ1lBQmlZODlma2ZIOE5sOFptRmtZUU9DeHdMekhDUHEvUGpNUDAzRWdsNE9CQ1NRS0FDWklDbkFBZU5wallHUmdZT2IrendBazR4bmtHQVNaZVJpQUlpaUFCUUF1dndHMEFBQUNVQUFBQVM0QVl3SWdBQjREWHdCVkFBQUFBQUFPQUlnQXhnQUFlTnBqWUdSZ1lHQmg4R0ZnWmdBQlJnWTBBQUFJYlFCV2VOcE5qRDF2d2pBUWhwK29DVkxEd0lJNk1MUWVPbHRCWVdCaVlXQmlaV0lCN0tJTWNaQWRJaUZWSGZuZFBZd0h6dExwZVQvT1FNa2ZHWS9KbU1UOW1KeEMxSk1MeGt3VGowUjlKUzZaOGMwYldmNHV6aWVyeExrays4UUZIL3drSG9uL203aGt3WDNkdFpkcmI3M2Fkc1o2ZDJwRFdPNnNEMDNuMUZ4WFVXK3NzLzdRVzZPT04yV0dKZ3puVnRXNjBqVnJPbG91WE9teGVCUmJjVXhreDBteUlHL0pManFCUmxJbnJUbWE2aVhmU081aTV4Qi9NdEk1Y3BOdEdPUXF5RDVMVzFISFMwMzlEK3B0TURzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBzQUFvQUFBQUFCSVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRTBBQUFCZ3ltRmh6R050WVhBQUFBRkVBQUFBTkFBQUFFUWwrd0t4WjJ4NVpnQUFBWGdBQUFFVEFBQUJSTDU0NDJkb1pXRmtBQUFDakFBQUFDMEFBQUEyS01pQS8yaG9aV0VBQUFLOEFBQUFIZ0FBQUNRRld2L2xhRzEwZUFBQUF0d0FBQUFRQUFBQUVBbVFBTnRzYjJOaEFBQUM3QUFBQUFvQUFBQUtBUFlBZ20xaGVIQUFBQUw0QUFBQUdBQUFBQ0FBQndBM2JtRnRaUUFBQXhBQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBRDRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVNtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBZzRJRGpKMVNYSmJPd0tZay9zQ0FXZkdQRVFNRHN5THpPYUF3STBMMS8vOE1EQUFQeXc5TkFBQUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUUF1V1V4RldmUFRENC94L0J1dnZxbG96OFpiQmFNQUFBRzdnTXpIamFOWTZ4U3NOUUZJYlBmOUxjcEdtOFNUQnBJdWd0V3RyZzBtSnRtMEZwY0pMcUlHNkNwaEg2QnE3cTdLQ2JpT0RzV3pqNUd1TG1Td2hDOVJKMStUam4rK0huSjlBcHRmR0ZkeG9SZFdLRlNGaWlqeFlrTnJwcDVuRTNIWTV6cEQyTXh0bWdoVDVQc0szZ0llZG1IQW9MaDArMlpDWEVnMnNpQ2lNRWQyNWRzZlR1SysrNHQ2YkRpSnpZWWY4ditkNHpHcDR5VUp0ZkRBSXBnK2ZDaHFHa0svTGZvRjdzSENlQnhLcjMrSjhRTVIxUmh5MjlzMEV4a1o1bjlaQk9rQ2tZbXZyV1JvRXR2cG9WMTF6eGJWb3l6dzRxZ3M2MHZTd3JMajY1bk82ZmMwVmRSbHVVWXNpN0pQVmpDRjJXTFZmVmNST2JyNWF2Mkx5cEpXdEpHNHlQeFVsb0xEaytYdVE2b0ZacytnSHdZUzljQUhqYVkyQmtZR0FBNHZVZHkwemorVzIrTWpDek1JREFZNEY1ajVGcDVvbE1Oa0NLZzRFSnhBTUFJVDRKZndBQUFIamFZMkJrWUdCVy9HTUVKQ2N5R0RMSU1yRXpBRVZRQUFzQVBka0NSQUFBQTVFQUFBSlhBRnNDVndCUEFWRUFNUUFBQUFBQVZBQ0NBS0lBQUhqYVkyQmtZR0JnWVRCallHSUFBVVlHTkFBQUJqQUFQM2phVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9GUmlZMkZnWW1YcUF0aWdESEdRSFNKRnFqcnl1M3U0SG5yRDZYay83b0NTSHpLZWsvRWE5M055Q2xGL1hQRENXK0twcUVYaWtnK1dUTWp5bVRoek5vbHpTYjRTRjd4elNUd1YvenR4eVNlUGJkZmU3cjMxYXQ4WjY5MjVEZVA2WUgxb09xZFd1b3A2WjUzMXg5NGFkUnFWR1pvd1hGdFY2MHJYYk9sb3VYR254K0pSN01VeGtSMW55UUlqYXc3UkNUU1NPbW10MEZULzhwM2tMbmFPOFpPUnpra1NKVFRJVlpCOWxiYWlqcGVhK2hmemVUQlBBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRQUFBb0FBQUFBQklnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUUwQUFBQmd5bU5pZDJOdFlYQUFBQUZFQUFBQU5BQUFBRVFsK3dLeFoyeDVaZ0FBQVhnQUFBRW1BQUFCU0JrODJ5cG9aV0ZrQUFBQ29BQUFBQzBBQUFBMktZeUEvMmhvWldFQUFBTFFBQUFBSHdBQUFDUUYvUURiYUcxMGVBQUFBdkFBQUFBUUFBQUFFQXY4QVcxc2IyTmhBQUFEQUFBQUFBb0FBQUFLQVBnQWdtMWhlSEFBQUFNTUFBQUFHQUFBQUNBQUJ3QTJibUZ0WlFBQUF5UUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUQ5QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0rczg0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFBQkJnVUhHRHVsdUN5ZGdVMUovSUVCczlZZlN3WUdaaTNtNDBCaFJvVHEvLzhaR0FCSjlBLzZBQUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FBdVdVeEZXZlBURDQveC9CdXZ2cWxvejhaYkJhTUFBQUc3Z016SGphTFkvUFNnSlJGTWJQZDY3Y2l6a3pPYzUxL2xDTk50TE1ybERNZ1FoN0JxRm9FMGtFQTRvdWN1dW1kV21QWU5DdVorZzFXclR3T1lJMjB1M1A1anZuZkI5OC9BNkJucWpGdDFoVGx3aDVyK05ydVEwLzhBTUg2UkVha09vUTNUTW9tU1dwbVdtV1puMTBHc2pTNDI0djl3T0ZoMmNyMHE1OHZiendHRG9xdjlpU0U5ZVQxdU9CdE91aDhUV2pIdG9yUzNwdXdoWHNETXM2Y2JpL3Q2L0Ntb2E4S1U1aWdWclFMczdyMEVuMVB5Z1BpL2FXWFFNM3JvbVk3a254REY5VW9jQ1FPakJjaGlTUElZeWEzVGd4ZUNhV28vRkNpTVY0dFB3Y1RKZ25nOEdVZVFvYUxZWEpmblh6OFdQL2hSTlRSa1BLTU9kVHFwcER5SmI1TWZkTWE4Y1BwTUxkdTdSOFQ1UldJb3FqRkNoaHZibHlsYktyZUhPYWFPNWFGbjBEeXhvME13QUFlTnBqWUdSZ1lBRGlUekdiak9QNWJiNHlNTE13Z01CamdYbVBrV21XVUNZYklNWEJ3QVRpQVFBa1NBbGxBQUFBZU5wallHUmdZTmI2WThuQXdCTEtFTS9nd1ZURUFCUkJBU3dBU1pNQzNRQUVWUUFBQXZJQWpnTHlBSUFCd3dCZkFBQUFBQUJVQUlJQXBBQUFlTnBqWUdSZ1lHQmhNR1ZnWWdBQlJnWTBBQUFHRndBK2VOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUM0QUFBQTJLQXVBeEdob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0aE5jaXcvSDg5dDhaV0JtWVFDQnh3THpIaVBvLzR4TWw1bEJYQTRHSmhBRkFEZXZDcXNBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5nQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTno3R050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDZ0FBQUFyS0FDSGFSb1pXRmtBQUFDQkFBQUFDNEFBQUEySjdpQXcyaG9aV0VBQUFJMEFBQUFId0FBQUNRRWp3RzhhRzEwZUFBQUFsUUFBQUFLQUFBQUNnUkdBR1JzYjJOaEFBQUNZQUFBQUFnQUFBQUlBQ3dBVm0xaGVIQUFBQUpvQUFBQUZ3QUFBQ0FBQlFBWmJtRnRaUUFBQW9BQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRFVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXZNYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWU5Ca1p2Z1A1RE5EcEpIVS9BY0tBd0R2a1EwZWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaRWo1ejhBWXdzekFJTTdBd0NxaXBLYXV4Mml1Wm1adXgyakV6OGpIS000bUpNOG94aGdzbG15b0tjUElLS05tbUNiR3lCUG53Y2prRXMvUC9JMHJLVDVpbGEzVHd0RGtWQjZCeEQvdGxmLytwUWl5TUFBQkk0TWwwRnhOaUxtTVltenNmSXhLcGtCVDFVM1U5Qm5Wek0yTXhNVGxHQmsxd0NhSzhzWjZNUVg3Q0RFek1vcUM3V0dBbXBqMHQzWGhCMThoRmlhd1BRQVZKQ0ZNZU5wallHUmdZQURpenh0RWo4ZnoyM3hsWUdaaEFJSEhBdk1lSStqL0RFd056Q0F1QndNVGlBSUFRSlVLbmdBQWVOcGpZR1JnWUdiNHo4REF3TlRBWU1sZ3lSakNBQlJCQVV3QU8yd0NVQUFDZ0FBQUFZMEFaQUE1QUFBQUFBQUFBQ3dBVm5qYVkyQmtZR0JnWnBCZ0FORU1VQklKQUFBREVBQWZBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV29BQW9BQUFBQUJwQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaGR4NHBHTnRZWEFBQUFFOEFBQUFOUUFBQUVRQWV3UitaMng1WmdBQUFYUUFBQUxPQUFBRFRQUHNWVEpvWldGa0FBQUVSQUFBQUM4QUFBQTJLSkdBekdob1pXRUFBQVIwQUFBQUhnQUFBQ1FHakFKS2FHMTBlQUFBQkpRQUFBQVVBQUFBRkE2bUFQOXNiMk5oQUFBRXFBQUFBQXdBQUFBTUFYWUNYbTFoZUhBQUFBUzBBQUFBR0FBQUFDQUFDUUJZYm1GdFpRQUFCTXdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGbkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtZXNjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdJTkdCaVNRVWx5V0RwUjBaTDdJelBBZnlHZG1ZQVFKTXlKVS9BY0tBd0FsdHc1ekFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUlMa25CalNtQy8rL3c5a09VSlkvdy84bi92SEdLd1dEQUQ2Tnd2MkFBQUFlTnBGa3MxckUwRVl4dWQ5WnpPVGJPTE81bXUyU2R0dE41dnMrcEVtbXFRYlRkTzBUYXYydzM1WmFhMUtnNktDSWlxSUlLaUk0RUV2ZXZIZ3dZc0hRYng1OTZiL2dIcFMvRGU4YWVOc1FaeUJZZDczWWVENVBmTVNKSzErbjA3aUQxSW5BU0ZOQ0pvMWFhVXpzbDZUMlF5dkFxL0FlQWVzRGpSOVJ3REwybEMzcEdXQVVwamZnYm9TSFBvTjd1azVJNHJuNUtHRW1XbE5QdEVabUxGeUhuSzdQMC9yRE4xb25BR0l5TFd6Q1FvaVdwNTRBL3p3Zlp5WGtFaitlWlkydEhnV0tHaWcweVFIU0ViZlAwckZZNWs0MHBpcU5RMU13ZW5CajdCS0NDV0wvZDkwR3o4U2g0eVJZOHB4dWhsNFZYQ1pGMWlPRGNvWlZ5ZFRWcmtUOW1TUURqMEdudTk2ak5OL2Q4cmtwNmNheE15Y01RSXBBKzVldmdYMGNlLzBCY0RsMU1hRDNUdERtTngzYlBqZHUyc1BBY2VYWDQrWWtkdHZlNDhwZE9hL0wwRmlEVWNsWjBDMUFnZmNhTTlkVGVuclI1ZG1qQTdWWEVXUWdqbDZvK3VjMU1DUWZ6N2dqZFhxSXU1KzVaUVFJRXY5S2w3SEwyUmFGVFMwcVJ3WHZEQkthVW5HNVFoMFlJcnU4WVJtVmI4VzV1MTZ2aGMwRmFtQkF1cUJaRDY4YVptYW1ZL05ITm5mQWlobVBSWHRpQkNpNk5EaGlqaGxZMXFzaTZ3aHUrNkJOb0FybFc3YVFxUlN0aDdOOTBJWlh1NStYa3hPTnpLejFIUHRVU3d5UHg1RDBKYXlyMzV0VVlXMnRUM29lNlhpZndseTN0aHpyUkFGb2hhU3cvMWYrRUt4TEpCTlJXUEpEUGNaMzl1ZUgwelJZTHpoK1Fvdm5KYUttaXlGby80bUl5akxNbW5WOWhxS0tJUnZLbmhMY2hWQUVQNlBlcVNDa0xoWnNQYlZCMXNEZzhjMzJ6MEVQUzA0aXJSZGlFZTRya1pLaW9Sdmw2ZEFFOXlLNEdqZ1RqcER4VVNuSFcxRjhGTDNoTTBqRW9EdERGQVlMTldXVVR1U2I4QnRqZ05hOU1yRmtyMm1RV1BlZFZjbmhtTkdkZ2hndXBLSkE2STVPeVJIQVJwbFBUbVQyOG1uOCtQWW1hamRiWmdsdG45bDRTYlYyZ21qMjQ3Tmw4NmNyNjBnM1duUE9HWmV4ZkVYVDcxNUVRQUFlTnBqWUdSZ1lBQmk3K01WbmZIOE5sOFptRmtZUU9DeHdMekhDUHEvUG5NazB5MGdsNE9CQ1NRS0FEY3dDeFFBZU5wallHUmdZR2I0endBa1N4Z00vbDlnam1RQWlxQUFWZ0JjWWdQY0FBQUN4Z0FBQTNBQU9nTjBBRW9DT2dCTEFzSUFNQUFBQUFBQVdBQzRBUjRCcG5qYVkyQmtZR0JnWlFobllHWUFBVVlHTkFBQUNac0FZbmphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9DQ3hkV0ZnWW1YcUF0aEZHV3dqSjBSQ3FqcjJkL2RoUFBRTlYrZCsyRURORHdYM0s1Z2x2VjlKSmU3QkZWUG1tU2ZpM2pMWExIam5pYUo4bHVTVmo4eWxOSitaSzE3NHlqeVIvRHR6ellyZlRYQ1g2MkNqMmdWam96ODUxNjMzTnZaZDhHcXBtK1MzMXR0NEdLeFJ4NXN5WTllUFo2ZGEzZWlXRFFISGhTc0Rsb2hpSjRsSjdEbEo1K2hZczA5Skx4d2tWeXpSTlAvNnJmUStiUTdwSnlPYkl6ZFJ3eWlMWHZRc1cwV2JYbXJhUDh1aEwvY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSSUFBb0FBQUFBQk9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVngxc21OdFlYQUFBQUU0QUFBQU1RQUFBRHdBblFCNVoyeDVaZ0FBQVd3QUFBR0NBQUFCc01Fd20veG9aV0ZrQUFBQzhBQUFBQzhBQUFBMktQK0F6MmhvWldFQUFBTWdBQUFBSUFBQUFDUUhNd01nYUcxMGVBQUFBMEFBQUFBTUFBQUFEQW8xQU9Sc2IyTmhBQUFEVEFBQUFBZ0FBQUFJQUdZQTJHMWhlSEFBQUFOVUFBQUFHQUFBQUNBQUJnQktibUZ0WlFBQUEyd0FBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUVQQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1UbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvNk1xUXhNL3dIOHBraDBraHEvZ09GQWM4Q0RQOEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPaktrL2Y4UDVJUHAvd2YrendHckFnSUFsRDBKRUFBQUFIamFIWkROVHR0QUZJWG4zREV6VGp6K21kaXhRNEMwc1pGVEVDUkFnaTBRU2dDaGlCWWh0Y3V5Nkw1SWJGcXBtNzRCTENyMUNYZ0lKUFpJQ0lrdGEzWkk4QklrMk55enVUOW5jYjdMaVAyY1R2a2RQYkl0dHNNWS9CYjZXUmlGc2djWGFXZUlLTXp5SHRwU3VDUmtDM2tVUmc3S1k1eDIwaXdmSXNjUUc2SGtiWHI1ZzhhYTVRUE4zZjNQQnpYQVYrYTJZZXZKdlcvd0l5VkFxV2xKUUl2Zmc2NWhFYVN6dnQvQ2YrbkY2dVFKQ2QyOG5tc2JRczBSQnppOGVnV1FlbndDTXM0Q3ExS3JncmdxbGdhNHJOSXNJZW5TMkZMcTErU0tGUVgyZDdwS3QvVEFEb3VCdXhEU2dSUWxSVCtNQWlIREQwWFdQQnNoeXhPUmJnNnlxRi8yN3lxeGtuZWt0SWU0d0MzL0VFZ2g4YnhsVjNTenRyY2FIM01zMVpkNVVIY2RmMkZ4UnRmbXRmWGQ5Z1AzaHlPTWhta24zejU5S1N6aE1vZHFlYTdmaktxcWNXWUhKamR3TWJrZXhqdEx6VDRoN3NZeDcraDJWWUlvcTQ5T0wwKzNJZXlnZ3EvdGp3TlA5d3dzcnBRVzBYRk1Rc01iL1lPWXRUZ1lld056MWpsZkFBQjQybU5nWkdCZ0FPSmREOW0veC9QYmZHVmdabUVBZ2NjQzg1NGc2UCs2ek1lWjdnSzVIQXhNSUZFQVZJa01Dd0I0Mm1OZ1pHQmdadmpQd01EQW9zcVErZjg3ODNFR29BZ0tZQVlBWlQ4RVdnTlVBQUFFSlFCcEFyd0Fld0FBQUFBQVpnRFllTnBqWUdSZ1lHQm04R1JnWWdBQlJnWTBBQUFIOEFCUmVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnd05xRmdZbVZxUXRnRjJXd2pad1FDYW5xMk4vZGgvSFFOMXlkKzJFRE5UOFUzSzlnbHZSK0paVzRCMWRNbVdlZWlIdkxYTFBnblNlSzhsbVNWejR5bDlKOFpxNTQ0U3Z6UlBMdnpEVXJmamZCWGE2RGpXb1hqSTMrNUZ5MzN0dllkOEdycFc2UzMxcHY0Mkd3UmgxdnlveGRQNTZkYW5Xald6WUVIQmV1REZnaWlwMGtKckhuSkoyalk4MCtKYjF3a0Z5eFJOUDg2N2ZTKzdRNXBKK01iSTdjUkEyakxIclJzMndWYlhxcGFmOEF5QkV2N3dBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPTUFBb0FBQUFBQkJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxazZUKzJOdFlYQUFBQUZBQUFBQU13QUFBRHdpWVNJNloyeDVaZ0FBQVhRQUFBQzhBQUFBNUVQQlBLdG9aV0ZrQUFBQ01BQUFBQzhBQUFBMktGU0JkMmhvWldFQUFBSmdBQUFBSGdBQUFDUUZ4ZitBYUcxMGVBQUFBb0FBQUFBTUFBQUFEQWYrQUhCc2IyTmhBQUFDakFBQUFBZ0FBQUFJQURRQWNtMWhlSEFBQUFLVUFBQUFGd0FBQUNBQUJRQW1ibUZ0WlFBQUFxd0FBQURUQUFBQlBxODNkZUZ3YjNOMEFBQURnQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1Xc1U0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTVzU3M1SW1zOVFmVFFZR1ppbm02MEJoUm9UUy8vOFpHQUFGR0E1OEFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lOSUEwRzVCbVpHQlNZbGJTL1ArZmdRRkMzLzEzOXlaWUZSQUFBSTRPQ05rQWVOcGpZR1N3L1ArZmlaSHBCSU1zQXdPam9CaWJ1aUtibW9tWnVLSWdHbTBteHNUQXlDdnhyNEZYVEl5WHNmcmZaRjVSVVY3RzNIK3RZSDZEQkMvVG9yL05rcnlNak95eTdJeU1haWdVSDlCb0J2UC9yNWlLbVZJWVZDRDJLS21aQzVxcHFlc3hzcXV4c3dFaFRNaWUwY3pZU0Z4TVhJeXBDS3laU2RKQ0sxekZ5RVZKMXBvRkxNRGlLeEdjR0Iwa0tPRE4yUHF2azA5TWpJK3hTRHhRWFVxWWtWR01XMXd6Nmw4dldLd2kwNXhmWDV1VHg0d0JBSXpNSk5ONDJtTmdaR0JnQU9LZDgvYlp4L1BiZkdWZ1ptRUFnY2NDODU0ZzZQK3ZtR1dZVGdDNUhBeE1JRkVBU3AwTHd3QjQybU5nWkdCZ2x2cWpDU1JsR013WnpKbUtHWUFpS0lBWkFEczlBa29BQUFNY0FBQUNPQUE1QXFvQU53QUFBQUFBTkFCeWVOcGpZR1JnWUdCbVVHVUEwUXhRRWdrQUFBUlZBQ3dBZU5wTmpyRnF3ekFRaGo5VHgxQW5rS2tkT2hSTkdZV044d0NGREpteVppd2trUWdPV0E2U1kvQlM4Z0I5NkY0VURUM0I4ZW0vNzRTQWtoOHlIcFd4alAxUk9ZWGNuanhqemx2aVFvNUtYUExCaWhleS9GV1NUNzRTNXl6NFRqempuVXZpUXZKNzRwSTF2NXUrdTk0RzY5V3VOOWE3VXhlbXV0cGJIOXJlcVZwWHoyQnJuZldId1JwMW5KUVoyekNlTzlYb1NqZHM2T200Y21QQTR1Vm5PMGxNWk1kSlpvR0ptb3A5ekFLdHpKMTROVnJTLzhaV0RCZXRRM3pOaUhXVW1SSWFaUzlJUDR1dmFPS3VwdmtEQ1ZFeEV3QjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTOEFBb0FBQUFBQld3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwNTJOdFlYQUFBQUU0QUFBQU1nQUFBRHdBblFCN1oyeDVaZ0FBQVd3QUFBSHFBQUFDTExsR1dXaG9aV0ZrQUFBRFdBQUFBQzhBQUFBMktENkEwR2hvWldFQUFBT0lBQUFBSGdBQUFDUUdMUUhOYUcxMGVBQUFBNmdBQUFBUUFBQUFFQXB6QUlWc2IyTmhBQUFEdUFBQUFBb0FBQUFLQVdvQXNHMWhlSEFBQUFQRUFBQUFHQUFBQUNBQUNBQkNibUZ0WlFBQUE5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVzQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1tc000Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpFaGpadmdQNURORHBKSFUvQWNLQXdEaDVRMHplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPakdrL2Y4UDVEdUM2UDhIL3M4RnF3SUNBSlJmQ1JJQUFIamFOZEV4YjlOQUZBZncrOS9GNXlUWVBoUEhkcXZFU1J5bk5pb2lLWFd3MndvTWFtaEFyUklWS2xDSFNraEkwQTBoMUJiWU1uU0VDWUVFQ3dzYkg0QUJKaVkrQUNzRFl1UXpKT0ZjaVp2dS91OE52M2VQVU5LWnorbHYrb3YweUNvaEtaSjAxWEd0cWhNbkR1OUJqY0tvbjdoT2t2YmdxN3pxdUlsclFPWjVIR2RJWS9ZRmozaFY1OGljU3pZMDVXaFNWS0Nmcy9xc3BNN21ZNzF1NlF5NmNyaXZRU3Uxcy9kLy9STjYzMFJKVENlT1lKNEt4a0NMUWdVMDkvSFdhYlZqZ2dxRDUzRlpjQVEvY0pmSXc4akYrWlJ4K28wMHlESlprMUtySDBSYzJ2d0diQU5xQXk0WDRLclB6N3hXamt2Q0tBaTV5djdmbVd5SVA3MnVSWjRRMkQ5NHlDWjdPM3VndDh6UjhleE4zVEEyR2gvZlBUaWk2QTVPbTVieTVOWEJDYVVydDc4UEM0Q3hTOWZQVTFaWFFlOXNiQitLOG5oOVo5UElDdmtFc0xERm5nMDdOeW5FNHZRemV6NWUybVd6UHhWZUpnUWttWGZwRmZxVDNKQ1BIS0JLYkR1TU1zVHlveDB1NGFua1dVSHVqcThqZ3l0ekE0SHNDWk8wQzVXclhOQjhIUkZlWklZaVhPUHFjaXNCQWx2WW9HNWdlb1VvMUVZRHp4VERoZkxpdU9ZbkZHMWJPTUJDU3pRTHZsQ0ttbjJ2QmxQZ3crenJ3THAydWJsSk80SFhxbFQwc0NCWHg1Nk84Slo1SEM4dmJLL1FvSE5XV1ZMeVNsTVAxNDd6c1FuNUJ4a25WSUlBQUhqYVkyQmtZR0FBNGdhL0grTHgvRFpmR1poWkdFRGdzY0M4SndqNnZ4NHpHOU5kSUplRGdRa2tDZ0FxVkFxUEFIamFZMkJrWUdCbStNOEFKRGtZVlA0ZllHWmpBSXFnQUJZQVNVZ0RBQUFBQW5ZQUFBTUFBQ1FEQ0FBckFmVUFOZ0FBQUFBQVZBQ3dBUllBQUhqYVkyQmtZR0JnWVhCa1lHWUFBVVlHTkFBQUIxb0FTM2phVFk2eGFzTXdFSVkvVThkUXA5Q3BIVG9VVFJtRmpmc0FnUXlac21Zc0pKRUlEa2dLc21QSUV2b0FmZWhlRkEwOXdmSGRkNytFZ0pvYkJmY3FlRTM5WGlXVlRBK2VNZWN0Y3lWSFphNzVZTUVUUmZrczVwTmw1cElYdmpQUGVPZVV1UkwvazdubWk5OVZjT2ZMYUtQYUJHT2pQempYdDgzV3hxRVBYclc2ZVlpMTlUYnVSbXZVL3FyTTFBL1QwYWxPTjdwalJjQng1c0tJSmNyUE5tSk1ZczlCZG82ZWxvWnRjb05NUVRaS25CYjdQN0dXaEUrcFhYck5TR3JQVmJwaGtzd2cvU2hwUlpmdWFyby8zL1F3dXdBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY4IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTQuNjE5ODMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00MS42MzM1MzInIHk9Jy0yMC44MzUxOTgnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTM1LjY4MzU4NScgeT0nLTI0LjQ1MDU2Mic+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0zMS4xMDM1MzEnIHk9Jy0yMC44MzUxOTgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTI3LjIyOTE1NycgeT0nLTIwLjgzNTE5OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTkuMTcyNTQ5JyB5PSctMjQuNDUwNTYyJz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTE2LjM3NzQ3MycgeT0nLTIwLjgzNTE5OCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtMTAyLjA4NDY0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC0xMS4xMDk3M1YtOTAuODQxNicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDAuMCwtMTEuMzU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC05MS4wOTE2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjcuNDY2NDYsLTUxLjg3NTY2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzYuOTY2OTQ4JyB5PSctMjMuODQxNzE1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTMyLjgwMTk3OCcgeT0nLTIwLjgzNTE5OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMjkuNjg4NjM1JyB5PSctMjAuODM1MTk4Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy4zMjk0NzMnIHk9Jy0yMy44NDE3MTUnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y4JyB4PSctMjAuNjM0Njk5JyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDk0LjEzODQ2LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zMy41NzY5MjQnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NS41NDEyNCwtMTAyLjA4NDY0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTkuMTc1MzcgMEg4OS4wODI5MicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OS4zMzI5MiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU0LjM3OTE0LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005OS41ODQ2NC04LjYwOTczVi05MC44NDE2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsOTkuNTg0NjQsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsOTkuNTg0NjQsLTkxLjA5MTYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwMi44NDg1MywtNTAuNjI1NjYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0LTk5LjU4NDY0SDkwLjQ4NTcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTAuNzM1NywtOTkuNTg0NjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ3LjMwMzU3LC0xMDcuMjU3NTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU2LjkwNTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzEuNTc3MzgsNDAuMTc5MTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zNC4xNjE1MzMnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMjkuMTUyNTkxJyB5PSctMjAuODM1MTk4Jz7iiKk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTIwLjI5Njk0MycgeT0nLTIwLjgzNTE5OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTQuMzQ2OTk2JyB5PSctMjQuNDUwNTYyJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTkuNzY2OTQyJyB5PSctMjAuODM1MTk4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01Ljg5MjU2OCcgeT0nLTIwLjgzNTE5OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScyLjE2NDA0JyB5PSctMjQuNDUwNTYyJz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nNC45NTkxMTYnIHk9Jy0yMC44MzUxOTgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTMxLjA3NjkzLDQwLjE3OTEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+4oiDPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0zNi4wOTg3MTUnIHk9Jy0xOS4zNDA4MTcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTMwLjkzNDAwMScgeT0nLTIwLjgzNTE5OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMjcuMDU5NjI3JyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xOS41ODc2MjgnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMTYuNzkyNTUyJyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xMC43MDQzMTInIHk9Jy0yMC44MzUxOTgnPuKIqTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMS44NDg2NjQnIHk9Jy0yMC44MzUxOTgnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNi4yMDc5NDQnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS43NTI3MiwtNTkuNDA1NTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zNC4xNjE1MzMnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNDIuMDc4NjMsLTU5LjQwNTUyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+4oiDPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0zNi4wOTg3MTUnIHk9Jy0xOS4zNDA4MTcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTMwLjkzNDAwMScgeT0nLTIwLjgzNTE5OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMjcuMDU5NjI3JyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xOS41ODc2MjgnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMTYuNzkyNTUyJyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1IDMxLjU2OTRWLTQ3LjQ3Nzk3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwzMS4zMTk0KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ3LjcyNzk3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNMTU2LjQ5MDE0IDMxLjIwODMxVi00Ny40Nzc5NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDE1Ni40OTAxNCwzMC45NTgzMSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwxNTYuNDkwMTQsLTQ3LjcyNzk3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNNjYuNjEzODMtNTYuOTA1NTJIMTMzLjc1MDk2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEzMy42MjU5NiwtNTYuOTA1NTIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J003MC44ODgzOC02NC40NjY2NEg5Ny43OTM5Vi01MC43OTQ0M0g3MC44ODgzOFonIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDczLjg4ODM4LC01OC42NTU1MiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00MS42MzM1MzInIHk9Jy0yMC44MzUxOTgnPs+RPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zNi44MjI1OTEnIHk9Jy0xOS4wMDMxNTUnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMyLjgyNzEyJyB5PSctMTkuMDAzMTU1Jz7il6Y8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTI5LjE2MDI3JyB5PSctMTkuMDAzMTU1Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy45OTg5ODknIHk9Jy0yMC40Njk4ODQnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J000Ni42MDM5LTY0LjYzNTIyTDguNzA1NTItOTMuMDU5MTcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43OTk5NywwLjU5OTk5LC0wLjU5OTk5LDAuNzk5OTcsNDYuNDAzOSwtNjQuNzg1MjIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjc5OTk3LC0wLjU5OTk5LDAuNTk5OTksLTAuNzk5OTcsOC41MDU1NCwtOTMuMjA5MTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J00xNDIuMzc1MjMtNjcuNDk2MjNMMTA4LjU4MzU3LTkyLjgzOTI4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzk5OTksMC41OTk5NiwtMC41OTk5NiwwLjc5OTk5LDE0Mi4xNzUyMywtNjcuNjQ2MjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjc5OTk5LC0wLjU5OTk2LDAuNTk5OTYsLTAuNzk5OTksMTA4LjM4MzU4LC05Mi45ODkyNiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTI5LjQyMzI4LC04OC4yNjUxNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy00MS42MzM1MzInIHk9Jy0yMC44MzUxOTgnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y4JyB4PSctMjkuODgzMTkzJyB5PSctMjAuODM1MTk4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0yNi43Njk4NDknIHk9Jy0yMC44MzUxOTgnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIwLjI4OTA4NScgeT0nLTIwLjgzNTE5OCc+4pemPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xNC4zOTI5NjgnIHk9Jy0yMC44MzUxOTgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTguNDAxNTA2JyB5PSctMjMuODQxNzE1Jz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTUuNzA2NzMyJyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004Ni43ODkxNyA0Mi42NzkxMkgxMjYuMDIxNCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMjYuMjcxNCw0Mi42NzkxMiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPHBhdGggZD0nTTQzLjI2OTA3IDMyLjQ0OTYzTDEyLjI5OTAxIDkuMjI3NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjgwMDA1LDAuNTk5OSwtMC41OTk5LDAuODAwMDUsNDMuMDY5MDYsMzIuMjk5NjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjgwMDA1LC0wLjU5OTksMC41OTk5LC0wLjgwMDA1LDEyLjA5OSw5LjA3NzUzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNMTQyLjM3NTggMzIuMDg4NDFMMTA5Ljk4NjM2IDcuNzk2ODMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43OTk5OSwwLjU5OTk2LC0wLjU5OTk2LDAuNzk5OTksMTQyLjE3NTgsMzEuOTM4NCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNzk5OTksLTAuNTk5OTYsMC41OTk5NiwtMC43OTk5OSwxMDkuNzg2MzYsNy42NDY4NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram,node distance = 3.5cm]
      \SpliceDiagramSquare {
        width = 3.5cm,
        height = 3.5cm,
        nw = f^{*}(B'),
        sw = A,
        ne = B',
        se = B,
        west = f^{*}(B'),
        west/style = {>->},
        south = f,
        east/style = {>->},
      }
      \node  [right = 2cm of nw] (ref1) {};
      \node  [above = 1.5cm of ref1] (nw') {$A' \cap  f^{*}(B')$};
      \node  [right = of nw'] (ne') {$\exists _{f}(A') \cap  B'$};
      \node  [below = of nw'] (sw') {$A'$};
      \node  [below = of ne'] (se') {$\exists _{f}(A')$};
      \draw  [>->,morphism] (nw') to (sw');
      \draw  [>->,morphism] (ne') to (se');
      \draw  [cover,morphism] (sw') to node[near start,desc] {$\vartheta _{f \circ  A'}$} (se');
      \draw  [>->,morphism] (sw') to (sw);
      \draw  [>->,morphism] (se') to node {$\mathsf {Img}(f \circ  A')$} (se);
      \draw  [->,morphism] (nw') to (ne');
      \draw  [>->,morphism] (nw') to (nw);
      \draw  [>->,morphism] (ne') to (ne);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By the <fr:link
type="local"
href="ct-0008.xml"
addr="ct-0008"
title="Pasting lemma of pullbacks">pasting lemma</fr:link>, the back square is also a pullback. Then since covers are stable under pullback in a regular category, the north edge of the back square is also a cover. The diagonal of the right face is <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f \circ  A') \cap  B']]></fr:tex>, which forms a cover-mono factorization of the composite <fr:tex
display="inline"><![CDATA[f \circ  (A' \cap  f^{*}(B'))]]></fr:tex>. Thus, by <fr:link
type="local"
href="ct-000Q.xml"
addr="ct-000Q"
title="Cover-mono factorization">uniqueness</fr:link>, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f \circ  (A' \cap  f^{*}(B'))) \cong  \mathsf {Img}(f \circ  A') \cap  B']]></fr:tex> as required.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Backlinks">Backlinks</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1345</fr:anchor><fr:addr
type="user">log-000J</fr:addr><fr:route>log-000J.xml</fr:route><fr:title
text="Subobject doctrine of a regular category">Subobject doctrine of a regular category</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>, then the subobject doctrine <fr:tex
display="inline"><![CDATA[\mathsf {Sub}\colon \mathcal {C}^\mathrm {op}\to \mathsf {Lat}]]></fr:tex> has <fr:link
type="local"
href="log-000I.xml"
addr="log-000I"
title="Comprehension schema">comprehension schema</fr:link>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>661</fr:anchor><fr:addr
type="machine">#253</fr:addr><fr:route>unstable-253.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Each fiber <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> has finite limits inherited from <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
    By <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />, each <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> has the required left adjoint <fr:tex
display="inline"><![CDATA[\exists _{f}]]></fr:tex>.
    They satisfy the <fr:link
type="local"
href="log-000E.xml"
addr="log-000E"
title="Beck-Chevalley condition">Beck-Chevalley condition</fr:link> because images commute with pullbacks in a regular category.
    Then by construction the <fr:link
type="local"
href="log-000H.xml"
addr="log-000H"
title="Naming fucntor">naming functor</fr:link> <fr:tex
display="inline"><![CDATA[{\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{X}\colon {{\mathcal {C}}_{/{X}}}\to \mathsf {Sub}(X)]]></fr:tex> is just <fr:tex
display="inline"><![CDATA[\mathsf {Img}]]></fr:tex>, which admits the inclusion functor as a right adjoint.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1346</fr:anchor><fr:addr
type="user">ct-001A</fr:addr><fr:route>ct-001A.xml</fr:route><fr:title
text="Beck-Chevalley condition">Beck-Chevalley condition</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-0019.xml"
addr="ct-0019"
title="Heyting category">Heyting category</fr:link> and the following square be a pullback in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="91dde1e68d573f25c38df957a8ab78c1"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNy40MDc2NTZwdCcgaGVpZ2h0PScxMTQuOTAyMzMxcHQnIHZpZXdCb3g9Jy03MiAtNzIgNzguMjcxNzcxIDc2LjYwMTU1NCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdVQUFvQUFBQUFCdGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjB4Mk50WVhBQUFBRTRBQUFBTWdBQUFEd0FnZ0RDWjJ4NVpnQUFBV3dBQUFMQ0FBQURuUEtyWjJSb1pXRmtBQUFFTUFBQUFDOEFBQUEySi82QXJXaG9aV0VBQUFSZ0FBQUFJQUFBQUNRRnFnR2NhRzEwZUFBQUJJQUFBQUFVQUFBQUZBeFVBUkZzYjJOaEFBQUVsQUFBQUF3QUFBQU1BYTRDb20xaGVIQUFBQVNnQUFBQUdBQUFBQ0FBQ0FCWWJtRnRaUUFBQkxnQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRmlBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUttZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTVdRek0vd0g4cGtoMGtocS9nT0ZBZG1BRFRnQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS1pqQmsvLzhQNUtlQjZQK3ovODhFcXdJQ0FKbU5DVDRBQUhqYWJkTkxiOU5BRUFkd3o2d2ZzUk43NDllNlRWSTNpWjExcXFaSjI2Uk9XMExhTkFXcDd4WUpTaEdDRXlCeFF1S0NRT0lUSUlRUUI2N2MrQXJjSy9YTWh3R0pTOHVhOGpoUTcyMW5EL09iLzFnQ2FlZWlnMC94cTdRdVNVQW9xSm9GV3AwblEraXlnS2thbTRZaHJKRkk1V25RSFVKZjNDK3l3SUtJSnp6dDh3NVlTS0diTWpXQlQ2dEZ1VmpTUnd2TlZZRFk1d1RvTktVMHJwR3BOdDBOMGFWSDFMZllSalF6QUlpWXFCZERTaDBuTkhLbGgxa1pQcHlmYnR2clBXOU1lQlJXTVZhVHZJNGc3L2dmdngyVHVnYkhKK1dFTitKL0paamtjMi9sZWc0azhhSFV1cGpEQnB4S2JXbWNhWVJFL1NVUkhYdXFGckF1U3dWZ1RTRGJrS1Q5N0lRUUNKVjRRTllnVFFSSzFiSVJzR0F4ZTRxMVovcnpGNTBIc3VqWFptQTVGYnZtRGFJSzA0TCsxdWdFeVlqYVd5Zk5KWk9VSE5PSDl4MENudDhyamF0KzBRYWVoQnVWZ2dZdnowZWRld1Q5MWxUTmRmT2hvU0RrSzVQejFmdGRHWTRQSCsyN2RKTkF6SW9NaXZiNWp5ODAzNGhrYUM3eDBmcEJIeHBWYWdvYlNIc1gzL0VWbmtrN21VeTBIS0ttWHNibHExbXphVGNJaFZjY2tWNVBZREllVDdJWlVGbmsxWWFsdmpzRUhsMkcyMCtaQnFQOXlxMlZtNzBDb0lkdXdUUklaWHJnb0cyb0VPVHRhTmhjQm1KYWpDR3k1dUJ3Z2lwdVZjOFpnZTdZeWpzWmFhd1hBU3h0czlVQS9IeCtWdXVDMHVtWjdZRjZyVnlyMlhWY3UrNGdCdk1CYTh1ZG1VSytHbStNRi93RnhIR1Q1YmRmOHpMTmcyc3kzRFNwSVJzMHA4bWs4TnQ1UXpqdlpNNHNnMFhtLzEwM29jM01ZalBGOFNqeFdIQzVrOW5GSHp6dnA0bklsNElGZFg0Rit2SDAzZVRvTmhjakZ5c1lWQzF2OWlEaHdVUzFSK204akVRQjZ2RlpnMmlHcmdJVURhK3lrb3dSRkFLd3ZSeFJPZUJYOFo5WXU0Mmxsb0JqYk1VNUMyQ1YxenpSZ3FLekZVTTN5Njc0a2VTOW1CcUlodEl1VjlweU43VWNTMjBteXB0VlorSy9RVWpTVHd5d2RSSUFBSGphWTJCa1lHQUE0akRCSk41NGZwdXZETXdzRENEd1dHRGVUUVQ5WDVmcEdOTkZJSmVEZ1Fra0NnQUR2Z29rQUhqYVkyQmtZR0JtK00vQXdNQjBqRUhuL3dXbWFnYWdDQXBnQlFCbVlBUktBc1lBQUFJNkFFc0NPZ0FzQXF3QVRRSnVBRTBBQUFBQUFHWUExQUZJQWM1NDJtTmdaR0JnWUdVSVoyQmlBQUZHQmpRQUFBbUVBR0Y0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVWtBQW9BQUFBQUJmUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUYyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1haMng1WmdBQUFXUUFBQUpZQUFBQ3VKSGpjY2xvWldGa0FBQUR2QUFBQUM4QUFBQTJLRytCZFdob1pXRUFBQVBzQUFBQUhnQUFBQ1FHWGdJbGFHMTBlQUFBQkF3QUFBQVVBQUFBRkE2b0FLdHNiMk5oQUFBRUlBQUFBQXdBQUFBTUFXSUNERzFoZUhBQUFBUXNBQUFBR0FBQUFDQUFDUUE2Ym1GdFpRQUFCRVFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGR0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtZXNjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJoWnZnUDVETkRwSkhVL0FjS0F3RDcxUTFqZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1Fndmd1Ly84RFNjZi8vLzhmQVBNWkFGTEtCcUI0MmpYUnYwOFRZUnpIOGVmemZOdm5hR252S2xmdWFxRFhsSlllWUZvSXZkd0JpY1ZRcVFpeC9LaEJnbzFFRXlTU2lEOUFaR0RvZ0RFYUdJd0ppWEZ3ME0wNHV6ZzVNVG01T3FpVDhVOHdiWDJPaE9kWm5ueHp3L3Y3T3NaWnR0M21QL2tQTnN4R0dmUGdlcU9HcWNlTm9tdUlZU2gyem5aYzAzQzlZYVFWRVRkTTExUWg1LzY0V0lKWHBNOVlGL0dvUU1uSWR5TVMzR2wwQkJIdDFCMEtLYTEyTmRxclJ3blI0TVpLQkpGUVgrbk4zL1F1WDQ0aHBEVWJoa1pKQlVUZ0hab0NSTXk3MHdmeGJBeGNVNFUvRG1zQ21STXNNWG1JWFdnM1NmQXZ6R0pEYkV5VzZrN0dGckl0YmFGYmhXTEJGQnFFa2hhbnZib2Y1K2JzVEU0b2RQWW0rVUh4dzFHUG5kUTByTlR2VUtNMlZ3Ty9FcnYycFBXNlYxVW5ySGZIYXpzY2hmSkJTZzl1SGRaM09SK1orVm9KQU9vQ0h6L0hxVmNCWDV5WTNkREMxZkc1S2JVVThEZUFqbWw2WE1sZTV0RE9Oei9TMDJyL0FyVitkNGt3WTJERjloL3E1Ti85WnBDS2pCU2RoSk96WmJNZmJGcndKSzlmbUlJbEY1RHpBbXpYODY5aEdxWW4xNkh3SlJMaFVCQWN5L1BUejBZcVBjSkFZUC9xd0pycjVFVWdwQVFwWHhsOFZONTdTMVJ6WnJjUGFvTURZa1pGaEorMC9xbXlXZEZ5cTV0QWVXeGxMVkhQNzk3bTZCc3ExQk9kQUkvY24rb3ZnbzRiTDNabW5TVUtaUHZWZVpXVE5PZHNVSnA3MGp6QjhyNjRld1p1Q3NXL1o5YW5ycWEvd2lSY3V3QkZxcjgvUXRtS1NlYnRmZEQ4ME5obW8vVXBxVW5pWDRjKzU4dGJlK1pFb3FNTC9GNTFLNlZMM1JoUlV2NzJWdytlUDd5WXYwNWtDUW5MeTgxdjBoR0JoZFRpemZRTmUzMFYwR1RhZi9RQmQxZDQybU5nWkdCZ0FPTGpZbnNYeHZQYmZHVmdabUVBZ2NjQzgyNGk2UDh2bWMyWjdnSzVIQXhNSUZFQVJjQUx3d0I0Mm1OZ1pHQmdadmpQQUNUOUdWVCtYMkEyWndDS29BQldBRlVyQTRrQUFBSjJBQUFEQUFBa0F3Z0FLd0xiQURNRFR3QXBBQUFBQUFCVUFMQUJEZ0ZjZU5wallHUmdZR0Jsc0dSZ1pnQUJSZ1kwQUFBR3JRQkVlTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02MS4zNDIwMzUnIHk9Jy02MS44MDM1Myc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy45MzEyNCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTcuNjg0MDUsLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPms8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuNjI3MDMsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02MS4zNDIwMzUnIHk9Jy02MS44MDM1Myc+RDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NCAwSDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY1MTgsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5oPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjQ4Njc5LTU2LjkwNTVINDcuNTcxNDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuODIxNDksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI2LjIwMjkxLC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = A,
    nw/style = {pullback},
    ne = B,
    sw = C,
    se = D,
    north = h,
    south = g,
    west = k,
    east = f,
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Then the following square commutes up to isomorphism.</fr:p>
    
      
      <fr:figure><fr:resource
hash="82bfda273017a444f9e3613a31d6e9ef"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0NS41NDM3NDFwdCcgaGVpZ2h0PScxMTkuMTA2NTlwdCcgdmlld0JveD0nLTcyIC03MiA5Ny4wMjkxNjEgNzkuNDA0Mzk0Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hYZDBnMk50WVhBQUFBRTRBQUFBTXdBQUFFUUFkZ0V5WjJ4NVpnQUFBV3dBQUFFNkFBQUJVQ2lDYjJkb1pXRmtBQUFDcUFBQUFDOEFBQUEySjJLQm5taG9aV0VBQUFMWUFBQUFId0FBQUNRRk53RmdhRzEwZUFBQUF2Z0FBQUFPQUFBQURnYkVBSUZzYjJOaEFBQURDQUFBQUFvQUFBQUtBUG9BaG0xaGVIQUFBQU1VQUFBQUdBQUFBQ0FBQndBeWJtRnRaUUFBQXl3QUFBRFRBQUFCUHFrcmRkdHdiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9HTTVReWMvNEg4cGs1R2RIVS9BY0tBd0M2YWd6cWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VTQ0daSVlTdi8vUjdEK3IvdS80SDhmV0MwWUFBRHVoZ3VpQUhqYVBZNnhUc0pRQUVYZmZWVWFIUXF2RFRVSUZndENvUVlxSmZDQ0dnaXhFVEVHR2pUQjZLSTRxSW5PYXRUTndkRmZjRFh4RTVnNytnTzZPRG00dW9MUEdFM3VjdTRkN2lFZ2hmRUh4dlNOTEJFQ3VRaExnV3hnNWo4Q1ExbUxHK0IxY0RIL0p2dERybzdYY0tMWGFIVkE0N0p1TDNxYktUVU5lblBzWG5qaHRTdHp2UVBNUnRSQ283Q1JYSkZ3ZmNiMzZGTXZsZ050T3lsN1VvdE1NeU9qdGR6ZDJ3a2s4OXVWZVVyOWlsbFNWQmFlTXN4bXMzc3B4UWdobE95TXYvQkpBeEloQ1VJMFZ2OHpFeWJSTk5PaU90ZXJRazVXOE9qMGsrMTlLcDEzeTU3cSs5YXFleUJKL1pMTmFUQjZXWWhCdWo4NnZhT3dWRWNVRCs4ZWhUOFlDTTJjK0FIcGlaOGhBcUlLWU9tS2duUVJuSlZaU0hlcm5HRzRaUjNhZFFjK25UdHBBY0dvVmpMamFOYlFIejJuTW53WitXK25kRUJTQUFCNDJtTmdaR0JnQU9MZWVSZG54L1BiZkdWZ1ptRUFnY2NDODk0aDZQOHZtTFNZN2dLNUhBeE1JRkVBV0tvTU9nQjQybU5nWkdCZzV2elB3TURBWk1HZ3k2REMrSjhCS0lJQ21BRS9ZQUtjQUFJcUFBQUNPQUF0QWhBQVZBQlNBQUFBQUFBQUFGSUFoZ0NvQUFCNDJtTmdaR0JnWUdFd1pHQmlBQUZHQmpRQUFBV3pBRHA0MmsyT3NXckRNQkNHUDFQYlVMZlFxUjA2RkUwWmhZMzdBSVVNbWJKbUxDU1JNQzVZRHBKajhGTDZBSG5vWEJRTnZZT2ZULy85ZHdpbytDWGpWaGt2VVcrVlU4cnJ6Z1ZQdkNZdXBWWGlpbmRXUEpEbGorSjg4SlU0NTVudnhBVnYvQ1F1eGY5TFhQSEpaVDBPcC9Oa3ZkcU94bnAzSEVKbzZwMzFvUitkYW5SOU56YldXYitmckZHSFJabTVEM00zcUZiWHVtWE55TUNKTXhNV0x6L2JpbU1pTzQ0eUM5SU5OYnZvQlhxWk84azFhSEgvSnphU2NERzFqOWVNcEE0c29vWlo5b0pvSjNsRkczYzE3UlgrQ0REN0FIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVNFQUFvQUFBQUFCVHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjFXR050WVhBQUFBRTRBQUFBTVFBQUFEd0FnZ0MrWjJ4NVpnQUFBV3dBQUFIQUFBQUNETkFPZXZKb1pXRmtBQUFETEFBQUFDOEFBQUEyS0l5QTJXaG9aV0VBQUFOY0FBQUFIZ0FBQUNRR1F3SlBhRzEwZUFBQUEzd0FBQUFNQUFBQURBa1lBUHBzYjJOaEFBQURpQUFBQUFnQUFBQUlBSElCQm0xaGVIQUFBQU9RQUFBQUZ3QUFBQ0FBQlFCZmJtRnRaUUFBQTZnQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRWVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbTVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTVdRek0vd0g4cGtoMGtocS9nT0ZBYkdMRE1vQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS3BqRmsvLzhQNUlQcC83UC9Ud2VyQWdJQW1Va0pPZ0FBQUhqYUhaQTljdE5BR0liMWZscnZ5clorTEZuZWRaell4SkpuWlR1MlRKQXQ4V2Q3NkJnR1pwSWlCUVVVMEdXR2hvNmg0QUFNY0lVY2dKNkdsdUVBSElJVDBDYXNNdThXV3p6Rjl6d1dySTgzUy9wRmY2eW5sZ1U3QUJjK0JOZlpEb1ZVTVJmeURuYW95ajNLS3VWNnN5NVZVZjl2SjVXUFZHZTZyUFFLaWVBQmlsTEdnZ3Y4ZmVBMXcwSDBaSm04c0RIcnplMjRGL2pkNGFRUlJrZGgrNlhYallQWFBtZDl4MHZQcDg4TUl1YzIzRkVuNkE1VXkrMi84MkxIWnZoOC9XT1hQSjROQ2tLU0o0bWRoZU9XQUZIWjIxOWVYVDRFOStJbXpzYkg2MDY0WXBnc2FvUm52a1BvZC9iZndBL2FOaXlqWlgyNitVZmY2YmYxcW5Zc0t5TjByNzQ5eTdIUlJpMUhhcVROTTdKU1NjRVZsOHBBcG9FYW1ScG1pZEdzeWt6WFMydFVaMVhYaEREaUpsWjVHMGoySkQ2OGZWUlVid3A5Q2xwRWZZbGczR1JCdUxoWStHdFozTzlzR0hnRDZCek5Wc0p1ZXE2RDJJMlM3ZW81Z1RHd1BJeE9lem5KWWNyWUYwWncvTFFkRVhHNzhkV05RVmZYN3c4WCtSWW5lbjRNSFByc3hHY05nYzNFbTNvVWNiVjExWkJGVTJKbkk3OUZKTzhlcUJXclNoRUh6akxrclBuVDFZU0pvazNFT1FlWmZxNHA1S0xoTVpQcFB3b0tQeDE0Mm1OZ1pHQmdBT0tGdnowTTQvbHR2akl3c3pDQXdHT0JlZThROUg5ZDVoQ215MEF1QndNVFNCUUFPZzRMSGdCNDJtTmdaR0JnWnZqUEFDUkRHS3IvZjJjNnlnQVVRUUhNQUdzZ0JKY0FBQU5VQUFBQ3ZBQjdBd2dBZndBQUFBQUFjZ0VHZU5wallHUmdZR0JtaUdNQTBReFFFZ2tBQUFubUFHVUFlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ3dOcUZnWW1WcVF0Z0YyV3dqWndRQ2FucTJOL2RoL0hRTjF5ZCsyRUROVDhVM0s5Z2x2UitKWlc0QjFkTW1XZWVpSHZMWExQZ25TZUs4bG1TVno0eWw5SjhacTU0NFN2elJQTHZ6RFVyZmpmQlhhNkRqV29YakkzKzVGeTMzdHZZZDhHcnBXNlMzMXB2NDJHd1JoMXZ5b3hkUDU2ZGFuV2pXellFSEJldURGZ2lpcDBrSnJIbkpKMmpZODArSmIxd2tGeXhSTlA4NjdmUys3UTVwSitNYkk3Y1JBMmpMSHJSczJ3VmJYcXBhZjhBeUJFdjd3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSUUFBb0FBQUFBQk93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWUowMjJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDN1oyeDVaZ0FBQVdRQUFBR1NBQUFCeE9iUmpMUm9aV0ZrQUFBQytBQUFBQzhBQUFBMkovNkF6V2hvWldFQUFBTW9BQUFBSHdBQUFDUUZxUUhmYUcxMGVBQUFBMGdBQUFBTUFBQUFEQWVzQUhsc2IyTmhBQUFEVkFBQUFBZ0FBQUFJQUc0QTRtMWhlSEFBQUFOY0FBQUFHQUFBQUNBQUJnQk5ibUZ0WlFBQUEzUUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUVSQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm02bU9jd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBxbU0yUXdNL3dIOHBraDBraHEvZ09GQWVHakRVMEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2Z1ovLzhEeWZULy8vL1BBdk1aQUZYR0JzUjQyaDJRelc3VFFCUkdmZTg0TTQzL0pyYmpHV2lOYThlSjdVckJidXZFQmhFYzNFUklCVkVxTnFnSXNldStFaHRVSko0QjhSUzhBbnVrdmhFU214UWJmZHV6T09kVFVKbmZQOFlaL0ZaeVphTW9RQ3hnTkVrYktFK0ZIRk1tUlNtcXVvRTFVSlpEV3RYOUFwQU4xQjFBMWxDbFNacFFScGtGUXA3MktFWTN3ODlmaWs4cXhNSVdZRG0rSFkxWHNTK1lyTS9iS3lRdHQ4K3ZzcVZKOWgzVGd4OEZnYkczMk4rRTNzaUdKQTNPZklQQjdhNHRQaEQwNW84aTE5VURiWUNnK3crUHc0K2xDdTh2cnk5Y3ZpVXdGU01CSTN2Mzl4ZlhaN0VLMlRKcFg3eXRZUlp5VStsaWxEZjNmL0FyM2ltdis3Sk9PVUJHT2ZTdUh1MWxxMUlHWFcrM1NaSXV1cGcrTDBuN0Q3aHFRWnpEc25ZYlNPTEovMHZxU2pCb0wveDNUMTh1RE1BeHVvYXBFZjl3NWFDdFVaQzZIVGZaRXlDbUpRU2l5RmFYRC9qQURZZDdtaHc2OXVDN2ludzZIQUZZYkR1ZkFmN2MzVVVsRElxRm1hL29zNE1vc2llNGZ1NGd5bU1wY3JVNE12Undlclk1OFU0UU41blFYMzFMRHJnT3JpbHdhM0pOMWZnZVU0bnhEN2pQTzhzQUFIamFZMkJrWUdBQTRxcFdyY254L0RaZkdaaFpHRURnc2NDOGR3ajZ2eTdUTWFialFDNEhBeE5JRkFBdTFBc3FBSGphWTJCa1lHQm0rTS9Bd01CMGpFR0hRWlNwbWdFb2dnS1lBVUVkQW80QUFzWUFBQUk2QUN3Q3JBQk5BQUFBQUFCdUFPSjQybU5nWkdCZ1lHYndZV0JpQUFGR0JqUUFBQWc3QUZSNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVrQUFvQUFBQUFCZlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDFGMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNYWjJ4NVpnQUFBV1FBQUFKWUFBQUN1SkhqY2Nsb1pXRmtBQUFEdkFBQUFDOEFBQUEyS0crQm4yaG9aV0VBQUFQc0FBQUFIZ0FBQUNRR1hnSWxhRzEwZUFBQUJBd0FBQUFVQUFBQUZBNm9BS3RzYjJOaEFBQUVJQUFBQUF3QUFBQU1BV0lDREcxaGVIQUFBQVFzQUFBQUdBQUFBQ0FBQ1FBNmJtRnRaUUFBQkVRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRkdBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaFp2Z1A1RE5EcEpIVS9BY0tBd0Q3MVExamVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZndS8vOERTY2YvLy84ZkFQTVpBRkxLQnFCNDJqWFJ2MDhUWVJ6SDhlZnpmTnZuYUdudktsZnVhcURYbEpZZVlGb0l2ZHdCaWNWUXFRaXgvS2hCZ28xRUV5U1NpRDlBWkdEb2dERWFHSXdKaVhGdzBNMDR1emc1TVRtNU9xaVQ4VTh3YlgyT2hPZFpubnh6dy92N09zWlp0dDNtUC9rUE5zeEdHZlBnZXFPR3FjZU5vbXVJWVNoMnpuWmMwM0M5WWFRVkVUZE0xMVFoNS82NFdJSlhwTTlZRi9Hb1FNbklkeU1TM0dsMEJCSHQxQjBLS2ExMk5kcXJSd25SNE1aS0JKRlFYK25OMy9RdVg0NGhwRFViaGtaSkJVVGdIWm9DUk15NzB3ZnhiQXhjVTRVL0Rtc0NtUk1zTVhtSVhXZzNTZkF2ekdKRGJFeVc2azdHRnJJdGJhRmJoV0xCRkJxRWtoYW52Ym9mNStic1RFNG9kUFltK1VIeHcxR1BuZFEwck5UdlVLTTJWd08vRXJ2MnBQVzZWMVVuckhmSGF6c2NoZkpCU2c5dUhkWjNPUitaK1ZvSkFPb0NIei9IcVZjQlg1eVkzZERDMWZHNUtiVVU4RGVBam1sNlhNbGU1dERPTnovUzAyci9BclYrZDRrd1kyREY5aC9xNU4vOVpwQ0tqQlNkaEpPelpiTWZiRnJ3Sks5Zm1JSWxGNUR6QW16WDg2OWhHcVluMTZId0pSTGhVQkFjeS9QVHowWXFQY0pBWVAvcXdKcnI1RVVncEFRcFh4bDhWTjU3UzFSelpyY1Bhb01EWWtaRmhKKzAvcW15V2RGeXE1dEFlV3hsTFZIUDc5N202QnNxMUJPZEFJL2NuK292Z280YkwzWm1uU1VLWlB2VmVaV1ROT2RzVUpwNzBqekI4cjY0ZXdadUNzVy9aOWFucnFhL3dpUmN1d0JGcXI4L1F0bUtTZWJ0ZmREODBOaG1vL1VwcVVuaVg0Yys1OHRiZStaRW9xTUwvRjUxSzZWTDNSaFJVdjcyVncrZVA3eVl2MDVrQ1FuTHk4MXYwaEdCaGRUaXpmUU5lMzBWMEdUYWYvUUJkMWQ0Mm1OZ1pHQmdBT0xqWW50OTQvbHR2akl3c3pDQXdHT0JlZThROVArWHpPWk1kNEZjRGdZbWtDZ0FPMm9MbVFCNDJtTmdaR0JnWnZqUEFDVDlHVlQrWDJBMlp3Q0tvQUJXQUZVckE0a0FBQUoyQUFBREFBQWtBd2dBS3dMYkFETURUd0FwQUFBQUFBQlVBTEFCRGdGY2VOcGpZR1JnWUdCbHNHUmdaZ0FCUmdZMEFBQUdyUUJFZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5nQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTno3R050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDZ0FBQUFyS0FDSGFSb1pXRmtBQUFDQkFBQUFDNEFBQUEySjdpQTJXaG9aV0VBQUFJMEFBQUFId0FBQUNRRWp3RzhhRzEwZUFBQUFsUUFBQUFLQUFBQUNnUkdBR1JzYjJOaEFBQUNZQUFBQUFnQUFBQUlBQ3dBVm0xaGVIQUFBQUpvQUFBQUZ3QUFBQ0FBQlFBWmJtRnRaUUFBQW9BQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRFVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXZNYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWU5Ca1p2Z1A1RE5EcEpIVS9BY0tBd0R2a1EwZWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaRWo1ejhBWXdzekFJTTdBd0NxaXBLYXV4Mml1Wm1adXgyakV6OGpIS000bUpNOG94aGdzbG15b0tjUElLS05tbUNiR3lCUG53Y2prRXMvUC9JMHJLVDVpbGEzVHd0RGtWQjZCeEQvdGxmLytwUWl5TUFBQkk0TWwwRnhOaUxtTVltenNmSXhLcGtCVDFVM1U5Qm5Wek0yTXhNVGxHQmsxd0NhSzhzWjZNUVg3Q0RFek1vcUM3V0dBbXBqMHQzWGhCMThoRmlhd1BRQVZKQ0ZNZU5wallHUmdZQURpenh0RVo4ZnoyM3hsWUdaaEFJSEhBdlBlSWVqL0RFd056Q0F1QndNVGlBSUFPeXNLaUFBQWVOcGpZR1JnWUdiNHo4REF3TlRBWU1sZ3lSakNBQlJCQVV3QU8yd0NVQUFDZ0FBQUFZMEFaQUE1QUFBQUFBQUFBQ3dBVm5qYVkyQmtZR0JnWnBCZ0FORU1VQklKQUFBREVBQWZBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWXlBdFdob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMmhNSkorUDViYjR5TUxNd2dNQmpnWG52a0dtV1VNWTdRSXFEZ1FuRUF3QTJKZ3BWQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNa0FBb0FBQUFBQTRRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVrQUFBQmdxa21VUzJOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKVFoyeDVaZ0FBQVd3QUFBQmdBQUFBWUw3dmtMZG9aV0ZrQUFBQnpBQUFBQzhBQUFBMktNbUJqR2hvWldFQUFBSDhBQUFBSGdBQUFDUUZ1di9VYUcxMGVBQUFBaHdBQUFBSUFBQUFDQVluQUJCc2IyTmhBQUFDSkFBQUFBWUFBQUFHQURBQUFHMWhlSEFBQUFJc0FBQUFGZ0FBQUNBQUJRQVlibUZ0WlFBQUFrUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQURGQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1GbWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4b0FBSEdDT2x1Q3lkZ1UySlFZbUJXZkdQRVFPUVpENEhGR1pFS1AzL240RUJBTXNRRGNnQUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVb00vLzlEeUh1TVlIa0dBRWsyQlg4QUFBQUNBQkQvN0FLSUFzY0FFd0FXQUFBSkFRY0dCeVluQVNjMk54WWZBU0UzUGdFWEZnRWJBUUtBL3VrR0FoVVZCdjdtQndJWUZBWmVBVk5lQnlnRUF2NHZsWk1DbXYxeERCQURBaFVDbHhNWUFnSVczTjRWQVJvQi92WCtwQUZjQUhqYVkyQmtZR0FBWWllUGpaTHgvRFpmR1poWkdFRGdzY0M4ZHdqNi94dm1pVXpIZ1Z3T0JpYVFLQUFsVHd0TkFIamFZMkJrWUdCVy9HTUVKQ2N5Q0REd01YVXdBRVZRQUJNQVF6Z0Nrd0FBQTVFQUFBS1dBQkFBQUFBQUFEQUFBSGphWTJCa1lHQmdZaEFIWWhCZ1pFQURBQUx6QUI0QUFIamFUWXc5YjhJd0VJYWZpQVNKZE9oU2RlZ0FIcGl0b0ZSaVkyRmdZbVhxQXRpZ0RIR1FIU0pGcWpyeXUzdTRIbnJENlhrLzdvQ1NIektlay9FYTkzTnlDbEYvWFBEQ1crS3BxRVhpa2crV1RNanltVGh6Tm9selNiNFNGN3h6U1R3Vi96dHh5U2VQYmRmZTdyMzFhdDhaNjkyNURlUDZZSDFvT3FkV3VvcDZaNTMxeDk0YWRScVZHWm93WEZ0VjYwclhiT2xvdVhHbngrSlI3TVV4a1IxbnlRSWphdzdSQ1RTU09tbXQwRlQvOHAza0xuYU84Wk9SemtrU0pUVElWWkI5bGJhaWpwZWEraGZ6ZVRCUEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUxLjY1ODkxLC02MS4zMjIyNzIpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTUuODc2NzUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MS4zMjIyNzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjEuMzIyMjcyJz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYxLjMyMjI3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjEuMzIyMjcyJz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yMy44OTgzNzInIHk9Jy02MS4zMjIyNzInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE2LjExMTgzLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYxLjMyMjI3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTEuNjU4OTEnIHk9Jy02MS4zMjIyNzInPlN1YjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzUuODI5MzU1JyB5PSctNjEuMzIyMjcyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zMS45NTQ5ODEnIHk9Jy02MS4zMjIyNzInPkQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTIzLjQyOTk5MicgeT0nLTYxLjMyMjI3Mic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC04LjkwOTczVi00Ny40OTU3NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDcuNzQ1NzcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMi4zMDIxMiwtMzAuMjAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjEuMzIyMjcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01MS42NTg5MScgeT0nLTYxLjMyMjI3Mic+4oiAPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny4xNDgwMjUnIHk9Jy02MC4yNjUxMjUnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMzIyMTQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MS4zMjIyNzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjEuMzIyMjcyJz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYxLjMyMjI3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjEuMzIyMjcyJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNC40ODI5ODInIHk9Jy02MS4zMjIyNzInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMTQwOSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MS4zMjIyNzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjEuMzIyMjcyJz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYxLjMyMjI3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjEuMzIyMjcyJz5DPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNC4xMjE4NjcnIHk9Jy02MS4zMjIyNzInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTIwLjQzMjMgMEgzNi4yNjY2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM2LjUxNjYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4xNjgyNywyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYxLjMyMjI3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTEuNjU4OTEnIHk9Jy02MS4zMjIyNzInPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2Ljk5NDY1MScgeT0nLTY0LjMyODc5Jz7iiJc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtOC45MDk3M1YtNDcuNDk1NzcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00Ny43NDU3NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTMwLjIwMjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYxLjMyMjI3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuNjU4OTEnIHk9Jy02MS4zMjIyNzInPuKIgDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuMTQ4MDI1JyB5PSctNjAuMjY1MTI1Jz5rPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00yMC42NjczNy01Ni45MDU1SDM2LjA4NTM2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM2LjMzNTM2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC40NTk4NCwtNjUuMDYxNDgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjEuMzIyMjcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01MS42NTg5MScgeT0nLTYxLjMyMjI3Mic+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDcuNTIxOTU5JyB5PSctNjQuMzI4NzknPuKIlzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = {\mathsf {Sub}(B)},
    ne = {\mathsf {Sub}(A)},
    sw = {\mathsf {Sub}(D)},
    se = {\mathsf {Sub}(C)},
    north = {h^{*}},
    west = {\forall _{f}},
    south = {g^{*}},
    east = {\forall _{k}},
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>647</fr:anchor><fr:addr
type="machine">#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Consider the corresponding left adjoint square.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="db7b171d9b91c63362e7abc04f3f7b47"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0NS41NDM3NDFwdCcgaGVpZ2h0PScxMjAuMTYxODEzcHQnIHZpZXdCb3g9Jy03MiAtNzIgOTcuMDI5MTYxIDgwLjEwNzg3NSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5vQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDMEFBQUEyS1l5QWkyaG9aV0VBQUFKQUFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFtQUFBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNhQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUp3QUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9nQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFdBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaTJoT0pzdkg4Tmw4Wm1Ga1lRT0N4d0x5YnlEUkxLT01kSU1YQndBVGlBUUFWcUFtQUFBQUFlTnBqWUdSZ1lOYjZZOG5Bd0JMSzBNZlF6NVRNQUJSQkFVd0FVb0FEUWdBRVZRQUFBdklBamdBQUFBQUFWQUFBZU5wallHUmdZR0JpTUdVQTBReFFFZ2tBQUFYS0FEc0FlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ2xKV0ZnWW1WcVF0Z2d6TEVRWGFJRktucXlPL3U0WHJvRGFmbi9iZ0RTbjdJZUU3R2E5elB5U2xFL1hIQkMyK0pwNklXaVVzK1dESWh5MmZpek5ra3ppWDVTbHp3emlYeFZQenZ4Q1dmUExaZGU3djMxcXQ5WjZ4MzV6YU02NFAxb2VtY1d1a3E2cDExMWg5N2E5UnBWR1pvd25CdFZhMHJYYk9sbytYR25SNkxSN0VYeDBSMm5DVUxqS3c1UkNmUVNPcWt0VUpUL2N0M2tydllPY1pQUmpvblNaVFFJRmRCOWxYYWlqcGVhdXBmNytrd1J3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUlFBQW9BQUFBQUJRZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMHltTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWdnQytaMng1WmdBQUFXd0FBQUdNQUFBQjJBdloyckJvWldGa0FBQUMrQUFBQUM4QUFBQTJKLzZBcjJob1pXRUFBQU1vQUFBQUlBQUFBQ1FGdUFHYWFHMTBlQUFBQTBnQUFBQU1BQUFBREFkdUFKaHNiMk5oQUFBRFZBQUFBQWdBQUFBSUFHWUE3RzFoZUhBQUFBTmNBQUFBRndBQUFDQUFCUUJZYm1GdFpRQUFBM1FBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFUkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1LY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F6TS93SDhwa2gwa2hxL2dPRkFkcVhEVHNBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpGay8vOFA1SVBwLzdQL1R3ZXJBZ0lBbVVrSk9nQUFBSGphUlpFN2J4TkJGSVgzek16dWVBYzhkMk92WjBNYy9OcnhURkNDQTNHeVN5eGs4cUxKUXlnRkJDbzZrUGd0Q0ZGUTBOTHhRNUNvK1RGUUpzd3FFdHpUbmRPYzc5d0kwZG5OTnZ2QWZrVUhVUVJPU0tTR25EaS94TndVSnBGbWlDV2U4VEp4VlRGZm9nNytqaWswU3VkZFZidHRhRWFZVnlieCtMYklSTGFXSGo3ZVdBQzI1emhvU0VSMnpPL1A2SHpBdW5SSlBXMk95Z2RQZ2RLRVBCc1FkVG9EMVZwNzI4VDRjdjNqZE9WZ056L21yaHlNbUUzOG5aUkJuUFcrL3I3aUU0bXJOMzN2cHZaL2hIdnU0U2N4YVNFS2gramk1Zzk3em41R3J4cVdLblRkTWIxL1ZRTllneGVvZ25MaXVTbHVlUnBESmtFQjI5V1ZuOEVUTkNadXIrNHU0Y3JiTmVyS1NCeStHNzcybHk4ZGJGTy9HT2w4ODRWM3hlcG9sK2lSWUR3RzVXNVRjYW5TQk1oVXZyN3ZqeGxpRHB3K0tVa1ViaVgrTEJqWk5BTzBQTm1hZ24yL2ZxL1BwM3RiL2ZHWVdXMWJHbGk0Y1I0cXhLblpWMm03M3cxUEVCZVdGR01xbnZYWFoySmU2WTVPTm56OGNkRlo3YllOTzJtVEVvcGFVdkM3WVlxLzR4UTVTSGphWTJCa1lHQUFZdjFmZmJyeC9EWmZHWmhaR0VEZ3NjQzhtd2o2dno3VE1hYUxRQzRIQXhOSUZBQXl2d3MwQUhqYVkyQmtZR0JtK00vQXdNQjBqTUg3L3dXbUxBYWdDQXBnQmdCbjVBUldBc1lBQUFJNkFFc0NiZ0JOQUFBQUFBQm1BT3g0Mm1OZ1pHQmdZR1lJWndEUkRGQVNDUUFBQ1RjQVhnQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJjQUFvQUFBQUFCUGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFjbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUM3WjJ4NVpnQUFBV1FBQUFHZUFBQUIwRWdYV254b1pXRmtBQUFEQkFBQUFDOEFBQUEyS0l5QW9taG9aV0VBQUFNMEFBQUFIZ0FBQUNRR1dnS2JhRzEwZUFBQUExUUFBQUFNQUFBQURBbHdBT1JzYjJOaEFBQURZQUFBQUFnQUFBQUlBR3dBNkcxaGVIQUFBQU5vQUFBQUdBQUFBQ0FBQmdCUmJtRnRaUUFBQTRBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRVVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVZtV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTJRd00vd0g4cGtoMGtocS9nT0ZBYnZjRE9VQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZnWi8vOER5ZlQvLy8vUEF2TVpBRlhHQnNSNDJoMlFNVy9UVUJTRmZhN3Q1OFIrdFJQYjd6bEFIRnFiMkNta2NacTJ0cXFHcEdvb1ZFclVWcXdncEFyQkFtc0hKaVlraEFSc3pQd01aaVRFRDBKTVNDM1AxVG5EMVQxM09OL1ZTSHQxUGFSUCtLV050SVdtUVhlUnNnSlpQc05FaXBCWjhpN2tqT1p3WVkyUWwxV3RpWXpLcWdkaFZXVjlxaUlYb29kcVZwcyt2QTIvdmluMm5CMEQvWW0wVzVSc1JmTW5IZGJ4VjVQbGE5S1AyLzc1UlhKNHE1MEV3YmN0Q0NPYWJwN0l1RXY3NjRQajJHM2k4bXExUEtHbXpvdTRmOXRyZEQyVEFIczg3bDYwK29UblQxK3VBdTlJdjVQa2dIRC8vYkJUbGhnWXA4WGx4c0VReUdQUFV5RGErK3UvOUlkK2EyYzFsV3FtK2pJUHRRV0xicHJ1UkRJS0xhYWt5SGJuS0pXcjNTeTk0ZkZJZlNMTHEwQXRzd0lzcTluVkxJWEV1M1A1WW5tNnBNQU1iYytpalh6bUdnM09tNGg1ZTdBb0RxRzN1Q0NoZ3VtejlkQzFFOHZzdGxMRCtHd1FHbTdxK0VSTU43L3dFUFQ5Nm1lODBMRW83eC93L1U0ZXRsS2RIZzI5SnBFVGJvZCtvY0EydVpQM0hyTHBLQm5RNCsxZSt1QmpKeEM0RjlHZXp4Z0RnYTF4UndlSHVXYjhCODVTUGdnQUFIamFZMkJrWUdBQTRvMy91d3ZqK1cyK01qQ3pNSURBWTRGNU54SDBmeDNtRUtialFDNEhBeE5JRkFCUGpRdCtBSGphWTJCa1lHQm0rTThBSkVNWVVobWNtVDR6QUVWUUFETUFSK0lDL0FBQUExUUFBQUxOQUdVRFR3Qi9BQUFBQUFCc0FPaDQybU5nWkdCZ1lHWUlZR0JpQUFGR0JqUUFBQWlmQUZoNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVrQUFvQUFBQUFCZlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDFGMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNYWjJ4NVpnQUFBV1FBQUFKWUFBQUN1SkhqY2Nsb1pXRmtBQUFEdkFBQUFDOEFBQUEyS0crQmRXaG9aV0VBQUFQc0FBQUFIZ0FBQUNRR1hnSWxhRzEwZUFBQUJBd0FBQUFVQUFBQUZBNm9BS3RzYjJOaEFBQUVJQUFBQUF3QUFBQU1BV0lDREcxaGVIQUFBQVFzQUFBQUdBQUFBQ0FBQ1FBNmJtRnRaUUFBQkVRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRkdBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaFp2Z1A1RE5EcEpIVS9BY0tBd0Q3MVExamVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZndS8vOERTY2YvLy84ZkFQTVpBRkxLQnFCNDJqWFJ2MDhUWVJ6SDhlZnpmTnZuYUdudktsZnVhcURYbEpZZVlGb0l2ZHdCaWNWUXFRaXgvS2hCZ28xRUV5U1NpRDlBWkdEb2dERWFHSXdKaVhGdzBNMDR1emc1TVRtNU9xaVQ4VTh3YlgyT2hPZFpubnh6dy92N09zWlp0dDNtUC9rUE5zeEdHZlBnZXFPR3FjZU5vbXVJWVNoMnpuWmMwM0M5WWFRVkVUZE0xMVFoNS82NFdJSlhwTTlZRi9Hb1FNbklkeU1TM0dsMEJCSHQxQjBLS2ExMk5kcXJSd25SNE1aS0JKRlFYK25OMy9RdVg0NGhwRFViaGtaSkJVVGdIWm9DUk15NzB3ZnhiQXhjVTRVL0Rtc0NtUk1zTVhtSVhXZzNTZkF2ekdKRGJFeVc2azdHRnJJdGJhRmJoV0xCRkJxRWtoYW52Ym9mNStic1RFNG9kUFltK1VIeHcxR1BuZFEwck5UdlVLTTJWd08vRXJ2MnBQVzZWMVVuckhmSGF6c2NoZkpCU2c5dUhkWjNPUitaK1ZvSkFPb0NIei9IcVZjQlg1eVkzZERDMWZHNUtiVVU4RGVBam1sNlhNbGU1dERPTnovUzAyci9BclYrZDRrd1kyREY5aC9xNU4vOVpwQ0tqQlNkaEpPelpiTWZiRnJ3Sks5Zm1JSWxGNUR6QW16WDg2OWhHcVluMTZId0pSTGhVQkFjeS9QVHowWXFQY0pBWVAvcXdKcnI1RVVncEFRcFh4bDhWTjU3UzFSelpyY1Bhb01EWWtaRmhKKzAvcW15V2RGeXE1dEFlV3hsTFZIUDc5N202QnNxMUJPZEFJL2NuK292Z280YkwzWm1uU1VLWlB2VmVaV1ROT2RzVUpwNzBqekI4cjY0ZXdadUNzVy9aOWFucnFhL3dpUmN1d0JGcXI4L1F0bUtTZWJ0ZmREODBOaG1vL1VwcVVuaVg0Yys1OHRiZStaRW9xTUwvRjUxSzZWTDNSaFJVdjcyVncrZVA3eVl2MDVrQ1FuTHk4MXYwaEdCaGRUaXpmUU5lMzBWMEdUYWYvUUJkMWQ0Mm1OZ1pHQmdBT0xqWW5zWHh2UGJmR1ZnWm1FQWdjY0M4MjRpNlA4dm1jMlo3Z0s1SEF4TUlGRUFSY0FMd3dCNDJtTmdaR0JnWnZqUEFDVDlHVlQrWDJBMlp3Q0tvQUJXQUZVckE0a0FBQUoyQUFBREFBQWtBd2dBS3dMYkFETURUd0FwQUFBQUFBQlVBTEFCRGdGY2VOcGpZR1JnWUdCbHNHUmdaZ0FCUmdZMEFBQUdyUUJFZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1nQUFvQUFBQUFBNHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FreVVUbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pXWjJ4NVpnQUFBV3dBQUFCY0FBQUFhSjVnVklab1pXRmtBQUFCeUFBQUFDOEFBQUEyS01tQmRtaG9aV0VBQUFINEFBQUFIZ0FBQUNRRnV3QVVhRzEwZUFBQUFoZ0FBQUFJQUFBQUNBWW5BRkJzYjJOaEFBQUNJQUFBQUFZQUFBQUdBRFFBQUcxaGVIQUFBQUlvQUFBQUZ3QUFBQ0FBQkFBZmJtRnRaUUFBQWtBQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBREVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtYWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhvQUFIR0NPbHVDeWRnVTJKV1ltWldmR1BFUU1Ec3lMek9hQXdJMExwLy84TURBREx4QTNPQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyTS8vOUR5THYvd1BJTUFGQnRCb0VBQUhqYVkyQmtDUGovbjhtRDZRU0RMQU1EbzZBWW03b2ltNXFKbWJpaUlCcHRKc2JremlnbytTK0tUMHFTbjNIT3YwSWVTUmsreHE1L0tXRCtNa2xCcHZsL082WDRHUms1VkRnWUdTVWhsRGdqcHpJbkk2TUFBd0Q3TmhITmVOcGpZR1JnWUFEaTVtZ04zM2grbTY4TXpDd01JUEJZWU41TkJQMy9QL05FcGhOQUxnY0RFMGdVQUNMbUN6WUFlTnBqWUdSZ1lGYjhZd1FrSnpJRU1QZ3hlVEFBUlZBQUV3QkplQUxUQUFBRGtRQUFBcFlBVUFBQUFBQUFOQUFBZU5wallHUmdZR0Jpa0dNQTBReFFFZ2tBQUFPTEFDUUFlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ1ZHSmpZV0JpWmVvQzJLQU1jWkFkSWtXcU92SzdlN2dlZXNQcGVUL3VnSklmTXA2VDhScjNjM0lLVVg5YzhNSmI0cW1vUmVLU0Q1Wk15UEtaT0hNMmlYTkp2aElYdkhOSlBCWC9PM0hKSjQ5dDE5N3V2ZlZxM3hucjNia040L3BnZldnNnAxYTZpbnBubmZYSDNocDFHcFVabWpCY1cxWHJTdGRzNldpNWNhZkg0bEhzeFRHUkhXZkpBaU5yRHRFSk5KSTZhYTNRVlAveW5lUXVkbzd4azVIT1NSSWxOTWhWa0gyVnRxS09sNXI2Ri9ONU1FOEFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmdBQW9BQUFBQUE5UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFVOejdHTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUNnQUFBQXJLQUNIYVJvWldGa0FBQUNCQUFBQUM0QUFBQTJKN2lBcjJob1pXRUFBQUkwQUFBQUh3QUFBQ1FFandHOGFHMTBlQUFBQWxRQUFBQUtBQUFBQ2dSR0FHUnNiMk5oQUFBQ1lBQUFBQWdBQUFBSUFDd0FWbTFoZUhBQUFBSm9BQUFBRndBQUFDQUFCUUFaYm1GdFpRQUFBb0FBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFEVUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtdk1jNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwVFVZTkJrWnZnUDVETkRwSkhVL0FjS0F3RHZrUTBlZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pFajV6OEFZd3N6QUlNN0F3Q3FpcEthdXgyaXVabVp1eDJqRXo4akhLTTRtSk04b3hoZ3NsbXlvS2NQSUtLTm1tQ2JHeUJQbndjamtFcy9QL0kwcktUNWlsYTNUd3REa1ZCNkJ4RC90bGYvK3BRaXlNQUFCSTRNbDBGeE5pTG1NWW16c2ZJeEtwa0JUMVUzVTlCblZ6TTJNeE1UbEdCazF3Q2FLOHNaNk1RWDdDREV6TW9xQzdXR0FtcGowdDNYaEIxOGhGaWF3UFFBVkpDRk1lTnBqWUdSZ1lBRGl6eHRFMzhmejIzeGxZR1poQUlISEF2TnVJdWovREV3TnpDQXVCd01UaUFJQVJZRUtzZ0FBZU5wallHUmdZR2I0ejhEQXdOVEFZTWxneVJqQ0FCUkJBVXdBTzJ3Q1VBQUNnQUFBQVkwQVpBQTVBQUFBQUFBQUFDd0FWbmphWTJCa1lHQmdacEJnQU5FTVVCSUpBQUFERUFBZkFIamFSWXd4YjhJd0VJVy9pQVNKZE9oU2RXQUFEOHhXb2pCM1lXQmlaV0lCYktJTWNaQVRJaUdoanYzZFBZd2xibmo2N3IxM0IrVDhrdkNjaE0rZ3owbkpaSHR4eGdkZmthZXlMU1BuekZreElVbG40aXo0aVp4S2NvaWM4YzBsOGxUOFIrU2NOWCticnIzZUJ1dlZyalBXdTNQcnkySnZmZDkwVHBXNkNQdldPdXVQZ3pYcWRGZG1iUHF4YmxXbEMxMnhvYVBseW8wQmkwZXhFOGNFZHB3bDg1UVU3SVBUMDBqcXBGV2l4WDNuVzhsZDZCekRKeU9kRTNkUnd5aFh2V2d0YlVVVkxqWFZQMk05THc4QUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3MxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFhkMGcyTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWRnRXlaMng1WmdBQUFXd0FBQUU2QUFBQlVDaUNiMmRvWldGa0FBQUNxQUFBQUM4QUFBQTJKMktCZEdob1pXRUFBQUxZQUFBQUh3QUFBQ1FGTndGZ2FHMTBlQUFBQXZnQUFBQU9BQUFBRGdiRUFJRnNiMk5oQUFBRENBQUFBQW9BQUFBS0FQb0FobTFoZUhBQUFBTVVBQUFBR0FBQUFDQUFCd0F5Ym1GdFpRQUFBeXdBQUFEVEFBQUJQcWtyZGR0d2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtVW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb0dNNVF5Yy80SDhwazVHZEhVL0FjS0F3QzZhZ3pxZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVNDR1pJWVN2Ly9SN0Qrci91LzRIOGZXQzBZQUFEdWhndWlBSGphUFk2eFRzSlFBRVhmZlZVYUhRcXZEVFVJRmd0Q29RWXFKZkNDR2dpeEVURUdHalRCNktJNHFJbk9hdFROd2RGZmNEWHhFNWc3K2dPNk9EbTR1b0xQR0UzdWN1NGQ3aUVnaGZFSHh2U05MQkVDdVFoTGdXeGc1ajhDUTFtTEcrQjFjREgvSnZ0RHJvN1hjS0xYYUhWQTQ3SnVMM3FiS1RVTmVuUHNYbmpodFN0enZRUE1SdFJDbzdDUlhKRndmY2IzNkZNdmxnTnRPeWw3VW90TU15T2p0ZHpkMndrazg5dVZlVXI5aWxsU1ZCYWVNc3htczNzcHhRZ2hsT3lNdi9CSkF4SWhDVUkwVnY4ekV5YlJOTk9pT3RlclFrNVc4T2owaysxOUtwMTN5NTdxKzlhcWV5QkovWkxOYVRCNldZaEJ1ajg2dmFPd1ZFY1VEKzhlaFQ4WUNNMmMrQUhwaVo4aEFxSUtZT21LZ25RUm5KVlpTSGVybkdHNFpSM2FkUWMrblR0cEFjR29WakxqYU5iUUh6Mm5NbndaK1crbmRFQlNBQUI0Mm1OZ1pHQmdBT0xlZVJmZngvUGJmR1ZnWm1FQWdjY0M4MjRpNlA4dm1MU1k3Z0s1SEF4TUlGRUFZd0FNWkFCNDJtTmdaR0JnNXZ6UHdNREFaTUdneTZEQytKOEJLSUlDbUFFL1lBS2NBQUlxQUFBQ09BQXRBaEFBVkFCU0FBQUFBQUFBQUZJQWhnQ29BQUI0Mm1OZ1pHQmdZR0V3WkdCaUFBRkdCalFBQUFXekFEcDQyazJPc1dyRE1CQ0dQMVBiVUxmUXFSMDZGRTBaaFkzN0FJVU1tYkptTENTUk1DNVlEcEpqOEZMNkFIbm9YQlFOdllPZlQvLzlkd2lvK0NYalZoa3ZVVytWVThycnpnVlB2Q1l1cFZYaWluZFdQSkRsaitKODhKVTQ1NW52eEFWdi9DUXV4ZjlMWFBISlpUME9wL05rdmRxT3hucDNIRUpvNnAzMW9SK2RhblI5TnpiV1diK2ZyRkdIUlptNUQzTTNxRmJYdW1YTnlNQ0pNeE1XTHovYmltTWlPNDR5QzlJTk5idm9CWHFaTzhrMWFISC9KemFTY0RHMWo5ZU1wQTRzb29aWjlvSm9KM2xGRzNjMTdSWCtDREQ3QUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE1Ljg3Njc1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01MS42NTg5MScgeT0nLTYwLjc0NjM2OCc+U3ViPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zNS44MjkzNTUnIHk9Jy02MC43NDYzNjgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMxLjk1NDk4MScgeT0nLTYwLjc0NjM2OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjMuODk4MzcyJyB5PSctNjAuNzQ2MzY4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNi4xMTE4MywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MC43NDYzNjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjAuNzQ2MzY4Jz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYwLjc0NjM2OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjAuNzQ2MzY4Jz5EPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yMy40Mjk5OTInIHk9Jy02MC43NDYzNjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOS40MDk3M1YtNDcuOTk1NzcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwwLjAsLTkuMTU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMi4xMjg1NCwtMzAuMjAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01MS42NTg5MScgeT0nLTYwLjc0NjM2OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDYuOTkyMzI1JyB5PSctNjMuNzUyODg1Jz7iiJc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMzIyMTQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MC43NDYzNjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjAuNzQ2MzY4Jz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYwLjc0NjM2OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjAuNzQ2MzY4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNC40ODI5ODInIHk9Jy02MC43NDYzNjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMTQwOSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MC43NDYzNjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjAuNzQ2MzY4Jz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYwLjc0NjM2OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjAuNzQ2MzY4Jz5DPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNC4xMjE4NjcnIHk9Jy02MC43NDYzNjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTIwLjkzMjMgMEgzNi43NjY2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDIwLjY4MjMsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4wMTY2NiwzLjg3MjkyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYwLjc0NjM2OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuNjU4OTEnIHk9Jy02MC43NDYzNjgnPuKIgzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuMTQ4MDI1JyB5PSctNTkuNjg5MjIxJz5oPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTkuNDA5NzNWLTQ3Ljk5NTc3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwtOS4xNTk3MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTMwLjIwMjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYwLjc0NjM2OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTEuNjU4OTEnIHk9Jy02MC43NDYzNjgnPms8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ3LjI1NTI1NScgeT0nLTYzLjc1Mjg4NSc+4oiXPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00yMS4xNjczNy01Ni45MDU1SDM2LjU4NTM2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDIwLjkxNzM3LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4yNzEzMiwtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01MS42NTg5MScgeT0nLTYwLjc0NjM2OCc+4oiDPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny4xNDgwMjUnIHk9Jy01OS43NTAxMDQnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = {\mathsf {Sub}(B)},
      ne = {\mathsf {Sub}(A)},
      sw = {\mathsf {Sub}(D)},
      se = {\mathsf {Sub}(C)},
      north = {\exists _{h}},
      north/style = {<-},
      west = {f^{*}},
      west/style = {<-},
      south = {\exists _{g}},
      south/style = {<-},
      east = {k^{*}},
      east/style = {<-},
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />, the two composites can be constructed as <fr:tex
display="inline"><![CDATA[f^{*}\mathsf {Img}\Sigma _{g}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathsf {Img}\Sigma _{h}k^{*}]]></fr:tex> respectively.
    Since images commute with pullbacks in a regular category, we have <fr:tex
display="inline"><![CDATA[f^{*}\mathsf {Img}\Sigma _{g} \cong  \mathsf {Img}f^{*}\Sigma _{g}]]></fr:tex>.
    Then by the <fr:link
type="local"
href="ct-0008.xml"
addr="ct-0008"
title="Pasting lemma of pullbacks">pasting lemma</fr:link>, <fr:tex
display="inline"><![CDATA[f^{*}\Sigma _{g}(m) \cong  \Sigma _{h}k^{*}(m)]]></fr:tex> for any subobject <fr:tex
display="inline"><![CDATA[m \in  \mathsf {Sub}(C)]]></fr:tex>, which assembles into a natural isomorphism <fr:tex
display="inline"><![CDATA[f^{*}\Sigma _{g} \cong  \Sigma _{h}k^{*}]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="e4fefc841687866bdf47763e1aa4cd13"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMC44NjUzN3B0JyBoZWlnaHQ9JzExNC45MDIzMzFwdCcgdmlld0JveD0nLTcyIC03MiAxMzMuOTEwMjQ3IDc2LjYwMTU1NCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS01pQTYyaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZEc4dDg0L2x0dmpJd3N6Q0F3R09CZVRlUmFlYUpURFpBaW9PQkNjUURBQ1NYQ1lnQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV1VBQW9BQUFBQUJ0Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMHgyTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWdnRENaMng1WmdBQUFXd0FBQUxDQUFBRG5QS3JaMlJvWldGa0FBQUVNQUFBQUM4QUFBQTJKLzZBcldob1pXRUFBQVJnQUFBQUlBQUFBQ1FGcWdHY2FHMTBlQUFBQklBQUFBQVVBQUFBRkF4VUFSRnNiMk5oQUFBRWxBQUFBQXdBQUFBTUFhNENvbTFoZUhBQUFBU2dBQUFBR0FBQUFDQUFDQUJZYm1GdFpRQUFCTGdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGaUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtS21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F6TS93SDhwa2gwa2hxL2dPRkFkbUFEVGdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLWmpCay8vOFA1S2VCNlArei84OEVxd0lDQUptTkNUNEFBSGphYmROTGI5TkFFQWR3ejZ3ZnNSTjc0OWU2VFZJM2laMTFxcVpKMjZST1cwTGFOQVdwN3hZSlNoR0NFeUJ4UXVLQ1FPSVRJSVFRQjY3YytBcmNLL1hNaHdHSlM4dWE4amhRNzIxbkQvT2IvMWdDYWVlaWcwL3hxN1F1U1VBb3FKb0ZXcDBuUStpeWdLa2FtNFlockpGSTVXblFIVUpmM0MreXdJS0lKenp0OHc1WVNLR2JNaldCVDZ0RnVWalNSd3ZOVllEWTV3VG9OS1UwcnBHcE50ME4wYVZIMUxmWVJqUXpBSWlZcUJkRFNoMG5OSEtsaDFrWlBweWZidHZyUFc5TWVCUldNVmFUdkk0ZzcvZ2Z2eDJUdWdiSEorV0VOK0ovSlpqa2MyL2xlZzRrOGFIVXVwakRCcHhLYldtY2FZUkUvU1VSSFh1cUZyQXVTd1ZnVFNEYmtLVDk3SVFRQ0pWNFFOWWdUUVJLMWJJUnNHQXhlNHExWi9yekY1MEhzdWpYWm1BNUZidm1EYUlLMDRMKzF1Z0V5WWphV3lmTkpaT1VITk9IOXgwQ250OHJqYXQrMFFhZWhCdVZnZ1l2ejBlZGV3VDkxbFROZGZPaG9TRGtLNVB6MWZ0ZEdZNFBIKzI3ZEpOQXpJb01pdmI1ank4MDM0aGthQzd4MGZwQkh4cFZhZ29iU0hzWDMvRVZua2s3bVV5MEhLS21Yc2JscTFtemFUY0loVmNja1Y1UFlESWVUN0laVUZuazFZYWx2anNFSGwyRzIwK1pCcVA5eXEyVm03MENvSWR1d1RSSVpYcmdvRzJvRU9UdGFOaGNCbUphakNHeTV1QndnaXB1VmM4WmdlN1l5anNaYWF3WEFTeHRzOVVBL0h4K1Z1dUMwdW1aN1lGNnJWeXIyWFZjdSs0Z0J2TUJhOHVkbVVLK0dtK01GL3dGeEhHVDViZGY4ekxOZzJzeTNEU3BJUnMwcDhtazhOdDVRemp2Wk00c2cwWG0vMTAzb2MzTVlqUEY4U2p4V0hDNWs5bkZIenp2cDRuSWw0SUZkWDRGK3ZIMDNlVG9OaGNqRnlzWVZDMXY5aURod1VTMVIrbThqRVFCNnZGWmcyaUdyZ0lVRGEreWtvd1JGQUt3dlJ4Uk9lQlg4WjlZdTQybGxvQmpiTVU1QzJDVjF6elJncUt6RlVNM3k2NzRrZVM5bUJxSWh0SXVWOXB5TjdVY1MyMG15cHRWWitLL1FValNUd3l3ZFJJQUFIamFZMkJrWUdBQTRqREJKTjU0ZnB1dkRNd3NEQ0R3V0dEZVRRVDlYNWZwR05ORklKZURnUWtrQ2dBRHZnb2tBSGphWTJCa1lHQm0rTS9Bd01CMGpFSG4vd1dtYWdhZ0NBcGdCUUJtWUFSS0FzWUFBQUk2QUVzQ09nQXNBcXdBVFFKdUFFMEFBQUFBQUdZQTFBRklBYzU0Mm1OZ1pHQmdZR1VJWjJCaUFBRkdCalFBQUFtRUFHRjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVa0FBb0FBQUFBQmZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxRjJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDWFoyeDVaZ0FBQVdRQUFBSllBQUFDdUpIamNjbG9aV0ZrQUFBRHZBQUFBQzhBQUFBMktHK0JkV2hvWldFQUFBUHNBQUFBSGdBQUFDUUdYZ0lsYUcxMGVBQUFCQXdBQUFBVUFBQUFGQTZvQUt0c2IyTmhBQUFFSUFBQUFBd0FBQUFNQVdJQ0RHMWhlSEFBQUFRc0FBQUFHQUFBQUNBQUNRQTZibUZ0WlFBQUJFUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZHQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmhadmdQNURORHBKSFUvQWNLQXdENzFRMWplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2Z3UvLzhEU2NmLy8vOGZBUE1aQUZMS0JxQjQyalhSdjA4VFlSekg4ZWZ6Zk52bmFHbnZLbGZ1YXFEWGxKWWVZRm9JdmR3QmljVlFxUWl4L0toQmdvMUVFeVNTaUQ5QVpHRG9nREVhR0l3SmlYRncwTTA0dXpnNU1UbTVPcWlUOFU4d2JYMk9oT2Rabm54encvdjdPc1padHQzbVAva1BOc3hHR2ZQZ2VxT0dxY2VOb211SVlTaDJ6blpjMDNDOVlhUVZFVGRNMTFRaDUvNjRXSUpYcE05WUYvR29RTW5JZHlNUzNHbDBCQkh0MUIwS0thMTJOZHFyUnduUjRNWktCSkZRWCtuTjMvUXVYNDRocERVYmhrWkpCVVRnSFpvQ1JNeTcwd2Z4YkF4Y1U0VS9EbXNDbVJNc01YbUlYV2czU2ZBdnpHSkRiRXlXNms3R0ZySXRiYUZiaFdMQkZCcUVraGFudmJvZjUrYnNURTRvZFBZbStVSHh3MUdQbmRRMHJOVHZVS00yVndPL0VydjJwUFc2VjFVbnJIZkhhenNjaGZKQlNnOXVIZFozT1IrWitWb0pBT29DSHovSHFWY0JYNXlZM2REQzFmRzVLYlVVOERlQWptbDZYTWxlNXRET056L1MwMnIvQXJWK2Q0a3dZMkRGOWgvcTVOLzlacENLakJTZGhKT3paYk1mYkZyd0pLOWZtSUlsRjVEekFtelg4NjloR3FZbjE2SHdKUkxoVUJBY3kvUFR6MFlxUGNKQVlQL3F3SnJyNUVVZ3BBUXBYeGw4Vk41N1MxUnpacmNQYW9NRFlrWkZoSiswL3FteVdkRnlxNXRBZVd4bExWSFA3OTdtNkJzcTFCT2RBSS9jbitvdmdvNGJMM1ptblNVS1pQdlZlWldUTk9kc1VKcDcwanpCOHI2NGV3WnVDc1cvWjlhbnJxYS93aVJjdXdCRnFyOC9RdG1LU2VidGZkRDgwTmhtby9VcHFVbmlYNGMrNTh0YmUrWkVvcU1ML0Y1MUs2VkwzUmhSVXY3MlZ3K2VQN3lZdjA1a0NRbkx5ODF2MGhHQmhkVGl6ZlFOZTMwVjBHVGFmL1FCZDFkNDJtTmdaR0JnQU9Malluc1h4dlBiZkdWZ1ptRUFnY2NDODI0aTZQOHZtYzJaN2dLNUhBeE1JRkVBUmNBTHd3QjQybU5nWkdCZ1p2alBBQ1Q5R1ZUK1gyQTJad0NLb0FCV0FGVXJBNGtBQUFKMkFBQURBQUFrQXdnQUt3TGJBRE1EVHdBcEFBQUFBQUJVQUxBQkRnRmNlTnBqWUdSZ1lHQmxzR1JnWmdBQlJnWTBBQUFHclFCRWVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNzAzNTU3LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNS43MDM1NTcnIHk9Jy02MS44MDM1Myc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy45MzEyNCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNzAzNTU3LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNS43MDM1NTcnIHk9Jy02MS44MDM1Myc+QzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03LjY4NDA1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNzAzNTU3LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNS43MDM1NTcnIHk9Jy02MS44MDM1Myc+azwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjcwMzU1NywtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNzAzNTU3JyB5PSctNjEuODAzNTMnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuNjI3MDMsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjcwMzU1NywtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNzAzNTU3JyB5PSctNjEuODAzNTMnPkQ8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQgMEg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1Ljk2NTE4LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjcwMzU1NywtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTUuNzAzNTU3JyB5PSctNjEuODAzNTMnPmg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjQ4Njc5LTU2LjkwNTVINDcuNTcxNDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuODIxNDksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI2LjIwMjkxLC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNTEuMjE1MDQtMTQuMjI2MzZILTQyLjY3OTE0Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi4wNTgyOSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzEuNzY4NDQyJyB5PSctNjUuNDE4ODk0Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjIzOTUyLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5DPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzIuMTI5NTU3JyB5PSctNjUuNDE4ODk0Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00NC44MTU5NS01Ni45MDU1SC04Ljk4Njc5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLC00NC41NjU5NSwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTguNzM2NzksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDQuOTk3MTggMEgtOC44MDU1NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwtNDQuNzQ3MTgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOC41NTU1NCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J00tNTYuOTA1NS02LjQwOTczVi00Ny40Nzc5NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLC01Ni45MDU1LC00Ny43Mjc5NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw = A,
        nw/style = {pullback},
        ne = B,
        sw = C,
        se = D,
        north = h,
        south = g,
        west = k,
        east = f,
      }
      \node  [left = of nw,pullback] (1) {$A'$};
      \node  [left = of sw] (2) {$C'$};
      \draw  [>->,morphism] (2) to (sw);
      \draw  [>->,morphism] (1) to (nw);
      \draw  [->,morphism] (1) to (2);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Thus, we can extend this natural isomorphism as follows:</fr:p>
  <fr:tex
display="block"><![CDATA[     f^{*}\mathsf {Img}\Sigma _{g} \cong  \mathsf {Img}f^{*}\Sigma _{g} \cong  \mathsf {Img}\Sigma _{h}k^{*}   ]]></fr:tex>
  <fr:p>Then both <fr:tex
display="inline"><![CDATA[\forall _{k}h^{*}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g^{*}\forall _{f}]]></fr:tex> are right adjoint to <fr:tex
display="inline"><![CDATA[f^{*}\exists _{g}]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[\forall _{k}h^{*} \cong  g^{*}\forall _{f}]]></fr:tex> by the uniqueness of adjoint.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1347</fr:anchor><fr:addr
type="user">ct-0011</fr:addr><fr:route>ct-0011.xml</fr:route><fr:title
text="Coherent categories admit distributive law"><fr:link
type="local"
href="ct-000X.xml"
addr="ct-000X"
title="Coherent category">Coherent categories</fr:link> admit distributive law</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a coherent category.
  Then intersections distribute over unions, i.e., for any three subobjects <fr:tex
display="inline"><![CDATA[A_{1}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[A_{3}]]></fr:tex> of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, the following holds.</fr:p><fr:tex
display="block"><![CDATA[   A_{1} \cap  (A_{2} \cup  A_{3}) \cong  (A_{1} \cap  A_{2}) \cup  (A_{1} \cap  A_{3}) ]]></fr:tex>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>638</fr:anchor><fr:addr
type="machine">#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  Let <fr:tex
display="inline"><![CDATA[m\colon A_{1}\rightarrowtail A]]></fr:tex> be a subobject of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
  Then by <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />, <fr:tex
display="inline"><![CDATA[A_{1} \cap  (\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]]></fr:tex> can be described as the composite <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A) \xrightarrow {m^{*}} \mathsf {Sub}(A_{1}) \xrightarrow {\exists _{m}} \mathsf {Sub}(A)]]></fr:tex>.
  Thus, we have
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  <fr:tex
display="block"><![CDATA[   \begin {align*}     A_{1} \cap  (A_{2} \cup  A_{3}) &\cong  \exists _{m}m^{*}(A_{2} \cup  A_{3}) && \text {$m^{*}$ preserves finite unions}\\                             &\cong  \exists _{m}(m^{*}(A_{2}) \cup  m^{*}(A_{3})) && \text {left adjoint preserves finite unions}\\                             &\cong  \exists _{m}m^{*}(A_{2}) \cup  \exists _{m}m^{*}(A_{3})\\                             &\cong  (A_{1} \cap  A_{2}) \cup  (A_{1} \cap  A_{3})   \end {align*} ]]></fr:tex></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1348</fr:anchor><fr:addr
type="user">ct-0012</fr:addr><fr:route>ct-0012.xml</fr:route><fr:title
text="Union as a pushout of intersection">Union as a pushout of intersection</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-000X.xml"
addr="ct-000X"
title="Coherent category">coherent category</fr:link> and <fr:tex
display="inline"><![CDATA[A_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex> be subobjects of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>.
  Then the following square is both a pullback and a pushout in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="d1d71d71af52a3bcac27b5f8014872c2"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE1MC4zMzYwOXB0JyBoZWlnaHQ9JzExNS41MTQ2NzVwdCcgdmlld0JveD0nLTcyIC03MiAxMDAuMjI0MDYgNzcuMDA5NzgzJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPd0FBb0FBQUFBQkJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVXgxQW1OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDRloyeDVaZ0FBQVdRQUFBRDBBQUFBOU51KytaSm9aV0ZrQUFBQ1dBQUFBQzBBQUFBMktJbUJpR2hvWldFQUFBS0lBQUFBSGdBQUFDUUZ1Z0t5YUcxMGVBQUFBcWdBQUFBS0FBQUFDZ1puQUpKc2IyTmhBQUFDdEFBQUFBZ0FBQUFJQURJQWVtMWhlSEFBQUFLOEFBQUFGd0FBQUNBQUJRQXRibUZ0WlFBQUF0UUFBQURLQUFBQk11c0lrZVp3YjNOMEFBQURvQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1lczA0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBRMFpEQmladmdQNURORHBKSFUvQWNLQXdEMnhBMCtlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aEcvLzhEU2NQLy8vOWZBUE1aQUZGWUJvNEFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FBQUVBWFFBQUFsc0NxZ0FyQUFBbEJ5RTFORDhDUGdFM0xnRW5JZ1lISGdFWERnRWpCaVluUGdFM01oWVhEZ0VIQmc4QkpUWTNQZ0UzQWxzaS9pUURDZm85VFFFQ2FFMDBVaFlZSVFFQkpoVU9MQUlDaEdwd213TUNhRWd2TldrQkFpb0tEUThDeHNZZkJRSUoxREZxUDB4VEFTb2pBaDhiSUIwQkdTZE5aUUpwWTFCcExpQW5UZ0VCQkF0QkVnQUFlTnBqWUdSZ1lBRGl4ZjF0dStQNWJiNHlNTE13Z01CamdYa2ZrR25tSUtiVlFJcURnUW5FQXdBMU93b3FBQUFBZU5wallHUmdZR2I0endBa2d4aGlHV0tab2htQUlpaUFDUUE5MFFKekFBQURVZ0FBQXJnQWtnQmRBQUFBQUFBQUFESUFlbmphWTJCa1lHQmdadEJoQU5FTVVCSUpBQUFGQkFBekFIamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU3ArYm00T1RxOFBickFuU29hbWt0ZWdpL25SdlEvQUdEdDg5NTl3QUdTOFNoa21ZQngwbWxUZVBQT2FIUmVTSitLdklHYitzR1pHa00zRlc3Q0tuVFBtUFBHWkpHWGtpL2lOeXhoL3ZmVlBmN3AzMTZ0Z1k2OTJsOXR1VDlXM1ZPTFhSK2JBZXJMUCszRm1qeXFjeWZkWDIxMW9WT3RjRmV4cHFidHpwc0hnVVIzRk1ZTWRGTXMrV1U5aGJLc21jZERabzhtOTZrTlNGeGpuOFlxUlI4aFExOUhMVGlsNmxxeWpDbmFiNEFGVXlMa01BQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPY0FBb0FBQUFBQkRBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxblNVSW1OdFlYQUFBQUZBQUFBQU13QUFBRHdpUFNLRloyeDVaZ0FBQVhRQUFBRElBQUFBK0NjNlByNW9aV0ZrQUFBQ1BBQUFBQzhBQUFBMktGU0JLbWhvWldFQUFBSnNBQUFBSGdBQUFDUUZ4ZjkvYUcxMGVBQUFBb3dBQUFBS0FBQUFDZ1g5QURkc2IyTmhBQUFDbUFBQUFBZ0FBQUFJQUQ0QWZHMWhlSEFBQUFLZ0FBQUFGd0FBQUNBQUJRQW1ibUZ0WlFBQUFyZ0FBQURUQUFBQlBxODNkZUZ3YjNOMEFBQURqQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm11c0E0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3BwSVdzOVFmVFFZR1ppbm02MEJoUm9UUy8vOFpHQUFYblE3SkFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lOSUEwRzVCbVpHQlMwbFRTK3YrZmdRRkMzNzF4OXdaWUZSQUFBSkxGQ1FBQWVOcGpZR1F3Ly8rS3FaZ3BoVUdGZ1lGUlVJeE5TYzFjMEV4TlhZK1JYWTJkRFFoaFF2YU1ac1pHNG1MaVlreEZqT3l5N0l4TWtoWmE0U3BHTGtxeTFpeGdBUlpmaWVERTZDQkJBVy9HMW4rZGZHSmlmSXhGNG9IcVVzS01qR0xjNHBwUi8zckJZaFdaNXZ6NjJwdzhaa0RyZ0hhL0JOcWRETEdialorUlRWbEpYUTBJQmRYTWpNVFlCZG5FeE9VWWpjWE16WUFRTE1SVWhMQ0ZCYXN6bU96L2RRSnRNTkRtNGpITFpDempGeFhsLzljdkhxUXVLY3dvRG5JRll4RlFpSUVCQUFoTktFTjQybU5nWkdCZ0FPSnYwM2IyeC9QYmZHVmdabUVBZ2NjQzh6NGc2UDh2bVdXWVVvQmNEZ1lta0NnQVhvd0w5Z0I0Mm1OZ1pHQmdsdnFqQ1NSbEdNd1p6Sm1LR1lBaUtJQUpBRHM4QWtrQUFBTWNBQUFDcWdBM0FEY0FBQUFBQUFBQVBnQjhlTnBqWUdSZ1lHQm1VR1VBMFF4UUVna0FBQVJWQUN3QWVOcE5qckZxd3pBUWhqOVR4MUFua0trZE9oUk5HWVdOOHdDRkRKbXlaaXdra1FnT1dBNlNZL0JTOGdCOTZGNFVEVDNCOGVtLzc0U0FraDh5SHBXeGpQMVJPWVhjbmp4anpsdmlRbzVLWFBMQmloZXkvRldTVDc0UzV5ejRUanpqblV2aVF2Sjc0cEkxdjV1K3U5NEc2OVd1TjlhN1V4ZW11dHBiSDlyZXFWcFh6MkJybmZXSHdScDFuSlFaMnpDZU85WG9TamRzNk9tNGNtUEE0dVZuTzBsTVpNZEpab0dKbW9wOXpBS3R6SjE0TlZyUy84WldEQmV0UTN6TmlIV1VtUklhWlM5SVA0dXZhT0t1cHZrRENWRXhFd0I0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPZ0FBb0FBQUFBQkFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVXgwakdOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDRloyeDVaZ0FBQVdRQUFBRGtBQUFBNU91YmdpOW9aV0ZrQUFBQ1NBQUFBQzBBQUFBMktBcUJobWhvWldFQUFBSjRBQUFBSHdBQUFDUUZTQUlZYUcxMGVBQUFBcGdBQUFBS0FBQUFDZ1ZiQUhCc2IyTmhBQUFDcEFBQUFBZ0FBQUFJQUN3QWNtMWhlSEFBQUFLc0FBQUFGd0FBQUNBQUJRQXJibUZ0WlFBQUFzUUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQURrQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvYU1oZ3hNL3dIOHBraDBraHEvZ09GQWN2bURNZ0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aEcvLzhEU2NQLy8vOWZBUE1aQUZGWUJvNEFBUUJ3QUFBQjVBS3BBQmtBQUFFUkJoWTdBUlV2QVE4Qk5UTXlOaWNSRGdFbk5SWTJOellXQVZjRElFa25aMUJ3UmlkSklBTXNWQlFoZERNVkN3S0wvY2thRlNVREFRSUNKUlVhQWdvVUNRRWtBaFl1QVFvQUFBRUFRUUFBQWdVQ3FBQXBBQUFsQnlFM05qOEJQZ0ltSnlZR0J4NEJCdzRCSXdZbUp6NEJOeDRCRnc0QkR3RUdCemMyTno0Qk53SUZILzViQVFJSDl4dENBMDlOSmxZWkp4WUJBU0lUQ2lvQ0FYTmhaWWNEQWxVN1ZTcE84aVVMQ2c0Q3Vyb2NCZ2IwRzJhRVlBSUJLelVDSlE4Y0d3RVZKa2xyQXdGcFhrZHFMRVVpUlFFQkJBcEFFd0I0Mm1OZ1pHQmdBT0xtR3hXbDhmdzJYeG1ZV1JoQTRMSEF2QS9JTk5ObHBwVkFpb09CQ2NRREFEU1BDbjBBQUFCNDJtTmdaR0JnWnZqUHdNREFkSm5Ca2NHSmlaVUJLSUlDbUFBL013Sm1BQUxUQUFBQ1J3QndBRUVBQUFBQUFBQUFMQUJ5ZU5wallHUmdZR0JtMEdJQTBReFFFZ2tBQUFUU0FERUFlTm85akRHcndqQVVoYjlpRmUwYkhBU0hOMGp3QjRSS0g3aTRPVGk1T3J6Tm1pQWRta3BhaXk3aVQvYzJCRy9nOE4xenpnMlE4U0pobUlSNTBHRlNlZlBJWTM1WVJKNkl2NHFjOGN1YUVVazZFMmZGTG5MS2xQL0lZNWFVa1NmaVB5Sm4vUEhlTi9YdDNsbXZqbzJ4M2wxcXZ6MVozMWFOVXh1ZEQrdkJPdXZQblRXcWZDclRWMjEvclZXaGMxMndwNkhteHAwT2kwZHhGTWNFZGx3azgydzVoYjJsa3N4Slo0TW0vNllIU1Yxb25NTXZSaG9sVDFGREx6ZXQ2Rlc2aWlMY2FZb1BXS3d1U3dBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRc0FBb0FBQUFBQk53QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWVIwdDJOdFlYQUFBQUU0QUFBQU1RQUFBRHdBa3dDNloyeDVaZ0FBQVd3QUFBRm9BQUFCckZGUG1NZG9aV0ZrQUFBQzFBQUFBQzhBQUFBMkovNkJkMmhvWldFQUFBTUVBQUFBSHdBQUFDUUZ0UUg2YUcxMGVBQUFBeVFBQUFBTUFBQUFEQWNYQUdCc2IyTmhBQUFETUFBQUFBZ0FBQUFJQUdBQTFtMWhlSEFBQUFNNEFBQUFHQUFBQUNBQUJnQk9ibUZ0WlFBQUExQUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUVJQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1pbVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwbU1wUXlNL3dIOHBraDBraHEvZ09GQWRHTkRTc0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtaaktVL3Y4UDVJUHAvelArOTRKVkFRRUFtc2dKUndBQUFIamFYYy9MVHNKQUZBYmcrUTkwS2hkYldxWXpqQmR1RllxYWxJSVVMMEJSRStLR3hCZHdiZUpibUxqeVFXVHZPL2dDTG53S3Q4YWQwWUdsT2FzLzU1emsveGl4NVBjYjk3UmlSVFpsREE3c0dHbUdvY3pOTVU1SGRwdmJQSXk2MGVoMGJLWU94VjNpdGdNMU5QbEUxV0diQS9NVGpiRkVxeVlDaE1maS9YS0g2L3BVd0N0eDFFcGVtQjJuZ0tXMTcxWnllNDFKbGJ3Q2h5ejU0Y3dzaUI1bEMxQ3ViT21mejVkclVZbHlrK3NLVWNFWnlDQzJNRHp3S2xkWHZhUG1Bdk9aVDZRU0plTThCcDBhZytuL1JVOTRZMHZHT3FlbXVCSXVPUWlFVkJrTW9RR3B4TG9pNzBZR3g2T1kxcEQvc0tGVWE1WE4xMjhtNHpYbDRqelBROGtMVHJVWmJtM2xTMFdPcXIrWGxtK0VudlV2a3QweS9KNEgzWmhXTjA1Vk5zN2VHYkN0MmlCNTBzOWNzbFlmK3FCaHErZTdJSGFDZmRBaTJ1VUdYTFF1V3lNaTJkZUhvRkNmTjIvdnczWUg4MnlqVHBSUkp6MVZQM3ZvZTNPTEpqczV3ZGdmUkp3MTJIamFZMkJrWUdBQTRxVkxCZC9HODl0OFpXQm1ZUUNCeHdMelBpRG8vMStZampFdEEzSTVHSmhBb2dCUm1neGdBSGphWTJCa1lHQm0rTS9Bd01CMGpNR0F3WUNwbVFFb2dnS1lBVVJJQXJVQUFzWUFBQUdlQURBQ3N3QXdBQUFBQUFCZ0FOWjQybU5nWkdCZ1lHYndaV0JpQUFGR0JqUUFBQWhVQUZWNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5vQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDA0V050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNVWjJ4NVpnQUFBV1FBQUFDb0FBQUFxTC9zRGVWb1pXRmtBQUFDREFBQUFDOEFBQUEyS0JtQnVXaG9aV0VBQUFJOEFBQUFIUUFBQUNRR0J3SWlhRzEwZUFBQUFsd0FBQUFJQUFBQUNBVjJBQ1JzYjJOaEFBQUNaQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUpzQUFBQUZnQUFBQ0FBQlFBMGJtRnRaUUFBQW9RQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRFdBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTJzMDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCa1p2Z1A1RE5EcEpIVS9BY0tBd0RvOXcwdGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpTy8vOUR5UDhId0h3R0FGS1hCcDBBQUFBQUFnQWsvLzhDNFFMZEFDOEFNZ0FBTndFMk56SVdGeE1VRmpNMkZnWXZBUWNuSmljME5oY1dOamN2QVNFSEJoUVdGellYRGdFdkFRY21KelEyTXo0Qk56TUR0d0ZsQmhRTkJnRStGaTBWQVF3RmRJQUlCUUVOQ3hNMEF3a0gvdjlPRFJ3VERRTUJEUVZuV0F3QkRBa2lQcG5ySVhZQ1ZoQUJDUS85Z0JZUEF4MEhBUU1EQVFJSUR3Y0JBUXdYWmtXRUZDUVFBUUlQRGdZQkF3TUJDZzhHQVNQSUFWSUFBQUI0Mm1OZ1pHQmdBT0tHNTdQRDQvbHR2akl3c3pDQXdHT0JlUjhROVAvL1RBK1o3Z0s1SEF4TUlGRUFXWFVNemdCNDJtTmdaR0JnWnZqUEFDSVpWQmprbVI0eUFFVlFBQk1BTll3Q01BQUFBQUoyQUFBREFBQWtBQUFBQUFCVUFBQjQybU5nWkdCZ1lHSXdCbUlRWUdSQUF3QUZyd0E2QUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTAuMjM0NDI3LC02MS4wMzU1Njcpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTcuNTQxNjYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUwLjIzNDQyNywtNjEuMDM1NTY3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01MC4yMzQ0MjcnIHk9Jy02MS4wMzU1NjcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQyLjc2MjQyOCcgeT0nLTU5LjU0MTE4Nic+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzYuMDc5MTkyJyB5PSctNjEuMDM1NTY3Jz7iiKk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTI3LjIyMzU0NCcgeT0nLTYxLjAzNTU2Nyc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTkuNzUxNTQ1JyB5PSctNTkuNTQxMTg2Jz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01Ljk5MzA3LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTAuMjM0NDI3LC02MS4wMzU1Njcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUwLjIzNDQyNycgeT0nLTYxLjAzNTU2Nyc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDIuNzYyNDI4JyB5PSctNTkuNTQxMTg2Jz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTEwLjEwOTdWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsMC4wLC0xMC4zNTk3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC05Ljk5NiwtMzAuMDM2MDcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MC4yMzQ0MjcsLTYxLjAzNTU2NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTAuMjM0NDI3JyB5PSctNjEuMDM1NTY3Jz5pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny40MTU3JyB5PSctNjAuMDM5MzAzJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUwLjkxMjQzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MC4yMzQ0MjcsLTYxLjAzNTU2NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTAuMjM0NDI3JyB5PSctNjEuMDM1NTY3Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Mi43NjI0MjgnIHk9Jy01OS41NDExODYnPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzkuMzYzODUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MC4yMzQ0MjcsLTYxLjAzNTU2NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTAuMjM0NDI3JyB5PSctNjEuMDM1NTY3Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Mi43NjI0MjgnIHk9Jy01OS41NDExODYnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTM2LjA3OTE5MicgeT0nLTYxLjAzNTU2Nyc+4oiqPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0yNy4yMjM1NDQnIHk9Jy02MS4wMzU1NjcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTE5Ljc1MTU0NScgeT0nLTU5LjU0MTE4Nic+MjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMjQuMjk3MiAwSDQ1Ljg1Njg5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDI0LjU0NzIsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni4xMDY4OSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMwLjg2MDk4LDMuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MC4yMzQ0MjcsLTYxLjAzNTU2NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTAuMjM0NDI3JyB5PSctNjEuMDM1NTY3Jz5pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny40MTU3JyB5PSctNjAuMDM5MzAzJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTEwLjEwOTdWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwtMTAuMzU5NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTMwLjAzNjA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTAuMjM0NDI3LC02MS4wMzU1Njcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTUwLjIzNDQyNycgeT0nLTYxLjAzNTU2Nyc+dTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDUuNTI0MDMyJyB5PSctNjAuMDM5MzAzJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMi43NDg2MS01Ni45MDU1SDM0LjMwODMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTIuOTk4NjEsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM0LjU1ODMsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE4LjM2MywtNjIuNzMxMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUwLjIzNDQyNywtNjEuMDM1NTY3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01MC4yMzQ0MjcnIHk9Jy02MS4wMzU1NjcnPnU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ1LjUyNDAzMicgeT0nLTYwLjAzOTMwMyc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = {A_{1} \cap  A_{2}},
    ne = {A_{2}},
    sw = {A_{1}},
    se = {A_{1} \cup  A_{2}},
    north = {i_{2}},
    north/style = {>->},
    west = {i_{1}},
    west/style = {>->},
    south = {u_{1}},
    south/style = {>->},
    east = {u_{2}},
    east/style = {>->},
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>where the <fr:tex
display="inline"><![CDATA[i]]></fr:tex>'s and the <fr:tex
display="inline"><![CDATA[u]]></fr:tex>'s are the product projections and coproduct injections in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> respectively.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>640</fr:anchor><fr:addr
type="machine">#263</fr:addr><fr:route>unstable-263.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>The diagram commutes since <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> is a preorder: any two morphisms <fr:tex
display="inline"><![CDATA[A_{1} \cap  A_{2} \rightrightarrows  A_{1} \cup  A_{2}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> are equal.
    Moreover, this diagram is a pullback in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> as the pullback of <fr:tex
display="inline"><![CDATA[u_{2}]]></fr:tex> along <fr:tex
display="inline"><![CDATA[u_{1}]]></fr:tex> is just the largest subobject contained in both <fr:tex
display="inline"><![CDATA[A_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex>, i.e., the intersection.
    Then since both the inclusion <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A) \hookrightarrow  {{\mathcal {C}}_{/{A}}}]]></fr:tex> (as a right adjoint) and the forgetful functor <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}} \to  \mathcal {C}]]></fr:tex> preserve pullbacks, the square is a pullback in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p>
  <fr:p>Note that the forgetful functor <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}} \to  \mathcal {C}]]></fr:tex> preserves arbitrary colimits, but the inclusion functor does not necessarily preserve them, so the same strategy does not work for pushout.</fr:p>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A_{1}\to B]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g\colon A_{2}\to B]]></fr:tex> be morphisms in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[fi_{1} = gi_{2}]]></fr:tex>.
    Consider the joint morphisms <fr:tex
display="inline"><![CDATA[(f,u_{1})\colon A_{1}\rightarrowtail B \times  (A_{1} \cup  A_{2})]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(g,u_{2})\colon A_{2}\rightarrowtail B \times  (A_{1} \cup  A_{2})]]></fr:tex>, which are monic because <fr:tex
display="inline"><![CDATA[u_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[u_{2}]]></fr:tex> are.
    Let <fr:tex
display="inline"><![CDATA[(m,n)\colon U\rightarrowtail B \times  (A_{1} \cup  A_{2})]]></fr:tex> be the union of <fr:tex
display="inline"><![CDATA[(f,u_{1})]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(g,u_{2})]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B \times  (A_{1} \cup  A_{2}))]]></fr:tex>.
    We show that <fr:tex
display="inline"><![CDATA[n]]></fr:tex> is an isomorphism.</fr:p>
  <fr:p>The functor <fr:tex
display="inline"><![CDATA[\exists _{\pi _{2}}\colon \mathsf {Sub}(B \times  (A_{1} \cup  A_{2}))\to \mathsf {Sub}(A_{1} \cup  A_{2})]]></fr:tex> constructed in <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />, as a left adjoint, preserves arbitrary unions.
    Let us consider the image of <fr:tex
display="inline"><![CDATA[n]]></fr:tex>:</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       \exists _{\pi _{2}}(m, n) &\cong  \mathsf {Img}(\pi _{2}(m,n))\\                       &\cong  \mathsf {Img}(n)\\                       &\cong  \exists _{\pi _{2}}((f,u_{1}) \cup  (g,u_{2}))\\                       &\cong  \exists _{\pi _{2}}(f,u_{1}) \cup  \exists _{\pi _{2}}(g,u_{2})\\                       &\cong  \mathsf {Img}(\pi _{2}(f,u_{1})) \cup  \mathsf {Img}(\pi _{2}(g,u_{2}))\\                       &\cong  u_{1} \cup  u_{2}\\                       &\cong  \mathsf {id}_{A_{1} \cup  A_{2}}     \end {align*}   ]]></fr:tex>
  <fr:p>Thus, if <fr:tex
display="inline"><![CDATA[n]]></fr:tex> is monic then <fr:tex
display="inline"><![CDATA[\mathsf {Img}(n) \cong  n \cong  \mathsf {id}_{A_{1} \cup  A_{2}}]]></fr:tex>, i.e., <fr:tex
display="inline"><![CDATA[n]]></fr:tex> is the whole of <fr:tex
display="inline"><![CDATA[A_{1} \cup  A_{2}]]></fr:tex>, so it is an isomorphism.
    Let <fr:tex
display="inline"><![CDATA[a,b\colon V\rightrightarrows U]]></fr:tex> be a pair of morphisms such that <fr:tex
display="inline"><![CDATA[na = nb]]></fr:tex>.
    To show that <fr:tex
display="inline"><![CDATA[a = b]]></fr:tex>, it suffices to show <fr:tex
display="inline"><![CDATA[ma = mb]]></fr:tex> since <fr:tex
display="inline"><![CDATA[n]]></fr:tex> and <fr:tex
display="inline"><![CDATA[m]]></fr:tex> are jointly monic.
    To this end, we show that the equalizer of <fr:tex
display="inline"><![CDATA[ma]]></fr:tex> and <fr:tex
display="inline"><![CDATA[mb]]></fr:tex> is an isomorphism.</fr:p>
  <fr:p>The object <fr:tex
display="inline"><![CDATA[U]]></fr:tex> (when viewed as the maximal subobject in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(U)]]></fr:tex>) is the union of the coproduct injections <fr:tex
display="inline"><![CDATA[\ell ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[k]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="ad434a33ce3a54a9b1d60689fac64135"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMC44NTkxMjNwdCcgaGVpZ2h0PScxMTMuMjc1MTI4cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTMzLjkwNjA4MiA3NS41MTY3NTInPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFnVUFBb0FBQUFBQ29RQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVjQUFBQmdoVWhreEdOdFlYQUFBQUU4QUFBQVNnQUFBRnpCZ2lGNFoyeDVaZ0FBQVlnQUFBVVBBQUFIRUNTd2tSRm9aV0ZrQUFBR21BQUFBQzhBQUFBMktSU0ExMmhvWldFQUFBYklBQUFBSUFBQUFDUUc5d0xuYUcxMGVBQUFCdWdBQUFBa0FBQUFKQlovQWQ5c2IyTmhBQUFIREFBQUFCUUFBQUFVQm1ZSVBHMWhlSEFBQUFjZ0FBQUFHQUFBQUNBQURBQnZibUZ0WlFBQUJ6Z0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUlDQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FHakFJTE5rRkpjbGc2VTFIbVF3TXp3SDhoblptQUVxMEdvK0E4VUJnRHhndzNyQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnOGdEUWZBd2RRam8xQmh5R2RJWnNoajZIMFFjTC8vMEJ4SFlZMElEOFh3djkvOWYrYy96UC96L2cvU1g0RldEY1NBQUNhRmhQUEFBQjQybjJWM1lzYlZSakc1MzNQZkdSbU1uTXltYTlrTjV1UG1jbE1kck5Oc3ZuTzdqYlpiSGJwMTladEZidXRsTFlJVmhRS1FxbEl4U3V2aENJaVhuaXJGeUlpaUplQ2w2VmVleUY0NFovUkZyelo5WnpFdGxCb1oyRGduRE01ZVovZjg1NW5CQkR1bm13S1Q0U1BCVThRQm9xc05LRGJIeFRCbFNuSVNwejBCMlA0TzYzYmhWSjVLWXJFcWxxbE9nRzVVOHFrRklCS3V3SXczampxR1cxQVE1RTJiZ3JzQXVIQ1NSTS94RCtGSFRZZ2ZDTVRsQ0JPeHREeGZFOVd2QktNWVVKQ09lNzduVEd3ditpMFBkK0VNRTdpL2lCdWdva1VPbjFQVHVDN3pZeVlXVktuRzdWTmdNaU5DZEFTcFRTcWtKVUdQU2lpVFM5VDEvUjJ3OVZ0Z05CajY1a2lwZGxzVVVzdDNlVEw4TTN4dy9QV1R0ZVprVGdzbGpHU0UxMUZFQys0M3o0NUlvRUNSOWVXazdnYXZWaUNmSHpxU3pGSUFkZUN3dnJKS2F6Q1E2RWh6TGdhcGtTZUsyRVZPN0xpZXgyUE01b0FSOGR3OGJzSVBsUEZYaUFUNkNkTWxLeHdCSjdmNXE5aTVTUDE3aWZOR3lLcjEvTEF6QmFzaXJNZEZqekZINXliWGtNeXBkYTVhN1dlUVpheWhndGZOd2s0Ym5kcFZuWXpGc1JKY2JlUVZ1RCs4YlQ1RGtGM2ZhVmkyM3BSa3hEMFFyNVZ2dDRSNGVqU2UyL1lkSTlBNUdVOHlGakgvLzVHOVdvb1FxMFhUM2NPQjFBdFUyUHUwOFdUcDdpUGZ3aFh1REplVzl0em45dkFLdWJXTWNmWTdWRGllUDdDS3o2aGNFbk0wbmpRVDVodUNpWUVjVzlnanlFT0YwNFArcDRDMDl1bHE4bmx0Mk5XQ3JQR0w1dE8vVENKL1Z5NVMybExSQ0lCZGVLNlJoUk5sUUV5bWxNWUpUTUVpUUNjSDRaVTlHTkwra3BFR3FrWkFGUFpXNjhDL25qOHZubFE3YTB2VnlvWW1WSEtCTmlNS3c0clFWSzlrYVlheXpack1QRmlSRFZFVFdvc0Z4cGlwMjltVGJtV1NBODJzem5iOEhEUG9KcW8wWlFpa3ZTaVoxc25UOGsvOEVpNEl3alZDZXZQT0RFSlJaUEV5WVQwZTEwMkJFYWtDUTFnb0hET29qOS9lbjZSOWNTaXkxMlplOXp2ektjV2hMb1RaRFAvLzN5eFlYY0F2OWNwUWFjK3VsQTNsUlZIVXQyQ0ExbzlyY3ZVTGdhNnBHaTZESTZsSnJNOXhUL2FXWDFUeTEzZFA1TXI2SUFPMnJxcGtaWHlaaGF6akpxWHRzTFR0UkVRbytvaXVxdmJoM2xUVndxdWxQS1dYWkRlK25uYkRqc0V0OGVWbFh1WEhHcXlobGo3cGRYd00yNEJZS2Zoc0MyUlRvdDJoR3U5eWhiaTJrNDRROG5QZFkzR3RyekZJRnNCVGs1bkVmMlc3elhFNW1wYUw5K2ViYmdiaUxPYXUxUjh0cWxrUCtlSTN6T09oNEx3T25DdkF3YnpZL1RDZ005ZUNXYjlDdUZBMG9aR0N1V3RMRnFhREw1dWhlUGFFRWlhZWg2K0RIbjZPdTJOYzYvV0hPM09Ockl2Z1Z6b2ZZeWZzM3c0WUgzRFR4QTdLc2gwelU4TFUxS0NlVTdJUERWNGRpUU4zZzZEcmhLd3FURGh6Y0RITEN6bUtTa3YrQXpnMTU3c2pFUTU5R1RWdE10aEtpWHFUSnVkTGZUU1o1ejg2ZVptYXprTjJab0YrZEsyRFJhajRxY1h1c0h3QTBDdjB4eFRsSDc0S3grVkZQK0w2MjdEZEZjQTk1TmxHZml4MktsMEViMW1maFV3ekkvS2g3ZkRvQXFUY1FaUk5WdSsyNUJhTmI4NC9LQnBUU1RjV2lMT1BBdHpKNC9oSWN2MWtYQ1dmeTFNakxzVDB1WEJNVmdrMzdOa21GdXJ5Rnc4WDVzQSs2SndkU3dqdWJ0alNMcktRdS85UkY0eGRHSW1WVkZQeFlFZUdOWmFyNW5XVVJxdXRhYUJKaUxJcWxFUDl5dk1mRVVsM2N5d1BkMmFEYXUxU1lGRXF5eFhhTzVCb09RZ3JZbG1KWWoyMjhtOTNWemJ6clpFTVF6cHU5ZjNoMmRMcVZRcXNFNlY2aUtzRlhWRU1DUzlwa1pBYnYwMHFnMXZmYXIxUVR4WXZ6TzRJZndIdWl2aXpRQjQybU5nWkdCZ0FHTGZKd2RNNC9sdHZqSXdzekNBd0dPQmVlOFE5SDlkNWp0TUY0RmNEZ1lta0NnQVF3a0x0UUI0Mm1OZ1pHQmdadmpQd01EQXdzc2c4ZjhDOHgwR29BZ0s0QVFBV2dJRDVRTEdBQUFCV3dCekFqb0FTd0k2QUN3Q2JnQk5CQTBBTUFMVEFEQUNzd0F3QWVrQUdBQUFBQUFBS2dDUUFQNEJoQUlvQXFBREZnT0llTnBqWUdSZ1lPQmt5R05nWWdBQlJnWTBBQUFNTHdCOGVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPOEFBb0FBQUFBQkN3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUV3QUFBQmdpU1NVU0dOdFlYQUFBQUZBQUFBQU1RQUFBRHhEanQvaFoyeDVaZ0FBQVhRQUFBRHJBQUFBOUttVDQ4dG9aV0ZrQUFBQ1lBQUFBQzhBQUFBMktGU0JKV2hvWldFQUFBS1FBQUFBSGdBQUFDUUYyUCtBYUcxMGVBQUFBckFBQUFBTUFBQUFEQWppQU10c2IyTmhBQUFDdkFBQUFBZ0FBQUFJQUR3QWVtMWhlSEFBQUFMRUFBQUFGd0FBQUNBQUJRQW1ibUZ0WlFBQUF0d0FBQURUQUFBQlBxODNkZUZ3YjNOMEFBQURzQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0rc1k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FNbUlIYUFjVktLeTlLQmt0ZVZ0SmlsL21neU1EQkxNVjhIQ2pNaWxQLy96OEFBQURhakQzMTQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lOSUEwRzVCbUJNcGVWOUw2L3gvSUI5UC90ZTdlQUtzQ0FnQ2psd21NQUFBQWVOb2RqVEZLQTBFVVFQLy9zNWxKTmlhenc1QVpJNnpDSnN5Z0Zzb0tNNEpGR2p1eGlZV2dsVmlsamVBUkJCdHR2SUtuOEFZdVNaVkxlQU9yNkxEbGV6eDRnUEFCUFhyQlg2Z0FNQVpyTEpkMGdFWnc0VTVRREhIaXZKdWhkekhFMnVKYk04dzFFdHY3K3F3elJOM3ZiSnBlbHl2R2l0V3FZRXp4RE10dmhhVHp0dWt5VFpSdG1yeERXZ3pXNjRGSURHa0Y4ZStIbnVnUnBna1VsOGdubFU4cnIxeW9qVkRjMkgwOE0ra2FZcXRvbVYzdjNqemN6MVZ4bGFFb0JkTDQvT2gyV2w5VzVVVXJhTFo5WFVSNWVwenZoQVUreTlGSWJ0L3QzSTgxMnI0OXZNTmxVZ0QvZllFbjBBQjQybU5nWkdCZ0FPTFhueitYeHZQYmZHVmdabUVBZ2NjQzg5NGg2UDh2bVdXWWtvRmNEZ1lta0NnQWNoNE1Zd0I0Mm1OZ1pHQmdsdnFqQ1NSbEdNd1p6Sm5hR0lBaUtJQVpBRHltQWwwQUFBTWNBQUFESEFDVUFxb0FOd0FBQUFBQVBBQjZlTnBqWUdSZ1lHQm1VR1VBMFF4UUVna0FBQVJWQUN3QWVOcE5qckZxd3pBUWhqOVR4MUFua0trZE9oUk5HWVdOOHdDRkRKbXlaaXdra1FnT1dBNlNZL0JTOGdCOTZGNFVEVDNCOGVtLzc0U0FraDh5SHBXeGpQMVJPWVhjbmp4anpsdmlRbzVLWFBMQmloZXkvRldTVDc0UzV5ejRUanpqblV2aVF2Sjc0cEkxdjV1K3U5NEc2OVd1TjlhN1V4ZW11dHBiSDlyZXFWcFh6MkJybmZXSHdScDFuSlFaMnpDZU85WG9TamRzNk9tNGNtUEE0dVZuTzBsTVpNZEpab0dKbW9wOXpBS3R6SjE0TlZyUy84WldEQmV0UTN6TmlIV1VtUklhWlM5SVA0dXZhT0t1cHZrRENWRXhFd0I0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJZQUFvQUFBQUFCTndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBSMk50WVhBQUFBRTRBQUFBTlFBQUFEd0FUUUIrWjJ4NVpnQUFBWEFBQUFHRkFBQUJwRFlXOElWb1pXRmtBQUFDK0FBQUFDNEFBQUEyS0F1QTJtaG9aV0VBQUFNb0FBQUFId0FBQUNRRlNBSWFhRzEwZUFBQUEwZ0FBQUFTQUFBQUVnanRBU3hzYjJOaEFBQURYQUFBQUF3QUFBQU1BTHdCTW0xaGVIQUFBQU5vQUFBQUZ3QUFBQ0FBQndBcmJtRnRaUUFBQTRBQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRVRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbU1tQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUJneE0vd0g4cGtoMGtocS9nT0ZBYkcrREhvQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS2FqSVkvZjhQNUdzd0dQNy8vLy9tLzB0Z1ZVQUFBSXR1Q01VQUFBQjQyaVhRVFVzYlVSUUc0UE9lcS9lU0NjNGtKRFBCSk5na2RXYUlYNFhHdVlNR21paW9EYlRhUlpKQ3E2S1ZLdHBRdEhVcmxLcTRLUDBSN3RxLzRMb1UrajkwWFJCQnVtanJEWExnZkd3ZVhnNkJEdjhEbndSUm5nZzVMNnVrQTZta1oxWUhRV2dxRGhyUTZBMHBOVGVyWmdTNjI1WWFPbzNzcE04OGFXdEI0SlNjN3FVT2ZuNzlzNVpJTWQ0Y2xVdEhXeCtPL2MrR3BLZkdiOS83R2FQbVBKV1Z5a1lRVHpmd0JQRVV3aURTOGVxSjdvUFZpbjVmZ0hEYXF4QUhpd2xJUWZmYXEvUG01aFpiWWlEOTdQZjVqNnRaU3lhWXFPL3ZtM2JKMzJuWXpMVDA2bkFmd1VGVWU2ekR0STB3OG5Tc1Bid1VwVmE0ODJKL01XeVZ4RVE3V3o2c3VVbis4dmRYM3ZVRm1IMDN6MVkyZ1ZIMnBtRDEzVGtpSHVSdlZDWHlWVG5XSmkyYmIwZzFBaFAvb1F4Q2szNEVPUnY5aDhVNk5pY1BQdmozR3F4dUMvTmk1WG5RSFE0OW9KS3h4aGdmTjkrZUNlN1VPMlBMMTM3U3N2bmlvaWpsVFdIN1pJTXhIckh2RkF0d2c5WTdnZDMxcGIySmhjb0NNR0ExTTNRSHZsOUVrUUFBQUhqYVkyQmtZR0FBNG1mcVUremorVzIrTWpDek1JREFZNEY1N3hEMGYwYW15OHdnTGdjREU0Z0NBQ3RtQ21rQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHUndZbUpsUUVvZ2dKWUFEODFBbWdBQXRNQUFBSEpBSFFCeVFCSUFrY0FjQUJCQUFBQUFBQUFBREFBWUFDTUFOSjQybU5nWkdCZ1lHWFFZZ0RSREZBU0NRQUFCUWdBTXdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMko3aUEyV2hvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaXp4dEVaOGZ6MjN4bFlHWmhBSUhIQXZQZUllai9ERXdOekNBdUJ3TVRpQUlBT3lzS2lBQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT3dBQW9BQUFBQUJCZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFV4MUFtTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ0ZaMng1WmdBQUFXUUFBQUQwQUFBQTlOdSsrWkpvWldGa0FBQUNXQUFBQUMwQUFBQTJLSW1CaEdob1pXRUFBQUtJQUFBQUhnQUFBQ1FGdWdLeWFHMTBlQUFBQXFnQUFBQUtBQUFBQ2dabkFKSnNiMk5oQUFBQ3RBQUFBQWdBQUFBSUFESUFlbTFoZUhBQUFBSzhBQUFBRndBQUFDQUFCUUF0Ym1GdFpRQUFBdFFBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEb0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtZXMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUTBaREJpWnZnUDVETkRwSkhVL0FjS0F3RDJ4QTArZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhHLy84RFNjUC8vLzlmQVBNWkFGRllCbzRBQVFDU0FBQUNOd0tyQUI0QUFBRVJCaFk3QVJVbUp5TUdCelV6TWpZbkVRNEJKeU0xTXhZL0FUWTNOaFlCbUFRaVRqTXNPdEU2TEROT0lRTXVWQk1TRWhJK0J6ODVHQTRDaS8zTkZ4UXRBd0VCQXkwVUZ3SUFFZ3dCTFFJS0Fnb3VBUWtBQUFFQVhRQUFBbHNDcWdBckFBQWxCeUUxTkQ4Q1BnRTNMZ0VuSWdZSEhnRVhEZ0VqQmlZblBnRTNNaFlYRGdFSEJnOEJKVFkzUGdFM0Fsc2kvaVFEQ2ZvOVRRRUNhRTAwVWhZWUlRRUJKaFVPTEFJQ2hHcHdtd01DYUVndk5Xa0JBaW9LRFE4Q3hzWWZCUUlKMURGcVAweFRBU29qQWg4YklCMEJHU2ROWlFKcFkxQnBMaUFuVGdFQkJBdEJFZ0FBZU5wallHUmdZQURpeGYxdGgrUDViYjR5TUxNd2dNQmpnWG52a0dubUlLYlZRSXFEZ1FuRUF3QTJOd291QUFBQWVOcGpZR1JnWUdiNHp3QWtneGhpR1dLWm9obUFJaWlBQ1FBOTBRSnpBQUFEVWdBQUFyZ0FrZ0JkQUFBQUFBQUFBRElBZW5qYVkyQmtZR0JnWnRCaEFORU1VQklKQUFBRkJBQXpBSGphUFl3eHE4SXdGSVcvWWhYdEd4d0VoemRJOEFlRVNwK2JtNE9UcThQYnJBblNvYW1rdGVnaS9uUnZRL0FHRHQ4OTU5d0FHUzhTaGttWUJ4MG1sVGVQUE9hSFJlU0orS3ZJR2Irc0daR2tNM0ZXN0NLblRQbVBQR1pKR1hraS9pTnl4aC92ZlZQZjdwMzE2dGdZNjkybDl0dVQ5VzNWT0xYUitiQWVyTFArM0ZtanlxY3lmZFgyMTFvVk90Y0ZleHBxYnR6cHNIZ1VSM0ZNWU1kRk1zK1dVOWhiS3NtY2REWm84bTk2a05TRnhqbjhZcVJSOGhRMTlITFRpbDZscXlqQ25hYjRBRlV5TGtNQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUzRBQW9BQUFBQUJXZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUNHTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWV3Q01aMng1WmdBQUFXd0FBQUhtQUFBQ0tKb2lwSHhvWldGa0FBQURWQUFBQUM4QUFBQTJLRUtCbjJob1pXRUFBQU9FQUFBQUhnQUFBQ1FHTVFHOWFHMTBlQUFBQTZRQUFBQVFBQUFBRUFzNEFKSnNiMk5oQUFBRHRBQUFBQW9BQUFBS0FXZ0FzRzFoZUhBQUFBUEFBQUFBR0FBQUFDQUFDQUJBYm1GdFpRQUFBOWdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFckFBQUFBd0FBQUFnQUFNQUFIamFZMkJtT3NjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaQWhsWnZnUDVETkRwSkhVL0FjS0F3RHlJZzFVZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pHRS92OFA1RHVDNlA4SC9xOERxd0lDQUpKeUNRRUFBSGphTmRGTmF4TkJHQWZ3K1Qrem1jM2I3cVR1WmxmSkd6RXhxNFkwMGlTN3RzZ0tqWTFpTVVRRFVyQlk4S1cxSGdTMVZyM2xrSk1vSGlxQ0p4RzllUll2bmp6NUpUeUlKL0V6SkhFMnhibk16UFBNNGZkL2hoR3J6bWIwaTM2eUpsdGlMSUFmTERtdVpUc3QzeEZONkY3TmEvdXU0d2RObEhWaE82N3ZtbEQxcU53S0ViVDRWOXdWdGlFUU9vMHMwckc5VVR3R0kyVzFlVUtmenZwRzNqSTRqTmpPUmhycHhQSHczZC95UGwzUElDRW5JMGZ5Z2c3T1FYR3BBMmwzZTIxc1Z6TWdhWXFvbkpRQ2xSKzR4dFRpckQ2YmNFSGZXSkdkWm1lVjFHcFhQS0ZzNVNLeUp2UWlYQ0VoOUxLWWU2MEk1OWU4U2szby9QK1pxd2V0VDY5eVhrRktiR3plNHFQaCtoQjBNWFBseWZRZ2I1b3J4ZmR2dC9ZSWk5MXh5WW85ZUxtNVQzVG0wdmVlQnBnRFdsNGdudGRCVjFjdTc4aGtmM2w5MVF5MUtBRXNyUEZIdmVvRmdqdzIrY3lmOWs4TStQVDNFWkZrREt3Nys4T1R5aDJxQzFmUVJYaTE4OXp2SFBKTENGekh0WVVYT1ZXQUlpS3NGWEdGRjBLMW5SSk1lQ2JveFkzQ2h6dkR4MFNKazQyVVVDRU1NUjZyWVV1N1U5QnV4NG1vMXhrYzVMZUFmRjF5OVJYM2R4TkVTR3ZuR2pTWXZybjNXc1AyVGR2NytLWHVpc01vODlHYktrQTJOMzFZeVI1ZDdlTDVMcDZsRm5KS2FzNzdtb2oyVS84QXl2ZFltd0FBZU5wallHUmdZQURpdlM0SjR2SDhObDhabUZrWVFPQ3h3THgzQ1ByL1MyWXVwcnRBTGdjREUwZ1VBQ1pkQ3YwQWVOcGpZR1JnWUdiNHp3QWtPUmhVL205ZzVtSUFpcUFBRmdCSVJBTDBBQUFDZGdBQUF3QUFKQU1JQUNzQ3VnQkRBQUFBQUFCVUFMQUJGQUFBZU5wallHUmdZR0Joc0dkZ1pnQUJSZ1kwQUFBSEtBQkplTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjEuNzM5ODY1LC02MS44MDM1MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01Ljk5MzA3LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS43Mzk4NjUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02MS43Mzk4NjUnIHk9Jy02MS44MDM1Myc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTQuMjY3ODY2JyB5PSctNjAuMzA5MTUnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuOTQ2NDksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjczOTg2NScgeT0nLTYxLjgwMzUzJz5VPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwNy44MTc5MywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuNzM5ODY1JyB5PSctNjEuODAzNTMnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU0LjI2Nzg2NicgeT0nLTYwLjMwOTE1Jz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1LjMyMDQ4LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuNzM5ODY1JyB5PSctNjEuODAzNTMnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjQ2OTM5MScgeT0nLTYxLjgwMzUzJz7DlzwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDEuNTA2Nzc3JyB5PSctNjEuODAzNTMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTM3LjYzMjQwNCcgeT0nLTYxLjgwMzUzJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0zMC4xNjA0MDUnIHk9Jy02MC4zMDkxNSc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMjMuNDc3MTY5JyB5PSctNjEuODAzNTMnPuKIqjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTQuNjIxNTIxJyB5PSctNjEuODAzNTMnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTcuMTQ5NTIyJyB5PSctNjAuMzA5MTUnPjI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIuNjgwMTUyJyB5PSctNjEuODAzNTMnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEyLjc0ODYxIDBINDcuODkwOTUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTIuOTk4NjEsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4xNDA5NSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI3Ljc5NjE0LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS43Mzk4NjUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02MS43Mzk4NjUnIHk9Jy02MS44MDM1Myc+7oGgPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMDEuMDYyNCAwSDY1LjkyMDA2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwMC44MTI0LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsNjUuNjcwMDYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4Mi4xMzExNSwyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuNzM5ODY1JyB5PSctNjEuODAzNTMnPms8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNDYzNjEtOS40NjUxNkw0Ny42NDczNy00Ny42NDIyNicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC43MDcxNSwwLjcwNzAzLC0wLjcwNzAzLC0wLjcwNzE1LDkuNjQwNCwtOS42NDE5MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNSwtMC43MDcwMywwLjcwNzAzLDAuNzA3MTUsNDcuODI0MTYsLTQ3LjgxOTAyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxLjgxNTM0LC0zNi4wMTQ1NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYxLjczOTg2NScgeT0nLTYxLjgwMzUzJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01OC42MjY1MjInIHk9Jy02MS44MDM1Myc+Zjx0c3BhbiB4PSctNTQuMzg4ODg3Jz4sPC90c3Bhbj48dHNwYW4geD0nLTUwLjY2MjExJz51PC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQ1Ljk1MTcxNScgeT0nLTYwLjgwNzI2Nic+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDIuMDYzNDY0JyB5PSctNjEuODAzNTMnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtOC42MDk3M1YtNDcuNDk1NzcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCw1Ni45MDU1LC04Ljg1OTczKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ3Ljc0NTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J000Mi44OTA0LTMzLjcwMjc0SDcwLjkyMDYxVi0yMC43MDI3NEg0Mi44OTA0Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDUuODkwNCwtMjguOTUyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS43Mzk4NjUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02MS43Mzk4NjUnIHk9Jy02MS44MDM1Myc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTguNjI2NTIyJyB5PSctNjEuODAzNTMnPm0sPHRzcGFuIHg9Jy00Ny44MzAxMzknPm48L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDIuOTA1Mjc3JyB5PSctNjEuODAzNTMnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTA0LjM0NzQtOS40NjUxNkw2Ni4xNjM2NC00Ny42NDIyNicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE1LDAuNzA3MDMsLTAuNzA3MDMsMC43MDcxNSwxMDQuMTcwNjEsLTkuNjQxOTIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjcwNzE1LC0wLjcwNzAzLDAuNzA3MDMsLTAuNzA3MTUsNjUuOTg2ODUsLTQ3LjgxOTAyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OS4xMjA0OCwtMzYuMDE0NTQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS43Mzk4NjUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02MS43Mzk4NjUnIHk9Jy02MS44MDM1Myc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTguNjI2NTIyJyB5PSctNjEuODAzNTMnPmc8dHNwYW4geD0nLTU0LjQ4OTU3Mic+LDwvdHNwYW4+PHRzcGFuIHg9Jy01MC43NjI3OTUnPnU8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDYuMDUyNCcgeT0nLTYwLjgwNzI2Nic+MjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDIuMTY0MTQ5JyB5PSctNjEuODAzNTMnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$A_{1}$};
      \node  [right = of 1] (2) {$U$};
      \node  [right = of 2] (3) {$A_{2}$};
      \node  [below = of 2] (4) {$B \times  (A_{1} \cup  A_{2})$};
      \draw  [>->,morphism] (1) to node {$\ell $} (2);
      \draw  [>->,morphism] (3) to node[swap] {$k$} (2);
      \draw  [>->,morphism] (1) to node[swap] {$(f,u_{1})$} (4);
      \draw  [>->,morphism] (2) to node[desc] {$(m,n)$} (4);
      \draw  [>->,morphism] (3) to node {$(g,u_{2})$} (4);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>The pullback of <fr:tex
display="inline"><![CDATA[\ell  \cup  k]]></fr:tex> along <fr:tex
display="inline"><![CDATA[a]]></fr:tex> or <fr:tex
display="inline"><![CDATA[b]]></fr:tex> are the maximal subobject of <fr:tex
display="inline"><![CDATA[V]]></fr:tex> since isomorphisms are stable under pullback.
    Thus, we have</fr:p>
  <fr:tex
display="block"><![CDATA[     V \cong  a^{*}(\ell  \cup  k) \cong  b^{*}(\ell  \cup  k)   ]]></fr:tex>
  <fr:p>Since finite unions are stable under pullback in a coherent category, we also have</fr:p>
  <fr:tex
display="block"><![CDATA[     V \cong  a^{*}(\ell ) \cup  a^{*}(k) \cong  b^{*}(\ell ) \cup  b^{*}(k)   ]]></fr:tex>
  <fr:p>Now, we can decompose <fr:tex
display="inline"><![CDATA[V]]></fr:tex> as the union of 4 subobjects using <fr:ref
addr="ct-0011"
href="ct-0011.xml"
taxon="Lemma" />.</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       V \cong  V \cap  V &\cong  (a^{*}(\ell ) \cup  a^{*}(k)) \cap  (b^{*}(\ell ) \cup  b^{*}(k))\\                    &\cong  ((a^{*}(\ell ) \cup  a^{*}(k)) \cap  b^{*}(\ell )) \cup  ((a^{*}(\ell ) \cup  a^{*}(k)) \cap  b^{*}(k))\\                    &\cong  (a^{*}(\ell ) \cap  b^{*}(\ell )) \cup  (a^{*}(\ell ) \cap  b^{*}(k)) \cup  (a^{*}(k) \cap  b^{*}(\ell )) \cup  (a^{*}(k) \cap  b^{*}(k))     \end {align*}   ]]></fr:tex>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[e\colon E\rightarrowtail V]]></fr:tex> be the equalizer of <fr:tex
display="inline"><![CDATA[ma]]></fr:tex> and <fr:tex
display="inline"><![CDATA[mb]]></fr:tex>.
    To show that it is an isomorphism, it suffices to show that each of the 4 subobjects is contained in <fr:tex
display="inline"><![CDATA[e]]></fr:tex>, i.e., each of the 4 subobjects equalizes <fr:tex
display="inline"><![CDATA[ma]]></fr:tex> and <fr:tex
display="inline"><![CDATA[mb]]></fr:tex>.
    Let <fr:tex
display="inline"><![CDATA[\ell ']]></fr:tex>, <fr:tex
display="inline"><![CDATA[\ell '']]></fr:tex>, <fr:tex
display="inline"><![CDATA[k']]></fr:tex>, and <fr:tex
display="inline"><![CDATA[k'']]></fr:tex> be given as follows:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="3426777d1613cd767d3b9b26c8e07e33"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzY1NC4wODU0MDVwdCcgaGVpZ2h0PScxMTcuMDI1MjU1cHQnIHZpZXdCb3g9Jy03MiAtNzIgNDM2LjA1NjkzNiA3OC4wMTY4MzcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPc0FBb0FBQUFBQkJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUUwQUFBQmdxbU5pZTJOdFlYQUFBQUZFQUFBQU13QUFBRHllV21SYloyeDVaZ0FBQVhnQUFBRGdBQUFBN0QwTlFsdG9aV0ZrQUFBQ1dBQUFBQ3dBQUFBMktZeUE3V2hvWldFQUFBS0VBQUFBSHdBQUFDUUY3Z0RhYUcxMGVBQUFBcVFBQUFBTUFBQUFEQWtLQU8xc2IyTmhBQUFDc0FBQUFBZ0FBQUFJQUZRQWRtMWhlSEFBQUFLNEFBQUFGd0FBQUNBQUJRQTJibUZ0WlFBQUF0QUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1abWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUE0TURqSjFTWEpiT3dLWWsvc0NBV2V1UEpRTURzeGJ6Y2FBd0kwTDEvLzhNREFEb3R3N2ZBQUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFabVJnVWhKL1lQRC9Qd01EaEw3N1N2NFNXQlVRQUFDbmlRbXlBSGphTFk1UFNzUXdIRWJ6cGNNdlZOUGFQMm5Tb2s3SERLYTdrU2wxQ2lMMUVvb2JzWWpRdld0dm9PQVJSbkRuR2J5R3l6bUxtTVdzSHQvN05vK0JmYkFsZjhhT2RZeWgzN1JhMFJHMDBTYUd1MEFORWl0ME54RFVXT2ZwR3RjTWFHczA3ckxiOU5vSXZIM0tTcVgwZlgrWGM2Z3EvSXFJMnpRbitYNU9VVkY2cnppS010cEt5bFBMRDNFOGhzckdmRGc5RTJXbVFFL1QxVHhBWnRiVGJRRmxrLzBSanRQNklNckE2MGVmeGtiVzRKVmZzOFNQZ0phK284OEg5SzAySlBEeVMxTG53V3diVlBQS0FUUHMvaDVTSWFJRVAvRUNpeE1wMlQ5dWZCL1FlTnBqWUdSZ1lBQmlSbStWdi9IOE5sOFptRmtZUU9DeHdMeGJ5RFJMS0pNTmtPSmdZQUx4QVAzV0NJMTQybU5nWkdCZzF2cGp5Y0RBRXNvUXorREJsTXdBRkVFQnpBQklkUUxOQUFSVkFBQUM4Z0NPQWNNQVh3QUFBQUFBVkFCMmVOcGpZR1JnWUdCbU1HVUEwUXhRRWdrQUFBWGxBRHdBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV3NBQW9BQUFBQUJyZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaFgxa2xtTnRZWEFBQUFFOEFBQUFOUUFBQUVRQWdPRXRaMng1WmdBQUFYUUFBQUxVQUFBRGROelkvNU5vWldGa0FBQUVTQUFBQUM4QUFBQTJKLzZCZG1ob1pXRUFBQVI0QUFBQUh3QUFBQ1FGWXdIc2FHMTBlQUFBQkpnQUFBQVVBQUFBRkF1WkFPWnNiMk5oQUFBRXJBQUFBQXdBQUFBTUFiSUNmRzFoZUhBQUFBUzRBQUFBR0FBQUFDQUFDQUJZYm1GdFpRQUFCTkFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGb0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtQ21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBR2pBSUxOa0ZKY2xnNlVUSHlRd016d0g4aG5abUFFcTBHbytBOFVCZ0RuT0EzeUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUlMa2toaXlIeVQ4L3c5a0pVSlkveGY4bnlHL0JLd1dEQUFRb2d5SEFBQUFlTnBWa2o5djIxWVV4WG5lZStTaktPczlTYVJJRlpJcGk2UWVHY2xTWEVzbVpTZVFLdHN5RXNOR0V2UlA0aUFKZ2dCdDBhRmpsM3JwMWlWRFAwYlJxVXVIN2dHNkZlZ25LTkIraFRaYjR6NDZhSUhjdTkxN2gvTTc1eHJFV0Z6OVRlN2lsVEUyUGpBTUxMRHJCNUlJdER3L1dHQ0p2QWMvOEN5dVc2VUNmSUkwTDhvT1FZczhWYW15dUI2SEtCWW9jdnhvYm5ZOE5GcytyMGgzSzdadDVqZ1czRVluRHc0YjRkM2gwVU93cFhSUEh3OW03MC9odGFiQlNleEd3SFlZeld5RmIzMjMzcmgvL3FRMUVYNFhaSjEyTEJEaW1LdXRLVVZuSEdiQTA3TlBIN2pORTRyb3plKy9iZ3dTUnJKYjhUZmpZZ0xTczd1R0xtSWNYYjNHSCtRWEl6Snl6VVJMWlg1Z1NWaWxmTFhVQXhWSEtsMWdxaGU4M0Mrd04wRWNhUlI5cGRraFRvTERiUDZNMGxYLzlHTDFFV0NOSjQ1RlpGSnBBSklmYnljb3NyWGIzc1FvdkwwUU5ndnRHK1Q3TjMvNkd1YkRpeS91eDhjVUYvZnEwYzgvRFlPYXd4eHBjMFkzL25tTTIrbk9aVHk3ZVN5bHVNemVteHhvZ2NiNTFXdXkxbm8vS2RYbVJSbENTeURXNXVhRmVxdUorMEhabnFUWHdlaWJhVGtvYytFYVJla3NOSnVFUUtUMkN2ZGRRcXcrNnoxS0gzeXNrUGlLSXRnUzN1aGVxb0wyMWt6S0hVYW9DZW1wa1VPNVU3R0F1dU4xOTlNakFwTUNwL05Zc2tBMXpPOVlTVjhIaEtZZlFNTitMczRHZTl1ZGZwOGtJckVGY0tENm5wWmdWdng5cDFMcnVINFA3RHlSVGhuaHBOT2RzR2t1bXNMS1V2UGxRYlB0MW54eVhKUC9tL00ydS9iVlgzaEZmalAyalR1R1VYQkIxR3hKWi9uMWUxMzNmOVRsMzdXNFZmNW51VnNpaERhTmx4bnJ0OVgzNmV6NmhsdGZwOVptclVwRk9tQlZXMFhWcU5ZWTd0M2NxQkp6UHR4WlJRNGpzQ3ExVWJ6dVYwM09LM1JXbisrdWJoM05COW15UzVNYjJqUFpmaG54TmpZY0p2cFJzdDVOdnpwczc3ck5IY2JpV0w1NHNwN2Y2ZG0ySFRYR3ZSSERNS3dTZ3BwWnpTb0o2UE1mOXJQNTgwc25CenZiL3JKNFp2d0x0TjExOEhqYVkyQmtZR0FBNHVZOUV4Ykg4OXQ4WldCbVlRQ0J4d0x6YmlIby8xK1lqakZkQkhJNUdKaEFvZ0JXMUF5SkFIamFZMkJrWUdCbStNL0F3TUIwakVHQ1FZSEprd0VvZ2dKWUFUeUVBbFVBQXNZQUFBSjZBRDRDQWdCREFtNEFUUUhwQUJnQUFBQUFBR29Bd2dGSUFicDQybU5nWkdCZ1lHVUlaMkJpQUFGR0JqUUFBQW1FQUdGNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSWUFBb0FBQUFBQk53QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wUjJOdFlYQUFBQUU0QUFBQU5RQUFBRHdBVFFCK1oyeDVaZ0FBQVhBQUFBR0ZBQUFCcERZVzhJVm9aV0ZrQUFBQytBQUFBQzRBQUFBMktBdUFzbWhvWldFQUFBTW9BQUFBSHdBQUFDUUZTQUlhYUcxMGVBQUFBMGdBQUFBU0FBQUFFZ2p0QVN4c2IyTmhBQUFEWEFBQUFBd0FBQUFNQUx3Qk1tMWhlSEFBQUFOb0FBQUFGd0FBQUNBQUJ3QXJibUZ0WlFBQUE0QUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQUVUQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1NbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1CZ3hNL3dIOHBraDBraHEvZ09GQWJHK0RIb0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEthaklZL2Y4UDVHc3dHUDcvLy8vbS8wdGdWVUFBQUl0dUNNVUFBQUI0MmlYUVRVc2JVUlFHNFBPZXEvZVNDYzRrSkRQQkpOZ2tkV2FJWDRYR3VZTUdtaWlvRGJUYVJaSkNxNktWS3RwUXRIVXJsS3E0S1AwUjd0cS80TG9VK2o5MFhSQkJ1bWpyRFhMZ2ZHd2VYZzZCRHY4RG53UlJuZ2c1TDZ1a0E2bWtaMVlIUVdncURoclE2QTBwTlRlclpnUzYyNVlhT28zc3BNODhhV3RCNEpTYzdxVU9mbjc5czVaSU1kNGNsVXRIV3grTy9jK0dwS2ZHYjkvN0dhUG1QSldWeWtZUVR6ZndCUEVVd2lEUzhlcUo3b1BWaW41ZmdIRGFxeEFIaXdsSVFmZmFxL1BtNWhaYllpRDk3UGY1ajZ0WlN5YVlxTy92bTNiSjMybll6TFQwNm5BZndVRlVlNnpEdEkwdzhuU3NQYndVcFZhNDgySi9NV3lWeEVRN1d6NnN1VW4rOHZkWDN2VUZtSDAzejFZMmdWSDJwbUQxM1RraUh1UnZWQ1h5VlRuV0ppMmJiMGcxQWhQL29ReENrMzRFT1J2OWg4VTZOaWNQUHZqM0dxeHVDL05pNVhuUUhRNDlvSkt4eGhnZk45K2VDZTdVTzJQTDEzN1Nzdm5pb2lqbFRXSDdaSU14SHJIdkZBdHdnOVk3Z2QzMXBiMkpoY29DTUdBMU0zUUh2bDlFa1FBQUFIamFZMkJrWUdBQTRtZnFVL3JqK1cyK01qQ3pNSURBWTRGNXR4RDBmMGFteTh3Z0xnY0RFNGdDQURVK0NwRUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR1J3WW1KbFFFb2dnSllBRDgxQW1nQUF0TUFBQUhKQUhRQnlRQklBa2NBY0FCQkFBQUFBQUFBQURBQVlBQ01BTko0Mm1OZ1pHQmdZR1hRWWdEUkRGQVNDUUFBQlFnQU13QjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLTWlBN1dob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0xkRzhzODQvbHR2akl3c3pDQXdHT0JlYmVRYWVhSlREWkFpb09CQ2NRREFDUVpDWVlBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU1VBQW9BQUFBQUJVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MDNHTnRZWEFBQUFFNEFBQUFOUUFBQUR3QWZBQ0taMng1WmdBQUFYQUFBQUcrQUFBQ0FEZ3VSdFJvWldGa0FBQURNQUFBQUM4QUFBQTJLRXVCYzJob1pXRUFBQU5nQUFBQUhRQUFBQ1FHT2dGSGFHMTBlQUFBQTRBQUFBQVFBQUFBRUFxRkFLRnNiMk5oQUFBRGtBQUFBQW9BQUFBS0FWUUF1RzFoZUhBQUFBT2NBQUFBR0FBQUFDQUFCd0JBYm1GdFpRQUFBN1FBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFaUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtV3NnNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaQWhqWnZnUDVETkRwSkhVL0FjS0F3RGg1ZzBvZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pLRS9mOFA1RHN5aFA3Ly8vL0EvN1ZnVlVBQUFKSm5DUUFBQUFCNDJqMlJ6VzdUUUJTRjU5eHh4bmJqc1ZQOEI4U21sRlFlb2hJaUpZNHRJV1FRRWUwT0ZhZ3FKQ1JZUUF0bGd4QUlsUldWeUlwTkY3QmhpWGlHaWcwUHdFdXdBSWtGNGhrU013bUl1eG5kY3pmZmQ0WVJXNnRyK2s3ZldKOE5HQ3RSbElNbzlvTm9XRVNpRDFObEtpL2lxQ2o3V0RWRkVNVkY3RUxuODNoWW9Senl6OWdWZ1JTb29sNElwL0hpMEdwQU52MmMyK2FzdmlFVFgzTEl4cU03RGh6N1hQWGg5K3BMMm1uQjlxYUhrY2RURTV5RExNOEVuSGp2K2lSWWE0RThWOHpqSlUrZzh4VzNtQjZ3Y2YyTEw5RVhWdW1GdXpBdlFtVlhlREhLTzBya3hRcktPSW9Eb1RKaGN1SGhET1owZmxsa1NxZ0sraHl0d0lWeVFXL3ZwaDhmM241T1pKL3ZOVVZicFZKTUpocmFDMGFwOGNBaW9vM1IxcnZrUHBDc2Uxd3JQZG0zaWVBWWwzdTBOWHYvK01qQTNyMUFmVHBlajhVeThlU2ZncXNWd3Zic1dTYzhlVzJNVi9zNGFDNjNOYW03dUJ0aS9uYTF4Nlg2Si9lMVI1Y3hHMExUOFR6ci9EWFFsU3NSK3ZvUC9sTVBRbE9ZbWFBM3N5TXJPTUZ2QnQxVFVqeDlMY2xyYm01Z3JIdTY0SEs0amQxdHFZWFNxN1E1UFE1Z0pIVGd0M2k2cVBHMENVcW5QNGlrYzViSVhYVHIyQlloWmV3UGdGOUtTUUFBZU5wallHUmdZQURpcHVseWt2SDhObDhabUZrWVFPQ3h3THhiQ1ByL1UyWmhwcnRBTGdjREUwZ1VBQnY1Q3JJQWVOcGpZR1JnWUdiNHp3QWlHVlQrT3pFTE13QkZVQUFMQUQ4aEFvY0FBQUFDZGdBQUF3QUFKQUs2QUVNQ1ZRQTZBQUFBQUFCVUFMZ0JBQUFBZU5wallHUmdZR0Joc0dkZ1lnQUJSZ1kwQUFBSEVRQkllTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ3LjY5Nzg1NywtNjAuODcyNTQzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuOTkzMDcsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ3LjY5Nzg1NywtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00Ny42OTc4NTcnIHk9Jy02MC44NzI1NDMnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTQwLjIyNTg1OCcgeT0nLTY0LjQ4NzkwNyc+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00MC4yMjU4NTgnIHk9Jy01OC4zOTk3MTQnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuMDI3NzcsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ny42OTc4NTcsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDcuNjk3ODU3JyB5PSctNjAuODcyNTQzJz5WPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTExLjA5MTgxVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDAuMCwtMTEuMzQxODEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIxLjM3OTQsLTMwLjUyNzEzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDcuNjk3ODU3LC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ3LjY5Nzg1NycgeT0nLTYwLjg3MjU0Myc+YTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDMuMzc2NDEzJyB5PSctNjMuODc5MDYnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMzkuMjExNDQ0JyB5PSctNjAuODcyNTQzJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zNi4wOTgxMDEnIHk9Jy02MC44NzI1NDMnPu6BoDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMzIuNzYzMzQ3JyB5PSctNjAuODcyNTQzJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUwLjkxMjQzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ny42OTc4NTcsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDcuNjk3ODU3JyB5PSctNjAuODcyNTQzJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00MC4yMjU4NTgnIHk9Jy01OS4zNzgxNjInPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuOTQ2NDksLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ny42OTc4NTcsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDcuNjk3ODU3JyB5PSctNjAuODcyNTQzJz5VPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMC41NDg2MSAwSDQ1Ljg1Njg5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjEwNjg5LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuNDI2NjgsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ3LjY5Nzg1NywtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Ny42OTc4NTcnIHk9Jy02MC44NzI1NDMnPu6BoDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDQuMzYzMTAzJyB5PSctNjMuODc5MDYnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS0xMC4xMDk3Vi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTEwLjM1OTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0zMC4wMzYwNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ3LjY5Nzg1NywtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Ny42OTc4NTcnIHk9Jy02MC44NzI1NDMnPu6BoDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC41ODMzMS01Ni45MDU1SDQ3Ljg5MDk1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjE0MDk1LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNi4zMTgzLC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDcuNjk3ODU3LC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ3LjY5Nzg1NycgeT0nLTYwLjg3MjU0Myc+YTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjUuOTg1NjAxLC02MC44NzI1NDMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNi4zMDU1NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg2NS45ODU2MDEsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSc2NS45ODU2MDEnIHk9Jy02MC44NzI1NDMnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nNzMuNDU3NjAxJyB5PSctNjQuNDg3OTA3Jz7ugLDugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNzMuNDU3NjAxJyB5PSctNTguMzk5NzE0Jz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00LjAyNzc3LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg2NS45ODU2MDEsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSc2NS45ODU2MDEnIHk9Jy02MC44NzI1NDMnPlY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtMTEuMDkxODFWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsMC4wLC0xMS4zNDE4MSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjAuNTU4NDEsLTMwLjUyNzEzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg2NS45ODU2MDEsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSc2NS45ODU2MDEnIHk9Jy02MC44NzI1NDMnPmI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNjkuNDg5MTM5JyB5PSctNjMuODc5MDYnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSc3My42NTQxMDgnIHk9Jy02MC44NzI1NDMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNzYuNzY3NDUxJyB5PSctNjAuODcyNTQzJz7ugaA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nODAuMTAyMjA2JyB5PSctNjAuODcyNTQzJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUwLjkxMjQzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDY1Ljk4NTYwMSwtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzY1Ljk4NTYwMScgeT0nLTYwLjg3MjU0Myc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSc3My40NTc2MDEnIHk9Jy01OS4zNzgxNjInPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuOTQ2NDksLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDY1Ljk4NTYwMSwtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzY1Ljk4NTYwMScgeT0nLTYwLjg3MjU0Myc+VTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTAuODYxMSAwSDQ1Ljg1Njg5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjEwNjg5LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjQuNDgwNDgsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNjUuOTg1NjAxLC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNjUuOTg1NjAxJyB5PSctNjAuODcyNTQzJz7ugaA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNjkuMzIwMzU2JyB5PSctNjMuODc5MDYnPu6AsO6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS0xMC4xMDk3Vi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTEwLjM1OTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0zMC4wMzYwNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNjUuOTg1NjAxLC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNjUuOTg1NjAxJyB5PSctNjAuODcyNTQzJz7ugaA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguNTgzMzEtNTYuOTA1NUg0Ny44OTA5NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4xNDA5NSwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjYuNzI4NzksLTY0LjU3ODQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDY1Ljk4NTYwMSwtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9JzY1Ljk4NTYwMScgeT0nLTYwLjg3MjU0Myc+YjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTgxLjU1NTg3NSwtNjAuODcyNTQzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuOTkzMDcsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTgxLjU1NTg3NSwtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzE4MS41NTU4NzUnIHk9Jy02MC44NzI1NDMnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTg5LjAyNzg3NCcgeT0nLTY0LjQ4NzkwNyc+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzE4OS4wMjc4NzQnIHk9Jy01OC4zOTk3MTQnPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuMDI3NzcsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDE4MS41NTU4NzUsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScxODEuNTU1ODc1JyB5PSctNjAuODcyNTQzJz5WPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTExLjA5MTgxVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDAuMCwtMTEuMzQxODEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIyLjQ1MjMsLTMwLjUyNzEzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxODEuNTU1ODc1LC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTgxLjU1NTg3NScgeT0nLTYwLjg3MjU0Myc+YTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScxODUuODc3MzE5JyB5PSctNjMuODc5MDYnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxOTAuMDQyMjg4JyB5PSctNjAuODcyNTQzJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzE5My4xNTU2MzEnIHk9Jy02MC44NzI1NDMnPms8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMTk3LjU1OTI4NScgeT0nLTYwLjg3MjU0Myc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MC45MTI0MywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxODEuNTU1ODc1LC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTgxLjU1NTg3NScgeT0nLTYwLjg3MjU0Myc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxODkuMDI3ODc0JyB5PSctNTkuMzc4MTYyJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjk0NjQ5LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxODEuNTU1ODc1LC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTgxLjU1NTg3NScgeT0nLTYwLjg3MjU0Myc+VTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTAuNTQ4NjEgMEg0NS44NTY4OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni4xMDY4OSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0Ljg5MDIzLDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDE4MS41NTU4NzUsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PScxODEuNTU1ODc1JyB5PSctNjAuODcyNTQzJz5rPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzE4NS45NTk1MjknIHk9Jy02My44NzkwNic+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTEwLjEwOTdWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwtMTAuMzU5NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTMwLjAzNjA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxODEuNTU1ODc1LC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTgxLjU1NTg3NScgeT0nLTYwLjg3MjU0Myc+azwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC41ODMzMS01Ni45MDU1SDQ3Ljg5MDk1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjE0MDk1LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNi4zMTgzLC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxODEuNTU1ODc1LC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTgxLjU1NTg3NScgeT0nLTYwLjg3MjU0Myc+YTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjk2LjcwNjA2MywtNjAuODcyNTQzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYuMzA1NTYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMjk2LjcwNjA2MywtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzI5Ni43MDYwNjMnIHk9Jy02MC44NzI1NDMnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMzA0LjE3ODA2MicgeT0nLTY0LjQ4NzkwNyc+7oCw7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzMwNC4xNzgwNjInIHk9Jy01OC4zOTk3MTQnPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuMDI3NzcsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDI5Ni43MDYwNjMsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScyOTYuNzA2MDYzJyB5PSctNjAuODcyNTQzJz5WPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTExLjA5MTgxVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDAuMCwtMTEuMzQxODEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIxLjYzMTMyLC0zMC41MjcxMyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMjk2LjcwNjA2MywtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9JzI5Ni43MDYwNjMnIHk9Jy02MC44NzI1NDMnPmI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMzAwLjIwOTYnIHk9Jy02My44NzkwNic+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzMwNC4zNzQ1NjknIHk9Jy02MC44NzI1NDMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMzA3LjQ4NzkxMicgeT0nLTYwLjg3MjU0Myc+azwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSczMTEuODkxNTY3JyB5PSctNjAuODcyNTQzJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUwLjkxMjQzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDI5Ni43MDYwNjMsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScyOTYuNzA2MDYzJyB5PSctNjAuODcyNTQzJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzMwNC4xNzgwNjInIHk9Jy01OS4zNzgxNjInPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuOTQ2NDksLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDI5Ni43MDYwNjMsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScyOTYuNzA2MDYzJyB5PSctNjAuODcyNTQzJz5VPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMC44NjExIDBINDUuODU2ODknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuMTA2ODksMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMy45NDQwMywyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgyOTYuNzA2MDYzLC02MC44NzI1NDMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjk2LjcwNjA2MycgeT0nLTYwLjg3MjU0Myc+azwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSczMDEuMTA5NzE3JyB5PSctNjMuODc5MDYnPu6AsO6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS0xMC4xMDk3Vi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTEwLjM1OTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0zMC4wMzYwNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMjk2LjcwNjA2MywtNjAuODcyNTQzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9JzI5Ni43MDYwNjMnIHk9Jy02MC44NzI1NDMnPms8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguNTgzMzEtNTYuOTA1NUg0Ny44OTA5NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4xNDA5NSwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjYuNzI4NzksLTY0LjU3ODQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDI5Ni43MDYwNjMsLTYwLjg3MjU0MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PScyOTYuNzA2MDYzJyB5PSctNjAuODcyNTQzJz5iPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = {A_{1}'},
      nw/style = {pullback},
      ne = {A_{1}},
      sw = V,
      se = U,
      north = {\ell '},
      south = a,
      west = {a^{*}(\ell )},
      west/style = {>->},
      east = \ell ,
      east/style = {>->},
    }
    \qquad 
    \DiagramSquare {
      nw = {A_{1}''},
      nw/style = {pullback},
      ne = {A_{1}},
      sw = V,
      se = U,
      north = {\ell ''},
      south = b,
      west = {b^{*}(\ell )},
      west/style = {>->},
      east = \ell ,
      east/style = {>->},
    }
    \qquad 
    \DiagramSquare {
      nw = {A_{2}'},
      nw/style = {pullback},
      ne = {A_{2}},
      sw = V,
      se = U,
      north = {k'},
      south = a,
      west = {a^{*}(k)},
      west/style = {>->},
      east = k,
      east/style = {>->},
    }
    \qquad 
    \DiagramSquare {
      nw = {A_{2}''},
      nw/style = {pullback},
      ne = {A_{2}},
      sw = V,
      se = U,
      north = {k''},
      south = b,
      west = {b^{*}(k)},
      west/style = {>->},
      east = k,
      east/style = {>->},
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>First, let us consider the subobject <fr:tex
display="inline"><![CDATA[x := a^{*}(\ell ) \cap  b^{*}(\ell )]]></fr:tex>.
    Let <fr:tex
display="inline"><![CDATA[\pi _{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\pi _{2}]]></fr:tex> be the product projections of <fr:tex
display="inline"><![CDATA[x]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="f63246155cc11c665dde60bff308a387"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMS4zMjYxMDdwdCcgaGVpZ2h0PScxMDguMjczMDg2cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTM0LjIxNzQwNSA3Mi4xODIwNTcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUG9BQW9BQUFBQUJIQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MDFHTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWZRQ0paMng1WmdBQUFXd0FBQUVkQUFBQk9OZWVVNHBvWldGa0FBQUNqQUFBQUM4QUFBQTJLRXVCa1dob1pXRUFBQUs4QUFBQUhRQUFBQ1FHT2dGR2FHMTBlQUFBQXR3QUFBQU1BQUFBREFmTEFGNXNiMk5oQUFBQzZBQUFBQWdBQUFBSUFGUUFuRzFoZUhBQUFBTHdBQUFBR0FBQUFDQUFCZ0EwYm1GdFpRQUFBd2dBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFEM0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtbXNrNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaQWhqWnZnUDVETkRwSkhVL0FjS0F3RGUvZzBnZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pLRS9mOFA1SVBwL3dmK3J3R3JBZ0lBa20wSkFBQUFBSGphSGM1QlNzTkFGTWJ4K2Q2WW1jUm1rbUNtRTVRR3JTMEpCYVhRaGdSY0JFRzBPMEVSOFFMVnBSc1JkeFowNzlxRGlCc1A0Q1ZjS0xqeURHMmM5aTEvaS9mOUdiRiswOUEzZmJFaEd6RldvYXhHSm9tMUdaZEdEQ0h6TEMvS3hKVFZFRjBwdEVuS0pJRDFKWTlyVkdQK2pxblFTcUEyKzIzNHp0M01kYUJhY2NFOXVXaE9WU2RXSE1xNXVmTGhlN3YxNjEvM25pNGplT0Y4WmtLZVNuQU9ja01KK01uMThiUHVSNkF3RUV0ZUR3VjZuemhuOXNBT21sOGUwd2NiTU9aQjVDTG5SZFlUUmJtTnlxYm1vaDNiOXN4NkRVdWp0aFF5RS9TMGVISDFCai9UZzAwbGJoOFZoYTNKQ1k3cy83MkFJM0NtRjRySVN3OXBNbi9UV092UVF4enhkRFcvSlVIcC9JZEkrVHRFd2FySjkxeEN5dGcvbFRNdE1RQUFBSGphWTJCa1lHQUFZbTl0N3IzeC9EWmZHWmhaR0VEZ3NjQzhsd2o2LzFObVlhYTdRQzRIQXhOSUZBQWFGUXErQUhqYVkyQmtZR0JtK004QUlobFUvanN4Q3pNQVJWQUFNd0EvSUFLR0FBQUFBbllBQUFNQUFDUUNWUUE2QUFBQUFBQlVBSng0Mm1OZ1pHQmdZR1l3Wm1CaUFBRkdCalFBQUFYS0FEdDQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFQVUFBb0FBQUFBQkV3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wUVdOdFlYQUFBQUU0QUFBQU1nQUFBRHdBVEFCK1oyeDVaZ0FBQVd3QUFBRUxBQUFCR0RFNTRtdG9aV0ZrQUFBQ2VBQUFBQzRBQUFBMktBdUEwR2hvWldFQUFBS29BQUFBSUFBQUFDUUZMZ0loYUcxMGVBQUFBc2dBQUFBUUFBQUFFQWlzQVN4c2IyTmhBQUFDMkFBQUFBb0FBQUFLQUx3QVlHMWhlSEFBQUFMa0FBQUFGd0FBQUNBQUJnQWNibUZ0WlFBQUF2d0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQUR5QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0wbWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1CZ3lNL3dIOHBraDBraHEvZ09GQWEvUURIUUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEthaklZL3Y4UDVHdUE2UDgzLzE4Q3F3SUNBSXRYQ01RQUFIamFKY3kvUzhOQUhBWHc3N3VUTzVMU0pNWGtpbkZKeFNRSVdzRTJGNnhnZFNrV0hCeUNndFJCQzNZcDBrclhndmhqRXYrSWp2NGZJdmgvNk96c0lIcWxQSGp2VFI4Q1RmNkFPMDRVRXFHcWZDbGNDQ21VdVM2UzFDUlAydEFZbHFVOGJNbGRqdE5yVzVhZk1xY1VNN2JsYUU1Z25tZ092Zkg3eTgrRjVURmNUV3ZSdEgvN0VOOGJrbzZNWHl6OFphTldsZlNGZEpEa3pUYjJrZGVSSnBuT2U0OTZEbTZzNlp0VmNMZm9nWTg3RmdTbmhYWStPN2pzTTVzdlZZNi9aMjlmTFZ0WWpHanVqMHg5c2xkYU1Wc1JhZy9CTmx4a2pSMmRWaHlrbWRLNVZqampVVGNkbkl3NmFUZmltNFZmbXpTQ0VudisvUWlEbUlPeE9BaVo3VnRZWjZvT20vNEJVa2N0bUFCNDJtTmdaR0JnQU9JUHM3ZnRqdWUzK2NyQXpNSUFBbzhGNXIxRTBQOFptUzR6ZzdnY0RFd2dDZ0JiWEF0N0FBQjQybU5nWkdCZ1p2alB3TURBZEpuQmc4R1Q4UWtEVUFRRnNBQUFVT0lEVkFMVEFBQUJ5UUIwQWNrQVNBSkhBSEFBQUFBQUFEQUFZQUNNQUFCNDJtTmdaR0JnWUdHUVpnRFJERkFTQ1FBQUEzWUFJd0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS01pQkMyaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZEc4dDQ0L2x0dmpJd3N6Q0F3R09CZVMrUmFlYUpURFpBaW9PQkNjUURBQnkzQ1dnQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWXlBcTJob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMmhNSmQrUDViYjR5TUxNd2dNQmpnWGt2a1dtV1VNWTdRSXFEZ1FuRUF3QTRuQXBmQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU93QUFvQUFBQUFCQmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVeDFBbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNGWjJ4NVpnQUFBV1FBQUFEMEFBQUE5TnUrK1pKb1pXRmtBQUFDV0FBQUFDMEFBQUEyS0ltQmVtaG9aV0VBQUFLSUFBQUFIZ0FBQUNRRnVnS3lhRzEwZUFBQUFxZ0FBQUFLQUFBQUNnWm5BSkpzYjJOaEFBQUN0QUFBQUFnQUFBQUlBRElBZW0xaGVIQUFBQUs4QUFBQUZ3QUFBQ0FBQlFBdGJtRnRaUUFBQXRRQUFBREtBQUFCTXVzSWtlWndiM04wQUFBRG9BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWVzMDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFEwWkRCaVp2Z1A1RE5EcEpIVS9BY0tBd0QyeEEwK2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoRy8vOERTY1AvLy85ZkFQTVpBRkZZQm80QUFRQ1NBQUFDTndLckFCNEFBQUVSQmhZN0FSVW1KeU1HQnpVek1qWW5FUTRCSnlNMU14WS9BVFkzTmhZQm1BUWlUak1zT3RFNkxETk9JUU11VkJNU0VoSStCejg1R0E0Q2kvM05GeFF0QXdFQkF5MFVGd0lBRWd3QkxRSUtBZ291QVFrQUFBRUFYUUFBQWxzQ3FnQXJBQUFsQnlFMU5EOENQZ0UzTGdFbklnWUhIZ0VYRGdFakJpWW5QZ0UzTWhZWERnRUhCZzhCSlRZM1BnRTNBbHNpL2lRRENmbzlUUUVDYUUwMFVoWVlJUUVCSmhVT0xBSUNoR3B3bXdNQ2FFZ3ZOV2tCQWlvS0RROEN4c1lmQlFJSjFERnFQMHhUQVNvakFoOGJJQjBCR1NkTlpRSnBZMUJwTGlBblRnRUJCQXRCRWdBQWVOcGpZR1JnWUFEaXhmMXQxK1A1YmI0eU1MTXdnTUJqZ1hrdmtXbm1JS2JWUUlxRGdRbkVBd0E0clFvNEFBQUFlTnBqWUdSZ1lHYjR6d0FrZ3hoaUdXS1pvaG1BSWlpQUNRQTkwUUp6QUFBRFVnQUFBcmdBa2dCZEFBQUFBQUFBQURJQWVuamFZMkJrWUdCZ1p0QmhBTkVNVUJJSkFBQUZCQUF6QUhqYVBZd3hxOEl3RklXL1loWHRHeHdFaHpkSThBZUVTcCtibTRPVHE4UGJyQW5Tb2Fta3RlZ2kvblJ2US9BR0R0ODk1OXdBR1M4U2hrbVlCeDBtbFRlUFBPYUhSZVNKK0t2SUdiK3NHWkdrTTNGVzdDS25UUG1QUEdaSkdYa2kvaU55eGgvdmZWUGY3cDMxNnRnWTY5Mmw5dHVUOVczVk9MWFIrYkFlckxQKzNGbWp5cWN5ZmRYMjExb1ZPdGNGZXhwcWJ0enBzSGdVUjNGTVlNZEZNcytXVTloYktzbWNkRFpvOG05NmtOU0Z4am44WXFSUjhoUTE5SExUaWw2bHF5akNuYWI0QUZVeUxrTUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWThBQW9BQUFBQUIzZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFZ0FBQUJnaGYxa3JHTnRZWEFBQUFFOEFBQUFQQUFBQUV5OXFTZmpaMng1WmdBQUFYZ0FBQU5ZQUFBRUpHR2xMeWxvWldGa0FBQUUwQUFBQUM4QUFBQTJKLzZCbEdob1pXRUFBQVVBQUFBQUlBQUFBQ1FGclFIbWFHMTBlQUFBQlNBQUFBQVlBQUFBR0E1dUFQaHNiMk5oQUFBRk9BQUFBQTRBQUFBT0E4SUNZbTFoZUhBQUFBVklBQUFBR0FBQUFDQUFDUUJZYm1GdFpRQUFCV0FBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFHTUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtU21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFR2pBSUxOa0ZKY2xnNlVUSHlRd016d0g4aG5abUFFQ1RNaVZQd0hDZ01BQ01VT2lIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ3NnRFFYQXdkUWpva2hpYUdDK2NDRGhQLy9nV0tKTVBiL0JmKzcvN2pJTHdYcmdBSUFsa1FQWjNqYVBaTzdiOXRXRk1idnVhVDRrc1JMaWk4cGxpaUtiOHQ2MkpaTUtwWXJXclpsSkc0S0orZ2pjSkFFUVlBTUdiSzFTdzBVUVpjdTJZcnVIWXRPWFRxMGM0cHVCZm9YRkdqL2hiUmI0eDdLUVhtMzg1M2grNzdmSWFGa2NmVTN2UTJ2eVpBY0VnSUwyTFVkUmxXd1ROdFpRQUZaRjJ6SEZFUjhjYUtDT0lJa3k4dm5BcGRuU1p6RWdvaGpGL0lGNUJuOFVPbHNtTkN3YkZGbWhoZElFcThvQWhqNlJ1WWM2ZTd0L3ZGOTRBdG1uRDJJcGpzVE1LMkpjeG9ZUHNEQTlhZFNERi9aaHFiZi9lQ2hOVkx0TnRCVnNpRUFwVXBsNlUwNDJCaTZLY0NqTzgvdUdZMVREdnkzZi94V2kwS2VwdlBnNVRBZkFlMUtiWUlmSmNkWC84Q2Y5RmZpa3d3emNhVXoyeEVZQ0tYOXVNQkJIUGh4c29BSkNtS3BMMkJ2QklHUFVYQUxzNE42Nmh5bHM4Y2N0K3lkWFN3L0FoQ0dJMFdnTEpSMUFDYWVERUxJMDVYUjdNQ1dlN0JRSmQ2Vk51bDNiLyt5TWN5SEY4L3ZCaWNjWEp4ci9rOC85cDI2d2l0TUVubXU5dThET0VpMkw0UHArSVF4OVRKdGpmYlJJTmxCQmgvREwrUVRRZ3FhcloyVXJRWlk3L1JkMmM1MUNCemlMTXZqTWNUclFQWmFXRU1TLzZmMExwenQyTGpRUmFoWGdTcEMwRXJ1bWJ3b0k1QmVuUTNQQm9kTW44YytWaGtaTVdlMkdycDFZMStMR01CN2cvTUcxV1VCdkxvMmVOODdOWTE1bUI1UkNKeUlvMW9YRjVPZEY2LzJQUzNxSGg0b0lxV3lNOUhZdUFLcDUvWUIvTDdYcFNIcnlRcWxNSjUvVTFpTENxd3lvMFJwN3pTME1ROSs0cVZSM1BacEtDUlZoYVAwb094aGhEMThEVCt2cVpYNTQ3MEN6ZWNCM3BpQWdaTTFLS2VIUGFDYUJGZ0FGbU9YOTRleDF6SXNDdDExUTg1c250d29HdWViRlJYVDBpMjd0K2ZDbDZ3TkhPKzBYcGEyTEUwRzZEVHFWcTBLMEtyQnAyOVdLNzdEa3UxdjcxTm5VZ01Lc2p3M1BRdEF0cGpjb0hsM1hGeDBhb3JaQWpBaWIxNThNYjYrdGViVkczaE5meWMzeVMxQ2NsR2w4YlRna0ZDSlpmMlF3alVaOUdtSlFvbXExQXIwYnBYTzhTYnhOOFA5WkxyZUVZWFBFNkZUcjNKcUV2RlZLZmFyZmwzdjc0MXJWVnFaOWJlWHZzSlRFT1Q2VnJEcVZTdWlLSE5UYmJhN25CL1BvclJvYytGbWFNZXMrY29YbTFCVGVMWG5oNnZkNUxPajVxN1IyT2I1SUdCUEg2NW10N3FTSlBuNnNMdkZROSt0WWlIMVNqV1ZRK0NlZkg4em5UMjVWRExnN3d4ZTVJL0pmeVNSalBWNDJtTmdaR0JnQU9JdnhYT3Z4dlBiZkdWZ1ptRUFnY2NDODE0aTZQOWZtSTR4WFFSeU9SaVlRS0lBYTZFTkRnQjQybU5nWkdCZ1p2alB3TURBZEl4QmdrR1NhVElEVUFRRnNBRUFRWEFDbVFMR0FBQUNlZ0ErQWdJQVF3S1hBREVDckFBdUFla0FHQUFBQUFBQWFnRENBVVlCb0FJU0FBQjQybU5nWkdCZ1lHTUlaMkJpQUFGR0JqUUFBQW1mQUdKNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS45OTMwNywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTQuMjY3ODY2JyB5PSctNjYuMjYyOTI4Jz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU0LjI2Nzg2NicgeT0nLTYwLjE3NDczNSc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MC45MTI0MywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTQuMjY3ODY2JyB5PSctNjEuMTUzMTgzJz4xPC90ZXh0Pgo8cmVjdCB4PSctNjEuNzM5ODY1JyB5PSctNTkuOTU3NzMnIGhlaWdodD0nLjM5ODQ4NCcgd2lkdGg9JzExLjk0MTM2NScvPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwNy41MDU0NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTQuMjY3ODY2JyB5PSctNjYuMjYyOTI4Jz7ugLDugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU0LjI2Nzg2NicgeT0nLTYwLjE3NDczNSc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44Nzc3MywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02MS43Mzk4NjUnIHk9Jy02Mi42NDc1NjQnPlY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTQ0LjE1Njg5IDBIMTEuMDQ4NjEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDMuOTA2ODksMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMC43OTg2MSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0LjE2MzIsMy44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02MS43Mzk4NjUnIHk9Jy02Mi42NDc1NjQnPs+APC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01Ny4wODEwMjEnIHk9Jy02MS42NTEzJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002OS42NTQxMSAwSDEwMi40NDk5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDY5LjkwNDExLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTAyLjY5OTksMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4MC45MTI0NSwzLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+z4A8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTU3LjA4MTAyMScgeT0nLTYxLjY1MTMnPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjQ0MzUtMTAuNDQ3Mkw0OC4zMTM2Ny00OC4zMDg5NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC43MDcxNywwLjcwNywtMC43MDcsLTAuNzA3MTcsMTAuNjIwMywtMTAuNjIzOTYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTcsLTAuNzA3LDAuNzA3LDAuNzA3MTcsNDguNDkwNDYsLTQ4LjQ4NTcyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3LjM5ODEsLTM2LjkzMzA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+YTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTcuNDE4NDIxJyB5PSctNjUuNjU0MDgxJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUzLjI1MzQ1MicgeT0nLTYyLjY0NzU2NCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTAuMTQwMTA5JyB5PSctNjIuNjQ3NTY0Jz7ugaA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ2LjgwNTM1NScgeT0nLTYyLjY0NzU2NCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS0xMi4xMDk2Vi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTEyLjM1OTYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTTUxLjYzODE0LTM0LjAzNjAzSDYyLjE3Mjg3Vi0yNS4wMjIxNEg1MS42MzgxNFonIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU0LjYzODE0LC0zMS4wMzYwMyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02MS43Mzk4NjUnIHk9Jy02Mi42NDc1NjQnPng8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTAzLjM2NzUxLTEwLjQ0NzJMNjUuNDk3MzMtNDguMzA4OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNywwLjcwNywtMC43MDcsMC43MDcxNywxMDMuMTkwNywtMTAuNjIzOTYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjcwNzE3LC0wLjcwNywwLjcwNywtMC43MDcxNyw2NS4zMjA1NCwtNDguNDg1NzIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4LjI5NzQsLTM2LjkzMzA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+YjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTguMjM2MzI4JyB5PSctNjUuNjU0MDgxJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU0LjA3MTM1OCcgeT0nLTYyLjY0NzU2NCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTAuOTU4MDE1JyB5PSctNjIuNjQ3NTY0Jz7ugaA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ3LjYyMzI2MScgeT0nLTYyLjY0NzU2NCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$A_{1}'$};
      \node  [right = of 1] (2) {$\underline {A_{1}}$};
      \node  [right = of 2] (3) {$A_{1}''$};
      \node  [below = of 2] (4) {$V$};
      \draw  [>->,morphism] (2) to node[swap] {$\pi _{1}$} (1);
      \draw  [>->,morphism] (2) to node {$\pi _{2}$} (3);
      \draw  [>->,morphism] (1) to node[swap] {$a^{*}(\ell )$} (4);
      \draw  [>->,morphism] (2) to node[desc] {$x$} (4);
      \draw  [>->,morphism] (3) to node {$b^{*}(\ell )$} (4);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Note that</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       u_{1}\ell '\pi _{1} &= n\ell \ell '\pi _{1}\\                    &= naa^{*}(\ell )\pi _{1} && \text {since $na = nb$}\\                    &= nba^{*}(\ell )\pi _{1} && \text {since $a^{*}(\ell )\pi _{1} = x = b^{*}(\ell )\pi _{2}$}\\                    &= nbb^{*}(\ell )\pi _{2}\\                    &= n\ell \ell ''\pi _{2}\\                    &= u_{1}\ell ''\pi _{2}     \end {align*}   ]]></fr:tex>
  <fr:p>Since <fr:tex
display="inline"><![CDATA[u_{1}]]></fr:tex> is monic, <fr:tex
display="inline"><![CDATA[\ell '\pi _{1} = \ell ''\pi _{2}]]></fr:tex>.
    Then</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       max &= maa^{*}(\ell )\pi _{1}\\           &= m\ell \ell '\pi _{1}\\           &= m\ell \ell ''\pi _{2}\\           &= mbb^{*}(\ell )\pi _{2}\\           &= mbx     \end {align*}   ]]></fr:tex>
  <fr:p>Analogously, the subobject <fr:tex
display="inline"><![CDATA[a^{*}(k) \cap  b^{*}(k)]]></fr:tex> is also contained in <fr:tex
display="inline"><![CDATA[e]]></fr:tex>.
    Now, we show that <fr:tex
display="inline"><![CDATA[y := a^{*}(\ell ) \cap  b^{*}(k)]]></fr:tex> is contained in <fr:tex
display="inline"><![CDATA[e]]></fr:tex>.
    The proof for <fr:tex
display="inline"><![CDATA[a^{*}(k) \cap  b^{*}(\ell )]]></fr:tex> is analogous to this one.</fr:p>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[\nu _{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\nu _{2}]]></fr:tex> be the product projections of <fr:tex
display="inline"><![CDATA[y]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="0b61b5494ca4929390b142c12a3d6f6b"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMS4zMjYxMDdwdCcgaGVpZ2h0PScxMDguMjczMDg2cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTM0LjIxNzQwNSA3Mi4xODIwNTcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQzBBQUFBMktZeUFpMmhvWldFQUFBSkFBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbUFBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDYUFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKd0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGkyaE9Kc3ZIOE5sOFptRmtZUU9DeHdMeWJ5RFJMS09NZElNWEJ3QVRpQVFBVnFBbUFBQUFBZU5wallHUmdZTmI2WThuQXdCTEswTWZRejVUTUFCUkJBVXdBVW9BRFFnQUVWUUFBQXZJQWpnQUFBQUFBVkFBQWVOcGpZR1JnWUdCaU1HVUEwUXhRRWdrQUFBWEtBRHNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT3dBQW9BQUFBQUJCZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFV4MUFtTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ0ZaMng1WmdBQUFXUUFBQUQwQUFBQTlOdSsrWkpvWldGa0FBQUNXQUFBQUMwQUFBQTJLSW1CV21ob1pXRUFBQUtJQUFBQUhnQUFBQ1FGdWdLeWFHMTBlQUFBQXFnQUFBQUtBQUFBQ2dabkFKSnNiMk5oQUFBQ3RBQUFBQWdBQUFBSUFESUFlbTFoZUhBQUFBSzhBQUFBRndBQUFDQUFCUUF0Ym1GdFpRQUFBdFFBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEb0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtZXMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUTBaREJpWnZnUDVETkRwSkhVL0FjS0F3RDJ4QTArZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhHLy84RFNjUC8vLzlmQVBNWkFGRllCbzRBQVFDU0FBQUNOd0tyQUI0QUFBRVJCaFk3QVJVbUp5TUdCelV6TWpZbkVRNEJKeU0xTXhZL0FUWTNOaFlCbUFRaVRqTXNPdEU2TEROT0lRTXVWQk1TRWhJK0J6ODVHQTRDaS8zTkZ4UXRBd0VCQXkwVUZ3SUFFZ3dCTFFJS0Fnb3VBUWtBQUFFQVhRQUFBbHNDcWdBckFBQWxCeUUxTkQ4Q1BnRTNMZ0VuSWdZSEhnRVhEZ0VqQmlZblBnRTNNaFlYRGdFSEJnOEJKVFkzUGdFM0Fsc2kvaVFEQ2ZvOVRRRUNhRTAwVWhZWUlRRUJKaFVPTEFJQ2hHcHdtd01DYUVndk5Xa0JBaW9LRFE4Q3hzWWZCUUlKMURGcVAweFRBU29qQWg4YklCMEJHU2ROWlFKcFkxQnBMaUFuVGdFQkJBdEJFZ0FBZU5wallHUmdZQURpeGYzdDR2SDhObDhabUZrWVFPQ3h3THlieURSekVOTnFJTVhCd0FUaUFRQVZ1UWxaQUFBQWVOcGpZR1JnWUdiNHp3QWtneGhpR1dLWm9obUFJaWlBQ1FBOTBRSnpBQUFEVWdBQUFyZ0FrZ0JkQUFBQUFBQUFBRElBZW5qYVkyQmtZR0JnWnRCaEFORU1VQklKQUFBRkJBQXpBSGphUFl3eHE4SXdGSVcvWWhYdEd4d0VoemRJOEFlRVNwK2JtNE9UcThQYnJBblNvYW1rdGVnaS9uUnZRL0FHRHQ4OTU5d0FHUzhTaGttWUJ4MG1sVGVQUE9hSFJlU0orS3ZJR2Irc0daR2tNM0ZXN0NLblRQbVBQR1pKR1hraS9pTnl4aC92ZlZQZjdwMzE2dGdZNjkybDl0dVQ5VzNWT0xYUitiQWVyTFArM0ZtanlxY3lmZFgyMTFvVk90Y0ZleHBxYnR6cHNIZ1VSM0ZNWU1kRk1zK1dVOWhiS3NtY2REWm84bTk2a05TRnhqbjhZcVJSOGhRMTlITFRpbDZscXlqQ25hYjRBRlV5TGtNQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJZQUFvQUFBQUFCTndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBSMk50WVhBQUFBRTRBQUFBTlFBQUFEd0FUUUIrWjJ4NVpnQUFBWEFBQUFHRkFBQUJwRFlXOElWb1pXRmtBQUFDK0FBQUFDNEFBQUEyS0F1QXNHaG9aV0VBQUFNb0FBQUFId0FBQUNRRlNBSWFhRzEwZUFBQUEwZ0FBQUFTQUFBQUVnanRBU3hzYjJOaEFBQURYQUFBQUF3QUFBQU1BTHdCTW0xaGVIQUFBQU5vQUFBQUZ3QUFBQ0FBQndBcmJtRnRaUUFBQTRBQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRVRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbU1tQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUJneE0vd0g4cGtoMGtocS9nT0ZBYkcrREhvQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS2FqSVkvZjhQNUdzd0dQNy8vLy9tLzB0Z1ZVQUFBSXR1Q01VQUFBQjQyaVhRVFVzYlVSUUc0UE9lcS9lU0NjNGtKRFBCSk5na2RXYUlYNFhHdVlNR21paW9EYlRhUlpKQ3E2S1ZLdHBRdEhVcmxLcTRLUDBSN3RxLzRMb1UrajkwWFJCQnVtanJEWExnZkd3ZVhnNkJEdjhEbndSUm5nZzVMNnVrQTZta1oxWUhRV2dxRGhyUTZBMHBOVGVyWmdTNjI1WWFPbzNzcE04OGFXdEI0SlNjN3FVT2ZuNzlzNVpJTWQ0Y2xVdEhXeCtPL2MrR3BLZkdiOS83R2FQbVBKV1Z5a1lRVHpmd0JQRVV3aURTOGVxSjdvUFZpbjVmZ0hEYXF4QUhpd2xJUWZmYXEvUG01aFpiWWlEOTdQZjVqNnRaU3lhWXFPL3ZtM2JKMzJuWXpMVDA2bkFmd1VGVWU2ekR0STB3OG5Tc1Bid1VwVmE0ODJKL01XeVZ4RVE3V3o2c3VVbis4dmRYM3ZVRm1IMDN6MVkyZ1ZIMnBtRDEzVGtpSHVSdlZDWHlWVG5XSmkyYmIwZzFBaFAvb1F4Q2szNEVPUnY5aDhVNk5pY1BQdmozR3F4dUMvTmk1WG5RSFE0OW9KS3h4aGdmTjkrZUNlN1VPMlBMMTM3U3N2bmlvaWpsVFdIN1pJTXhIckh2RkF0d2c5WTdnZDMxcGIySmhjb0NNR0ExTTNRSHZsOUVrUUFBQUhqYVkyQmtZR0FBNG1mcVV5Ykg4OXQ4WldCbVlRQ0J4d0x6YmlMby80eE1sNWxCWEE0R0poQUZBRFc4Q3BNQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHUndZbUpsUUVvZ2dKWUFEODFBbWdBQXRNQUFBSEpBSFFCeVFCSUFrY0FjQUJCQUFBQUFBQUFBREFBWUFDTUFOSjQybU5nWkdCZ1lHWFFZZ0RSREZBU0NRQUFCUWdBTXdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQzBBQUFBMktNaUE2MmhvWldFQUFBSGNBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZndBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPTGRHOHQ4NC9sdHZqSXdzekNBd0dPQmVUZVJhZWFKVERaQWlvT0JDY1FEQUNTWENZZ0FBQUI0Mm1OZ1pHQmdWdnhqQkNRbk1oZ3l5REthTUFCRlVBQVRBRUVhQW00QUFBT1JBQUFCVVFBeEFBQUFBQUFnQUFCNDJtTmdaR0JnWUdMZ1p3RFJERkFTQ1FBQUFoUUFGUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQWJZQUFvQUFBQUFDRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWdBQUFCZ2hmMWtsV050WVhBQUFBRThBQUFBUUFBQUFGUUVTT0cvWjJ4NVpnQUFBWHdBQUFQc0FBQUU4Rk9GRG5Cb1pXRmtBQUFGYUFBQUFDOEFBQUEySi82QXIyaG9aV0VBQUFXWUFBQUFJQUFBQUNRRmRnRzlhRzEwZUFBQUJiZ0FBQUFjQUFBQUhCQTBBV0ZzYjJOaEFBQUYxQUFBQUJBQUFBQVFBN2dFL20xaGVIQUFBQVhrQUFBQUdBQUFBQ0FBQ2dCWWJtRnRaUUFBQmZ3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBR3pBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUNtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUdqQUlMTmtGSmNsZzZVVEh5UXdNendIOGhuWm1BRUNUTWlWUHdIQ2dNQUFHb09jWGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdjZ0RRUEF3ZFFqb1VoaVNHYm9aSjU3NE9FLy8rQm9va0kzdjhGLzJmODcvN2pJYjhNckE4T0FDQjJFZUY0MmxXVVMyL2pWQnpGZmE3ZmRtekh0V01uU3BxSG5kaHUycVJ0a3RwcHA1T1F0aW5UVHF0T3hURFFlWFVHQklnRmlBMGJLZ1FDSkRhellJbjRBQWl4bWcwTHhIYWsyU0h4Q1pCQTRoUEE3R2k1TnkxSStPL1Z2ZGZTK1oxenJqbkNqUzcrSW50NHhuVzRsemdPSS9RODN5SW1DcTduanpCR1dvUG51NUpNSjRwTnlGM0VhY2FtQ2o1TDR5aU9KSmt1VjVHTmtLVjRLczZYWGN3VlBGbTFuSHFvS0lLbVNYRHNjdXB2MmRXOTl2WnJFTWFXczMrM05WanR3eTMwL2QzUUNZQ2xhakJRSW56cE9YbjcxdUg5UXRmMEtpRFR1Q3lCRUUyYzFQczh5cDFxQWp3NGVPdlltZHZsRVp6LytuT3UxUlJJY2kzOHRKTjFRV3BLaGFNUDRiWXZYdUEzOHB3THVKUXk4VXlaNTBzV0pDWS9HdE9GS0F5aWVJUSszWkRaL2doclhZUUJSYUduS0R2TVhYOHJHVDdrK1Vsai8yUnlHNUE2WFUwaVZsTzFBVXZlV1dvaVM2Wk9jUjZMMWMyUnFRaFZaWUY4ZC82N1IyRmVPWG4zVnJqRDQrUW9IL3o0UTlzM05FR3pGRm5nYzMvZnhXYThjaFlPbG5jc3l6eExTdDBOS3BBN3ZIaEJwbFR2SGFZMnpWZ0lCUk1oTlRmTm9rdE5zdWV6Y1MxK0ZndzkwMmNMTEJlWm9rUTBDOHBtd1VRUXJXWE8vd2t4ZWJ2MmVuejhhb1NtRi9IdzY2YTdlQlJIZnJFK3NLd1ZnZkFpTERkYTFIaFpVeVVncjdtVjlYaWJRT1NCL1dGb0NYNWtpMThKakQ0UG1KUytCUXI3am5uUVdsc3FOeHFrYVRZVkU5aUlHaTZWSUtyZXVxWWFaY2VyUVRoc1docUxzRnV1ZElWK2FzNlpVaEtMVHpibWlvN2hrUjNEK3M4Y2xoMjRsWXRsTXFKOVBHSmVYQmFPVXREOFBPbXFaZlNWUXRyR0xyS0ltU1VIMUlTUVZuRndWVXlmaVlBc2VYNUtDOHppN3RQUHlmcmp5dGZIMlJZUXVkbzhpSjA0ZlhuaGVxRldWbnZYdldHcFlnQ2xwczZYNnBzT2JGMUNVYmZEY1R1RllCU3JJRjR2cSt0bCtMR3QrdHE4QUh4Mi92SGo5NEhWSkd6QTlvV09YTktBcEJpOTNPN0NjRXNiVnUzT1BXOGZvM0dlRU5WYzlRcGRFYXN0dzJoZGUzUEJIb3Rpa0F2RTAyODJUUTAxaVhMZnBNVzlSN25qcThiU2w0cG15Vk1VUmpjbTZTelRRZG9mb3dyWkJVNi8rS2toRlVvTlFvcDYvZlQyMDExYmwxSGQ0QzlybWpjZTFISWk4TzM1NSszbkgvZ0J2U0RpdEhEelpPK1FCZkxKSDdhc2lOUjZsU0JIbE5tOUtWNzhpV2ZrRjI2ZHU4RnhtV3lTYUREbUIrbnNhcy9tMzhZeFVRVlpZdjhHdHNmMEZKampOQzNxT0QwZkQyWm5aT21qV0pvM2RONk1XNEt1UklFZUdIWjdiVG1uRTNIWVhwa0Vta0FncWNaaU9HM29vaXlyL0NBLzdFMnViUTlieWJqQ054ZG9YNjNpazBBdUlxY0paaU5vVG52eGgxdkZuak8zSWdoaGFMMXhmenE4VVZNVUpiQTd0VVVCN2FwT0NBeFJUOVFtK0VmZnJ5ZkRSMmNhemZCZzZiM3NJZmNQWUppbjJYamFZMkJrWUdBQTRvYU1STUY0ZnB1dkRNd3NEQ0R3V0dEZVRRVDlYNS9wR05ORklKZURnUWtrQ2dBYk13cXFBSGphWTJCa1lHQm0rTS9Bd01CMGpFSGkvM3VtYUFhZ0NBcGdCd0Jrd1FRM0FzWUFBQUo2QUQ0Q0FnQkRBbTRBVFFKUkFEQUNTZ0JMQWVrQUdBQUFBQUFBYWdEQ0FVZ0J4QUlHQW5oNDJtTmdaR0JnWUdjSVoyQmlBQUZHQmpRQUFBbTZBR040MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUG9BQW9BQUFBQUJIQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MDFHTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWZRQ0paMng1WmdBQUFXd0FBQUVkQUFBQk9OZWVVNHBvWldGa0FBQUNqQUFBQUM4QUFBQTJLRXVCY1dob1pXRUFBQUs4QUFBQUhRQUFBQ1FHT2dGR2FHMTBlQUFBQXR3QUFBQU1BQUFBREFmTEFGNXNiMk5oQUFBQzZBQUFBQWdBQUFBSUFGUUFuRzFoZUhBQUFBTHdBQUFBR0FBQUFDQUFCZ0EwYm1GdFpRQUFBd2dBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFEM0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtbXNrNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaQWhqWnZnUDVETkRwSkhVL0FjS0F3RGUvZzBnZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pLRS9mOFA1SVBwL3dmK3J3R3JBZ0lBa20wSkFBQUFBSGphSGM1QlNzTkFGTWJ4K2Q2WW1jUm1rbUNtRTVRR3JTMEpCYVhRaGdSY0JFRzBPMEVSOFFMVnBSc1JkeFowNzlxRGlCc1A0Q1ZjS0xqeURHMmM5aTEvaS9mOUdiRiswOUEzZmJFaEd6RldvYXhHSm9tMUdaZEdEQ0h6TEMvS3hKVFZFRjBwdEVuS0pJRDFKWTlyVkdQK2pxblFTcUEyKzIzNHp0M01kYUJhY2NFOXVXaE9WU2RXSE1xNXVmTGhlN3YxNjEvM25pNGplT0Y4WmtLZVNuQU9ja01KK01uMThiUHVSNkF3RUV0ZUR3VjZuemhuOXNBT21sOGUwd2NiTU9aQjVDTG5SZFlUUmJtTnlxYm1vaDNiOXN4NkRVdWp0aFF5RS9TMGVISDFCai9UZzAwbGJoOFZoYTNKQ1k3cy83MkFJM0NtRjRySVN3OXBNbi9UV092UVF4enhkRFcvSlVIcC9JZEkrVHRFd2FySjkxeEN5dGcvbFRNdE1RQUFBSGphWTJCa1lHQUFZbTl0N3IveC9EWmZHWmhaR0VEZ3NjQzhtd2o2LzFObVlhYTdRQzRIQXhOSUZBQWg5UXJlQUhqYVkyQmtZR0JtK004QUlobFUvanN4Q3pNQVJWQUFNd0EvSUFLR0FBQUFBbllBQUFNQUFDUUNWUUE2QUFBQUFBQlVBSng0Mm1OZ1pHQmdZR1l3Wm1CaUFBRkdCalFBQUFYS0FEdDQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS45OTMwNywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTQuMjY3ODY2JyB5PSctNjYuMjYyOTI4Jz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU0LjI2Nzg2NicgeT0nLTYwLjE3NDczNSc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1My4xNTU1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS43Mzk4NjUsLTYyLjY0NzU2NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuNzM5ODY1JyB5PSctNjIuNjQ3NTY0Jz5BPC90ZXh0Pgo8cmVjdCB4PSctNjEuNzM5ODY1JyB5PSctNjEuNDUyMTExJyBoZWlnaHQ9Jy4zOTg0ODQnIHdpZHRoPSc3LjQ3MTk5NScvPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwNy41MDU0NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNzM5ODY1LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjczOTg2NScgeT0nLTYyLjY0NzU2NCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTQuMjY3ODY2JyB5PSctNjYuMjYyOTI4Jz7ugLDugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU0LjI2Nzg2NicgeT0nLTYwLjE3NDczNSc+MjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44Nzc3MywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02MS43Mzk4NjUnIHk9Jy02Mi42NDc1NjQnPlY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTQ2LjM5OTk2IDBIMTEuMDQ4NjEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuMTQ5OTYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMC43OTg2MSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1LjYxODI0LDMuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS43Mzk4NjUsLTYyLjY0NzU2NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjEuNzM5ODY1JyB5PSctNjIuNjQ3NTY0Jz7OvTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNTcuNzQ1NTUzJyB5PSctNjEuNjUxMyc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNjcuNDExMDQgMEgxMDIuNDQ5OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCw2Ny42NjEwNCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwMi42OTk5LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODAuMTI0NDIsMy44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02MS43Mzk4NjUnIHk9Jy02Mi42NDc1NjQnPs69PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01Ny43NDU1NTMnIHk9Jy02MS42NTEzJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMC40NDM1LTEwLjQ0NzJMNDguMzEzNjctNDguMzA4OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNzA3MTcsMC43MDcsLTAuNzA3LC0wLjcwNzE3LDEwLjYyMDMsLTEwLjYyMzk2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE3LC0wLjcwNywwLjcwNywwLjcwNzE3LDQ4LjQ5MDQ2LC00OC40ODU3MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNy4zOTgxLC0zNi45MzMwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02MS43Mzk4NjUnIHk9Jy02Mi42NDc1NjQnPmE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU3LjQxODQyMScgeT0nLTY1LjY1NDA4MSc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01My4yNTM0NTInIHk9Jy02Mi42NDc1NjQnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUwLjE0MDEwOScgeT0nLTYyLjY0NzU2NCc+7oGgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ni44MDUzNTUnIHk9Jy02Mi42NDc1NjQnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtMTAuNjA5NlYtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCw1Ni45MDU1LC0xMC44NTk2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J001MS43NTIxNC0zNC42NDcxMUg2Mi4wNTg4N1YtMjQuMjcyMTRINTEuNzUyMTRaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1NC43NTIxNCwtMzAuMjg2MDMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS43Mzk4NjUsLTYyLjY0NzU2NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjEuNzM5ODY1JyB5PSctNjIuNjQ3NTY0Jz55PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwMy4zNjc1MS0xMC40NDcyTDY1LjQ5NzMzLTQ4LjMwODk2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTcsMC43MDcsLTAuNzA3LDAuNzA3MTcsMTAzLjE5MDcsLTEwLjYyMzk2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC43MDcxNywtMC43MDcsMC43MDcsLTAuNzA3MTcsNjUuMzIwNTQsLTQ4LjQ4NTcyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OC4yOTc0LC0zNi45MzMwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjczOTg2NSwtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02MS43Mzk4NjUnIHk9Jy02Mi42NDc1NjQnPmI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU4LjIzNjMyOCcgeT0nLTY1LjY1NDA4MSc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01NC4wNzEzNTgnIHk9Jy02Mi42NDc1NjQnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUwLjk1ODAxNScgeT0nLTYyLjY0NzU2NCc+azwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDYuNTU0MzYxJyB5PSctNjIuNjQ3NTY0Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$A_{1}'$};
      \node  [right = of 1] (2) {$\underline {A}$};
      \node  [right = of 2] (3) {$A_{2}''$};
      \node  [below = of 2] (4) {$V$};
      \draw  [>->,morphism] (2) to node[swap] {$\nu _{1}$} (1);
      \draw  [>->,morphism] (2) to node {$\nu _{2}$} (3);
      \draw  [>->,morphism] (1) to node[swap] {$a^{*}(\ell )$} (4);
      \draw  [>->,morphism] (2) to node[desc] {$y$} (4);
      \draw  [>->,morphism] (3) to node {$b^{*}(k)$} (4);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Then we have</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       u_{1}\ell '\nu _{1} &= n\ell \ell '\nu _{1}\\                    &= naa^{*}(\ell )\nu _{1} && \text {since $na = nb$}\\                    &= nba^{*}(\ell )\nu _{1}&& \text {since $a^{*}(\ell )\nu _{1} = y = b^{*}(k)\nu _{2}$}\\                    &= nbb^{*}(k)\nu _{2}\\                    &= nkk''\nu _{2}\\                    &= u_{2}k''\nu _{2}     \end {align*}   ]]></fr:tex>
  <fr:p>Thus, <fr:tex
display="inline"><![CDATA[\ell '\nu _{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[k''\nu _{2}]]></fr:tex> can be factored as follows:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="a7a8705981ee2025100fb0483a656e87"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwNC4zNDE4NzNwdCcgaGVpZ2h0PScxNzIuMzY4NDAzcHQnIHZpZXdCb3g9Jy03MiAtNzIgMTM2LjIyNzkxNSAxMTQuOTEyMjY5Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUlBQW9BQUFBQUEyZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYUR4aWhHTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJFQUFBQVJCNWFqSGRvWldGa0FBQUJzQUFBQUMwQUFBQTJLWXlBOTJob1pXRUFBQUhnQUFBQUh3QUFBQ1FGQmdEWmFHMTBlQUFBQWdBQUFBQUlBQUFBQ0FZWUFGOXNiMk5oQUFBQ0NBQUFBQVlBQUFBR0FDSUFBRzFoZUhBQUFBSVFBQUFBRndBQUFDQUFCQUFTYm1GdFpRQUFBaWdBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFDK0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtNW1HY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnEwL2xnd016RnJNeDRIQ2pBZ1YvLzh6TUFBQSt3TVBmd0I0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQUY4QUp3RjdBandBRUFBQUFRTUdJeWNtSnpjVFBnRTNNaFlYQmdjQmNkUUdEQllUQXdTZUF4a2VHU1lCQVFRQjNQNWNFUWNIRFJBQnV3NGdBU0FjREF3QWVOcGpZR1JnWUFCaTlzMExiT1A1YmI0eU1MTXdnTUJqZ1huM2tXbVdVQ1liSU1YQndBVGlBUUFITndqQkFBQUFlTnBqWUdSZ1lOYjZZOG5Bd0JMS0VNL2d3VmpOQUJSQkFVd0FTaWdDNHdBRVZRQUFBY01BWHdBQUFBQUFJZ0FBZU5wallHUmdZR0JpRUdRQTBReFFFZ2tBQUFKR0FCY0FlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ2xKV0ZnWW1WcVF0Z2d6TEVRWGFJRktucXlPL3U0WHJvRGFmbi9iZ0RTbjdJZUU3R2E5elB5U2xFL1hIQkMyK0pwNklXaVVzK1dESWh5MmZpek5ra3ppWDVTbHp3emlYeFZQenZ4Q1dmUExaZGU3djMxcXQ5WjZ4MzV6YU02NFAxb2VtY1d1a3E2cDExMWg5N2E5UnBWR1pvd25CdFZhMHJYYk9sbytYR25SNkxSN0VYeDBSMm5DVUxqS3c1UkNmUVNPcWt0VUpUL2N0M2tydllPY1pQUmpvblNaVFFJRmRCOWxYYWlqcGVhdXBmNytrd1J3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPd0FBb0FBQUFBQkJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVXgxQW1OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDRloyeDVaZ0FBQVdRQUFBRDBBQUFBOU51KytaSm9aV0ZrQUFBQ1dBQUFBQzBBQUFBMktJbUJabWhvWldFQUFBS0lBQUFBSGdBQUFDUUZ1Z0t5YUcxMGVBQUFBcWdBQUFBS0FBQUFDZ1puQUpKc2IyTmhBQUFDdEFBQUFBZ0FBQUFJQURJQWVtMWhlSEFBQUFLOEFBQUFGd0FBQUNBQUJRQXRibUZ0WlFBQUF0UUFBQURLQUFBQk11c0lrZVp3YjNOMEFBQURvQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1lczA0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBRMFpEQmladmdQNURORHBKSFUvQWNLQXdEMnhBMCtlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aEcvLzhEU2NQLy8vOWZBUE1aQUZGWUJvNEFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FBQUVBWFFBQUFsc0NxZ0FyQUFBbEJ5RTFORDhDUGdFM0xnRW5JZ1lISGdFWERnRWpCaVluUGdFM01oWVhEZ0VIQmc4QkpUWTNQZ0UzQWxzaS9pUURDZm85VFFFQ2FFMDBVaFlZSVFFQkpoVU9MQUlDaEdwd213TUNhRWd2TldrQkFpb0tEUThDeHNZZkJRSUoxREZxUDB4VEFTb2pBaDhiSUIwQkdTZE5aUUpwWTFCcExpQW5UZ0VCQkF0QkVnQUFlTnBqWUdSZ1lBRGl4ZjF0LytQNWJiNHlNTE13Z01CamdYbjNrV25tSUtiVlFJcURnUW5FQXdBOW1RcE1BQUFBZU5wallHUmdZR2I0endBa2d4aGlHV0tab2htQUlpaUFDUUE5MFFKekFBQURVZ0FBQXJnQWtnQmRBQUFBQUFBQUFESUFlbmphWTJCa1lHQmdadEJoQU5FTVVCSUpBQUFGQkFBekFIamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU3ArYm00T1RxOFBickFuU29hbWt0ZWdpL25SdlEvQUdEdDg5NTl3QUdTOFNoa21ZQngwbWxUZVBQT2FIUmVTSitLdklHYitzR1pHa00zRlc3Q0tuVFBtUFBHWkpHWGtpL2lOeXhoL3ZmVlBmN3AzMTZ0Z1k2OTJsOXR1VDlXM1ZPTFhSK2JBZXJMUCszRm1qeXFjeWZkWDIxMW9WT3RjRmV4cHFidHpwc0hnVVIzRk1ZTWRGTXMrV1U5aGJLc21jZERabzhtOTZrTlNGeGpuOFlxUlI4aFExOUhMVGlsNmxxeWpDbmFiNEFGVXlMa01BQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQWJvQUFvQUFBQUFDSGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWdBQUFCZ2hnVmtpbU50WVhBQUFBRThBQUFBUkFBQUFGeStFaWlCWjJ4NVpnQUFBWUFBQUFQM0FBQUZFQXNGN3lGb1pXRmtBQUFGZUFBQUFDOEFBQUEySi82QmdHaG9aV0VBQUFXb0FBQUFJQUFBQUNRRm5nRzlhRzEwZUFBQUJjZ0FBQUFjQUFBQUhBL21BVTVzYjJOaEFBQUY1QUFBQUJBQUFBQVFBOUlGUW0xaGVIQUFBQVgwQUFBQUdBQUFBQ0FBQ2dCWWJtRnRaUUFBQmd3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRzNBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWNtV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUdqQUlMTmtGSmNsZzZVekh5UXdNendIOGhuWm1BRUNUTWlWUHdIQ2dNQS9WUU9ibmphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmc4Z0RRZkF3ZFFqbzBoa3lHYm9aU2hpbm52ZzRULy80SGlLUHovTS81UC85LzN2K3VQaC93eXNHNGtBQUREM3hScmVOcGRsTXVQMjFRVXhuMk83ZXZZVHZ5S241TTBEOXV4TThsZ1p6S0puY3dqNlV5Ym9UQXpxcEFBOFNpMFlqR0lCUkliTnJBQXFXeVF1dUNmb0VLSUJhelpGblhkQmY4Q0c3YWxPenJjNjFFMytIcmpjOCtWenZmOXZtc091Y25WQzdqRXg1ekNIWEljYUNCbE1GL0IxT1hYVU14blVrZ2tFcVZKT2lzTHVqcmdFUjJKcElFM3BkOTdYZ2NrMmtEUHBBV2NROSszSFlqRzlyT2JXeVRvSE5wZ3FnUjgxWXhXNHptQUdBU1didkR0N2tFVFRabUFxMXJSRWQxQS9OYnRBM2k2MncvKy9mdkhFOXRJK1lNVEExSFdkbDBuRTJFYW04Yng4WERVMjhENnlFTDBKcDZiQ2JBNzhEbmdMcTVlNEFhZmN1L1M2Zm1pWktNN0drUkptaFJsUWdmVmdVaXV4NWF0ODdicnJZRDI3TEZDTlhsSUc4c2lwUUowS2o1TTVtVnpCVWxFeTdTckxGd0pqaSs3NzZWdnZaTkE3Q1k4ZUQzTkh0OU5FOC92elhSOUlpQXZnbTRuWTRXWEZLb0pETVZ1TDlOYkNDSVA4T1lpMGdVdk1jVWZCTlJqMlFEUXBOczdBOENmWG42cW5RL21PNjErSDJNdHJta0ErMG5mcGlPSXNydFU1RWFyNlhaQnVJaDFCVkVSczFZN0UvWUt6ZExJTUJVZjdWdCtzK0hpN1lhdUNJcGVrd1MrenRFSEtNdm4rQkNlY09jY04yQk9VTW1vZ1ZPcHBqaTdRRTFnb2ttU1V0QWt6WkJCL1Qva3Flc3h3aEtwekNwSytHMU83S1ZBSXBmSVdyTVgxV3FDcWhCb1d1MTUvWFU3T01yM0o2MDZXRU1UZ3U1aHMyTHUxU256NFFLZzRZV0E3bDYrMGxGOC9HY1FkeVh2KzN0T3BqazNBRGRwaXdDVGQ3TS9RM1R6WUJzd0NwYTl1NWRST0lEMXFrckF4S01KbUF5OXp1S3ozRnlMZUxERjI1WFcxZFUvNk1JZjNBWEhyWUVwdXc2azY1QlhYTE1xbXpsa3dHTEIzcW9ZSmJRYXBnVTFoUEtsQ1M3WnlTNTBnREMzZnZHMzhqUk96d3plb0VJaVZjdFAvY1J6QW1VMkV1dUtCRm5XS0E5T1M5UHNEZFdvcVIvb2ZJZUhTQmdjbVVuZ3RXUXI5Z2wxQjh2OFpMV2Fmd0FnSzVBTVRDcHphMnBxdWVCNWxneDRxQUtnc2NxMDNXeTVhL0d5UUVBTERHMXJSTFpGc0FKWGdYWllweTMySnQvZm5lWk03eG5INFllVWJjcHlmaTJIWnBpbG02Smk4TlpZVkxtZEZYdHJLa2F5QWU1LzkzdWZPRUVmMFZkNzk5Lys5ZFJVSmVqczh5eU1KaGlOajdwMUVlRHh5NGVqcDE4d1VGMXg0NXk5LzhZRkM5MDNmNWxTVGFUeGtoSHFXS09lSStkZlBZY24rSXhiY25jNHJwUTBUR1pyZmxhNVcxVHIxYTFpUXprU1lWallIcHZIWVltaVA0cDFSU09kU2RjWit5b2xOeG9xcjZVRFFhMGxvUm8yek5FOHI2c29Ma2FUNDFBUkVJamNHRWVidmlwS2tzelBqTVgwK09EV1lqQmN0L2w0bTk1SjNYOFVTajdVRlVIcmgvRm1tbjU1NGsrYjFrUVFva2ovNU41bWNhZGJxOVZDODdYdVdJQlJSMFdFaHFnTzVSajRCejh2aDRzSFh5c0ZDT2M3bjVjZmMvOEJvdWFncUFCNDJtTmdaR0JnQU9LNWQvaSt4dlBiZkdWZ1ptRUFnY2NDOCs0ajZQOWZtSTR4WFFSeU9SaVlRS0lBV1hRTW5RQjQybU5nWkdCZ1p2alB3TURBZEl4QjR2OTdwbVlHb0FnS1lBY0FaN2tFWHdMR0FBQUJuZ0F3QW00QVRRS3pBREFDTGdBK0Frb0FTd0hwQUJnQUFBQUFBR0FBNWdGY0FkUUNGZ0tJZU5wallHUmdZR0JuQ0dkZ1lnQUJSZ1kwQUFBSnVnQmplTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT2NBQW9BQUFBQUJEQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW5TVUltTnRZWEFBQUFGQUFBQUFNd0FBQUR3aVBTS0ZaMng1WmdBQUFYUUFBQURJQUFBQStDYzZQcjVvWldGa0FBQUNQQUFBQUM4QUFBQTJLRlNCQ0dob1pXRUFBQUpzQUFBQUhnQUFBQ1FGeGY5L2FHMTBlQUFBQW93QUFBQUtBQUFBQ2dYOUFEZHNiMk5oQUFBQ21BQUFBQWdBQUFBSUFENEFmRzFoZUhBQUFBS2dBQUFBRndBQUFDQUFCUUFtYm1GdFpRQUFBcmdBQUFEVEFBQUJQcTgzZGVGd2IzTjBBQUFEakFBQUFCQUFBQUFnQUFNQUFYamFZMkJtdXNBNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVNwcElXczlRZlRRWUdaaW5tNjBCaFJvVFMvLzhaR0FBWG5RN0pBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZTklBMEc1Qm1aR0JTMGxUUyt2K2ZnUUZDMzcxeDl3WllGUkFBQUpMRkNRQUFlTnBqWUdRdy8vK0txWmdwaFVHRmdZRlJVSXhOU2MxYzBFeE5YWStSWFkyZERRaGhRdmFNWnNaRzRtTGlZa3hGak95eTdJeE1raFphNFNwR0xrcXkxaXhnQVJaZmllREU2Q0JCQVcvRzFuK2RmR0ppZkl4RjRvSHFVc0tNakdMYzRwcFIvM3JCWWhXWjV2ejYycHc4WmtEcmdIYS9CTnFkRExHYmpaK1JUVmxKWFEwSUJkWE1qTVRZQmRuRXhPVVlqY1hNellBUUxNUlVoTENGQmFzem1Pei9kUUp0TU5EbTRqSExaQ3pqRnhYbC85Y3ZIcVF1S2N3b0RuSUZZeEZRaUlFQkFBaE5LRU40Mm1OZ1pHQmdBT0p2MDNaZWp1ZTMrY3JBek1JQUFvOEY1dDFIMFA5Zk1zc3dwUUM1SEF4TUlGRUFadW9NR0FCNDJtTmdaR0JnbHZxakNTUmxHTXdaekptS0dZQWlLSUFKQURzOEFra0FBQU1jQUFBQ3FnQTNBRGNBQUFBQUFBQUFQZ0I4ZU5wallHUmdZR0JtVUdVQTBReFFFZ2tBQUFSVkFDd0FlTnBOanJGcXd6QVFoajlUeDFBbmtLa2RPaFJOR1lXTjh3Q0ZESm15Wml3a2tRZ09XQTZTWS9CUzhnQjk2RjRVRFQzQjhlbS83NFNBa2g4eUhwV3hqUDFST1lYY25qeGp6bHZpUW81S1hQTEJpaGV5L0ZXU1Q3NFM1eXo0VGp6am5VdmlRdko3NHBJMXY1dSt1OTRHNjlXdU45YTdVeGVtdXRwYkg5cmVxVnBYejJCcm5mV0h3UnAxbkpRWjJ6Q2VPOVhvU2pkczZPbTRjbVBBNHVWbk8wbE1aTWRKWm9HSm1vcDl6QUt0ekoxNE5WclMvOFpXREJldFEzek5pSFdVbVJJYVpTOUlQNHV2YU9LdXB2a0RDVkV4RXdCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT2dBQW9BQUFBQUJBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MGpHTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ0ZaMng1WmdBQUFXUUFBQURrQUFBQTVPdWJnaTlvWldGa0FBQUNTQUFBQUMwQUFBQTJLQXFCWkdob1pXRUFBQUo0QUFBQUh3QUFBQ1FGU0FJWWFHMTBlQUFBQXBnQUFBQUtBQUFBQ2dWYkFIQnNiMk5oQUFBQ3BBQUFBQWdBQUFBSUFDd0FjbTFoZUhBQUFBS3NBQUFBRndBQUFDQUFCUUFyYm1GdFpRQUFBc1FBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEa0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd4TS93SDhwa2gwa2hxL2dPRkFjdm1ETWdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhHLy84RFNjUC8vLzlmQVBNWkFGRllCbzRBQVFCd0FBQUI1QUtwQUJrQUFBRVJCaFk3QVJVdkFROEJOVE15TmljUkRnRW5OUlkyTnpZV0FWY0RJRWtuWjFCd1JpZEpJQU1zVkJRaGRETVZDd0tML2NrYUZTVURBUUlDSlJVYUFnb1VDUUVrQWhZdUFRb0FBQUVBUVFBQUFnVUNxQUFwQUFBbEJ5RTNOajhCUGdJbUp5WUdCeDRCQnc0Qkl3WW1KejRCTng0QkZ3NEJEd0VHQnpjMk56NEJOd0lGSC81YkFRSUg5eHRDQTA5TkpsWVpKeFlCQVNJVENpb0NBWE5oWlljREFsVTdWU3BPOGlVTENnNEN1cm9jQmdiMEcyYUVZQUlCS3pVQ0pROGNHd0VWSmtsckF3RnBYa2RxTEVVaVJRRUJCQXBBRXdCNDJtTmdaR0JnQU9MbUd4VTc0L2x0dmpJd3N6Q0F3R09CZWZlUmFhYkxUQ3VCRkFjREU0Z0hBRHp0Q3A4QUFBQjQybU5nWkdCZ1p2alB3TURBZEpuQmtjR0ppWlVCS0lJQ21BQS9Nd0ptQUFMVEFBQUNSd0J3QUVFQUFBQUFBQUFBTEFCeWVOcGpZR1JnWUdCbTBHSUEwUXhRRWdrQUFBVFNBREVBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktIN2k0T1RpNU9yek5taUFkbWtwYWl5N2lUL2MyQkcvZzhOMXp6ZzJROFNKaG1JUjUwR0ZTZWZQSVkzNVlSSjZJdjRxYzhjdWFFVWs2RTJmRkxuTEtsUC9JWTVhVWtTZmlQeUpuL1BIZU4vWHQzbG12am8yeDNsMXF2ejFaMzFhTlV4dWREK3ZCT3V2UG5UV3FmQ3JUVjIxL3JWV2hjMTJ3cDZIbXhwME9pMGR4Rk1jRWRsd2s4Mnc1aGIybGtzeEpaNE1tLzZZSFNWMW9uTU12UmhvbFQxRkRMemV0NkZXNmlpTGNhWW9QV0t3dVN3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5vQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDA0V050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNVWjJ4NVpnQUFBV1FBQUFDb0FBQUFxTC9zRGVWb1pXRmtBQUFDREFBQUFDOEFBQUEyS0JtQmwyaG9aV0VBQUFJOEFBQUFIUUFBQUNRR0J3SWlhRzEwZUFBQUFsd0FBQUFJQUFBQUNBVjJBQ1JzYjJOaEFBQUNaQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUpzQUFBQUZnQUFBQ0FBQlFBMGJtRnRaUUFBQW9RQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRFdBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTJzMDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCa1p2Z1A1RE5EcEpIVS9BY0tBd0RvOXcwdGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpTy8vOUR5UDhId0h3R0FGS1hCcDBBQUFBQUFnQWsvLzhDNFFMZEFDOEFNZ0FBTndFMk56SVdGeE1VRmpNMkZnWXZBUWNuSmljME5oY1dOamN2QVNFSEJoUVdGellYRGdFdkFRY21KelEyTXo0Qk56TUR0d0ZsQmhRTkJnRStGaTBWQVF3RmRJQUlCUUVOQ3hNMEF3a0gvdjlPRFJ3VERRTUJEUVZuV0F3QkRBa2lQcG5ySVhZQ1ZoQUJDUS85Z0JZUEF4MEhBUU1EQVFJSUR3Y0JBUXdYWmtXRUZDUVFBUUlQRGdZQkF3TUJDZzhHQVNQSUFWSUFBQUI0Mm1OZ1pHQmdBT0tHNTdObngvUGJmR1ZnWm1FQWdjY0M4KzRqNlAvL21SNHkzUVZ5T1JpWVFLSUFZZE1NOEFCNDJtTmdaR0JnWnZqUEFDSVpWQmprbVI0eUFFVlFBQk1BTll3Q01BQUFBQUoyQUFBREFBQWtBQUFBQUFCVUFBQjQybU5nWkdCZ1lHSXdCbUlRWUdSQUF3QUZyd0E2QUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTQuMjMwNTcxLC0yMy4xMzMwODQpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTcuNTQxNjYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE0LjIzMDU3MSwtMjMuMTMzMDg0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xNC4yMzA1NzEnIHk9Jy0yMy4xMzMwODQnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYuNzU4NTcyJyB5PSctMjEuNjM4NzAzJz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0uMDc1MzM2JyB5PSctMjMuMTMzMDg0Jz7iiKk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nOC43ODAzMTInIHk9Jy0yMy4xMzMwODQnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMTYuMjUyMzExJyB5PSctMjEuNjM4NzAzJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01Ljk5MzA3LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTQuMjMwNTcxLC0yMy4xMzMwODQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTE0LjIzMDU3MScgeT0nLTIzLjEzMzA4NCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNi43NTg1NzInIHk9Jy0yMS42Mzg3MDMnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtMTAuMTA5N1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwwLjAsLTEwLjM1OTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTkuOTk2LC0zMC4wMzYwNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE0LjIzMDU3MSwtMjMuMTMzMDg0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xNC4yMzA1NzEnIHk9Jy0yMy4xMzMwODQnPmk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTExLjQxMTg0NCcgeT0nLTIyLjEzNjgyJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUwLjkxMjQzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNC4yMzA1NzEsLTIzLjEzMzA4NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTQuMjMwNTcxJyB5PSctMjMuMTMzMDg0Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Ljc1ODU3MicgeT0nLTIxLjYzODcwMyc+MjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzOS4zNjM4NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE0LjIzMDU3MSwtMjMuMTMzMDg0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xNC4yMzA1NzEnIHk9Jy0yMy4xMzMwODQnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYuNzU4NTcyJyB5PSctMjEuNjM4NzAzJz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0uMDc1MzM2JyB5PSctMjMuMTMzMDg0Jz7iiKo8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nOC43ODAzMTInIHk9Jy0yMy4xMzMwODQnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMTYuMjUyMzExJyB5PSctMjEuNjM4NzAzJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00yNC4yOTcyIDBINDUuODU2ODknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMjQuNTQ3MiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjEwNjg5LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzAuODYwOTgsMy44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE0LjIzMDU3MSwtMjMuMTMzMDg0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xNC4yMzA1NzEnIHk9Jy0yMy4xMzMwODQnPmk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTExLjQxMTg0NCcgeT0nLTIyLjEzNjgyJz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTEwLjEwOTdWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwtMTAuMzU5NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTMwLjAzNjA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTQuMjMwNTcxLC0yMy4xMzMwODQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTE0LjIzMDU3MScgeT0nLTIzLjEzMzA4NCc+dTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctOS41MjAxNzYnIHk9Jy0yMi4xMzY4Mic+MjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTIuNzQ4NjEtNTYuOTA1NUgzNC4zMDgzJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDEyLjk5ODYxLC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzNC41NTgzLC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxOC4zNjMsLTYyLjczMTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNC4yMzA1NzEsLTIzLjEzMzA4NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTQuMjMwNTcxJyB5PSctMjMuMTMzMDg0Jz51PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy05LjUyMDE3NicgeT0nLTIyLjEzNjgyJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00My45ODgzLDM3LjczODMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNC4yMzA1NzEsLTIzLjEzMzA4NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTQuMjMwNTcxJyB5PSctMjMuMTMzMDg0Jz5BPC90ZXh0Pgo8cmVjdCB4PSctMTQuMjMwNTcxJyB5PSctMjEuOTM3NjMxJyBoZWlnaHQ9Jy4zOTg0ODQnIHdpZHRoPSc3LjQ3MTk5NScvPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDEuMzQ0MTUgMzEuODI4NjlDLTQ2LjY3MDAzLTEuNDIzOTgtMzYuNjgzMjctMjcuNTc5MDQtMTAuOTM2NjMtNDguNTAyNDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43NzYwMywtMC42MzA2NSwwLjYzMDY1LDAuNzc2MDMsLTEwLjc0MjYzLC00OC42NjAxNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTU0Ljk3MjE4LC0yMS42MDcxNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE0LjIzMDU3MSwtMjMuMTMzMDg0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xNC4yMzA1NzEnIHk9Jy0yMy4xMzMwODQnPu6BoDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTAuODk1ODE3JyB5PSctMjYuMTM5NjAyJz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTguMjAxMDQyJyB5PSctMjMuMTMzMDg0Jz7OvTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNC4yMDY3MycgeT0nLTIyLjEzNjgyJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzMuMCwyLjAnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNLTMxLjkzMjc1IDMxLjkzNDA0TC04LjU5Mjk0IDguNTk2NTcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNCwtMC43MDcwNiwwLjcwNzA2LDAuNzA3MTQsLTguNDE2MTUsOC40MTk4MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNLTI1LjEzOTkxIDE1LjMzODU1SC0xNS4wMzIyNFYyNC4zNTI0NEgtMjUuMTM5OTFaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjIuMTM5OTEsMTguMzM4NTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNC4yMzA1NzEsLTIzLjEzMzA4NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTQuMjMwNTcxJyB5PSctMjMuMTMzMDg0Jz56PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTMxLjkzMjc1IDQxLjMzMDQ3QzIuNDYzNTggNDYuMjU3IDI5LjEyMDc0IDM1LjU2NzgzIDUwLjI3NjY0IDguNjM2MjInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC42MTc3LC0wLjc4NjM2LDAuNzg2MzYsMC42MTc3LDUwLjQzMTA2LDguNDM5NjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE3LjQzOTU4LDQwLjY5MjgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNC4yMzA1NzEsLTIzLjEzMzA4NClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTQuMjMwNTcxJyB5PSctMjMuMTMzMDg0Jz5rPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy05LjgyNjkxNycgeT0nLTI2LjEzOTYwMic+7oCw7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00LjkzNTUnIHk9Jy0yMy4xMzMwODQnPs69PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0uOTQxMTg4JyB5PSctMjIuMTM2ODInPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw = {A_{1} \cap  A_{2}},
        nw/style = {pullback},
        ne = {A_{2}},
        sw = {A_{1}},
        se = {A_{1} \cup  A_{2}},
        north = {i_{2}},
        north/style = {>->},
        west = {i_{1}},
        west/style = {>->},
        south = {u_{1}},
        south/style = {>->},
        east = {u_{2}},
        east/style = {>->},
      }
      \node  [above left = of nw] (a) {$\underline {A}$};
      \draw  [->,morphism,bend right] (a) to node[swap] {$\ell '\nu _{1}$} (sw);
      \draw  [->,morphism,exists] (a) to node[desc] {$z$} (nw);
      \draw  [->,morphism,bend left] (a) to node {$k''\nu _{2}$} (ne);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>This yields</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       may &= maa^{*}(\ell )\nu _{1}\\           &= m\ell \ell '\nu _{1}\\           &= m\ell  i_{1}z\\           &= fi_{1}z && \text {since $fi_{i} = gi_{2}$}\\           &= gi_{2}z\\           &= mki_{2}z\\           &= mkk''\nu _{2}\\           &= mbb^{*}(k)\nu _{2}\\           &= mby     \end {align*}   ]]></fr:tex>
  <fr:p>We may now conclude that <fr:tex
display="inline"><![CDATA[n]]></fr:tex> is an isomorphism.
    Then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> can be factored as <fr:tex
display="inline"><![CDATA[mn^{-1} u_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> can be factored as <fr:tex
display="inline"><![CDATA[mn^{-1} u_{2}]]></fr:tex>.
    It remains to show uniqueness.</fr:p>
  <fr:p>Let any two factors <fr:tex
display="inline"><![CDATA[A_{1} \cup  A_{2} \rightrightarrows  B]]></fr:tex> be given.
    Consider the equalizer <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex> of these two factors.
    By definition, both <fr:tex
display="inline"><![CDATA[u_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[u_{2}]]></fr:tex> equalize these two factors, but this means that both <fr:tex
display="inline"><![CDATA[u_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[u_{2}]]></fr:tex> are contained in the subobject <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>.
    Thus, <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex> is an isomorphism, so the two factors are equal.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1349</fr:anchor><fr:addr
type="user">ct-000R</fr:addr><fr:route>ct-000R.xml</fr:route><fr:title
text="Frobenius reciprocity">Frobenius reciprocity</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be a morphism in a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>. Then for any two subobjects <fr:tex
display="inline"><![CDATA[A' \rightarrowtail  A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[B' \rightarrowtail  B]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[\exists _{f}(A' \cap  f^{*}(B')) \cong  \exists _{f}(A') \cap  B']]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\exists _{f}]]></fr:tex> is the left adjoint of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> constructed in <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>629</fr:anchor><fr:addr
type="machine">#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By the construction of <fr:tex
display="inline"><![CDATA[\exists _{f}]]></fr:tex>, this is equivalent to showing the following isomorphism.
    <fr:tex
display="block"><![CDATA[       \mathsf {Img}(f \circ  (A' \cap  f^{*}(B'))) \cong  \mathsf {Img}(f \circ  A') \cap  B'     ]]></fr:tex></fr:p>

  <fr:p>Form the following diagram, where the front, left, and right faces are pullbacks.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="362c7fd0304540d388463e26df581e23"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMyMy44MTk1MzdwdCcgaGVpZ2h0PScyNDIuODk0ODU0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMjE1Ljg3OTY5MSAxNjEuOTI5OTAzJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzODtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUVlBQW9BQUFBQUJNd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFc5MG5HTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWV3RWdaMng1WmdBQUFXd0FBQUZNQUFBQmpQTndKSk5vWldGa0FBQUN1QUFBQUM4QUFBQTJLRVNBdVdob1pXRUFBQUxvQUFBQUhnQUFBQ1FHTndKMWFHMTBlQUFBQXdnQUFBQVFBQUFBRUFqOUFOWnNiMk5oQUFBREdBQUFBQW9BQUFBS0FOUUFpRzFoZUhBQUFBTWtBQUFBR0FBQUFDQUFDQUJOYm1GdFpRQUFBendBQUFET0FBQUJPQWQxS3Ixd2IzTjBBQUFFREFBQUFBd0FBQUFnQUFNQUFIamFZMkJtc21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcDZNdVF5Yy84SDhwbTVHZEhVL0FjS0F3REQ3d3o3ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVE4R2RJWmN2Ly9SN0QrNy9nLysvODBzRm93QUFEc2h3dVZBSGphVlZETFRzSlFFSjJaVzFvZ1dBU2xGZHRVYVdNTGlCQjV0TUJWRWhjU0l5cHE0a0lrU0dUamp4ZytEUk1TRXFJZjR0YUY0TVdObWtsT3ptTm1jUVlRUmdBd3BRa3dnSTJFazVnKzArU3JJVFFJeDFxV0tJN3ZVQUlPSFFEVVBVZFdkQzJsb2lKN3NtSmhVUEYxVFl5S3R1dTVmbEJFencvY1dnc0RYMjhoMDFhTzQ2NDJkWEVwNnhhV1JlNkpJUmFyY2xPU1RIeTYyRytFR0JYaWo4WlIzcTFLTko2TkdSbzVKWUZTMnFIaFpiRngvTEMwT1dFdDd3ajBlNlBtbXNwbzhESWdxUkJmTCtLOExTRUw1dzVQaDBTN3RPTW1pQ0poemJyaTNTN2Y1TnNSejJvYUIzV1JNbHVMTGo2d3lDdlZIM2hscHFsa3N0bE1WZzJSTENvRHdwMG9Ic00zMkJOQy9NTXZvZXVwcUtmKzBVcktGMTFFeGNCQ0ZyMW5xcFE4NDJYOEpiZnQzbmxUVHQ2YzlEbVdGblBNcHUyUXpWaS85dm1YempyWHhPcGJoazlzQ04vcnJEM3JlTnBqWUdSZ1lBQmlZODlma2ZIOE5sOFptRmtZUU9DeHdMekhDUHEvUGpNUDAzRWdsNE9CQ1NRS0FDWklDbkFBZU5wallHUmdZT2IrendBazR4bmtHQVNaZVJpQUlpaUFCUUF1dndHMEFBQUNVQUFBQVM0QVl3SWdBQjREWHdCVkFBQUFBQUFPQUlnQXhnQUFlTnBqWUdSZ1lHQmg4R0ZnWmdBQlJnWTBBQUFJYlFCV2VOcE5qRDF2d2pBUWhwK29DVkxEd0lJNk1MUWVPbHRCWVdCaVlXQmlaV0lCN0tJTWNaQWRJaUZWSGZuZFBZd0h6dExwZVQvT1FNa2ZHWS9KbU1UOW1KeEMxSk1MeGt3VGowUjlKUzZaOGMwYldmNHV6aWVyeExrays4UUZIL3drSG9uL203aGt3WDNkdFpkcmI3M2Fkc1o2ZDJwRFdPNnNEMDNuMUZ4WFVXK3NzLzdRVzZPT04yV0dKZ3puVnRXNjBqVnJPbG91WE9teGVCUmJjVXhreDBteUlHL0pManFCUmxJbnJUbWE2aVhmU081aTV4Qi9NdEk1Y3BOdEdPUXF5RDVMVzFISFMwMzlEK3B0TURzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBzQUFvQUFBQUFCSVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRTBBQUFCZ3ltRmh6R050WVhBQUFBRkVBQUFBTkFBQUFFUWwrd0t4WjJ4NVpnQUFBWGdBQUFFVEFBQUJSTDU0NDJkb1pXRmtBQUFDakFBQUFDMEFBQUEyS01pQS8yaG9aV0VBQUFLOEFBQUFIZ0FBQUNRRld2L2xhRzEwZUFBQUF0d0FBQUFRQUFBQUVBbVFBTnRzYjJOaEFBQUM3QUFBQUFvQUFBQUtBUFlBZ20xaGVIQUFBQUw0QUFBQUdBQUFBQ0FBQndBM2JtRnRaUUFBQXhBQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBRDRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVNtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBZzRJRGpKMVNYSmJPd0tZay9zQ0FXZkdQRVFNRHN5THpPYUF3STBMMS8vOE1EQUFQeXc5TkFBQUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUUF1V1V4RldmUFRENC94L0J1dnZxbG96OFpiQmFNQUFBRzdnTXpIamFOWTZ4U3NOUUZJYlBmOUxjcEdtOFNUQnBJdWd0V3RyZzBtSnRtMEZwY0pMcUlHNkNwaEg2QnE3cTdLQ2JpT0RzV3pqNUd1TG1Td2hDOVJKMStUam4rK0huSjlBcHRmR0ZkeG9SZFdLRlNGaWlqeFlrTnJwcDVuRTNIWTV6cEQyTXh0bWdoVDVQc0szZ0llZG1IQW9MaDArMlpDWEVnMnNpQ2lNRWQyNWRzZlR1SysrNHQ2YkRpSnpZWWY4ditkNHpHcDR5VUp0ZkRBSXBnK2ZDaHFHa0svTGZvRjdzSENlQnhLcjMrSjhRTVIxUmh5MjlzMEV4a1o1bjlaQk9rQ2tZbXZyV1JvRXR2cG9WMTF6eGJWb3l6dzRxZ3M2MHZTd3JMajY1bk82ZmMwVmRSbHVVWXNpN0pQVmpDRjJXTFZmVmNST2JyNWF2Mkx5cEpXdEpHNHlQeFVsb0xEaytYdVE2b0ZacytnSHdZUzljQUhqYVkyQmtZR0FBNHZVZHkwemorVzIrTWpDek1JREFZNEY1ajVGcDVvbE1Oa0NLZzRFSnhBTUFJVDRKZndBQUFIamFZMkJrWUdCVy9HTUVKQ2N5R0RMSU1yRXpBRVZRQUFzQVBka0NSQUFBQTVFQUFBSlhBRnNDVndCUEFWRUFNUUFBQUFBQVZBQ0NBS0lBQUhqYVkyQmtZR0JnWVRCallHSUFBVVlHTkFBQUJqQUFQM2phVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9GUmlZMkZnWW1YcUF0aWdESEdRSFNKRnFqcnl1M3U0SG5yRDZYay83b0NTSHpLZWsvRWE5M055Q2xGL1hQRENXK0twcUVYaWtnK1dUTWp5bVRoek5vbHpTYjRTRjd4elNUd1YvenR4eVNlUGJkZmU3cjMxYXQ4WjY5MjVEZVA2WUgxb09xZFd1b3A2WjUzMXg5NGFkUnFWR1pvd1hGdFY2MHJYYk9sb3VYR254K0pSN01VeGtSMW55UUlqYXc3UkNUU1NPbW10MEZULzhwM2tMbmFPOFpPUnpra1NKVFRJVlpCOWxiYWlqcGVhK2hmemVUQlBBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRQUFBb0FBQUFBQklnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUUwQUFBQmd5bU5pZDJOdFlYQUFBQUZFQUFBQU5BQUFBRVFsK3dLeFoyeDVaZ0FBQVhnQUFBRW1BQUFCU0JrODJ5cG9aV0ZrQUFBQ29BQUFBQzBBQUFBMktZeUEvMmhvWldFQUFBTFFBQUFBSHdBQUFDUUYvUURiYUcxMGVBQUFBdkFBQUFBUUFBQUFFQXY4QVcxc2IyTmhBQUFEQUFBQUFBb0FBQUFLQVBnQWdtMWhlSEFBQUFNTUFBQUFHQUFBQUNBQUJ3QTJibUZ0WlFBQUF5UUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUQ5QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0rczg0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFBQkJnVUhHRHVsdUN5ZGdVMUovSUVCczlZZlN3WUdaaTNtNDBCaFJvVHEvLzhaR0FCSjlBLzZBQUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FBdVdVeEZXZlBURDQveC9CdXZ2cWxvejhaYkJhTUFBQUc3Z016SGphTFkvUFNnSlJGTWJQZDY3Y2l6a3pPYzUxL2xDTk50TE1ybERNZ1FoN0JxRm9FMGtFQTRvdWN1dW1kV21QWU5DdVorZzFXclR3T1lJMjB1M1A1anZuZkI5OC9BNkJucWpGdDFoVGx3aDVyK05ydVEwLzhBTUg2UkVha09vUTNUTW9tU1dwbVdtV1puMTBHc2pTNDI0djl3T0ZoMmNyMHE1OHZiendHRG9xdjlpU0U5ZVQxdU9CdE91aDhUV2pIdG9yUzNwdXdoWHNETXM2Y2JpL3Q2L0Ntb2E4S1U1aWdWclFMczdyMEVuMVB5Z1BpL2FXWFFNM3JvbVk3a254REY5VW9jQ1FPakJjaGlTUElZeWEzVGd4ZUNhV28vRkNpTVY0dFB3Y1RKZ25nOEdVZVFvYUxZWEpmblh6OFdQL2hSTlRSa1BLTU9kVHFwcER5SmI1TWZkTWE4Y1BwTUxkdTdSOFQ1UldJb3FqRkNoaHZibHlsYktyZUhPYWFPNWFGbjBEeXhvME13QUFlTnBqWUdSZ1lBRGlUekdiak9QNWJiNHlNTE13Z01CamdYbVBrV21XVUNZYklNWEJ3QVRpQVFBa1NBbGxBQUFBZU5wallHUmdZTmI2WThuQXdCTEtFTS9nd1ZURUFCUkJBU3dBU1pNQzNRQUVWUUFBQXZJQWpnTHlBSUFCd3dCZkFBQUFBQUJVQUlJQXBBQUFlTnBqWUdSZ1lHQmhNR1ZnWWdBQlJnWTBBQUFHRndBK2VOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUM0QUFBQTJLQXVBeEdob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0aE5jaXcvSDg5dDhaV0JtWVFDQnh3THpIaVBvLzR4TWw1bEJYQTRHSmhBRkFEZXZDcXNBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5nQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTno3R050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDZ0FBQUFyS0FDSGFSb1pXRmtBQUFDQkFBQUFDNEFBQUEySjdpQXcyaG9aV0VBQUFJMEFBQUFId0FBQUNRRWp3RzhhRzEwZUFBQUFsUUFBQUFLQUFBQUNnUkdBR1JzYjJOaEFBQUNZQUFBQUFnQUFBQUlBQ3dBVm0xaGVIQUFBQUpvQUFBQUZ3QUFBQ0FBQlFBWmJtRnRaUUFBQW9BQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRFVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXZNYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWU5Ca1p2Z1A1RE5EcEpIVS9BY0tBd0R2a1EwZWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaRWo1ejhBWXdzekFJTTdBd0NxaXBLYXV4Mml1Wm1adXgyakV6OGpIS000bUpNOG94aGdzbG15b0tjUElLS05tbUNiR3lCUG53Y2prRXMvUC9JMHJLVDVpbGEzVHd0RGtWQjZCeEQvdGxmLytwUWl5TUFBQkk0TWwwRnhOaUxtTVltenNmSXhLcGtCVDFVM1U5Qm5Wek0yTXhNVGxHQmsxd0NhSzhzWjZNUVg3Q0RFek1vcUM3V0dBbXBqMHQzWGhCMThoRmlhd1BRQVZKQ0ZNZU5wallHUmdZQURpenh0RWo4ZnoyM3hsWUdaaEFJSEhBdk1lSStqL0RFd056Q0F1QndNVGlBSUFRSlVLbmdBQWVOcGpZR1JnWUdiNHo4REF3TlRBWU1sZ3lSakNBQlJCQVV3QU8yd0NVQUFDZ0FBQUFZMEFaQUE1QUFBQUFBQUFBQ3dBVm5qYVkyQmtZR0JnWnBCZ0FORU1VQklKQUFBREVBQWZBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV29BQW9BQUFBQUJwQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaGR4NHBHTnRZWEFBQUFFOEFBQUFOUUFBQUVRQWV3UitaMng1WmdBQUFYUUFBQUxPQUFBRFRQUHNWVEpvWldGa0FBQUVSQUFBQUM4QUFBQTJLSkdBekdob1pXRUFBQVIwQUFBQUhnQUFBQ1FHakFKS2FHMTBlQUFBQkpRQUFBQVVBQUFBRkE2bUFQOXNiMk5oQUFBRXFBQUFBQXdBQUFBTUFYWUNYbTFoZUhBQUFBUzBBQUFBR0FBQUFDQUFDUUJZYm1GdFpRQUFCTXdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGbkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtZXNjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdJTkdCaVNRVWx5V0RwUjBaTDdJelBBZnlHZG1ZQVFKTXlKVS9BY0tBd0FsdHc1ekFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUlMa25CalNtQy8rL3c5a09VSlkvdy84bi92SEdLd1dEQUQ2Tnd2MkFBQUFlTnBGa3MxckUwRVl4dWQ5WnpPVGJPTE81bXUyU2R0dE41dnMrcEVtbXFRYlRkTzBUYXYydzM1WmFhMUtnNktDSWlxSUlLaUk0RUV2ZXZIZ3dZc0hRYng1OTZiL2dIcFMvRGU4YWVOc1FaeUJZZDczWWVENVBmTVNKSzErbjA3aUQxSW5BU0ZOQ0pvMWFhVXpzbDZUMlF5dkFxL0FlQWVzRGpSOVJ3REwybEMzcEdXQVVwamZnYm9TSFBvTjd1azVJNHJuNUtHRW1XbE5QdEVabUxGeUhuSzdQMC9yRE4xb25BR0l5TFd6Q1FvaVdwNTRBL3p3Zlp5WGtFaitlWlkydEhnV0tHaWcweVFIU0ViZlAwckZZNWs0MHBpcU5RMU13ZW5CajdCS0NDV0wvZDkwR3o4U2g0eVJZOHB4dWhsNFZYQ1pGMWlPRGNvWlZ5ZFRWcmtUOW1TUURqMEdudTk2ak5OL2Q4cmtwNmNheE15Y01RSXBBKzVldmdYMGNlLzBCY0RsMU1hRDNUdERtTngzYlBqZHUyc1BBY2VYWDQrWWtkdHZlNDhwZE9hL0wwRmlEVWNsWjBDMUFnZmNhTTlkVGVuclI1ZG1qQTdWWEVXUWdqbDZvK3VjMU1DUWZ6N2dqZFhxSXU1KzVaUVFJRXY5S2w3SEwyUmFGVFMwcVJ3WHZEQkthVW5HNVFoMFlJcnU4WVJtVmI4VzV1MTZ2aGMwRmFtQkF1cUJaRDY4YVptYW1ZL05ITm5mQWlobVBSWHRpQkNpNk5EaGlqaGxZMXFzaTZ3aHUrNkJOb0FybFc3YVFxUlN0aDdOOTBJWlh1NStYa3hPTnpLejFIUHRVU3d5UHg1RDBKYXlyMzV0VVlXMnRUM29lNlhpZndseTN0aHpyUkFGb2hhU3cvMWYrRUt4TEpCTlJXUEpEUGNaMzl1ZUgwelJZTHpoK1Fvdm5KYUttaXlGby80bUl5akxNbW5WOWhxS0tJUnZLbmhMY2hWQUVQNlBlcVNDa0xoWnNQYlZCMXNEZzhjMzJ6MEVQUzA0aXJSZGlFZTRya1pLaW9Sdmw2ZEFFOXlLNEdqZ1RqcER4VVNuSFcxRjhGTDNoTTBqRW9EdERGQVlMTldXVVR1U2I4QnRqZ05hOU1yRmtyMm1RV1BlZFZjbmhtTkdkZ2hndXBLSkE2STVPeVJIQVJwbFBUbVQyOG1uOCtQWW1hamRiWmdsdG45bDRTYlYyZ21qMjQ3Tmw4NmNyNjBnM1duUE9HWmV4ZkVYVDcxNUVRQUFlTnBqWUdSZ1lBQmk3K01WbmZIOE5sOFptRmtZUU9DeHdMekhDUHEvUG5NazB5MGdsNE9CQ1NRS0FEY3dDeFFBZU5wallHUmdZR2I0endBa1N4Z00vbDlnam1RQWlxQUFWZ0JjWWdQY0FBQUN4Z0FBQTNBQU9nTjBBRW9DT2dCTEFzSUFNQUFBQUFBQVdBQzRBUjRCcG5qYVkyQmtZR0JnWlFobllHWUFBVVlHTkFBQUNac0FZbmphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9DQ3hkV0ZnWW1YcUF0aEZHV3dqSjBSQ3FqcjJkL2RoUFBRTlYrZCsyRURORHdYM0s1Z2x2VjlKSmU3QkZWUG1tU2ZpM2pMWExIam5pYUo4bHVTVmo4eWxOSitaSzE3NHlqeVIvRHR6ellyZlRYQ1g2MkNqMmdWam96ODUxNjMzTnZaZDhHcXBtK1MzMXR0NEdLeFJ4NXN5WTllUFo2ZGEzZWlXRFFISGhTc0Rsb2hpSjRsSjdEbEo1K2hZczA5Skx4d2tWeXpSTlAvNnJmUStiUTdwSnlPYkl6ZFJ3eWlMWHZRc1cwV2JYbXJhUDh1aEwvY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSSUFBb0FBQUFBQk9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVngxc21OdFlYQUFBQUU0QUFBQU1RQUFBRHdBblFCNVoyeDVaZ0FBQVd3QUFBR0NBQUFCc01Fd20veG9aV0ZrQUFBQzhBQUFBQzhBQUFBMktQK0F6MmhvWldFQUFBTWdBQUFBSUFBQUFDUUhNd01nYUcxMGVBQUFBMEFBQUFBTUFBQUFEQW8xQU9Sc2IyTmhBQUFEVEFBQUFBZ0FBQUFJQUdZQTJHMWhlSEFBQUFOVUFBQUFHQUFBQUNBQUJnQktibUZ0WlFBQUEyd0FBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUVQQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1UbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvNk1xUXhNL3dIOHBraDBraHEvZ09GQWM4Q0RQOEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPaktrL2Y4UDVJUHAvd2YrendHckFnSUFsRDBKRUFBQUFIamFIWkROVHR0QUZJWG4zREV6VGp6K21kaXhRNEMwc1pGVEVDUkFnaTBRU2dDaGlCWWh0Y3V5Nkw1SWJGcXBtNzRCTENyMUNYZ0lKUFpJQ0lrdGEzWkk4QklrMk55enVUOW5jYjdMaVAyY1R2a2RQYkl0dHNNWS9CYjZXUmlGc2djWGFXZUlLTXp5SHRwU3VDUmtDM2tVUmc3S1k1eDIwaXdmSXNjUUc2SGtiWHI1ZzhhYTVRUE4zZjNQQnpYQVYrYTJZZXZKdlcvd0l5VkFxV2xKUUl2Zmc2NWhFYVN6dnQvQ2YrbkY2dVFKQ2QyOG5tc2JRczBSQnppOGVnV1FlbndDTXM0Q3ExS3JncmdxbGdhNHJOSXNJZW5TMkZMcTErU0tGUVgyZDdwS3QvVEFEb3VCdXhEU2dSUWxSVCtNQWlIREQwWFdQQnNoeXhPUmJnNnlxRi8yN3lxeGtuZWt0SWU0d0MzL0VFZ2g4YnhsVjNTenRyY2FIM01zMVpkNVVIY2RmMkZ4UnRmbXRmWGQ5Z1AzaHlPTWhta24zejU5S1N6aE1vZHFlYTdmaktxcWNXWUhKamR3TWJrZXhqdEx6VDRoN3NZeDcraDJWWUlvcTQ5T0wwKzNJZXlnZ3EvdGp3TlA5d3dzcnBRVzBYRk1Rc01iL1lPWXRUZ1lld056MWpsZkFBQjQybU5nWkdCZ0FPSmREOW0veC9QYmZHVmdabUVBZ2NjQzg1NGc2UCs2ek1lWjdnSzVIQXhNSUZFQVZJa01Dd0I0Mm1OZ1pHQmdadmpQd01EQW9zcVErZjg3ODNFR29BZ0tZQVlBWlQ4RVdnTlVBQUFFSlFCcEFyd0Fld0FBQUFBQVpnRFllTnBqWUdSZ1lHQm04R1JnWWdBQlJnWTBBQUFIOEFCUmVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnd05xRmdZbVZxUXRnRjJXd2pad1FDYW5xMk4vZGgvSFFOMXlkKzJFRE5UOFUzSzlnbHZSK0paVzRCMWRNbVdlZWlIdkxYTFBnblNlSzhsbVNWejR5bDlKOFpxNTQ0U3Z6UlBMdnpEVXJmamZCWGE2RGpXb1hqSTMrNUZ5MzN0dllkOEdycFc2UzMxcHY0Mkd3UmgxdnlveGRQNTZkYW5Xald6WUVIQmV1REZnaWlwMGtKckhuSkoyalk4MCtKYjF3a0Z5eFJOUDg2N2ZTKzdRNXBKK01iSTdjUkEyakxIclJzMndWYlhxcGFmOEF5QkV2N3dBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPTUFBb0FBQUFBQkJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxazZUKzJOdFlYQUFBQUZBQUFBQU13QUFBRHdpWVNJNloyeDVaZ0FBQVhRQUFBQzhBQUFBNUVQQlBLdG9aV0ZrQUFBQ01BQUFBQzhBQUFBMktGU0JkMmhvWldFQUFBSmdBQUFBSGdBQUFDUUZ4ZitBYUcxMGVBQUFBb0FBQUFBTUFBQUFEQWYrQUhCc2IyTmhBQUFDakFBQUFBZ0FBQUFJQURRQWNtMWhlSEFBQUFLVUFBQUFGd0FBQUNBQUJRQW1ibUZ0WlFBQUFxd0FBQURUQUFBQlBxODNkZUZ3YjNOMEFBQURnQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1Xc1U0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTVzU3M1SW1zOVFmVFFZR1ppbm02MEJoUm9UUy8vOFpHQUFGR0E1OEFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lOSUEwRzVCbVpHQlNZbGJTL1ArZmdRRkMzLzEzOXlaWUZSQUFBSTRPQ05rQWVOcGpZR1N3L1ArZmlaSHBCSU1zQXdPam9CaWJ1aUtibW9tWnVLSWdHbTBteHNUQXlDdnhyNEZYVEl5WHNmcmZaRjVSVVY3RzNIK3RZSDZEQkMvVG9yL05rcnlNak95eTdJeU1haWdVSDlCb0J2UC9yNWlLbVZJWVZDRDJLS21aQzVxcHFlc3hzcXV4c3dFaFRNaWUwY3pZU0Z4TVhJeXBDS3laU2RKQ0sxekZ5RVZKMXBvRkxNRGlLeEdjR0Iwa0tPRE4yUHF2azA5TWpJK3hTRHhRWFVxWWtWR01XMXd6Nmw4dldLd2kwNXhmWDV1VHg0d0JBSXpNSk5ONDJtTmdaR0JnQU9LZDgvYlp4L1BiZkdWZ1ptRUFnY2NDODU0ZzZQK3ZtR1dZVGdDNUhBeE1JRkVBU3AwTHd3QjQybU5nWkdCZ2x2cWpDU1JsR013WnpKbUtHWUFpS0lBWkFEczlBa29BQUFNY0FBQUNPQUE1QXFvQU53QUFBQUFBTkFCeWVOcGpZR1JnWUdCbVVHVUEwUXhRRWdrQUFBUlZBQ3dBZU5wTmpyRnF3ekFRaGo5VHgxQW5rS2tkT2hSTkdZV044d0NGREpteVppd2trUWdPV0E2U1kvQlM4Z0I5NkY0VURUM0I4ZW0vNzRTQWtoOHlIcFd4alAxUk9ZWGNuanhqemx2aVFvNUtYUExCaWhleS9GV1NUNzRTNXl6NFRqempuVXZpUXZKNzRwSTF2NXUrdTk0RzY5V3VOOWE3VXhlbXV0cGJIOXJlcVZwWHoyQnJuZldId1JwMW5KUVoyekNlTzlYb1NqZHM2T200Y21QQTR1Vm5PMGxNWk1kSlpvR0ptb3A5ekFLdHpKMTROVnJTLzhaV0RCZXRRM3pOaUhXVW1SSWFaUzlJUDR1dmFPS3VwdmtEQ1ZFeEV3QjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTOEFBb0FBQUFBQld3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwNTJOdFlYQUFBQUU0QUFBQU1nQUFBRHdBblFCN1oyeDVaZ0FBQVd3QUFBSHFBQUFDTExsR1dXaG9aV0ZrQUFBRFdBQUFBQzhBQUFBMktENkEwR2hvWldFQUFBT0lBQUFBSGdBQUFDUUdMUUhOYUcxMGVBQUFBNmdBQUFBUUFBQUFFQXB6QUlWc2IyTmhBQUFEdUFBQUFBb0FBQUFLQVdvQXNHMWhlSEFBQUFQRUFBQUFHQUFBQUNBQUNBQkNibUZ0WlFBQUE5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVzQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1tc000Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpFaGpadmdQNURORHBKSFUvQWNLQXdEaDVRMHplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPakdrL2Y4UDVEdUM2UDhIL3M4RnF3SUNBSlJmQ1JJQUFIamFOZEV4YjlOQUZBZncrOS9GNXlUWVBoUEhkcXZFU1J5bk5pb2lLWFd3MndvTWFtaEFyUklWS2xDSFNraEkwQTBoMUJiWU1uU0VDWUVFQ3dzYkg0QUJKaVkrQUNzRFl1UXpKT0ZjaVp2dS91OE52M2VQVU5LWnorbHYrb3YweUNvaEtaSjAxWEd0cWhNbkR1OUJqY0tvbjdoT2t2YmdxN3pxdUlsclFPWjVIR2RJWS9ZRmozaFY1OGljU3pZMDVXaFNWS0Nmcy9xc3BNN21ZNzF1NlF5NmNyaXZRU3Uxcy9kLy9STjYzMFJKVENlT1lKNEt4a0NMUWdVMDkvSFdhYlZqZ2dxRDUzRlpjQVEvY0pmSXc4akYrWlJ4K28wMHlESlprMUtySDBSYzJ2d0diQU5xQXk0WDRLclB6N3hXamt2Q0tBaTV5djdmbVd5SVA3MnVSWjRRMkQ5NHlDWjdPM3VndDh6UjhleE4zVEEyR2gvZlBUaWk2QTVPbTVieTVOWEJDYVVydDc4UEM0Q3hTOWZQVTFaWFFlOXNiQitLOG5oOVo5UElDdmtFc0xERm5nMDdOeW5FNHZRemV6NWUybVd6UHhWZUpnUWttWGZwRmZxVDNKQ1BIS0JLYkR1TU1zVHlveDB1NGFua1dVSHVqcThqZ3l0ekE0SHNDWk8wQzVXclhOQjhIUkZlWklZaVhPUHFjaXNCQWx2WW9HNWdlb1VvMUVZRHp4VERoZkxpdU9ZbkZHMWJPTUJDU3pRTHZsQ0ttbjJ2QmxQZ3crenJ3THAydWJsSk80SFhxbFQwc0NCWHg1Nk84Slo1SEM4dmJLL1FvSE5XV1ZMeVNsTVAxNDd6c1FuNUJ4a25WSUlBQUhqYVkyQmtZR0FBNGdhL0grTHgvRFpmR1poWkdFRGdzY0M4SndqNnZ4NHpHOU5kSUplRGdRa2tDZ0FxVkFxUEFIamFZMkJrWUdCbStNOEFKRGtZVlA0ZllHWmpBSXFnQUJZQVNVZ0RBQUFBQW5ZQUFBTUFBQ1FEQ0FBckFmVUFOZ0FBQUFBQVZBQ3dBUllBQUhqYVkyQmtZR0JnWVhCa1lHWUFBVVlHTkFBQUIxb0FTM2phVFk2eGFzTXdFSVkvVThkUXA5Q3BIVG9VVFJtRmpmc0FnUXlac21Zc0pKRUlEa2dLc21QSUV2b0FmZWhlRkEwOXdmSGRkNytFZ0pvYkJmY3FlRTM5WGlXVlRBK2VNZWN0Y3lWSFphNzVZTUVUUmZrczVwTmw1cElYdmpQUGVPZVV1UkwvazdubWk5OVZjT2ZMYUtQYUJHT2pQempYdDgzV3hxRVBYclc2ZVlpMTlUYnVSbXZVL3FyTTFBL1QwYWxPTjdwalJjQng1c0tJSmNyUE5tSk1ZczlCZG82ZWxvWnRjb05NUVRaS25CYjdQN0dXaEUrcFhYck5TR3JQVmJwaGtzd2cvU2hwUlpmdWFyby8zL1F3dXdBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY4IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTQuNjE5ODMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00MS42MzM1MzInIHk9Jy0yMC44MzUxOTgnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTM1LjY4MzU4NScgeT0nLTI0LjQ1MDU2Mic+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0zMS4xMDM1MzEnIHk9Jy0yMC44MzUxOTgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTI3LjIyOTE1NycgeT0nLTIwLjgzNTE5OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTkuMTcyNTQ5JyB5PSctMjQuNDUwNTYyJz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTE2LjM3NzQ3MycgeT0nLTIwLjgzNTE5OCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtMTAyLjA4NDY0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC0xMS4xMDk3M1YtOTAuODQxNicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDAuMCwtMTEuMzU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC05MS4wOTE2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjcuNDY2NDYsLTUxLjg3NTY2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzYuOTY2OTQ4JyB5PSctMjMuODQxNzE1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTMyLjgwMTk3OCcgeT0nLTIwLjgzNTE5OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMjkuNjg4NjM1JyB5PSctMjAuODM1MTk4Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy4zMjk0NzMnIHk9Jy0yMy44NDE3MTUnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y4JyB4PSctMjAuNjM0Njk5JyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDk0LjEzODQ2LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zMy41NzY5MjQnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NS41NDEyNCwtMTAyLjA4NDY0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTkuMTc1MzcgMEg4OS4wODI5MicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OS4zMzI5MiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU0LjM3OTE0LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005OS41ODQ2NC04LjYwOTczVi05MC44NDE2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsOTkuNTg0NjQsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsOTkuNTg0NjQsLTkxLjA5MTYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwMi44NDg1MywtNTAuNjI1NjYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0LTk5LjU4NDY0SDkwLjQ4NTcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTAuNzM1NywtOTkuNTg0NjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ3LjMwMzU3LC0xMDcuMjU3NTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU2LjkwNTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzEuNTc3MzgsNDAuMTc5MTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zNC4xNjE1MzMnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMjkuMTUyNTkxJyB5PSctMjAuODM1MTk4Jz7iiKk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTIwLjI5Njk0MycgeT0nLTIwLjgzNTE5OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTQuMzQ2OTk2JyB5PSctMjQuNDUwNTYyJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTkuNzY2OTQyJyB5PSctMjAuODM1MTk4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01Ljg5MjU2OCcgeT0nLTIwLjgzNTE5OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScyLjE2NDA0JyB5PSctMjQuNDUwNTYyJz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nNC45NTkxMTYnIHk9Jy0yMC44MzUxOTgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTMxLjA3NjkzLDQwLjE3OTEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+4oiDPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0zNi4wOTg3MTUnIHk9Jy0xOS4zNDA4MTcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTMwLjkzNDAwMScgeT0nLTIwLjgzNTE5OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMjcuMDU5NjI3JyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xOS41ODc2MjgnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMTYuNzkyNTUyJyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xMC43MDQzMTInIHk9Jy0yMC44MzUxOTgnPuKIqTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMS44NDg2NjQnIHk9Jy0yMC44MzUxOTgnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNi4yMDc5NDQnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS43NTI3MiwtNTkuNDA1NTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MS42MzM1MzIsLTIwLjgzNTE5OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDEuNjMzNTMyJyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zNC4xNjE1MzMnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNDIuMDc4NjMsLTU5LjQwNTUyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDEuNjMzNTMyLC0yMC44MzUxOTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQxLjYzMzUzMicgeT0nLTIwLjgzNTE5OCc+4oiDPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0zNi4wOTg3MTUnIHk9Jy0xOS4zNDA4MTcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTMwLjkzNDAwMScgeT0nLTIwLjgzNTE5OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMjcuMDU5NjI3JyB5PSctMjAuODM1MTk4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xOS41ODc2MjgnIHk9Jy0yNC40NTA1NjInPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMTYuNzkyNTUyJyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1IDMxLjU2OTRWLTQ3LjQ3Nzk3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwzMS4zMTk0KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ3LjcyNzk3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNMTU2LjQ5MDE0IDMxLjIwODMxVi00Ny40Nzc5NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDE1Ni40OTAxNCwzMC45NTgzMSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwxNTYuNDkwMTQsLTQ3LjcyNzk3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNNjYuNjEzODMtNTYuOTA1NTJIMTMzLjc1MDk2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEzMy42MjU5NiwtNTYuOTA1NTIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J003MC44ODgzOC02NC40NjY2NEg5Ny43OTM5Vi01MC43OTQ0M0g3MC44ODgzOFonIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDczLjg4ODM4LC01OC42NTU1MiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00MS42MzM1MzInIHk9Jy0yMC44MzUxOTgnPs+RPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zNi44MjI1OTEnIHk9Jy0xOS4wMDMxNTUnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMyLjgyNzEyJyB5PSctMTkuMDAzMTU1Jz7il6Y8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTI5LjE2MDI3JyB5PSctMTkuMDAzMTU1Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy45OTg5ODknIHk9Jy0yMC40Njk4ODQnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J000Ni42MDM5LTY0LjYzNTIyTDguNzA1NTItOTMuMDU5MTcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43OTk5NywwLjU5OTk5LC0wLjU5OTk5LDAuNzk5OTcsNDYuNDAzOSwtNjQuNzg1MjIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjc5OTk3LC0wLjU5OTk5LDAuNTk5OTksLTAuNzk5OTcsOC41MDU1NCwtOTMuMjA5MTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J00xNDIuMzc1MjMtNjcuNDk2MjNMMTA4LjU4MzU3LTkyLjgzOTI4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzk5OTksMC41OTk5NiwtMC41OTk5NiwwLjc5OTk5LDE0Mi4xNzUyMywtNjcuNjQ2MjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjc5OTk5LC0wLjU5OTk2LDAuNTk5OTYsLTAuNzk5OTksMTA4LjM4MzU4LC05Mi45ODkyNiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTI5LjQyMzI4LC04OC4yNjUxNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQxLjYzMzUzMiwtMjAuODM1MTk4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy00MS42MzM1MzInIHk9Jy0yMC44MzUxOTgnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y4JyB4PSctMjkuODgzMTkzJyB5PSctMjAuODM1MTk4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0yNi43Njk4NDknIHk9Jy0yMC44MzUxOTgnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIwLjI4OTA4NScgeT0nLTIwLjgzNTE5OCc+4pemPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xNC4zOTI5NjgnIHk9Jy0yMC44MzUxOTgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTguNDAxNTA2JyB5PSctMjMuODQxNzE1Jz7ugLA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTUuNzA2NzMyJyB5PSctMjAuODM1MTk4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004Ni43ODkxNyA0Mi42NzkxMkgxMjYuMDIxNCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMjYuMjcxNCw0Mi42NzkxMiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPHBhdGggZD0nTTQzLjI2OTA3IDMyLjQ0OTYzTDEyLjI5OTAxIDkuMjI3NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjgwMDA1LDAuNTk5OSwtMC41OTk5LDAuODAwMDUsNDMuMDY5MDYsMzIuMjk5NjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjgwMDA1LC0wLjU5OTksMC41OTk5LC0wLjgwMDA1LDEyLjA5OSw5LjA3NzUzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNMTQyLjM3NTggMzIuMDg4NDFMMTA5Ljk4NjM2IDcuNzk2ODMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43OTk5OSwwLjU5OTk2LC0wLjU5OTk2LDAuNzk5OTksMTQyLjE3NTgsMzEuOTM4NCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNzk5OTksLTAuNTk5OTYsMC41OTk5NiwtMC43OTk5OSwxMDkuNzg2MzYsNy42NDY4NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram,node distance = 3.5cm]
      \SpliceDiagramSquare {
        width = 3.5cm,
        height = 3.5cm,
        nw = f^{*}(B'),
        sw = A,
        ne = B',
        se = B,
        west = f^{*}(B'),
        west/style = {>->},
        south = f,
        east/style = {>->},
      }
      \node  [right = 2cm of nw] (ref1) {};
      \node  [above = 1.5cm of ref1] (nw') {$A' \cap  f^{*}(B')$};
      \node  [right = of nw'] (ne') {$\exists _{f}(A') \cap  B'$};
      \node  [below = of nw'] (sw') {$A'$};
      \node  [below = of ne'] (se') {$\exists _{f}(A')$};
      \draw  [>->,morphism] (nw') to (sw');
      \draw  [>->,morphism] (ne') to (se');
      \draw  [cover,morphism] (sw') to node[near start,desc] {$\vartheta _{f \circ  A'}$} (se');
      \draw  [>->,morphism] (sw') to (sw);
      \draw  [>->,morphism] (se') to node {$\mathsf {Img}(f \circ  A')$} (se);
      \draw  [->,morphism] (nw') to (ne');
      \draw  [>->,morphism] (nw') to (nw);
      \draw  [>->,morphism] (ne') to (ne);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By the <fr:link
type="local"
href="ct-0008.xml"
addr="ct-0008"
title="Pasting lemma of pullbacks">pasting lemma</fr:link>, the back square is also a pullback. Then since covers are stable under pullback in a regular category, the north edge of the back square is also a cover. The diagonal of the right face is <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f \circ  A') \cap  B']]></fr:tex>, which forms a cover-mono factorization of the composite <fr:tex
display="inline"><![CDATA[f \circ  (A' \cap  f^{*}(B'))]]></fr:tex>. Thus, by <fr:link
type="local"
href="ct-000Q.xml"
addr="ct-000Q"
title="Cover-mono factorization">uniqueness</fr:link>, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f \circ  (A' \cap  f^{*}(B'))) \cong  \mathsf {Img}(f \circ  A') \cap  B']]></fr:tex> as required.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Related">Related</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1350</fr:anchor><fr:addr
type="user">ct-000K</fr:addr><fr:route>ct-000K.xml</fr:route><fr:title
text="Image">Image</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is said to have <fr:em><fr:strong>images</fr:strong></fr:em> if the inclusion functor <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A) \hookrightarrow  {{\mathcal {C}}_{/{A}}}]]></fr:tex> admits a left adjoint <fr:tex
display="inline"><![CDATA[\mathsf {Img}\colon {{\mathcal {C}}_{/{A}}}\to \mathsf {Sub}(A)]]></fr:tex> for all objects <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1351</fr:anchor><fr:addr
type="user">ct-000J</fr:addr><fr:route>ct-000J.xml</fr:route><fr:title
text="Slice comparison functor of a locally cartesian category admits a right adjoint"><fr:link
type="local"
href="ct-000I.xml"
addr="ct-000I"
title="Slice comparison functor">Slice comparison functor</fr:link> of a <fr:link
type="local"
href="ct-000G.xml"
addr="ct-000G"
title="Locally cartesian category">locally cartesian category</fr:link> admits a right adjoint</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is locally cartesian iff for all morphisms <fr:tex
display="inline"><![CDATA[f]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the functor <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> constructed in <fr:ref
addr="ct-000I"
href="ct-000I.xml"
taxon="Lemma" /> admits a right adjoint <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>. Moreover, <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> is (isomorphic to) the pullback functor.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>611</fr:anchor><fr:addr
type="machine">#281</fr:addr><fr:route>unstable-281.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By <fr:ref
addr="ct-000H"
href="ct-000H.xml"
taxon="Lemma" />, locally cartesian categories are precisely those categories with pullbacks.</fr:p>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>612</fr:anchor><fr:addr
type="machine">#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex> for any <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. We show that the following diagram</fr:p>
    
      
      <fr:figure><fr:resource
hash="dde2414601b7726e8df96b48e0fdca8e"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNC43NjA3MDdwdCcgaGVpZ2h0PScxMTcuODQ5NjI0cHQnIHZpZXdCb3g9Jy03MiAtNzIgNzYuNTA3MTM4IDc4LjU2NjQxNic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9VQUFvQUFBQUFBL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFYR050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFEWUFBQUEyTlZxTFR0b1pXRmtBQUFDUEFBQUFDOEFBQUEyS0l4L3FtaG9aV0VBQUFKc0FBQUFIZ0FBQUNRRjhRS2FhRzEwZUFBQUFvd0FBQUFJQUFBQUNBWWhBR1ZzYjJOaEFBQUNsQUFBQUFZQUFBQUdBR3dBQUcxaGVIQUFBQUtjQUFBQUZnQUFBQ0FBQlFCRmJtRnRaUUFBQXJRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGhBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTZRek0vd0g4cGtoMGtocS9nT0ZBYlFlRE04QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOUR5UCt6d0h3R0FGVzFCc01BQUFBQUFnQmwveXdDaWdIRkFDNEFRd0FBQVFNT0FTTUdMd0VtSno0Qk1oWVZGQVlIRmg4QkZqNENQd0VPQVFjdUFTYzJOelkzTmpjeUZoYzJOeDRCRlFjM05pOEJKaWNPQVFjT0FSVWVBVGMrQVRjK0FRS0ZiQlNQYXk4MUN6TUVBU1V5RmdvUUFpSXRGejlIR0FZWUVrd3lTMllDQTBVUkVsQmhJa0FaRVNJVEU1WXRBUlVFRnp3cFNCWWRIQUk1SUNoRkhRNEpBWFgrVEV0SUFna0REQzhkSlJvUENCd1BCUUlCQVFvd01CeGhFQ1VDQVZ4U1kwd1REMElER3lJbkFRRVZEdnU0Q2lNR0lnUUJNQ012ZFNFN0xBRUJKeDBQRHdCNDJtTmdaR0JnQU9KNXB6K2RqZWUzK2NyQXpNSUFBbzhGNXQxRDBQOTFtRU1ZandLNUhBeE1JRkVBWk9zTUFRQjQybU5nWkdCZ1p2alBBQ1JER0ZJWm5KbTZHSUFpS0lBSkFFQVdBcElBQUFOVUFBQUN6UUJsQUFBQUFBQnNBQUI0Mm1OZ1pHQmdZR0p3QVdJUVlHUkFBd0FIV0FCTEFBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWXlBbFdob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMmhPSm5QSDhObDhabUZrWVFPQ3h3THg3eURSTEtPTWRJTVhCd0FUaUFRQVRNZ2wyQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUd0FBb0FBQUFBQmJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0YzOG1OdFlYQUFBQUU4QUFBQU1nQUFBRHdIRmYxMloyeDVaZ0FBQVhBQUFBSWVBQUFDaEJMRnZFWm9aV0ZrQUFBRGtBQUFBQzhBQUFBMkovNkF0MmhvWldFQUFBUEFBQUFBSUFBQUFDUUZtUUdiYUcxMGVBQUFBK0FBQUFBUUFBQUFFQWxpQUtkc2IyTmhBQUFEOEFBQUFBb0FBQUFLQWFnQTFHMWhlSEFBQUFQOEFBQUFHQUFBQUNBQUJ3QkZibUZ0WlFBQUJCUUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUU1QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1pbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1XOWxadmdQNURNek1JS0VHUkVxL2dPRkFmQjVEZVlBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZemIvMy9IOGhQQTlIL1ovL3hBNnNDQWdDaUp3bUpBQUI0MmtYUlBXL1RRQndHY0Q5MzdqbHY5dG14Zlc2VDFIbHhiSWZTeG1uY09paXQ4dEpXUW0wUnBVS2lLa0lnaGk2ZGtCaEFmQWdHMUlHVmxXL0EzaDN4SFJpUm1CaFlVczd0d0oxMHd6MDMvSC8zS0ZDT2J4SnlTWDRvTTBVQjVXQ2FBYTBUeFJPa3doTk1FMDFNTUtVQml6SXZuV0FrNzRmQ014QkVjWlNOb2dRRzRVZ3p3V0o4R1p1cVdTdk9OM3Rqb090R0ZMekpPZSsyNldxZlAvS0p6VSs1YTRpOTRONHVFQWlabXo3bjFhcGZLdFJlNVRHdUZ0ZEgxbXpMMmFkUjRMZElsOFhsSW9GNjdINytjMFk3R3M3TzYzRVVkdjlIV0lrMlBxcWRBaFM1aUxKK3MwRkNYQ3Q5WlQvWFNBbTdsY2lKSGFaNUloV1pCRXdsc284NEcrWGJoeWRWOGdHZElvc2xpbW41Rndodm1EOGw3VGZGdCsrVGw2cWMxeEl3cWcycjdld0dEYUY1bzhQNU9hRnpiaDJlOTdaMVdxdnFMajRsRkk2N1ZkdHZ1YWFGS1BiM0doVU5IeGJ6NURrbDd2cHEyN2JMZm1tSm9OeFlHYlJlcENyT25sdzh0dmtCUlZlWUFxYTErUHVObDhOQVJXODdtczlPUmdoYlhMKzFEVzUrNFRlK0t6dTViV1RBWTU3c1puaG40SGNrS2JrN00rRkptQ0ZINk1zMlpZc1M2V1Y1YnpHTHhaUWtZRi9URU5oWmJhWW5ENnRxUVNjOWMvUHkyUVhJZ3lZTmlIcjF1akpzVzEzQUZhVmdySisrb3lTTWRpcnRBZWlrY2Ivc0w0Zk84bkx5c3o2MTErb2xRdXErQnRUalNxVGlhRHpZcXlKc3pwNEN6R0N1cWR0RWMwcllYT3ZZUmdIUW5VWVphcmdrVXhWRTB2NEIvMUJVbkFBQWVOcGpZR1JnWUFCaTNoTkhuOGJ6MjN4bFlHWmhBSUhIQXZQdUllai91a3pIbUM0Q3VSd01UQ0JSQUV6OUM5Y0FlTnBqWUdSZ1lHYjR6OERBd0hTTVFlZi9CYVlzQnFBSUNtQUJBR1VjQkRnQ3hnQUFBam9BU3dJNkFDd0NLQUF3QUFBQUFBQm1BTlFCUWdBQWVOcGpZR1JnWUdCaGNHRmdZZ0FCUmdZMEFBQUhqZ0JOZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzRBQUFBMktBdUF1bWhvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRoTmNpNi9IODl0OFpXQm1ZUUNCeHdMejdpSG8vNHhNbDVsQlhBNEdKaEFGQURvbENyVUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLTWlBOVdob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0xkRzhzczQvbHR2akl3c3pDQXdHT0JlZmVRYWVhSlREWkFpb09CQ2NRREFDSWhDWDRBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLRDZCazJob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0clpQdnFueC9EWmZHWmhaR0VEZ3NjQzhld2o2LzE5bU5xYTdRQzRIQXhOSUZBQkMvd3VmQUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU1LjEwNTAxMycgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTcuOTEwNDI4JyB5PSctNjQuNjg1NTE1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUzLjc0NTQ1OScgeT0nLTYxLjY3ODk5Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTAuNjMyMTE2JyB5PSctNjEuNjc4OTk3Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ni40OTUxNjUnIHk9Jy02MS42Nzg5OTcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTEuNDU5MzIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU0LjUyMDQwNCcgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjg2MjEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuNjc4OTk3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINDYuNDAzNzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNjUzNzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4zMjU4Miw0Ljc4NDAxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+zrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU4LjgxMjk5JyB5PSctNjAuNjgyNzMzJz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        
    \SpliceDiagramSquare {
      sw = A,
      se = B,
      nw = A',
      ne = B',
      south = f,
      east = g,
      west = f^{*}(g),
      west/node/style = {right},
      north = \varepsilon _{g},
    }
  
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>is a pullback, where <fr:tex
display="inline"><![CDATA[\varepsilon _{g}]]></fr:tex> is the counit of the adjunction. Note that since <fr:tex
display="inline"><![CDATA[f \circ  f^{*}(g) = \Sigma _{f}(f^{*}(g))]]></fr:tex> by construction, the component <fr:tex
display="inline"><![CDATA[\varepsilon _{g}]]></fr:tex> makes the diagram commute.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[h'\colon C\to A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h\colon C\to B']]></fr:tex> be morphisms such that <fr:tex
display="inline"><![CDATA[fh' = gh]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="008e9ec91729d17ae945074e135ddf2f"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3Ni40MjcyMjhwdCcgaGVpZ2h0PScxNzQuNDQ0ODM3cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE3LjYxODE1MiAxMTYuMjk2NTU4Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLSXgveW1ob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0o1cHovMXh2UGJmR1ZnWm1FQWdjY0M4OTRoNlA4NnpDR01SNEZjRGdZbWtDZ0FYUXNMNFFCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUzBBQW9BQUFBQUJWUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MC9tTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1daMng1WmdBQUFXUUFBQUhxQUFBQ0hQVC9FenRvWldGa0FBQURVQUFBQUM4QUFBQTJLRU9CbjJob1pXRUFBQU9BQUFBQUhnQUFBQ1FHTWdIZGFHMTBlQUFBQTZBQUFBQVFBQUFBRUF0WkFJSnNiMk5oQUFBRHNBQUFBQW9BQUFBS0FXSUFzRzFoZUhBQUFBTzhBQUFBR0FBQUFDQUFDQUE2Ym1GdFpRQUFBOVFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFcUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNZNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJtWnZnUDVETkRwSkhVL0FjS0F3RHpBQTFLZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpPLy84RFNjZi8vLzhmQVBNWkFGSzVCcDk0MmpYUXoyb1RVUlFHOFB2ZGs3blRKSk9aNktRemxhWlQwdnladHBLa2RJYVp0b3NvallrMXhiUTJVSUlFZ29JV0JBVTFSaGN1c29nTFFWZENRVnk0Y2VjRHVISGxxZy9nMW9XNEVoOUJrbmhINkxtYnc4ZGQvTDdET0N2TVp2d24vOEdxYkpPeEVFRzRhZGxteHZJQ1MxU2h1aVhYRDJ3ckNLdklxU0pqMllHdFErWlI3TlVRZXZRRjkwUW1KVkN6eXZQUWxNRm9Ua0VxYWZvVVY2ZXpkaXBycGdncDVhU3JRWXV2MU43L3lRMzVjUnB4WXpLeURGcFNRUVErWjZpQVp0OXZqRE9GTkxpaGl5aE9HQUw1TXh3eE9jUXV6eVlrK0ZmbXNIVzJKYVdtbjNlRnRPVWN6T3RRSGRqQ2dGQno0ci9YakhCQnljMlhoRXJuTzhrUDNxZTNpKzZTWWFEYnUwdWp6bjRIL0hyNjVyUHB1Nnl1N3pnZlQvc0Rqa3A5dkd3cWo5NzBocHh2N0gxcnhnRDlrRzlmNEpSVndXL3R0RTZNUkh0N2YxZXZ4YUlHTU5HZ0o4M0NOUTdqMHVRelBXOFhEMm42NjZKSU1BYm16WDVUa24rUHpDQWRlWG5SSy9CTHJqUkhZTnRCS004YkNaZmh5QUl5cjhBTnd1aFp0bVdIc2c0bHJwSkl4QlZ3SEI4MFhtMDBGNFdGMk1zYnEvM0FMNHRZWEZXbzNGeDdYSC94Z2FqanQ1Nk9PMnVyWWsrSHhzK21mM1ZwVm8zUzdRZEFmYXZiWCtpVmgzYzRWdFlydllVa3dMV0h1MFVQZERwNlBXajVSeFFyRlBVRG5STmovd0FkMGxyK0FBQjQybU5nWkdCZ0FHSU8vV2JkZUg2YnJ3ek1MQXdnOEZoZzNqc0UvZjhsTXpmVFhTQ1hnNEVKSkFvQUMra0tiUUI0Mm1OZ1pHQmdadmpQQUNRNUdGVCtYMkRtWmdDS29BQVdBRXIzQXhVQUFBSjJBQUFEQUFBa0F3Z0FLd0xiQURNQUFBQUFBRlFBc0FFT0FBQjQybU5nWkdCZ1lHR3daR0JtQUFGR0JqUUFBQWFTQUVONDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0F1QTJtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhOY2k2Zkg4OXQ4WldCbVlRQ0J4d0x6M2lIby80eE1sNWxCWEE0R0poQUZBREpGQ3BVQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSc0FBb0FBQUFBQlF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUZFQUFBQmdxR3ppWldOdFlYQUFBQUZJQUFBQU5BQUFBRVFpTEFDNloyeDVaZ0FBQVh3QUFBR05BQUFCek1VV0kxZG9aV0ZrQUFBRERBQUFBQzhBQUFBMktZMkF6MmhvWldFQUFBTThBQUFBSHdBQUFDUUY3Z0RiYUcxMGVBQUFBMXdBQUFBUUFBQUFFQXUwQVd4c2IyTmhBQUFEYkFBQUFBb0FBQUFLQVZZQXhHMWhlSEFBQUFONEFBQUFGd0FBQUNBQUJnQktibUZ0WlFBQUE1QUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUVZQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc3M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lBR0lCWmdZSENBY2hsU2lzdlNHZGdVRkI0WU1HdjlzV1JnWU5aaVBnNFVabVNBZy8vL0dSZ0FXVUVRVHdBQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUFMbEZCU1V4QjhZL1ArUFlOMS9lUGUxL0dXd1dqQUFBUHpGREFGNDJqV1F3VzdUUUJDRzk1KzFkK3ZFanAxNGJjZHRhamRyWXplcVNHaEliSVFxNThxQkk0aExSWVNxNWs3VkV4eTRVNGxIS0JJM2VBVmVvOGMrQzdCRmNKblJQL09QOVAzRHdENzkxdlNZN3RnTHhwQWpReVI4Q1BsUTJtcUJxbDQxR3pSckh3TVVjNnlhZHBuemFrSFZ1a1BTeE1sZjh3WWRubVpRUW1wemdrdnVPUmFFTFRtWGJrSjh6NUt3K3oyZXpzSzVtZ2JCTkJyUGp2ZkpsbjJiU2lGS2doMEkydisvVmZOd2hoOVplM3lpUDF5OXZFajJDQmdGbDgrdWI4ckZreFBmNHozUm84TFhKQnpIbXVURm1UNG9BNktnUEN6Tzg0bmxDSWUwWDVCeE1ST0pmV0VGWGVDZXJZeG9tMldzREhLY3hNa0FoalUzOUNiVkJsTFV1aks5cXF1Nnd6SkhYYTFOMkRpUitQelZUZFZRZkgvek9pU28xUG5tQ2RMRFVMZzNqNFFYamMxY0VhS3hkK3VLY0tpcGo0T3RvL1NBdXNPcEhJOFV4THZkODR4amxKenVYa1ZRT3ZpM2NMYTcwNTQzQXVWdkh6aTNyTVpIT21PQkVWd1VocU1OTzdSTDgyT0o5M2ZDalVOdTNmSTBTeXZBd3Yydjg2R1VYb0NmZ3lNY1RWeVgvUUdZQWpjc0FBQUFlTnBqWUdSZ1lBRGlaK3FLamZIOE5sOFptRmtZUU9DeHdMeDNDUHEvRWtzbzB4VWdsNE9CQ1NRS0FDZHRDckFBZU5wallHUmdZTmI2WThuQXdCTEtFTS9nd1pUTUFCUkJBU3dBU0hZQ3pnQUVWUUFBQXFvQWZ3THlBSTRCd3dCZkFBQUFBQUJ3QU1RQTVnQUFlTnBqWUdSZ1lHQmg4R1FBMFF4UUVna0FBQWYwQUZFQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdzQUFvQUFBQUFCcWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjRBMk50WVhBQUFBRThBQUFBTWdBQUFEd0hGZjE0WjJ4NVpnQUFBWEFBQUFMV0FBQURiSHhIbEI5b1pXRmtBQUFFU0FBQUFDOEFBQUEySi82QTEyaG9aV0VBQUFSNEFBQUFJQUFBQUNRRnFnR2NhRzEwZUFBQUJKZ0FBQUFVQUFBQUZBd09BUFJzYjJOaEFBQUVyQUFBQUF3QUFBQU1BYTRDaW0xaGVIQUFBQVM0QUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQk5BQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRm9BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXltU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVc5bFp2Z1A1RE16TUlLRUdSRXEvZ09GQWZhbURmY0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5bVl3Yi8zL0g4aFBBOUgvWi8veEI2c0NBZ0NpU1FtTEFBQjQya1dTUFcvYlZoU0crUjVTcEVTS3ZQd1FMeDFMcGtSUkpKWFVFU1ZUcGxKYmxTekxTQkc3elVjTDFIQVFKT2lRSlZPQkRpMWFvRCtoQ0lJTVdiTVYvUWZaQTJRTThoOHlGdWpVQWwzc1hsWkQ3d0h1Y004ZHpuT2VWNEowZHBYVE0vb2dIVWtTWkFaVnM2RDEwMnlCZ2dkYzFYZ1hDeXpsV0UzTG9GaGdKdDczZUdBaFRyTzBuS1U1TEdJb1NxNW1lSDFnSy9aMll6VVpIZ0FEUDVYQnVveXhRU1R2ak5nWElYbnNBZk10Zmh4Zm53TXhGMzA3Wk14MVE3MisvYVJxNCtYbDIxUG5hTnBheTJrYzltaWdaa2FEb0p6NXIvNDZsL3NhemkvYVdab00vbS9oV25yelY2VmZoeVFPU2J0WE55bkJXMmtrclNzYVFhTCtSeUltYnFsYXdBdGVDb0NsZ0J3aEsyZFZoUWdFbGZnZ0wxRm1Ba3JWcWhYd1lLLzZTdEYzamU5L3pCOHJZbDZIdzNJN1R0U2F4eDJ1QmJNN3F3dVNWOHk1Y3pIY04rVnQxL1R4SXBmUjhxZmI2NTV2TzBpejhMalQxUERUNVNwL0tKTy91eE41bmhIcU5ZTFJ1VGJ1UFNvVW5OOS9ldGRqSnpJRzNPYXduY3QvM2pBamlSVU05OVBWMGIwWmtoNHpCUnVrTDYvK3BwL3BuWFJXa1ltUlE5TFVqUzVmcllZdGl5QVV2S0tFdmFtQXFmRFNyTm9CVTRTdkVmWm4zZ0pwdkpFN0s3bUcxZDNPVjUvZW5qWkJMZkthcGk1M3VuT1hIRjFGWURqeFluZ0xzbWx4VHNTSDgvdGJyT2IxR25VOWFMaE83YmxDYk5Dd0FVczcyVTFBdjEyK2l3clU4cWs1bXF1SDdTaHkrclQ4ekNVS3hnRWZLZm4xcHRFYkhLOG4vb1JvUGVURzZTOXBteG53VEU0bkp0TVZuZFUxUlc0S2grT3JQL0FuM2t1SGxjT1poVUFOUkFiM05xN1lScDNBMzl3bEY5QWlqV2syRXFrVmFSVXlnN0xLWjZabWZFazUxTitMQkRqYzZSYjNQbmVWdWtsRGUvTHNtNmVnVzEwNUp1WGx0ODI5eUJrQVB0ZmpBL1BCRHpJbDZXRXpHb3NkZHo0eHdxMmt0YldWZjJ3dnZSdHRuYWdkYWtBN2E2WUtUZy9HeHk2Uzd0SFhnR3Fwdm0xNnBMVjBURzcwUGFzT21LMk9BU1dwaWE0Q0Vnci9CWUcxY1NJQUFIamFZMkJrWUdBQVlsTmJydmg0ZnB1dkRNd3NEQ0R3V0dEZU93VDlYNWZwR05ORklKZURnUWtrQ2dBSCtBcFRBSGphWTJCa1lHQm0rTS9Bd01CMGpFSG4vd1dtYWdhZ0NBcGdCUUJtWUFSS0FzWUFBQUk2QUVzQ09nQXNBcXdBVFFJb0FEQUFBQUFBQUdZQTFBRklBYlo0Mm1OZ1pHQmdZR1h3WVdCaUFBRkdCalFBQUFoeEFGWjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS01pQkZXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZEcwdC94dlBiZkdWZ1ptRUFnY2NDODk0aDA4d1RtV3lBRkFjREU0Z0hBRVVWQ2wwQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTEzLjk5Mzk5NycgeT0nLTI3LjU2NDIyMSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTYuNzk5NDEyJyB5PSctMjYuOTU1Mzc1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTEyLjYzNDQ0MycgeT0nLTIzLjk0ODg1OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS41MjExJyB5PSctMjMuOTQ4ODU4Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01LjM4NDE0OScgeT0nLTIzLjk0ODg1OCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTMuNDA5Mzg4JyB5PSctMjcuNTY0MjIxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg0Ni40MDM3OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni42NTM3OCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0LjMyNTgyLDQuNzg0MDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTcuNzAxOTc0JyB5PSctMjIuOTUyNTk0Jz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ0LjE2OTU0LDM3LjczODMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDEuMDgxMTggMzMuODI4NTdDLTQ2LjQ3NDQ5LTEuMTM0MzUtMzUuODg3Ni0yOC4zODUzLTguNjk1MzYtNTAuMjI0NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjc3OTY1LC0wLjYyNjE2LDAuNjI2MTYsMC43Nzk2NSwtOC41MDA0NiwtNTAuMzgxMDQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00Ny43MDk2MywtMjEuNzY1ODUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xNi44MDE3MzgnIHk9Jy0yNi45NTUzNzUnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTMxLjc1MTUxIDQxLjM1NDMxQzIuMzI5ODYgNDYuMzc0MjggMjguNjcyNDkgMzUuOTMyODUgNDkuNzUwMjcgOS4zMTk0OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjYyMDgyLC0wLjc4Mzg3LDAuNzgzODcsMC42MjA4Miw0OS45MDU0Nyw5LjEyMzUyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNy4xNzg0LDM5Ljk2MjE5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+aDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2UtZGFzaGFycmF5PSczLjAsMi4wJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KPHBhdGggZD0nTS0zMy44MjgwOCAzMy44Mjg1N0wtOS4yNzcxNiA5LjI4MTA3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTQsLTAuNzA3MDUsMC43MDcwNSwwLjcwNzE0LC05LjEwMDM3LDkuMTA0MzEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTS0yOC42MzMzOSAxNi42MjgwN0gtMTQuMTE4MjlWMjkuMTE4MDZILTI4LjYzMzM5Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTI1LjYzMzM5LDE5LjYyODA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+aDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTYuODAxNzM4JyB5PSctMjYuOTU1Mzc1Jz7igKA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        
    \SpliceDiagramSquare {
      sw = A,
      se = B,
      nw = A',
      ne = B',
      south = f,
      east = g,
      west = f^{*}(g),
      west/node/style = {right},
      north = \varepsilon _{g},
    }
  
        \node  [above left = of nw] (c) {$C$};
        \draw  [->,morphism,bend right] (c) to node[swap] {$h'$} (sw);
        \draw  [->,morphism,bend left] (c) to node {$h$} (ne);
        \draw  [->,morphism,exists] (c) to node[desc] {$h^{\dag }$} (nw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Note that <fr:tex
display="inline"><![CDATA[h]]></fr:tex> is a morphism <fr:tex
display="inline"><![CDATA[h\colon \Sigma _{f}(h')\to g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. Thus, it corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[h^{\dag }\colon h'\to f^{*}(g)]]></fr:tex> under the adjunction.</fr:p><fr:p>The transpose of <fr:tex
display="inline"><![CDATA[h^{\dag }]]></fr:tex> can be computed as <fr:tex
display="inline"><![CDATA[\varepsilon _{g} \circ  \Sigma _{f}(h^{\dag })]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> is the identity on morphisms, we have
      <fr:tex
display="block"><![CDATA[         (h^{\dag })^{\dag } = \varepsilon _{g} \circ  \Sigma _{f}(h^{\dag }) = \varepsilon _{g} \circ  h^{\dag } = h       ]]></fr:tex>
      Thus, the top triangle also commutes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>613</fr:anchor><fr:addr
type="machine">#280</fr:addr><fr:route>unstable-280.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has pullbacks. Then we can take <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> to be the pullback functor. It remains to check that <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex>.</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
      
  <html:tr>
        
  <html:th>Unit</html:th>

        
  <html:th>Counit</html:th>

      </html:tr>

      
  <html:tr>
        
  <html:td>
          Let <fr:tex
display="inline"><![CDATA[h \in  {{\mathcal {C}}_{/{A}}}]]></fr:tex> be an object, we take <fr:tex
display="inline"><![CDATA[\eta _{h}\colon h\to f^{*}(\Sigma _{f}(h))]]></fr:tex> to be the unique morphism given by the following pullback:
          
    
      
      <fr:figure><fr:resource
hash="7731b9d03a7d6d3a0f77419dff374215"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI0My4yNTI3NDdwdCcgaGVpZ2h0PScxODEuMzgwMTM0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTYyLjE2ODQ5OCAxMjAuOTIwMDknPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFRQUFvQUFBQUFCSlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hjTjRabU50WVhBQUFBRThBQUFBTWdBQUFEd0hMLzBNWjJ4NVpnQUFBWEFBQUFGQ0FBQUJZQm9QaUZGb1pXRmtBQUFDdEFBQUFDMEFBQUEyS0ttQTEyaG9aV0VBQUFMa0FBQUFIZ0FBQUNRRzFBTTlhRzEwZUFBQUF3UUFBQUFRQUFBQUVBdDdBVjVzYjJOaEFBQURGQUFBQUFvQUFBQUtBT1lBYUcxaGVIQUFBQU1nQUFBQUZ3QUFBQ0FBQmdBcWJtRnRaUUFBQXpnQUFBREtBQUFCTXVzSWtlWndiM04wQUFBRUJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFRVWUY3TXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBWHFnNGNBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5bW95TC83L0g4alhBTkgvYi81SkFLc0NBZ0NZbXdrNUFBQjQyaTJQUFV2RFVCU0c3NXViM0h6YUQ2MkpyYVEwS1NSQ3RZS21hVUZpNldoZFJLSFNRZ2NwaXFQRlJSMEY5ODcrZ3Y2SWpvS0xnL2dMQkFjM0YzRVFOZldhZXM1eTN1Vjl6a05BYnFjRTk1U1FJaUZJUVdhV21XeU91WDRWdnVlSDlXM1V3dzF6a2VGdS8wYWlycUt0WFNoZ2haYlRMa1dpR0pYYVRxdkFJTHlHSDVQKzVaSjFkU3hxb2hiWXZlaHNQQjVHWFR2UVJKWHdBUmx3MW9pemxubGc4aC9OVzBlUUFPWTkzK09IVllSbFl2VGZTZ1hKUC9ScU9EbVhLWjBCUVdhZGtCUkZ0QWVkYXhTKytyb3VJUUZ5eHRGMFNvZkNoS3dRb3NJeG0wZ0VOcW5EdkpwWFYxRkZMUWd0eHlwenV5ckt6b0lwbS9pTW4zQmdOUEpibFh5VXJyZy9nWkVUTWxpTkgyV2FUUXNQYnNWb2xPelRadno4cllOaU4zNERmeTJqN0hXNEVETVVIVmwwbWFwa1pMenZkRkp6UnZ4aXlCSlgvZ1ZyT0VIVkFBQjQybU5nWkdCZ0FHTE9UU25WOGZ3Mlh4bVlXUmhBNExIQXZMY0krajhEY3lFemlNdkJ3QVNpQUJqS0NiOEFBQUI0Mm1OZ1pHQmdadmpQQUNTdk1pUXlKRE1YTWdCRlVBQUxBRTB1QXhrQUFBTlNBQUFDS2dDYUFpb0FZd1BWQUdFQUFBQUFBRFlBYUFDd0FBQjQybU5nWkdCZ1lHSFFaQURSREZBU0NRQUFCTlFBTVFCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRXFmbTV1RGs2dkQyNndKMHFHcHBMWG9JdjUwYjBQd0JnN2ZQZWZjQUJrdkVvWkptQWNkSnBVM2p6em1oMFhraWZpcnlCbS9yQm1ScEROeFZ1d2lwMHo1anp4bVNSbDVJdjRqY3NZZjczMVQzKzZkOWVyWUdPdmRwZmJiay9WdDFUaTEwZm13SHF5ei90eFpvOHFuTW4zVjl0ZGFGVHJYQlhzYWFtN2M2YkI0RkVkeFRHREhSVExQbGxQWVd5ckpuSFEyYVBKdmVwRFVoY1k1L0dLa1VmSVVOZlJ5MDRwZXBhc293cDJtK0FCVk1pNURBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFXWUFBb0FBQUFBQnFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0QzJOdFlYQUFBQUU4QUFBQU93QUFBRXdFUFFTTloyeDVaZ0FBQVhnQUFBSzdBQUFEVk9MVDN6aG9aV0ZrQUFBRU5BQUFBQzhBQUFBMkovNkF6V2hvWldFQUFBUmtBQUFBSUFBQUFDUUZyZ0djYUcxMGVBQUFCSVFBQUFBVUFBQUFGQXd1QVBoc2IyTmhBQUFFbUFBQUFBd0FBQUFNQWE0Q2hHMWhlSEFBQUFTa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUJMd0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZqQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm15bWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1XOW5admdQNURNek1JS0VHUkVxL2dPRkFma09EZjhBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1Jnc2dEUVhBd2RRam9raGpTR0RlU3Z6OXYvL2dXSnc5di9aLzJmOThmdmpDOVlCQlFCNWJRN0hBSGphUlpJOWI5dFdGSWI1SGxLWEVyOHVKWktYaWlWVEh4UkoyVWtweVZMSTJGSWt4d29TMUc2Ymp3SU4yaVhJa0NWTGxoUVpBdlFuRkIweWRNMFdkT21mQ0pJbFFOSC8wTEZBcDNhMGUyVUZ5RDNBSGM2N25PYzhSNEZ5ZGpHaVovU25jcXdvVURtWTdrRHZwOWtTVXhFS3Bvc09sbGlwTVV1TGNMcEVLZnNISW5RUXAxbGFsT2tJRG5GTUM4RXl2RGx5TlhlbmRtc3lQQUlHUWFxQ2R6am5nNTY2bS9Pdkl2TDRBeDQ0NGlUZVd3Q3hrTGtiY2Q1b1JFWjE1L0VteHV2emQ2ZjE0NW0vVnRNNDZ0S0FaV2FOb0owRnYvNzdTTzNyZVBSOUswdVR3ZWNJVjlJdmZ0YjZWU2p5UWZuNjRqOTZSUitVc3cyTEhEWWluVzJSQWhZZUZHVXhEU1BvVEpZa25LMGdPMldSWnBLWWNVMHk1YmhlZWt1azhYWUJaU0YwM1BxbS9mRHd6c3dDK2VSWnRxRzJPNHNHMVEyRzBLekh5K0VOcUxZakJKRVlMdTQzZWNYcjFxcEdXR3ZVSzc5b3hBYzFGM0QwMjljUzBOdnpENzBwS3FPWm5TL1l2TlhyMWZ1MHV0a2dDc2VoeUxYUm5tVjJCeWZyU1RBaFdnK0ZlZnBUMnVJbVBGdlFiWnNibXNHcnVxWmFDaW5qaTcveEQvNVE1c3BhVVVvSElRdWxwdzFnR1dFRG5FUE9YMjcvUWtob2FTek5jbWxXR2cyWENJdU53NHhsWWtVanNOK21DVERmN1V6djNXMW9WWnVHN3VUWmQwOUJOenBxVE5ycko5WkJyejRBQW1IRVIvYURseW9sNmR6cWplV08yMWZOcUpuNHplYm9yOWJLMjI4WlJLMUlCMXFabFdvNFBScWZOSkIwanI4Rm1NTUMxL1pJOXcxTTl2dWVVd1ZzdjIxQ1N5b3kxVUJiaCtPTGhPN2d2WEp6NDNCN2k5SUpYVnB5d01sUjAyeWxGdGRubnpvajVOTGpraTZ4SW5tTXRIaE93WTdqUTN1aHFTVDI1dEtLb2UvNmxWclE5bUZjdFV6R3ZhaHZWblREWkJEY3lnNi9yRTUvNk42VmpvSHdmR1hGNU5ZRGZMU2J3MHNUd1U3MDQzMmZPM0RyKzcrUDg5QU4yc0J4N3BzZ2N0ZHQwYVhrY0Q2Z2pkaVdSUGdmRjZSb2dRQjQybU5nWkdCZ0FPTGN2alRyZUg2YnJ3ek1MQXdnOEZoZzNsc0UvVitWNlJqVFJTQ1hnNEVKSkFvQUtXTUxDZ0I0Mm1OZ1pHQmdadmpQd01EQWRJekI0UDhGcG1vR29BZ0tZQVVBWnJ3RVRnTEdBQUFDT2dCTEFxd0FUUUlvQURBQ1dnQXdBQUFBQUFCbUFOb0JTQUdxZU5wallHUmdZR0JsOEdGZ1lnQUJSZ1kwQUFBSWNRQldlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVA0QUFvQUFBQUFCR3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hjTjM4bU50WVhBQUFBRThBQUFBTWdBQUFEd0hMLzBNWjJ4NVpnQUFBWEFBQUFFcEFBQUJPTkNXS2VGb1pXRmtBQUFDbkFBQUFDNEFBQUEyS0RLQTJHaG9aV0VBQUFMTUFBQUFIZ0FBQUNRR1F3S1JhRzEwZUFBQUF1d0FBQUFRQUFBQUVBbW9BUU5zYjJOaEFBQUMvQUFBQUFvQUFBQUtBTXdBWUcxaGVIQUFBQU1JQUFBQUZ3QUFBQ0FBQmdBaWJtRnRaUUFBQXlBQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRDdBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXltS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHBxTUM5bVp2Z1A1RE16TUlLRUdSRXEvZ09GQWUxM0RhZ0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5bW95TC83L0g4alhBTkgvYi81SkFLc0NBZ0NZbXdrNUFBQjQyaVhPdlU0Q1FSUUY0SHRtTmpQT3lzK0N1QnMxRVphVlJRdElGTmlORktLTldsQVNDNE9Ga2xpaENVYnRVT05QWStKRDBQb01sc1pIOEEwb2pJbTJhdUxxRUhKUGNhcnZYQUtkL2dGWG5HaVdDSTZka1NJSklZV3RheEorVVYvb054Q2dHNWR5b3k1WE9YWU9UUm0vcXlVbUM0eVZFZ0VuTUV0VXUxYnY1ZUY3VDFrTUIzMDMxKytjM0JTdU5VbmIybStOL1NtdE9yYk1DSm1BSDFZYldFTllSdEd2QldIN05oaUJTL25nZUE0ODJXcUQ5ellWQktleHRqdFkzKzh3a3h1cDV1ZmdlVmczaFdKRUkzK0xpUDJ3SjhvUktiajZWWjJ3SXQyOFh3c1YvTUJ4SGE4TTZlcHhpY2ZvQXl1bHhjcXlYYmE4N085OUxNVXdIYjBobG1ibldjKzY2RWZSME9CQU14cUNZOFphT1BzeXpBbk00eWl0OEg3Wk5LSlhvU1RSUDVMY08wUUFBQUI0Mm1OZ1pHQmdBT0o1M2FyTDQvbHR2akl3c3pDQXdHT0JlVzhSOUg5R3BsL01JQzRIQXhPSUFnQXdPd3FqQUFCNDJtTmdaR0JnWnZqUEFDU2RHZHdaUEpsK01RQkZVQUFMQUVTTEF0c0FBQUxUQUFBQnlRQjBBY2tBU0FOREFFY0FBQUFBQURBQVlBQ2NBQUI0Mm1OZ1pHQmdZR0ZRWkFEUkRGQVNDUUFBQkF3QUtRQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDArMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNWWjJ4NVpnQUFBV1FBQUFGTEFBQUJZRG1Tc1RKb1pXRmtBQUFDc0FBQUFDOEFBQUEyS0Q2QnMyaG9aV0VBQUFMZ0FBQUFIZ0FBQUNRR0xBSU9hRzEwZUFBQUF3QUFBQUFNQUFBQURBaCtBRTlzYjJOaEFBQUREQUFBQUFnQUFBQUlBRlFBc0cxaGVIQUFBQU1VQUFBQUZnQUFBQ0FBQndBNmJtRnRaUUFBQXl3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaVp2Z1A1RE5EcEpIVS9BY0tBd0R5S1ExSGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoTy8vOERTY2YvLy84ZkFQTVpBRktvQnA1NDJqV1BNVS9DUUFDRjc5M0JIV0RiUTF2YUdBRlRRWnBvRkVOSkt3d01LbWcwRXBURU1KQ1ltQ2liZzBGY0dSaDFNakZ4Y25IekI3ZzRPZmtuSEl5anZ3R3dOZkZOTDEvZThEMUNTWDQ2cFYvMGt4UkppUkFmbmw4eUxkMHdYYy9rUlFpbjRKUTl5L1Q4SW16QkRkUHlMQTBCRDdGYmcrK3lWNXh6UStXb21Xc3BLTkgrTUJhRk9xT1hXVnhNcGswMXJhc01hclRYVWFERWwycVBQL2FBbmlRUmwrT2hLVmxHZ0RIUW1CU0FZbDNVUjBZK0NTbzFIdUtFNU1oOTRKZ0VZV1IxT21hY3ZwRXNXU0diZ2FsZXpqazhjTE96U0drUVdWaGNnZ3ViLy9ucW9aeFhjSElGTHRoL1o4SEFmYjViY0RKU290TTlZOFAyUVJ0ME4zbDRQYmxQYTFvMSsvUncycWRZM3g0dDZ0SEwyKzZBMG8yOTkwWUUwRnEwTWt0WldvQWVWZmQ3TXRHc0hHeHB0VWo0QURycTdLcVIzNkdROCtNWGR0TmNickhKOXh4UGtGK3p2VHVEQUhqYVkyQmtZR0FBNHJaUHZxcngvRFpmR1poWkdFRGdzY0M4ZHdqNi8xOW1OcWE3UUM0SEF4TklGQUE3SHd0L0FIamFZMkJrWUdCbStNOEFKRGtZVkJpWW1Oa1lnQ0lvZ0JrQUk4Y0JRZ0FBQW5ZQUFBTUFBQ1FEQ0FBckFBQUFBQUJVQUxCNDJtTmdaR0JnWUdhd0JHSVFZR1JBQXdBR2R3QkNBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5vQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDMEFBQUEyS1l5QXRXaG9aV0VBQUFKQUFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFtQUFBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNhQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUp3QUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9nQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFdBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaTJoTUpKK1A1YmI0eU1MTXdnTUJqZ1hudmtHbVdVTVk3UUlxRGdRbkVBd0EySmdwVkFBQUFlTnBqWUdSZ1lOYjZZOG5Bd0JMSzBNZlF6NVRNQUJSQkFVd0FVb0FEUWdBRVZRQUFBdklBamdBQUFBQUFWQUFBZU5wallHUmdZR0JpTUdVQTBReFFFZ2tBQUFYS0FEc0FlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ2xKV0ZnWW1WcVF0Z2d6TEVRWGFJRktucXlPL3U0WHJvRGFmbi9iZ0RTbjdJZUU3R2E5elB5U2xFL1hIQkMyK0pwNklXaVVzK1dESWh5MmZpek5ra3ppWDVTbHp3emlYeFZQenZ4Q1dmUExaZGU3djMxcXQ5WjZ4MzV6YU02NFAxb2VtY1d1a3E2cDExMWg5N2E5UnBWR1pvd25CdFZhMHJYYk9sbytYR25SNkxSN0VYeDBSMm5DVUxqS3c1UkNmUVNPcWt0VUpUL2N0M2tydllPY1pQUmpvblNaVFFJRmRCOWxYYWlqcGVhdXBmNytrd1J3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUm9BQW9BQUFBQUJRd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMWJHTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWZBREJaMng1WmdBQUFXd0FBQUdpQUFBQjNQNTNiMFZvWldGa0FBQURFQUFBQUM4QUFBQTJLSXlBMldob1pXRUFBQU5BQUFBQUhnQUFBQ1FHY1FKUGFHMTBlQUFBQTJBQUFBQU1BQUFBREFsZkFQcHNiMk5oQUFBRGJBQUFBQWdBQUFBSUFISUE3bTFoZUhBQUFBTjBBQUFBRndBQUFDQUFCUUJSYm1GdFpRQUFBNHdBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFFWEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtbG1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F3TS93SDhwa2gwa2hxL2dPRkFibVBETjRBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpGay9QOFA1SVBwLzdQL3p3S3JBZ0lBbVBJSk53QUFBSGphSGRCTlR0dEFGQWR3dnpmMmpCT1B4MTh6dG9sSVN1eklUbEpJaWhJYzBhWkpxeUNFUUh3dEVSSUhRT0lBVlJmZFZxcmFYb0ZiZEYrcDZnRjZDQTZBdWdYRzBiekZ6THkzZUwrL0FjYm41eDM4Zy8rTUk4TUE0Z0ZsQWhndHlnVk00a1JTRnIrQ0JjeXFKVlN6bkJaNzB5cVoxUGYxaVJNQmVWRVcxYXdZUThhb0I1TXFsb3d5ZU5oM0cwRXIvTGlUblJJWXFDR1J5aE5SdTJjRjRXYmdYTG1SOUc0RU5WUGJ6Uy83eDNva0hoTGdIZCtMV2ttVHAzZXV0SWtKMzU1K0xiTDVvRFZCeUVaWlJzcWcyMlNBV0tubDdmM3RXNkN1Yk1CRmQydnFCMk1UZXR2MUNDMkZqWkQ2eTU5QU54d0NobVlaWDU3LzR5UCtOYzVybytaMFFPbGw2MUkwMFcrTlRiUldiMDdaQ01xcEZ0YklhWkhyTUFSNHVIYk9JdjJwcFRxZGFwMUlyR0w0ZEJIZm5KeWRZR1RKcHNld1d5NkVhWFBlZ0RZUCtxdnhCeUErVjZoMFkzNjlKVVV6WTlhbW41dm1keFBCRnJrVElsSmkvZUFTOFA3cGQzdEZZRlVOMy9IOXRKUitUdkJnMjJzZ09uSlhocHI0WnNDZHN2T2V6a2RaSHc5M08vbnJyMm1rb0pmZ1hrZ3BCZFNSY0kzbVlMbm1DNCsxTy8wQUFIamFZMkJrWUdBQVloZnZSTTE0ZnB1dkRNd3NEQ0R3V0dEZU93VDlYNWM1aE9reWtNdkJ3QVFTQlFBTlhBb2lBSGphWTJCa1lHQm0rTThBSkVNWXF2OS9aL3JNQUJSQkFjd0Fib29FeFFBQUExUUFBQUs4QUhzRFR3Qi9BQUFBQUFCeUFPNTQybU5nWkdCZ1lHWUlZQURSREZBU0NRQUFDSWdBVndCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLTWlCRldob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0xkRzB0L3h2UGJmR1ZnWm1FQWdjY0M4OTRoMDh3VG1XeUFGQWNERTRnSEFFVVZDbDBBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjE1Mjc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0xNC43MjQ3NDcnIHk9Jy0yMi45NDA2OTEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzLjI2Mzg5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE3LjUzMDE2MScgeT0nLTIyLjMzMTg0NCc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xMy4zNjUxOTInIHk9Jy0xOS4zMjUzMjcnPijOozwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNC41NjQ4MTQnIHk9Jy0xOC4yNjgxOCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctLjA3MTIxMycgeT0nLTE5LjMyNTMyNyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczLjA0MjEzJyB5PSctMTkuMzI1MzI3Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzcuNzA2Mzg5JyB5PSctMTkuMzI1MzI3Jz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3OS45MTIwOCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTQuMTQwMTM3JyB5PSctMjIuOTQwNjkxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODEuMzE0ODcsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINzQuODU2NTQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzUuMTA2NTQsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzMC45NjUwMSw2Ljg3MjkxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+zrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTE4LjQzMjcyNCcgeT0nLTE3Ljk5MTQzMSc+zqM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTEzLjY1ODg3OScgeT0nLTE2LjI0Nzk2OSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctOS4xNjUyNzgnIHk9Jy0xNy45OTE0MzEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYuNDY3MDIzJyB5PSctMTcuOTkxNDMxJz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yLjM0NDY5NCcgeT0nLTE3Ljk5MTQzMSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNODUuMzU4MjYtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw4NS4zNTgyNiwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4LjYyMjE1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPs6jPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xNi41MDk3MScgeT0nLTE4LjI2ODE4Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xMi4wMTYxMDknIHk9Jy0xOS4zMjUzMjcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTguOTAyNzY2JyB5PSctMTkuMzI1MzI3Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00LjIzODUwOCcgeT0nLTE5LjMyNTMyNyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NC01Ni45MDU1SDc2LjI1OTMyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDc2LjUwOTMyLC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MC4xOTAzOCwtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00NS42ODQ0OCwzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTQuMTQwMTM3JyB5PSctMjIuOTQwNjkxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC42OTUzNi01MC4yMjQ1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzc5NjUsLTAuNjI2MTYsMC42MjYxNiwwLjc3OTY1LC04LjUwMDQ2LC01MC4zODEwNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ1LjAwNDczLC0yMC44MzEzOCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPmg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScxLjYnPgo8cGF0aCBkPSdNLTMwLjIzNjU3IDQyLjQwNTI2QzEyLjY1NzEyIDUyLjA3MjIgNDcuNDM2MzcgNDEuMjQxMDEgNzcuMjU1MTQgOC45Mjc1NScgZmlsbD0nbm9uZScvPgo8ZyBzdHJva2Utd2lkdGg9JzAuNic+CjxnIHN0cm9rZT0nI2ZmZic+CjxwYXRoIGQ9J00tMzAuMjM2NTcgNDIuNDA1MjZDMTIuNjU3MTIgNTIuMDcyMiA0Ny40MzYzNyA0MS4yNDEwMSA3Ny4yNTUxNCA4LjkyNzU1JyBmaWxsPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzMuMCwyLjAnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNLTMzLjgyODA4IDMzLjgyODU3TC05LjI3NzE2IDkuMjgxMDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNCwtMC43MDcwNSwwLjcwNzA1LDAuNzA3MTQsLTkuMTAwMzcsOS4xMDQzMSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNLTI4Ljc1NDgyIDE1LjI2Njk4SC0xMy45OTY4NVYyNS42NDE5NUgtMjguNzU0ODJaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjUuNzU0ODIsMTkuNjI4MDcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz7OtzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTguMDkxOTU4JyB5PSctMTguMjY4MTgnPmg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                width = 3cm,
                sw = A,
                nw/style = pullback,
                se = B,
                nw = A',
                ne = B',
                south = f,
                east = \Sigma _{f}(h),
                west = f^{*}(\Sigma _{f}(h)),
                west/node/style = {right},
                north = \varepsilon _{\Sigma _{f}(h)},
              }
              \node  [above left of = nw] (c) {$B'$};
              \draw  [->,morphism,bend right] (c) to node[swap] {$h$} (sw);
              \draw  [double,morphism,bend left] (c) to (ne);
              \draw  [->,morphism,exists] (c) to node[desc] {$\eta _{h}$} (nw);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          <fr:p>where <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> is the counit defined on the right. Then naturality is a consequence of uniqueness.</fr:p>
        </html:td>

        
  <html:td>Let <fr:tex
display="inline"><![CDATA[g \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex> be an object. We take <fr:tex
display="inline"><![CDATA[\varepsilon _{g}\colon \Sigma _{f}(f^{*}(g))\to g]]></fr:tex> to be the following morphism.
          
    
      
      <fr:figure><fr:resource
hash="c239ad61beb496a381c8c783d1048aaa"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzOC44MDA0NDNwdCcgaGVpZ2h0PScxMTcuODQ5NjI0cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTIuNTMzNjI5IDc4LjU2NjQxNic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9VQUFvQUFBQUFBL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFYR050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFEWUFBQUEyTlZxTFR0b1pXRmtBQUFDUEFBQUFDOEFBQUEyS0l4L3ptaG9aV0VBQUFKc0FBQUFIZ0FBQUNRRjhRS2FhRzEwZUFBQUFvd0FBQUFJQUFBQUNBWWhBR1ZzYjJOaEFBQUNsQUFBQUFZQUFBQUdBR3dBQUcxaGVIQUFBQUtjQUFBQUZnQUFBQ0FBQlFCRmJtRnRaUUFBQXJRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGhBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTZRek0vd0g4cGtoMGtocS9nT0ZBYlFlRE04QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOUR5UCt6d0h3R0FGVzFCc01BQUFBQUFnQmwveXdDaWdIRkFDNEFRd0FBQVFNT0FTTUdMd0VtSno0Qk1oWVZGQVlIRmg4QkZqNENQd0VPQVFjdUFTYzJOelkzTmpjeUZoYzJOeDRCRlFjM05pOEJKaWNPQVFjT0FSVWVBVGMrQVRjK0FRS0ZiQlNQYXk4MUN6TUVBU1V5RmdvUUFpSXRGejlIR0FZWUVrd3lTMllDQTBVUkVsQmhJa0FaRVNJVEU1WXRBUlVFRnp3cFNCWWRIQUk1SUNoRkhRNEpBWFgrVEV0SUFna0REQzhkSlJvUENCd1BCUUlCQVFvd01CeGhFQ1VDQVZ4U1kwd1REMElER3lJbkFRRVZEdnU0Q2lNR0lnUUJNQ012ZFNFN0xBRUJKeDBQRHdCNDJtTmdaR0JnQU9KNXB6KzF4dlBiZkdWZ1ptRUFnY2NDOHo0ZzZQODZ6Q0dNUjRGY0RnWW1rQ2dBWEE4TDNRQjQybU5nWkdCZ1p2alBBQ1JER0ZJWm5KbTZHSUFpS0lBSkFFQVdBcElBQUFOVUFBQUN6UUJsQUFBQUFBQnNBQUI0Mm1OZ1pHQmdZR0p3QVdJUVlHUkFBd0FIV0FCTEFBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWXlBdVdob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMmhNSkIrUDViYjR5TUxNd2dNQmpnWGtma0dtV1VNWTdRSXFEZ1FuRUF3QTFLZ3BSQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLRDZCdDJob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0clpQdnJMeC9EWmZHWmhaR0VEZ3NjQzhEd2o2LzE5bU5xYTdRQzRIQXhOSUZBQTZJd3Q3QUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzRBQUFBMktBdUEzbWhvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRoTmNpL3ZqK1cyK01qQ3pNSURBWTRGNUh4RDBmMGFteTh3Z0xnY0RFNGdDQURGSkNwRUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVHdBQW9BQUFBQUJid0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGMzhtTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SEZmMTJaMng1WmdBQUFYQUFBQUllQUFBQ2hCTEZ2RVpvWldGa0FBQURrQUFBQUM4QUFBQTJKLzZBMjJob1pXRUFBQVBBQUFBQUlBQUFBQ1FGbVFHYmFHMTBlQUFBQStBQUFBQVFBQUFBRUFsaUFLZHNiMk5oQUFBRDhBQUFBQW9BQUFBS0FhZ0ExRzFoZUhBQUFBUDhBQUFBR0FBQUFDQUFCd0JGYm1GdFpRQUFCQlFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFNUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtaW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZkI1RGVZQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlxWXpiLzMvSDhoUEE5SC9aLy94QTZzQ0FnQ2lKd21KQUFCNDJrWFJQVy9UUUJ3R2NEOTM3amx2OXRteGZXNlQxSGx4YklmU3htbmNPaWl0OHRKV1FtMFJwVUtpS2tJZ2hpNmRrQmhBZkFnRzFJR1ZsVy9BM2gzeEhSaVJtQmhZVXM3dHdKMTB3ejAzL0gvM0tGQ09ieEp5U1g0b00wVUI1V0NhQWEwVHhST2t3aE5NRTAxTU1LVUJpekl2bldBazc0ZkNNeEJFY1pTTm9nUUc0VWd6d1dKOEdadXFXU3ZPTjN0am9PdEdGTHpKT2UrMjZXcWZQL0tKelUrNWE0aTk0TjR1RUFpWm16N24xYXBmS3RSZTVUR3VGdGRIMW16TDJhZFI0TGRJbDhYbElvRjY3SDcrYzBZN0dzN082M0VVZHY5SFdJazJQcXFkQWhTNWlMSitzMEZDWEN0OVpUL1hTQW03bGNpSkhhWjVJaFdaQkV3bHNvODRHK1hiaHlkVjhnR2RJb3NsaW1uNUZ3aHZtRDhsN1RmRnQrK1RsNnFjMXhJd3FnMnI3ZXdHRGFGNW84UDVPYUZ6YmgyZTk3WjFXcXZxTGo0bEZJNjdWZHR2dWFhRktQYjNHaFVOSHhiejVEa2w3dnBxMjdiTGZtbUpvTnhZR2JSZXBDck9ubHc4dHZrQlJWZVlBcWExK1B1Tmw4TkFSVzg3bXM5T1JnaGJYTCsxRFc1KzRUZStLenU1YldUQVk1N3NabmhuNEhja0tiazdNK0ZKbUNGSDZNczJaWXNTNldWNWJ6R0x4WlFrWUYvVEVOaFpiYVluRDZ0cVFTYzljL1B5MlFYSWd5WU5pSHIxdWpKc1cxM0FGYVZnckorK295U01kaXJ0QWVpa2NiL3NMNGZPOG5MeXN6NjExK29sUXVxK0J0VGpTcVRpYUR6WXF5SnN6cDRDekdDdXFkdEVjMHJZWE92WVJnSFFuVVlaYXJna1V4VkUwdjRCLzFCVW5BQUFlTnBqWUdSZ1lBQmkzaE5INThiejIzeGxZR1poQUlISEF2TStJT2ovdWt6SG1DNEN1UndNVENCUkFFUWhDN01BZU5wallHUmdZR2I0ejhEQXdIU01RZWYvQmFZc0JxQUlDbUFCQUdVY0JEZ0N4Z0FBQWpvQVN3STZBQ3dDS0FBd0FBQUFBQUJtQU5RQlFnQUFlTnBqWUdSZ1lHQmhjR0ZnWWdBQlJnWTBBQUFIamdCTmVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS01pQkdXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZEcwcy94dlBiZkdWZ1ptRUFnY2NDOHo0ZzA4d1RtV3lBRkFjREU0Z0hBRVFaQ2xrQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00Ni41NTA1MTgnIHk9Jy02MS42Nzg5OTcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTM5LjA3ODUxOScgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMi41MzEwNCwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ni41NTA1MTgsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDYuNTUwNTE4JyB5PSctNjEuNjc4OTk3Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00MS44ODM5MzQnIHk9Jy02NC42ODU1MTUnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzcuNzE4OTY1JyB5PSctNjEuNjc4OTk3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zNC42MDU2MjEnIHk9Jy02MS42Nzg5OTcnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTMwLjQ2ODY3MScgeT0nLTYxLjY3ODk5Nyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzguNDkzOTEnIHk9Jy02NS4yOTQzNjEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOS43MDgzMyAwSDQ2LjQwMzc4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjY1Mzc4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjQuMzI1ODIsNC43ODQwMSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Ni41NTA1MTgnIHk9Jy02MS42Nzg5OTcnPs61PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Mi43ODY0OTYnIHk9Jy02MC42ODI3MzMnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NC01Ni45MDU1SDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNS45NjQsLTY0LjU3ODQxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \DiagramSquare {
              sw = A,
              nw/style = pullback,
              se = B,
              nw = A',
              ne = B',
              south = f,
              east = g,
              west = f^{*}(g),
              north = \varepsilon _{g},
            }
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          Let <fr:tex
display="inline"><![CDATA[\alpha \colon g\to g']]></fr:tex> be a morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. By the construction of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>, we have the following commutative diagram.
          
    
      
      <fr:figure><fr:resource
hash="e13b4e05f371e68c21c24c6a30757ac5"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5OC4yMjM2MjFwdCcgaGVpZ2h0PScxNzUuNDY3NzY2cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTMyLjE0OTA4MSAxMTYuOTc4NTExJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLSXgvdEdob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0o1cHovdGpPZTMrY3JBek1JQUFvOEY1ajFHMFA5MW1FTVlqd0s1SEF4TUlGRUFZblVMOXdCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPc0FBb0FBQUFBQkJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUUwQUFBQmdxbU5pZTJOdFlYQUFBQUZFQUFBQU13QUFBRHllV21SYloyeDVaZ0FBQVhnQUFBRGdBQUFBN0QwTlFsdG9aV0ZrQUFBQ1dBQUFBQ3dBQUFBMktZeUEvMmhvWldFQUFBS0VBQUFBSHdBQUFDUUY3Z0RhYUcxMGVBQUFBcVFBQUFBTUFBQUFEQWtLQU8xc2IyTmhBQUFDc0FBQUFBZ0FBQUFJQUZRQWRtMWhlSEFBQUFLNEFBQUFGd0FBQUNBQUJRQTJibUZ0WlFBQUF0QUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1abWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUE0TURqSjFTWEpiT3dLWWsvc0NBV2V1UEpRTURzeGJ6Y2FBd0kwTDEvLzhNREFEb3R3N2ZBQUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFabVJnVWhKL1lQRC9Qd01EaEw3N1N2NFNXQlVRQUFDbmlRbXlBSGphTFk1UFNzUXdIRWJ6cGNNdlZOUGFQMm5Tb2s3SERLYTdrU2wxQ2lMMUVvb2JzWWpRdld0dm9PQVJSbkRuR2J5R3l6bUxtTVdzSHQvN05vK0JmYkFsZjhhT2RZeWgzN1JhMFJHMDBTYUd1MEFORWl0ME54RFVXT2ZwR3RjTWFHczA3ckxiOU5vSXZIM0tTcVgwZlgrWGM2Z3EvSXFJMnpRbitYNU9VVkY2cnppS010cEt5bFBMRDNFOGhzckdmRGc5RTJXbVFFL1QxVHhBWnRiVGJRRmxrLzBSanRQNklNckE2MGVmeGtiVzRKVmZzOFNQZ0phK284OEg5SzAySlBEeVMxTG53V3diVlBQS0FUUHMvaDVTSWFJRVAvRUNpeE1wMlQ5dWZCL1FlTnBqWUdSZ1lBQmlSbStWbS9IOE5sOFptRmtZUU9DeHdMekh5RFJMS0pNTmtPSmdZQUx4QVBsb0NIdDQybU5nWkdCZzF2cGp5Y0RBRXNvUXorREJsTXdBRkVFQnpBQklkUUxOQUFSVkFBQUM4Z0NPQWNNQVh3QUFBQUFBVkFCMmVOcGpZR1JnWUdCbU1HVUEwUXhRRWdrQUFBWGxBRHdBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzRBQUFBMktBdUF4R2hvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRoTmNpdy9IODl0OFpXQm1ZUUNCeHdMekhpUG8vNHhNbDVsQlhBNEdKaEFGQURldkNxc0FBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV1FBQW9BQUFBQUJwZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGNEVtTnRZWEFBQUFFOEFBQUFOUUFBQUVRRHhnU0haMng1WmdBQUFYUUFBQUs0QUFBRFZLVWdxMlJvWldGa0FBQUVMQUFBQUM4QUFBQTJKLzZBd1dob1pXRUFBQVJjQUFBQUlBQUFBQ1FGNHdIT2FHMTBlQUFBQkh3QUFBQVVBQUFBRkF4YUFPWnNiMk5oQUFBRWtBQUFBQXdBQUFBTUFhSUNmbTFoZUhBQUFBU2NBQUFBR0FBQUFDQUFDQUJGYm1GdFpRQUFCTFFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGaEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZndaRGdZQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUlMazBwazNNbS85L3gvSVNvT3cvcy8rRS9USEg2d1dEQUFJREF4TkFBQUFlTnBOMHMxUDAyQWNCL0IrZnkzdDZGNzZzdllwYktOajY5cE9CRFpXNkFqZ3hzQ2d2QWdTaldURStKWWdFUzhtSmtxOCtROFlRemg0OWVyWmkzZnV4di9CbzRrWFBYZ0JuNDZEdGtrUHorOUordjA4MzBlQXNIblJvQ1A2Sml3TEFrUU5zcEtEVWczQ0RpTG1NRmxoWlhUUUZUMDVpSjJvZ3paZmJ6RW5CeThJZzdnZE5KQWpEVkhNNUJBZkYzUkpMd3ozWnVvTFFNME9SR2hsVGROcUZYRnNXdHR5S2EvdGFuYU9yWGhYbGdDUDhibnVhcHBwdW1xcThEQVo0L1Q4Yk1OWW5yVld4Y0J6eDZrbWgrbGhnclJwZi9pOUoxWVY3UFdMWWVEWC9vMHdHa3k5azZvcENQd2hZZkppaW55Y0NkUENhcUxoRW5rZzRZa3RXWEZZeEdJTzZITGtOTUs0bmJ3dUhLN2lHOFF1NHBDalpDVTVBdWEwa3ExVWVUSDg4cmp4UU9KNURZYWNXVElxMXBKWFlvclRYdS8xU2V4cHhucS9QcGNWQzJiV3hrbERoR1hQRmxiSGJkMUFFTG9ycFl5Q04rZTl4cjVJOXVSWUpaOVB1K29RSVYwYWJZN2ZqeVRzM1Q3WXptdlhSZFNZenFBYjUzKythR25mazFDZkMzckxPMjM0NDFwMllPdGUvS0xQQXh0dnluZlI1cGJaeUJuSXVKSmIvemZ4MnBMOFpiaElPdVV3UGcwU21XUHhYbU5xU2l5dDFqS21LaU9hR3UxWWs4YzM5eCtSdEdaWXU0ZmJ6eklFV2kwTktTb2ZGNGJMSnhLa29lYTE0aTAvNUQrT3lxL2U3OWNsbUtVMFNEVWpJaS8ySXREaCtwTWRTK2VXL2ExMHBYWDNxYTZDeUY0ejFwLzNHMTZyTDhLYm1uOWJuTDBHcW5KUDgrSUhmdUtyc0poMDFlYTU1Q1IwNnpLL2Rsa1JiK2J5R3pPSG8zSklHRXFWMzBwZW1oTW45ekNVUTlhbEJ1UlBrUThzanBXam5SdW1sTXBTWFo4NXVuY0FtaStMSGttbmp6T3RpbEVEYktaNkM5bmQxeUw1d1dLbTBvVFlLVjFOdXlPK05UTFMrRjdzNWllS0tsSFJWWUJpbUFra2JDdzBWMHo0NWVVN2dKeVRiVDJiSjhWU01UTlJ6ZWRTUU5iaXh5RDVRM3dxZ1hoVmZ3RyszbktBZU5wallHUmdZQURpbHhiblpPUDViYjR5TUxNd2dNQmpnWG1QRWZSL1hhWmpUQmVCWEE0R0pwQW9BRHdQQzI0QWVOcGpZR1JnWUdiNHo4REF3UFNEUWVmL0JhWXRERUFSRk1BS0FHOTlCTFVDeGdBQUFqb0FTd0k2QUN3QytBQS9BaWdBTUFBQUFBQUFaZ0RVQVR3QnFuamFZMkJrWUdCZ1pYQmhZR0lBQVVZR05BQUFCNmtBVG5qYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLTWlBLzJob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0xkRzh0VTQvbHR2akl3c3pDQXdHT0JlWStSYWVhSlREWkFpb09CQ2NRREFCK3JDWFFBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLRDZCbldob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0clpQdm9IeC9EWmZHWmhaR0VEZ3NjQzh4d2o2LzE5bU5xYTdRQzRIQXhOSUZBQkFpUXVWQUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNi4zMDU1NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIuMTU3ODU5JyB5PSctMjYuODgyMjY5Jz7ugLDugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC05LjYyOTg1OCwtMjMuMjY2OTA2KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy05LjYyOTg1OCcgeT0nLTIzLjI2NjkwNic+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQuOTYzMjc0JyB5PSctMjYuMjczNDIzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS43OTgzMDQnIHk9Jy0yMy4yNjY5MDYnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMi4zMTUwMzknIHk9Jy0yMy4yNjY5MDYnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNi40NTE5ODknIHk9Jy0yNi4yNzM0MjMnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc5LjE0Njc2MycgeT0nLTIzLjI2NjkwNic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MC4zMDY1NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTEuNTczMjUnIHk9Jy0yNi44ODIyNjknPu6AsO6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjg2MTEgMEg0NS4yNTEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDUuNTAxLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjIuOTczMzksNS42MjI5NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS44NjU4MzYnIHk9Jy0yMS40MzQ4NjMnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTIuMTk3Mjc5JyB5PSctMjIuOTAxNTkyJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNDkyOTA4JyB5PSctMjYuMjczNDIzJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00NS4zOTEwOCwzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIuMTU3ODU5JyB5PSctMjYuODgyMjY5Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC42OTUzNi01MC4yMjQ1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzc5NjUsLTAuNjI2MTYsMC42MjYxNiwwLjc3OTY1LC04LjUwMDQ2LC01MC4zODEwNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTU5LjU5MDE1LC0yMS4zMTQ0NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00Ljk2MzI3NCcgeT0nLTI2LjI3MzQyMyc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0uNzk4MzA0JyB5PSctMjMuMjY2OTA2Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzIuMzE1MDM5JyB5PSctMjMuMjY2OTA2Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzYuNDUxOTg5JyB5PSctMjMuMjY2OTA2Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tMzAuNTI5OTcgNDEuNTE0OTRDMy4wNzcyOSA0Ni4yMjg4OCAyOS4xNzQ1OSAzNS42NzUyNSA0OS43NTI5OCA5LjMyMTYyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNjE1NDMsLTAuNzg4MTYsMC43ODgxNiwwLjYxNTQzLDQ5LjkwNjgzLDkuMTI0NTkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE3Ljc5OTY1LDQxLjgwMzM0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPs6xzrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLS42ODY0OTQnIHk9Jy0yMi4yNzA2NDInPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00tMzMuODI4MDggMzMuODI4NTdMLTkuMjc3MTYgOS4yODEwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE0LC0wLjcwNzA1LDAuNzA3MDUsMC43MDcxNCwtOS4xMDAzNyw5LjEwNDMxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00tMzQuNTMyNTYgMTQuODc4MDdILTguMjE5MTFWMjcuOTcyMjJILTM0LjUzMjU2Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMxLjUzMjU2LDE5LjYyODA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQuOTYzMjc0JyB5PSctMjYuMjczNDIzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS43OTgzMDQnIHk9Jy0yMy4yNjY5MDYnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMi4zMTUwMzknIHk9Jy0yMy4yNjY5MDYnPs6xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzcuNDk0MzgnIHk9Jy0yMy4yNjY5MDYnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                nw = A'',
                nw/style = pullback,
                ne = B'',
                sw = A,
                se = B,
                north = \varepsilon _{g'},
                west = f^{*}(g'),
                west/node/style = {right},
                south = f,
                east = g',
              }
              \node  [above left of = nw] (a') {$A'$};
              \draw  [->,morphism,bend right] (a') to node[swap] {$f^{*}(g)$} (sw);
              \draw  [->,morphism,bend left] (a') to node {$\alpha \varepsilon _{g}$} (ne);
              \draw  [->,morphism,exists] (a') to node[desc] {$f^{*}(\alpha )$} (nw);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          Thus, <fr:tex
display="inline"><![CDATA[\varepsilon _{g'}\Sigma _{f}(f^{*}(\alpha )) = \varepsilon _{g'}f^{*}(\alpha ) = \alpha \varepsilon _{g}]]></fr:tex> as required.
        </html:td>

      </html:tr>

    </html:table>
<fr:p>By construction, <fr:tex
display="inline"><![CDATA[\varepsilon _{\Sigma _{f}}\eta  = \mathsf {id}_{\Sigma _{f}}]]></fr:tex>. Thus, it remains to verify the other triangle equality.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[g \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex> be an object. We need to show that <fr:tex
display="inline"><![CDATA[f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} = \mathsf {id}_{f^{*}(g)}]]></fr:tex>. Note that <fr:tex
display="inline"><![CDATA[f^{*}(g)f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} = f^{*}(g)]]></fr:tex> by the construction of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>. Moreover, we also have the following equation.</fr:p><fr:tex
display="block"><![CDATA[       \begin {align*}         \varepsilon _{g}f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} &= \varepsilon _{g}\varepsilon _{f \circ  f^{*}(g)}\eta _{f^{*}(g)} && \text {by the construction of } f^{*}\\                                                     &= \varepsilon _{g}\mathsf {id} && \text {by the construction of } \eta \\                                                     &= \varepsilon _{g}       \end {align*}     ]]></fr:tex><fr:p>Thus, <fr:tex
display="inline"><![CDATA[f^{*}(\varepsilon _{g})\eta _{f^{*}(g)}]]></fr:tex> corresponds to the same cone over <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> as <fr:tex
display="inline"><![CDATA[\mathsf {id}_{f^{*}(g)}]]></fr:tex>. Then uniqueness implies that they are equal.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>