<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>882</fr:anchor><fr:addr
type="user">log-0009</fr:addr><fr:route>log-0009.xml</fr:route><fr:title
text="Elementary morphism">Elementary morphism</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>18</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[h\colon M\to N]]></fr:tex> be a <fr:link
type="local"
href="log-0006.xml"
addr="log-0006"
title="Sigma structure">homomorphism</fr:link> between <fr:link
type="local"
href="log-0006.xml"
addr="log-0006"
title="Sigma structure"><fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structures</fr:link> in a <fr:link
type="local"
href="ct-0019.xml"
addr="ct-0019"
title="Heyting category">Heyting category</fr:link> <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p><fr:ul><fr:li>The homomorphism <fr:tex
display="inline"><![CDATA[h]]></fr:tex> is called an <fr:em><fr:strong>elementary morphism</fr:strong></fr:em> if for all <fr:link
type="local"
href="log-0003.xml"
addr="log-0003"
title="Formulas">first-order formulas</fr:link>-in-context <fr:tex
display="inline"><![CDATA[\Gamma .\varphi ]]></fr:tex>, there is a morphism <fr:tex
display="inline"><![CDATA[g\colon {\mathopen {}\llbracket \Gamma .\varphi \rrbracket \mathclose {}}_{M}\to {\mathopen {}\llbracket \Gamma .\varphi \rrbracket \mathclose {}}_{N}]]></fr:tex> such that the following square commutes:
    
    
      
      <fr:figure><fr:resource
hash="feb385a3099f482a6b40e543fbedee8e"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0MC43Mzc3NzhwdCcgaGVpZ2h0PScxMTEuNjY4NjM4cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTMuODI1MTg2IDc0LjQ0NTc1OCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTWNBQW9BQUFBQUE0Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaVMxNHltTnRZWEFBQUFFOEFBQUFLZ0FBQURRQURBUG1aMng1WmdBQUFXZ0FBQUJvQUFBQWFGWWZEQ0pvWldGa0FBQUIwQUFBQUN3QUFBQTJLSVRNeUdob1pXRUFBQUg4QUFBQUhBQUFBQ1FHVndKVmFHMTBlQUFBQWhnQUFBQUlBQUFBQ0FaU0FGVnNiMk5oQUFBQ0lBQUFBQVlBQUFBR0FEUUFBRzFoZUhBQUFBSW9BQUFBRndBQUFDQUFCQUFpYm1GdFpRQUFBa0FBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEREFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRG1LY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRURBeEpJS1M1TFoyQmpuZ3lFRFArQmZHWUdScEF3STBMRmY2QXdBUEJ2RGU0QUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ1VnRFFMRUFMNXpKUC8vNGVRZi9MQThnd0FXWk1HOGdBQUFBRUFWUUFBQXdBQ3R3QWdBQUFCRnlNbUp5WUhJeVlHRnhFR0Zqc0JGU1luSXlJSE5UTXlOaWNSTmlZckFUVUMzaUlyQ2lvcmZKVWpFUUlESDBjc0xEUmdYazhmT3hzREF4czdId0szODJjd01BRUJFQmo5OVJrU0xRTUJCQzBTR0FJSkdCSXRBQUI0Mm1OZ1pHQmdBT0psTEllcjQvbHR2akl3c3pDQXdHTStseTVrbWptSWFUdVE0bUJnQXZFQStlOElKM2phWTJCa1lHQm0rTThBSklNWVFrRnNCcUFJQ21BQ0FDN0xBYlFEVWdBQUF3QUFWUUFBQUFBQU5BQUFlTnBqWUdSZ1lHQmlVR1FBMFF4UUVna0FBQVBXQUNjQWVObzlqREdyd2pBVWhiOWlGZTBiSEFTSE4wandCNFJLbjV1Ymc1T3J3OXVzQ2RLaHFhUzE2Q0wrZEc5RDhBWU8zejNuM0FBWkx4S0dTWmdISFNhVk40ODg1b2RGNUluNHE4Z1p2Nndaa2FRemNWYnNJcWRNK1k4OFpra1plU0wrSTNMR0grOTlVOS91bmZYcTJCanIzYVgyMjVQMWJkVTR0ZEg1c0I2c3MvN2NXYVBLcHpKOTFmYlhXaFU2MXdWN0dtcHUzT213ZUJSSGNVeGd4MFV5ejVaVDJGc3F5WngwTm1qeWIzcVExSVhHT2Z4aXBGSHlGRFgwY3RPS1hxV3JLTUtkcHZnQVZUSXVRd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVhFQUFvQUFBQUFCdEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXaDFibU50WVhBQUFBRTRBQUFBTlFBQUFEd0FsQUNTWjJ4NVpnQUFBWEFBQUFMdUFBQURsSzBYenE1b1pXRmtBQUFFWUFBQUFDOEFBQUEyS2NMTUJXaG9aV0VBQUFTUUFBQUFJQUFBQUNRSHZnTW9hRzEwZUFBQUJMQUFBQUFVQUFBQUZBK2xBUXhzYjJOaEFBQUV4QUFBQUF3QUFBQU1BZG9Dc20xaGVIQUFBQVRRQUFBQUdBQUFBQ0FBQ0FCU2JtRnRaUUFBQk9nQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRnVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVZtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHI2TW1Rd00vd0g4cGtoMGtocS9nT0ZBYmRDRE1jQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUSytqRmsvUDhQNVBzeXBQLy8vMy9ML3psZ1ZVQUFBSllIQ1NBQUFBQjQyaldTelc4YlJSakc5MzFuZHNiZWo1bjluQzNKeHJIalpOY2x3ZHZHemk0UTQ5U05CUlJLQ1J5b2loQzNTRWl0MmtxOVZDQWhRUzlGZk1NL3diK0FoT2dGcVJKM3hKRVROMjVJbFhxd3pVd0F6V1ZtbmxlYTUvYzhZNEYxZGJXaVgrTWo2OFN5Z0hDbU5xRk9XQVVTaWdyR2RhYnFKZ2JHdDBvWFdHWlVsUW1vZ0d0MUN0a1VtcmlwOWI3UGlqb2IxU3FMemZXb3poSldGb3lxaHhSNFZHNUsrOVBaa1Vzd0VDOXVrRytYYnpsSkFyY2Yyb0JKSlZvQTByNTEweUVJUHA4OGEzOUNvUlVrY1E4aStYM3FrVlA0M0JISkZ4c1FCVTJPSHl6K3pEZ0hwSDBPRkloMkZuS0FhQTNuaXdjSnlmSDI0bytVZWpsQjB0WUNwWG9nYUFIWlhVZFVuQUdoVzNxOEhTOGU0YXRDNjdIVXg4VFM2TllycXlYNUhYK3lEazBPQXZwYlJRbkVJR2Y3S3RXQmNGYitCMXo4endweGZWQlhVR2hoRXhvbG9CUkEzdm1LdEZ6ZVpzdmZIakRBZE5pV0pMcDEwMGNRN0hEWC9xdzNnMGg4R1hvMjJIY29tWnYzRGIwRVlVOTI4ZXJpVjlHeVBUeGQvSDJHWVR2blVFTUVVak1NT3RqbnR2SFB2TVZmOExOd1M0TVpHRXhjTjVDYUE2MjkxWE80QTc5WVErdjRYeExPak1IUnZ0S2Q4RXlOZEtOVE9OTEJES0dzRzdNNloxeDZnQnhCWFJhNk9NNjQwRTN2bTFIczNXM2Z1MSs5VDZHdlFnVWl5c05lTXVubmltZk5sZGtOSkRNWlhya3hPUERKV3VTbjhGMUZJRW5IYThmZE5BaDFOcDNMdWNmaHcrV3NlcGRndXJmUmkyTzM0OWdJYnY3TWhlNTdJd3JYVDA2dnhYSk9ZRnNGQ29KdytmUkg2ZTcwS1F3T2l0bWxOeHZZNlVyL3JLTTNWay93STN4c3ZXN0l0T1VPY2liQmVFMlpNVnVQc283bTFVdTNOOVl3QnE4b1RRYVM2azZIY05ERVV5aE11VHFTcGxZY1p0Znl0MTk0ZWV6cHY0aXg1enNrMzV4RUdEb01NamZzVHdmUEEvR0ZVdnIvRENZbjU2UWRkOXN0SjJ0SG9mME5SYm5kRGdBRW4rL3RBUDZ3Zk53YmdWMk4vZUdFSGE3M2V1RVdIcjBVSVdZWE1qV2sxWG5QN1c1ZlByNllYa1E4SGlqM3RZK0xkZWxDN0N1Yys5S2hqbXh4U3J4L0FGVG9ldU1BQUhqYVkyQmtZR0FBNGt1emYveU01N2Y1eXNETXdnQUNqL2xjdWhEMGYxMldmcWJqUUM0SEF4TklGQUJSSVFzWEFIamFZMkJrWUdCbStNL0F3TUFTemFEei96aExQd05RQkFXd0FnQmRDQVB1QXNZQUFBUmJBRXdEbmdCSEFqb0FMQUtzQUUwQUFBQUFBSVFBNkFGV0FjcDQybU5nWkdCZ1lHVUlaR0JpQUFGR0JqUUFBQWp1QUZ0NDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVRQUFvQUFBQUFCZlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hjbDRZV050WVhBQUFBRThBQUFBTlFBQUFFUUFZd1J0WjJ4NVpnQUFBWFFBQUFJekFBQUNxSzBmYmlwb1pXRmtBQUFEcUFBQUFDOEFBQUEyS1dETDcyaG9aV0VBQUFQWUFBQUFIZ0FBQUNRSFdBS1hhRzEwZUFBQUEvZ0FBQUFVQUFBQUZBMUhBT0JzYjJOaEFBQUVEQUFBQUF3QUFBQU1BUVFCM20xaGVIQUFBQVFZQUFBQUdBQUFBQ0FBQ0FCSmJtRnRaUUFBQkRBQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRkJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVdzNDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFRVWTc3S3pQQWZ5R2RtWUFRSk15SlUvQWNLQXdBS0V3NGRBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGs5Qmo4bUsvKy93OW0rWUpZL3kvLzMvcEhINndXREFEejRndk5BQUFBZU5vMWtNMVAxRUFZeHVlWmFhZmJiVHZ0YnJkZFliZTdaSkdPQ3JzWVdWdEJQa1FUaEhpQUJJMFNQdzdHUkl4dzRFQk11S0NKQVlrbUp2d2RocE5INGczL0FMMTcwSk5uejNXZDdzYThrL2NqejNONGZrTkFOZ2pJR2RraUJVSlNnVmJjVGE2RVoyaTJtK29sWWQ2YmhDalBSSytudGVrWGNsc2R6RVVEaWNBa0RCbkxibElOazlRSE4rS3JGbmpBd3liQ29LOXlwYzBqOVJPWmIxTkpXUFV4ajN6aE11YnM4enNOR0p1R283L2VMK3J3bkptR2Z2ejNLUys1Rys4MTFNWWREcUc5ZU80NDJ0d0VQOEN0aHVkKzhHMnNZYmNneW9jMXVPVTBvdHZaajdMaGNDMHl3QmlGNlhMQWI5QTcyU3Voc1lEdVpkK0U2UThCMUJTNUF6WFZMNDNRdXNkWXBLeEdLVHVseTRLRDFRMGc2TE5lNkdYc2dKNlN1WnhWWUpSTEpsa09WbFhCRlZaTEtvaWNLNTdFZjdBYTBpU1dYQ2xOcE9vSEJLUUE0eCtaYmxxRm5ubW9ZM2pjNytQWWdLVXJvQ010T2g4Sjc4aXorTTlkb0Q3dU10ajY1cVpKS1d4dHRrM1hzcStpd0VMNnFKejlFbVpwbU5KNlRtQzVBNEl4Z3c1Q0cwNzJHOSt0VWsyRkhUQnFQSjhYQ2FGa3FqZEM5M0JHT21TQmtHcmFnVXpTdkVJak5BU0NpbUxxM3cwRTNNaXJKVlZUNlZ1eFRBZFNOMVlvTHVWVEo4bjZZOUNHWlk4RWd0SmlSOTViank5N2xmVEo5Q3hiQ2FNSE82RTliRkR6bkc1V2NMeXpaaGVYV2FlN3REVmtGNmg3OHFteXVYSmpxVmE5em1nQjlzeWJvV3VycGJmYm8vV0hHbGJuWDk2UHFpdU1Ia3RXS3NMMi9yQkZzN2gwVnk1UXV2L3NabHY3QjFmb1l5RUFlTnBqWUdSZ1lBRGl2Z01LM2ZIOE5sOFptRmtZUU9BeG4wc1hndjZ2d0tMTHRBL0k1V0JnQW9rQ0FBMndDVG9BZU5wallHUmdZR2I0endBa0h6Sm8vTi9Bb3NzQUZFRUJyQUJnZndQMkFBQUNkZ0FBQVJ3QVdRUGhBQ3dETmdBb0FwNEFNd0FBQUFBQUZBQ0tBUEFCVkhqYVkyQmtZR0JnWmZCZ1lHSUFBVVlHTkFBQUNBMEFVbmphVFk2eGFzTXdFSVkvVThkUXA5Q3BIVG9VVFJtRmpmc0FnUXlac21Zc0pKRUlEa2dLc21QSUV2b0FmZWhlRkEwOXdmSGRkNytFZ0pvYkJmY3FlRTM5WGlXVlRBK2VNZWN0Y3lWSFphNzVZTUVUUmZrczVwTmw1cElYdmpQUGVPZVV1UkwvazdubWk5OVZjT2ZMYUtQYUJHT2pQempYdDgzV3hxRVBYclc2ZVlpMTlUYnVSbXZVL3FyTTFBL1QwYWxPTjdwalJjQng1c0tJSmNyUE5tSk1ZczlCZG82ZWxvWnRjb05NUVRaS25CYjdQN0dXaEUrcFhYck5TR3JQVmJwaGtzd2cvU2hwUlpmdWFyby8zL1F3dXdBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUFVBQW9BQUFBQUJFUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGNOM2ZtTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SEQvMGNaMng1WmdBQUFYQUFBQUQ5QUFBQkRLS2xPNWxvWldGa0FBQUNjQUFBQUMwQUFBQTJKN1BNRVdob1pXRUFBQUtnQUFBQUhnQUFBQ1FGZUFHRmFHMTBlQUFBQXNBQUFBQVFBQUFBRUFmdUFMOXNiMk5oQUFBQzBBQUFBQW9BQUFBS0FMSUFWbTFoZUhBQUFBTGNBQUFBRndBQUFDQUFCZ0FmYm1GdFpRQUFBdlFBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFEeEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtWW1PY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcHFNRTltWnZnUDVETXpNSUtFR1JFcS9nT0ZBY2RURFRRQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXltb3lULzcvSDhqWEFOSC9iLzRwQUtzQ0FnQ1d5d2twQUFCNDJpM05UMHJEUUJpSDRlODNVeE9SMnByUXpJU1ltcHJBeENKVUdrMUNFRjJJaW9oZHBZSWJMZjJqSXA3QUE0am42RXJ3QkwyT0c5ZXVYTmxxaUw0SGVGNENUWDRJZlU0a2laWWF2Z283U0ZXU0hpS3Fvd2FwbVI0RWNqSHV0bDNBVmQwN2dlck5HZGp4b002L1ZrYURxN2VEbytubCtMYTZOdngrZVZvc0prYUZpa0JaNGJiL1hBaE5yOEdQQ3pYY1V6dFFhUklKdVFGc2xhSzFlbjNPOGd1VEExYjVvWDl4TkgrZWZ2Yk1DaXMvaGVrVHNUNmJVYk13WmRDQkhpaE5HcHJZaHhVR2Vyd2JKYUdScUczRUxHMDZ5eWVQRDRFQjdwMXU1cTg5TzNNWWN6S2J6VDd1aDRCcHo5L1hSWXZ6VnNObHRtdDVSTC81eEMvNkFBQUFlTnBqWUdSZ1lBRGlxOWIyc3ZIOE5sOFptRmtZUU9BeG4wc1hndjdQd05UQURPSnlNRENCS0FEditRZ2hBQUFBZU5wallHUmdZR2I0ejhEQXdOVEFvQVFrUXhpQUlpaUFCUUEweEFJREFBQUNnQUFBQVkwQVpBR05BRGtDVkFBaUFBQUFBQUFzQUZZQWhnQUFlTnBqWUdSZ1lHQmhrR01BMFF4UUVna0FBQVBCQUNZQWVOcEZqREZ2d2pBUWhiK0lCSWwwNkZKMVlBQVB6RmFpTUhkaFlHSmxZZ0Zzb2d4eGtCTWlJYUdPL2QwOWpDVnVlUHJ1dlhjSDVQeVM4SnlFejZEUFNjbGtlM0hHQjErUnA3SXRJK2ZNV1RFaFNXZmlMUGlKbkVweWlKenh6U1h5VlB4SDVKdzFmNXV1dmQ0RzY5V3VNOWE3Yyt2TFltOTkzM1JPbGJvSSs5WTY2NCtETmVwMFYyWnMrckZ1VmFVTFhiR2hvK1hLalFHTFI3RVR4d1IybkNYemxCVHNnOVBUU09xa1ZhTEZmZWRieVYzb0hNTW5JNTBUZDFIREtGZTlhQzF0UlJVdU5kVS9ZejB2RHdBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OnN0bWFyeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNOEFBb0FBQUFBQTlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdjSEJaRm1OdFlYQUFBQUZBQUFBQUxnQUFBRFFBRE9DZVoyeDVaZ0FBQVhBQUFBQ0lBQUFBcUlPUE8vMW9aV0ZrQUFBQitBQUFBQzBBQUFBMkpyak1FV2hvWldFQUFBSW9BQUFBSHdBQUFDUUUxZlhqYUcxMGVBQUFBa2dBQUFBS0FBQUFDZ01MQUhkc2IyTmhBQUFDVkFBQUFBZ0FBQUFJQUNvQVZHMWhlSEFBQUFKY0FBQUFHQUFBQUNBQUJnQVpibUZ0WlFBQUFuUUFBQUMyQUFBQk5TQ1NTTXR3YjNOMEFBQURMQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1iR1djd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQjF3TnZack12Mmd3TXpHYmNWNEhDakFnVi8vOHpNQUFBTGp3UVF3QjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytRKzgvLzhIa2w3Ly84dHZCOHN6QUFCbXBRZUhBQUI0Mm1OZ1lpai96OERZeXN6QUlNd2d6c0FnTG1obWJpd21Mc3JHcml3SXBkV0VnY3h5UnE3djNJeU0zRkZSSVBJN1YxMVkyRmZtVjF5TWpGekNYSXgvZ3NBVUkvTzFQMEVNUU1ERUlBazBVd1ZvSmpQWVRHTkJaV0dRUWVxbVFNTUZvYlNZK0pMdzhBWkdycThnUThMRFFTU1FlWjE1M1I4VHFMSE02eURHY2dHTkJBQXVneHc0ZU5wallHUmdZQUJpdVlPVEErTDViYjR5TUxNd2dNQmpQcGN1QlAyZmdiR1ZHY1RsWUdBQ1VRRDkyUWg3QUFBQWVOcGpZR1JnWURiN29zM0F3RGlYUVpKQmdyR1ZBU2lDQXBnQVJsUUNzZ0FCVlFBQUFaMEFkd0FaQUFBQUFBQUFBQ29BVkhqYVkyQmtZR0JnWnBCZ1lHSUFBVVlHTkFBQUF5Y0FJSGphYll3eEQ0SXdFSVVmRVFqaXd1U2dTeFAzQmxKWFp5WlhOb2NTR3NKQVNTZ2hZWEh4ai9zZzFVVnZ1UHZ1M1hzSElNVVRBZFlLa0d4OXJaQ2NlSTV3UU9ZNXBucjJuT0tFQzNZSXdqMlZERGZQSWZudU9jSVJEODh4ZGVjNXhSVXZOL1Y2WElyOE15c3p1bTZ3b3BCZnFUVFdqSG95amFnWDBjeWRtOXRlS0psTHhWY1RlbWlNV0ZBZy85a3JHTEpEaHdFV2dwcjg0eXJwc3B0VDgyTFEwRm56SmtnenM0NjlaVUpBYlhrSjlRYkJ1UzZwQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OnN0bWFyeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTEuNTIwNTQzLC02My4zNzI2Mjgpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTYuMjUwNzIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjUyMDU0MywtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01MS41MjA1NDMnIHk9Jy02My4zNzI2MjgnPu6BijwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDcuNTA3ODA1JyB5PSctNjMuMzcyNjI4Jz7OkzwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDEuMjgxMTM2JyB5PSctNjMuMzcyNjI4Jz4uz5U8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTMxLjk5NjQ5NScgeT0nLTYzLjM3MjYyOCc+7oGLPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yNy45ODM3NicgeT0nLTYwLjM4Mzg1MSc+TTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTUuNjA0ODksLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS41MjA1NDMsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTEuNTIwNTQzJyB5PSctNjMuMzcyNjI4Jz7ugYo8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ3LjUwNzgwNScgeT0nLTYzLjM3MjYyOCc+zpM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQxLjI4MTEzNicgeT0nLTYzLjM3MjYyOCc+Ls+VPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zMS45OTY0OTUnIHk9Jy02My4zNzI2MjgnPu6BizwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjcuOTgzNzYnIHk9Jy02MC4zODM4NTEnPk48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOS40MDk3Vi00Ny40OTU3NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDcuNzQ1NzcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03LjQxNjMyLC0zMC40NTI3MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjUyMDU0MywtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01MS41MjA1NDMnIHk9Jy02My4zNzI2MjgnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDQuNDk1NzcsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjUyMDU0MywtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01MS41MjA1NDMnIHk9Jy02My4zNzI2MjgnPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQwLjc2OTInIHk9Jy02My4zNzI2MjgnPijOkyk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDUuMzI5MTIsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS41MjA1NDMsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuNTIwNTQzJyB5PSctNjMuMzcyNjI4Jz5OPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Mi40Mjk2NTMnIHk9Jy02My4zNzI2MjgnPijOkyk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTIzLjAwNjI2IDBIMzkuNDQwMjMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMjMuMjU2MjYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzOS42OTAyMywwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMwLjM3MzI1LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS41MjA1NDMsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTguOTA5NzNWLTQ3LjQ5NTc3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDcuNzQ1NzcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0zMC4yMDI3NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjUyMDU0MywtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01MS41MjA1NDMnIHk9Jy02My4zNzI2MjgnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ2Ljg1NjI4NScgeT0nLTYyLjM3NjM2NCc+zpM8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTIyLjM2MDQzLTU2LjkwNTVINDAuMjczNTcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMjIuNjEwNDMsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQwLjUyMzU3LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzMC40NjcsLTU5LjcxNzMyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNTIwNTQzLC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \DiagramSquare {
        nw = {{\mathopen {}\llbracket \Gamma .\varphi \rrbracket \mathclose {}}_{M}},
        ne = {M(\Gamma )},
        sw = {{\mathopen {}\llbracket \Gamma .\varphi \rrbracket \mathclose {}}_{N}},
        se = {N(\Gamma )},
        north/style = {>->},
        south/style = {>->},
        east = {h_{\Gamma }},
        west = g,
      }
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  
    Here, <fr:tex
display="inline"><![CDATA[h_{\Gamma }]]></fr:tex> is a shorthand for <fr:tex
display="inline"><![CDATA[h_{A_{1}} \times  \cdots  \times  h_{A_{n}}]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[A_{1},\ldots ,A_{n}]]></fr:tex> are sorts appearing in the context <fr:tex
display="inline"><![CDATA[\Gamma ]]></fr:tex>.</fr:li>
  <fr:li>The homomorphism <fr:tex
display="inline"><![CDATA[h]]></fr:tex> is called an <fr:em><fr:strong>embedding</fr:strong></fr:em> (alternatively, <fr:tex
display="inline"><![CDATA[M]]></fr:tex> is a <fr:em><fr:strong>substructure</fr:strong></fr:em> of <fr:tex
display="inline"><![CDATA[N]]></fr:tex>) if the square above is a pullback for all <fr:link
type="local"
href="log-0003.xml"
addr="log-0003"
title="Formulas">atomic formulas</fr:link>.</fr:li>
  <fr:li>The homomorphism <fr:tex
display="inline"><![CDATA[h]]></fr:tex> is called an <fr:em><fr:strong>elementary embedding</fr:strong></fr:em> if the square above is a pullback for all first-order formulas.</fr:li></fr:ul></fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Backlinks">Backlinks</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>883</fr:anchor><fr:addr
type="user">log-000B</fr:addr><fr:route>log-000B.xml</fr:route><fr:title
text="Model">Model</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>18</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[M]]></fr:tex> be a <fr:link
type="local"
href="log-0006.xml"
addr="log-0006"
title="Sigma structure"><fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structure</fr:link> in a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
  Fix an <fr:link
type="local"
href="log-000A.xml"
addr="log-000A"
title="Axiomatization">axiomatization</fr:link> of a theory <fr:tex
display="inline"><![CDATA[\mathscr {T}]]></fr:tex> interpretable in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
  Then <fr:tex
display="inline"><![CDATA[M]]></fr:tex> is a <fr:em><fr:strong>model</fr:strong></fr:em> of <fr:tex
display="inline"><![CDATA[\mathscr {T}]]></fr:tex>, denoted as <fr:tex
display="inline"><![CDATA[M \vDash  \mathscr {T}]]></fr:tex>, if every axiom of (the given axiomatization of) <fr:tex
display="inline"><![CDATA[\mathscr {T}]]></fr:tex> is <fr:link
type="local"
href="log-000T.xml"
addr="log-000T"
title="Satisfaction">satisfied</fr:link>.</fr:p><fr:p>The category <fr:tex
display="inline"><![CDATA[\mathscr {T}\text {-}\mathsf {Mod}(\mathcal {C})]]></fr:tex> is the full subcategory of <fr:tex
display="inline"><![CDATA[\Sigma \text {-}\mathsf {Str}(\mathcal {C})]]></fr:tex> spanned by the models of <fr:tex
display="inline"><![CDATA[\mathscr {T}]]></fr:tex>, and the category <fr:tex
display="inline"><![CDATA[\mathscr {T}\text {-}\mathsf {Mod}(\mathcal {C})_{e}]]></fr:tex> has the same objects as <fr:tex
display="inline"><![CDATA[\mathscr {T}\text {-}\mathsf {Mod}(\mathcal {C})]]></fr:tex> but the morphisms are all <fr:link
type="local"
href="log-0009.xml"
addr="log-0009"
title="Elementary morphism">elementary morphisms</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Related">Related</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>884</fr:anchor><fr:addr
type="user">log-0006</fr:addr><fr:route>log-0006.xml</fr:route><fr:title
text="Sigma structure">Sigma structure</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with finite products and <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> be a <fr:link
type="local"
href="log-0001.xml"
addr="log-0001"
title="Signature">signature</fr:link>.
  The category of <fr:em><fr:strong><fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structures</fr:strong></fr:em> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, denoted as <fr:tex
display="inline"><![CDATA[\Sigma \text {-}\mathsf {Str}(\mathcal {C})]]></fr:tex>, consists of the following data:</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
  
  <html:tr>
    
  <html:th>Objects</html:th>

    
  <html:th>Morphisms</html:th>

  </html:tr>

  
  <html:tr>
    
  <html:td>
      A <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structure consists of the following data:
      <fr:ul><fr:li>Each sort <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> is associated with an object <fr:tex
display="inline"><![CDATA[MA]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
          This is extended to any finite string of sorts by the assignment <fr:tex
display="inline"><![CDATA[M(A_{1},\ldots ,A_{n}) \mapsto  MA_{1} \times  \cdots  \times  MA_{n}]]></fr:tex>.
          The empty string is associated with the terminal object <fr:tex
display="inline"><![CDATA[1]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:li>
        <fr:li>Each function symbol <fr:tex
display="inline"><![CDATA[f\colon A_{1},\ldots ,A_{n}\to B]]></fr:tex> is associated with a morphism <fr:tex
display="inline"><![CDATA[Mf\colon M(A_{1},\ldots ,A_{n})\to MB]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:li>
        <fr:li>Each relation symbol <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1},\ldots ,A_{n}]]></fr:tex> is associated with a subobject of <fr:tex
display="inline"><![CDATA[M(A_{1},\ldots ,A_{n})]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:li></fr:ul>
    </html:td>

    
  <html:td>
      Let <fr:tex
display="inline"><![CDATA[M]]></fr:tex> and <fr:tex
display="inline"><![CDATA[N]]></fr:tex> be <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structures.
      A <fr:em><fr:strong>homomorphism</fr:strong></fr:em> <fr:tex
display="inline"><![CDATA[h\colon M\to N]]></fr:tex> consists of an indexed family of morphisms <fr:tex
display="inline"><![CDATA[h_{A}\colon MA\to NA]]></fr:tex> for each sort <fr:tex
display="inline"><![CDATA[A]]></fr:tex>.
      This data is subject to the following conditions:
      <fr:ul><fr:li>For each function symbol <fr:tex
display="inline"><![CDATA[f\colon A_{1},\ldots ,A_{n}\to B]]></fr:tex>, the following square commutes:
          
    
      
      <fr:figure><fr:resource
hash="68256d5cdadb620029f9ea7e4d51a670"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI1MC41ODkzMnB0JyBoZWlnaHQ9JzExOS42OTY4NjJwdCcgdmlld0JveD0nLTcyIC03MiAxNjcuMDU5NTQ3IDc5Ljc5NzkwOCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU4wQUFvQUFBQUFBOWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ2lNSnk0Mk50WVhBQUFBRkFBQUFBTVFBQUFEd0JDUUQwWjJ4NVpnQUFBWFFBQUFDbEFBQUFxUDdSclZSb1pXRmtBQUFDSEFBQUFDOEFBQUEyS01UTC9taG9aV0VBQUFKTUFBQUFIZ0FBQUNRR2NnQTZhRzEwZUFBQUFtd0FBQUFNQUFBQURBaDlBU1pzYjJOaEFBQUNlQUFBQUFnQUFBQUlBQm9BVkcxaGVIQUFBQUtBQUFBQUZ3QUFBQ0FBQlFBamJtRnRaUUFBQXBnQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBRGFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU1tQmlTUVVseVdEcFRjem5DZFdmR1BFUU1Ec3lMek9hQXdJMExGLy84TURBQXJ6QStVQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWU5JQTBHNUJtQk1wdVo3aisveitRRDZiL2UvM1hCcXNDQWdDdlZBbjNBQUFBZU5vVmpVOEtna0FjUm4vZitHZHExQ1RVVVNNd0xYUVpHT2dpeVBQVXRndDRwKzdRcmhzRURxNTAweFZxZW9zSER6NzRDSFNuSjAwNGswTVVyTUNMc3JxZ3JlV0UzU1k2UUZ2dVFVbU9iUHNYYVVDUDc0ZTlXVUM1RHA1QlJ2YStPSUxiVlZtVkhhcXliZG9tUTRmbVZNZVN2VlIvdGN4UThIbjBSTUtNWUJqV1lJbmpqc3F6RnFFSktOWGZUSkZhcy9MQllxNEh2b2daZkRXNFJyclVsejh0V2grNkFBQUFlTnBqWUdSZ1lBRGl2MXVTek9QNWJiNHlNTE13Z01CalBwY0dCUDMvSGZORUptRWdsNE9CQ1NRS0FDUzFDZjBBZU5wallHUmdZRmI4WXdRa0p6SVVNeFF6M1dFQWlxQUFaZ0Jhb3dPd0FBQURrUUFBQVZzQWN3T1JBTE1BQUFBQUFCb0FWSGphWTJCa1lHQmdabEJpQU5FTVVCSUpBQUFFQ2dBcEFIamFUWXc5YjhJd0VJYWZpQVNKZE9oU2RlZ0FIcGl0b0ZSaVkyRmdZbVhxQXRpZ0RIR1FIU0pGcWpyeXUzdTRIbnJENlhrLzdvQ1NIektlay9FYTkzTnlDbEYvWFBEQ1crS3BxRVhpa2crV1RNanltVGh6Tm9selNiNFNGN3h6U1R3Vi96dHh5U2VQYmRmZTdyMzFhdDhaNjkyNURlUDZZSDFvT3FkV3VvcDZaNTMxeDk0YWRScVZHWm93WEZ0VjYwclhiT2xvdVhHbngrSlI3TVV4a1IxbnlRSWphdzdSQ1RTU09tbXQwRlQvOHAza0xuYU84Wk9SemtrU0pUVElWWkI5bGJhaWpwZWEraGZ6ZVRCUEFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTWNBQW9BQUFBQUE0UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MUcyTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUJrQUFBQVpERnVBckpvWldGa0FBQUJ5QUFBQUMwQUFBQTJLSVRNcUdob1pXRUFBQUg0QUFBQUhnQUFBQ1FGeXdMV2FHMTBlQUFBQWhnQUFBQUlBQUFBQ0FZS0FKSnNiMk5oQUFBQ0lBQUFBQVlBQUFBR0FESUFBRzFoZUhBQUFBSW9BQUFBRndBQUFDQUFCQUFnYm1GdFpRQUFBa0FBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEREFBQUFCQUFBQUFnQUFNQUFYamFZMkJtWm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd5TS93SDhwa2gwa2hxL2dPRkFhTjNERmdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy85RHlQOFh3SHdHQUZGSEJvMEFBQUFBQVFDU0FBQUNOd0tyQUI0QUFBRVJCaFk3QVJVbUp5TUdCelV6TWpZbkVRNEJKeU0xTXhZL0FUWTNOaFlCbUFRaVRqTXNPdEU2TEROT0lRTXVWQk1TRWhJK0J6ODVHQTRDaS8zTkZ4UXRBd0VCQXkwVUZ3SUFFZ3dCTFFJS0Fnb3VBUWtBZU5wallHUmdZQURpSDFjZXA4YnoyM3hsWUdaaEFJSEhmQzROeURSekVOTnFJTVhCd0FUaUFRQXN5QWt6QUFBQWVOcGpZR1JnWUdiNHp3QWtneGdtTVRReW1UTUFSVkFBRXdCQzNBS29BQUFEVWdBQUFyZ0FrZ0FBQUFBQU1nQUFlTnBqWUdSZ1lHQmlrR2NBMFF4UUVna0FBQU9rQUNVQWVObzlqREdyd2pBVWhiOWlGZTBiSEFTSE4wandCNFJLbjV1Ymc1T3J3OXVzQ2RLaHFhUzE2Q0wrZEc5RDhBWU8zejNuM0FBWkx4S0dTWmdISFNhVk40ODg1b2RGNUluNHE4Z1p2Nndaa2FRemNWYnNJcWRNK1k4OFpra1plU0wrSTNMR0grOTlVOS91bmZYcTJCanIzYVgyMjVQMWJkVTR0ZEg1c0I2c3MvN2NXYVBLcHpKOTFmYlhXaFU2MXdWN0dtcHUzT213ZUJSSGNVeGd4MFV5ejVaVDJGc3F5WngwTm1qeWIzcVExSVhHT2Z4aXBGSHlGRFgwY3RPS1hxV3JLTUtkcHZnQVZUSXVRd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVJQUFvQUFBQUFCY3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDJIR050WVhBQUFBRTRBQUFBTWdBQUFEd0FyUUJ6WjJ4NVpnQUFBV3dBQUFJOEFBQUNsQ2p4ZUkxb1pXRmtBQUFEcUFBQUFDOEFBQUEyS1F2TXoyaG9aV0VBQUFQWUFBQUFId0FBQUNRSE5nTjVhRzEwZUFBQUEvZ0FBQUFRQUFBQUVBOGtBVUZzYjJOaEFBQUVDQUFBQUFvQUFBQUtBYkFBekcxaGVIQUFBQVFVQUFBQUdBQUFBQ0FBQ0FCVWJtRnRaUUFBQkN3QUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRS9BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVBzazRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWk1oalp2Z1A1RE5EcEpIVS9BY0tBd0R6aEExcGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS09qSGsvZjhQNUR1QzZQOEgvazhGcXdJQ0FKVkhDUm9BQUhqYU5aRy9iOU5RRU1mZjNYdjR4Zlp6Yk1lTzNSK3BXemZGYmlvYU4ybHFLeFZ5K2t1QnFGV0hJam9VQm9vNmdLQUxTRXdNU0NDRUdKRGdYMkJqWW1DRHFSSXE0aTlnWVdPQVA0QUZxU25QclhwM3c5MTlsL3ZjbHlDNWYzcEtqL0VuNlpLcmhJQVR3R0xxK1I1UHdJUW96c0gzMGl5QmtDc21LanlBelBmOE1oVGlkQlJIYVpaREJqbTBQVTVEL1AwRVJoWjBCMkJzWlcyd1VRRndSR21aR2Zid3U4UG9wbEFBbzVMT0FXemxjYWZKZEFSZWJxMEY4STViMDJMdkY5VHg2T1MxYllBaXhwRUNVTENxS2dDMyszdUE3TkRWMVlvR1NJVmNNcUJjdzFHRWVoUDd1aENQaHArSURFcWVTcFlmK0lYTWtnN3BFWkk1MlZLVWdCSXRkVkkvRE1CWGVKRUI4UE1tUEZmYXFiTW9PVHBSWEk4VVRpOTZ5b2N2cWUzV0hNZTE0UDJERjhqV0RXc3d1SGNINkk0d2J6MGZycGRkcjVwTmZEdzZmSU9EcmMrVE5udjQ5ZUF0Mjk3KzE2YzNjVlFZREFBVXc1VVVOMWI3ODVvNnE1cTdyYzFjVTVlcHBKUWdGdlRvM2RXNUhFRjRKMGU0djlVZTRQQ1BJMW1BM0Q3OVMrZmdtT3dRMHFQcFVockZaZmt3cU1meTcxbGFwT2ZMUzl0ZVZUR2hxS3BTekRrc1NvdmNNNzRteEdjT3BmRVpyMG5MaFd2WnQ5RFFGTERIcGlLQnFqQkswaEhOQ2JwVHUzeDh2ei9ZeGlyenl4ckRNT3FackZUb0U4SnFiQ1E5Uk5XWlI0bmFIckV2bDNoRFZXdmpIaWdIcnhibVBjT2VBYnpXMUZSRTdWSlNxeVVNNS9LWkZWenRYbG5SODdDbVczVUthNGtwZGQxdHVaV0V3VUpqdEpJOFM2NGphM2tqSGRmL01PbVlsVXBBL2dPdG1tRFhlTnBqWUdSZ1lBRGllNnZXSnNmejIzeGxZR1poQUlISGZDNE5DUHIvVitZYlRIZUJYQTRHSnBBb0FENWJDMk1BZU5wallHUmdZR2I0ejhEQXdLTEdFTVBneDN5REFTaUNBbGdBUWFvQ3VBQURWQUFBQkNVQWFRUW1BSHdEaFFCY0FBQUFBQUJtQU13QlNnQUFlTnBqWUdSZ1lHQmhDR1pnWmdBQlJnWTBBQUFKSEFCZGVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnd05xRmdZbVZxUXRnRjJXd2pad1FDYW5xMk4vZGgvSFFOMXlkKzJFRE5UOFUzSzlnbHZSK0paVzRCMWRNbVdlZWlIdkxYTFBnblNlSzhsbVNWejR5bDlKOFpxNTQ0U3Z6UlBMdnpEVXJmamZCWGE2RGpXb1hqSTMrNUZ5MzN0dllkOEdycFc2UzMxcHY0Mkd3UmgxdnlveGRQNTZkYW5Xald6WUVIQmV1REZnaWlwMGtKckhuSkoyalk4MCtKYjF3a0Z5eFJOUDg2N2ZTKzdRNXBKK01iSTdjUkEyakxIclJzMndWYlhxcGFmOEF5QkV2N3dBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVkwQUFvQUFBQUFCOGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXaDFaMk50WVhBQUFBRTRBQUFBUEFBQUFFd0JEZ0VQWjJ4NVpnQUFBWFFBQUFOVUFBQUVkTmhXZnZSb1pXRmtBQUFFeUFBQUFDNEFBQUEyS2NMTC9XaG9aV0VBQUFUNEFBQUFJQUFBQUNRSHdnTXBhRzEwZUFBQUJSZ0FBQUFZQUFBQUdCSjRBVnRzYjJOaEFBQUZNQUFBQUE0QUFBQU9CQXdDcW0xaGVIQUFBQVZBQUFBQUZ3QUFBQ0FBQ0FCU2JtRnRaUUFBQlZnQUFBRE5BQUFCT1BOZktxTndiM04wQUFBR0tBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUZtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHI2TXVReE0vd0g4cGtoMGtocS9nT0ZBYk0zRE1BQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdDeUFOQmNEQjFDT2ljR1BJWTBoZ3lIdi8zK2dtQytNL1gvTC83bi81L3lmRHRZQkJRQllWQTRVZU5xTjA3K1BHMFVVQi9COWIyWm52RDg4czc4M25IK2R2YzZ1RXdmNzd1eGJrN094enptTFFPNkFDMFZPVkZTUkVJbENSWVZBZ2pSQlFBQkJRUXNWSGY4QUlnMGlFaDBGb3FTaVM0ZWdzODNzSFFTSkFxRnRadWM3MHI3UHZMY2FhRWZyTmYwSUgyakhtZ2FFczZnQmVjRDZJQ0h0d3pDUG8zemtBK090ekFJV0Yya1VDK2dEVitrVTRpbU0vRkd1MWdsTDgzaVFSN0ZmYkEveU9HQlp5bWgwandMM3NvYlUzNTNQTElLTzJLdVJUMWJYelNDQU8vZDB3S0F2U2dCU3YzM0xKQWhsUHJtb3YwT2g1QVIrRXp6NWFXaVRtL0MrS1lJUGF1QTVveXErdXZ3MTVoeVFKaHdvRUZXWnl3RzhEVndzN3dha2luZVd2NFRVcmhJa2hnb29WUWVjRXBCdUJUSGlEQWh0cWVPR3YzeUF6d3FWKzFLOUJwcWlhMWZYSy9JemZxT05pM3NRa0xUU0RFaEJqbmVpVUYwSVo5bGY0UFJ2Sy9qNWJ0NkhWQVVOR0VVQ01nSGt4bjFTc3JqQlZqL2RaWUJoejVERXUzMnJqQ0RZdUt1LzE1eURKejUwYlIzMDF5bFpGTjh2OUJLRVB1bmkwZklIVWRKdHZMbjg3WlNobStkUUlSeXBESjA2Smx3djZtZjI4aEY4SzZ5c1lEb0ZFeXNGOHRSeHVPN2phL2lqdGw4NHBQSUw0SzJpeEVFVVI0eXJEazVoUnM3NnBUUnFmNmRvYVpKbWFUNVNuUlFvUWVGWUJsL3NPZFRaTU9iYm5UMkFkcGdTa0EwcFpidEphajE1VkVkZlhwZWhpSzRrRnlZQVNhUnlweTZsNTlYTjBzWXJSUXlmcmI2NzV1NFBnd09TSnZWTmJMUE1NaERvWWZqNTd5ZEVTVTVlcm1UcCtmWS9FVHlSUG5tZnRrcWduVnFlWC8rQmIrSkQ3YkN3cUdMcnlOa1pLV1R4VGo3S0IzRmROVVk5U2ppY2dkcFIwNmk2b0k1UlplckI3c2lmUXBxY1hjQW9qempNWDZpK2RQbVpvYTFtRDMyN2JKSnFZK0toYXpLSUxUZVpkcDRDVWhaUnBPYWxNemsrSjNWLzB5aVpzZUc1K3NjVVpkdHdBQVJmWERvUCtOWHFZWE1BZW45WTdrM1l1TkpzdWkyY1BlMGh4bHR4MUtQOUM3YTEyYjV5c0IxdUl4NTBJdXZhMjJsRld1Q1hJMXlVcFVsTldlS1UyTXE1cFp4Znd2ZmFpNW8ySS9udThKUlEvR1k5UlpwaVZJeWRtcmYvWlNjU0JVbXp0N3EyeGFSZmIxazZOeTBHZ1d0a0J3c2VuK3hmdWtFZTB6ZkgvNkxic3FBSDNjdUhYY0ZyZ1c2RTFRRG1YMi8xWWllc0F1ejNBZ3NRNWJ6dXQvSGlibk9NMkh2dXYvWGVnT0JrMnF5OWNSeElBWTZyL1FudTVaTTBlTnBqWUdSZ1lBRGlRb2wrLzNoK202OE16Q3dNSVBDWXo2VUJRZi9YWitsbnVnamtjakF3Z1VRQitNTUpHQUFBZU5wallHUmdZR2I0ejhEQXdCTE5ZUEQvT0VzL0ExQUVCYkFCQUYxbEEvTUN4Z0FBQkZzQVRBT2VBRWNDT2dCTEFxd0FUUUxUQURBQUFBQUFBSVFBNkFGT0FjSUNPZ0FBZU5wallHUmdZR0JqQ0dRQTBReFFFZ2tBQUFqeUFGc0FlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1NQUFvQUFBQUFBM2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVeDBvMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNFWjJ4NVpnQUFBV1FBQUFCWUFBQUFXT2ErZEJWb1pXRmtBQUFCdkFBQUFDd0FBQUEyS0FYTXBtaG9aV0VBQUFIb0FBQUFJQUFBQUNRRlZnSTVhRzEwZUFBQUFnZ0FBQUFJQUFBQUNBVWFBSEJzYjJOaEFBQUNFQUFBQUFZQUFBQUdBQ3dBQUcxaGVIQUFBQUlZQUFBQUZ3QUFBQ0FBQkFBYmJtRnRaUUFBQWpBQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBQy9BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9hTWhneU0vd0g4cGtoMGtocS9nT0ZBZFNCRE44QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpRy8vOUR5UDhYd0h3R0FGRkhCbzBBQUFBQUFRQndBQUFCNUFLcEFCa0FBQUVSQmhZN0FSVXZBUThCTlRNeU5pY1JEZ0VuTlJZMk56WVdBVmNESUVrbloxQndSaWRKSUFNc1ZCUWhkRE1WQ3dLTC9ja2FGU1VEQVFJQ0pSVWFBZ29VQ1FFa0FoWXVBUW9BZU5wallHUmdZQURpUGhibTRuaCttNjhNekN3TUlQQ1l6NlVCbVdhNnpMUVNTSEV3TUlGNEFOZGdCNlY0Mm1OZ1pHQmdadmpQd01EQWRKbWhnQ0daOFFrRFVBUUZNQUVBVnBvRGxBTFRBQUFDUndCd0FBQUFBQUFzQUFCNDJtTmdaR0JnWUdLUVlnRFJERkFTQ1FBQUF5Y0FJQUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzBBQUFBMko3UEwvV2hvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaXp6dnJnK1A1YmI0eU1MTXdnTUJqUHBjR0JQMmZnYW1CR2NUbFlHQUNVUUFkMkFrZkFBQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFYTUFBb0FBQUFBQnZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVWQwdm1OdFlYQUFBQUU0QUFBQVFRQUFBRXdBcEFEWFoyeDVaZ0FBQVh3QUFBTGNBQUFEa0ZJRkh3MW9aV0ZrQUFBRVdBQUFBQzhBQUFBMktXRE1GR2hvWldFQUFBU0lBQUFBSGdBQUFDUUhWQUtaYUcxMGVBQUFCS2dBQUFBY0FBQUFIQkhOQVZSc2IyTmhBQUFFeEFBQUFCQUFBQUFRQWhvQzhHMWhlSEFBQUFUVUFBQUFHQUFBQUNBQUN3QkpibUZ0WlFBQUJPd0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZ3QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm02bWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBycU1QZ3hNL3dIOHBraDBraHEvZ09GQWRaMURQVUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQ3lBTkJjREIxQ09pVUdIUVkvQmljSHYvMytnR0lqdHlPRDcvLy8vcS8rdi9ELzBmd2RZQnhRQUFEb1NEWElBQUFCNDJqMlN6V3ZVUUJqRzU1bEpKcHZkemN6dVpqZEx1MTl0ZDd2UmZsaHQxNnd0dW9MZldDelZnclpRRUFwYUJmVWdiUVV2OWlCK1lFVlFFRHg1OGVaVjhGSThDSXJIb21jRjlTVCtEZW42SnFXR1pESjU1eVU4ditkNUdkaDhkNHB0c1p1c3dGaGJhaWo0elhZSDdaWWw2L3ZRQ3RyZWxsR1hEUTlDOXc3QmNQTTlsVXJQVVZ4cUpROGd6Vlh2L0dUTzBPZ2JxY0ZnZElFdDBQT0ozV0FKK3AvQ1FMTVZqSHVmVUJ1dDBSMTQwVnFqUHM0YTNTNy95Yit6TVRaT25RamE0MTdSelhzVGdTZkhZUGxOdnhVVXZhQTlobjVMNXIxaVVGU2dlbFNlSUhrVDRqMnV5THdqMGZGR0MwaWJLK3NKRTA3S2JRbmIydTdPT0dYWEVYRE01ZmswMHZaQTU5WGYvalYrTVFOYmgrdWVGaFVMUW9BbnRBV2tpMWRQM3M4M011QmF5YWljMUJMMUw3Z1E4UWcyM0EyRjVKdXN5b2JZSVZMcXR1cStKRzM5VlJRVXJDcUs1SnEwK21XczE0M0VCVTIvM3BTVzJOMExhcGg0ODdUa1Y3VEcvT0tTV0orYm5nTS9uVG0zdXYyaXJOUlU5ZlhMeXlzYys0N2ZyN25tclkzRk5jNzNuL2w0eWdEVUxKL01jbEcyd005UG5WM1d5Wm5KNldPcVkwUUVjSEZTM0Q3Vk9NR2hlOEszNHM3TTRLelkvcDJUeVNpSGtXN1hHT1VmMkduNklBRlZCTEdCLzQxMVNYVHpZQXF5SUwwYXZFSjhHa0dRYURlSUVTbUxvb3NPb28zMG0xSzhlMFNTQmlmSjEvVjdTUk1aWjZwcVB0OWVrbG05OE1SQWFaamlVTWIxWmNjeGpveklCemhlemVnTk40MVpyQ1pVN21FSk90ZXU4SnZoajV6bFNDUE9nRk1pa2tpcWZEcThvd3hSNEhmRHI4cDJld0J1cXppbEVxMURmYnljRWFKQ3JWWTIzT1Jub3FUSUZCVGltZHRER1QyZ2pJNUVyQXAxNlF0ZlJHREZuV2thOEFraTRtcU9ZUmVzRkdjajZhU0dOamxBZzY4ZzVETmgycWxFMTM1b29uZllqWEhTUU1va29NZEdwVkZSbWNlWmxQeTFDcFNIdGFEQnUzYk41aHhwNC9Bb253MC9xNFR3K0dJdS9LM3NiQy9uNVlnZ3BYY0lCaTIrSTlweXdqLzRsc3FXU093T295R2o5MTcyRDNFdWlDSjQybU5nWkdCZ0FHSXJoME95OGZ3Mlh4bVlXUmhBNERHZlN3T0MvbS9Gb3N0MEY4amxZR0FDaVFJQThuWUl2d0I0Mm1OZ1pHQmdadmpQQUNRZk1xajgzOENpeXdBVVFRSHNBR0FsQS9RQUFBSjJBQUFCSEFCWUFSd0FXUU1BQUNRRENBQXJBK0VBTEFNMkFDZ0FBQUFBQUNnQVBBQ1FBT3dCWWdISWVOcGpZR1JnWUdCbjhHQmdaZ0FCUmdZMEFBQUlXZ0JWZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYuNzk0NzI1LC02MC40NDc1MDEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzIuODYwNSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNi43OTQ3MjUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNi43OTQ3MjUnIHk9Jy02MC40NDc1MDEnPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMy45NTY2MTcnIHk9Jy02MC40NDc1MDEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNy44MzA5OTEnIHk9Jy02MC40NDc1MDEnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMTUuMzAyOTknIHk9Jy01OC45NTMxMic+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScxOS43NzIzNicgeT0nLTYwLjQ0NzUwMSc+LDx0c3BhbiB4PScyNC4yMDAxNjgnPi48L3RzcGFuPjx0c3BhbiB4PScyOC42Mjc5NzYnPi48L3RzcGFuPjx0c3BhbiB4PSczMy4wNTU3ODQnPi48L3RzcGFuPjx0c3BhbiB4PSczNy40ODM1OTInPiw8L3RzcGFuPjx0c3BhbiB4PSc0MS45MTE0Jz5BPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNDkuMzgzMzk5JyB5PSctNTguOTUzMTInPm48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNTQuODA2MzkxJyB5PSctNjAuNDQ3NTAxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMi4wMjcxNiwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYuNzk0NzI1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYuNzk0NzI1JyB5PSctNjAuNDQ3NTAxJz5OPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzIuMjk2MTY1JyB5PSctNjAuNDQ3NTAxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzYuMTcwNTM4JyB5PSctNjAuNDQ3NTAxJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzEzLjY0MjUzNycgeT0nLTU4Ljk1MzEyJz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzE4LjExMTkwNycgeT0nLTYwLjQ0NzUwMSc+LDx0c3BhbiB4PScyMi41Mzk3MTUnPi48L3RzcGFuPjx0c3BhbiB4PScyNi45Njc1MjMnPi48L3RzcGFuPjx0c3BhbiB4PSczMS4zOTUzMzEnPi48L3RzcGFuPjx0c3BhbiB4PSczNS44MjMxMzknPiw8L3RzcGFuPjx0c3BhbiB4PSc0MC4yNTA5NDcnPkE8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc0Ny43MjI5NDYnIHk9Jy01OC45NTMxMic+bjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSc1My4xNDU5MzknIHk9Jy02MC40NDc1MDEnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOC45MDk3M1YtNDcuNDk1NzcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ3Ljc0NTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjIuNDM1OTEsLTMwLjIwMjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNi43OTQ3MjUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNi43OTQ3MjUnIHk9Jy02MC40NDc1MDEnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIuMTMwNDY3JyB5PSctNTkuNDQ1Njg4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9JzMuMDMwODE0JyB5PSctNTcuOTUxMjkyJz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzkuMjMxMzc1JyB5PSctNjAuNDQ3NTAxJz7Dlzx0c3BhbiB4PScxNy4yNzIyMzYnPsK3PC90c3Bhbj48dHNwYW4geD0nMjAuOTk5MDEyJz7CtzwvdHNwYW4+PHRzcGFuIHg9JzI0LjcyNTc4OSc+wrc8L3RzcGFuPjx0c3BhbiB4PScyOC45MDYwNjknPsOXPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMzYuOTQ2OTI5JyB5PSctNjAuNDQ3NTAxJz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzQxLjYxMTE4NycgeT0nLTU5LjQ0NTY4OCc+QTx0c3BhbiB5PSctNTguNDQ5NDM5Jz5uPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzUuOTE5MDQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYuNzk0NzI1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYuNzk0NzI1JyB5PSctNjAuNDQ3NTAxJz5NPHRzcGFuIHg9JzMuOTU2NjE3Jz5CPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzYuNzUyMzgsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Ljc5NDcyNSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Ljc5NDcyNScgeT0nLTYwLjQ0NzUwMSc+Tjx0c3BhbiB4PScyLjI5NjE2NSc+QjwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00zNy40MTYwNSAwSDcwLjg2MzUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzEuMTEzNSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ3Ljg1OTUzLDQuMTcyOTEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Ljc5NDcyNSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Ljc5NDcyNScgeT0nLTYwLjQ0NzUwMSc+TTx0c3BhbiB4PScxLjU1MDM4Nyc+ZjwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004NS4zNTgyNi02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDg1LjM1ODI2LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODguNjIyMTUsLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNi43OTQ3MjUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNi43OTQ3MjUnIHk9Jy02MC40NDc1MDEnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIuMTMwNDY3JyB5PSctNTkuNDQ1Njg4Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00zNi41ODI3LTU2LjkwNTVINzEuNjk2ODQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzEuOTQ2ODQsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjUwNTM3LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYuNzk0NzI1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYuNzk0NzI1JyB5PSctNjAuNDQ3NTAxJz5OPHRzcGFuIHg9Jy4yNjM1NDEnPmY8L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \DiagramSquare {
              width = 3cm,
              nw = {M(A_{1},\ldots ,A_{n})},
              ne = MB,
              sw = {N(A_{1},\ldots ,A_{n})},
              se = NB,
              north = Mf,
              south = Nf,
              west = {h_{A_{1}} \times  \cdots  \times  h_{A_{n}}},
              east = {h_{B}},
            }
          ]]></fr:resource-source></fr:resource></fr:figure></fr:li>
        <fr:li>For each relation symbol <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1},\ldots ,A_{n}]]></fr:tex>, there is a morphism <fr:tex
display="inline"><![CDATA[g\colon MR\to NR]]></fr:tex> such that the following diagram commutes:
          
    
      
      <fr:figure><fr:resource
hash="68bfacd7e58acc8e5d9f64ee34d4efb6"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI0NS41OTU3NjZwdCcgaGVpZ2h0PScxMTAuOTIxNDg0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTYzLjczMDUxMSA3My45NDc2NTYnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOMEFBb0FBQUFBQTlnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdpTUp5NDJOdFlYQUFBQUZBQUFBQU1RQUFBRHdCQ1FEMFoyeDVaZ0FBQVhRQUFBQ2xBQUFBcVA3UnJWUm9aV0ZrQUFBQ0hBQUFBQzhBQUFBMktNVEwvR2hvWldFQUFBSk1BQUFBSGdBQUFDUUdjZ0E2YUcxMGVBQUFBbXdBQUFBTUFBQUFEQWg5QVNac2IyTmhBQUFDZUFBQUFBZ0FBQUFJQUJvQVZHMWhlSEFBQUFLQUFBQUFGd0FBQUNBQUJRQWpibUZ0WlFBQUFwZ0FBQURPQUFBQk9CTi9LcnR3YjNOMEFBQURhQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FNbUJpU1FVbHlXRHBUY3puQ2RXZkdQRVFNRHN5THpPYUF3STBMRi8vOE1EQUFyekErVUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lOSUEwRzVCbUJNcHVaN2orL3orUUQ2Yi9lLzNYQnFzQ0FnQ3ZWQW4zQUFBQWVOb1ZqVThLZ2tBY1JuL2YrR2RxMUNUVVVTTXdMWFFaR09naXlQUFV0Z3Q0cCs3UXJoc0VEcTUwMHhWcWVvc0hEejc0Q0hTbkowMDRrME1Vck1DTHNycWdyZVdFM1NZNlFGdnVRVW1PYlBzWGFVQ1A3NGU5V1VDNURwNUJSdmErT0lMYlZWbVZIYXF5YmRvbVE0Zm1WTWVTdlZSL3RjeFE4SG4wUk1LTVlCaldZSW5qanNxekZxRUpLTlhmVEpGYXMvTEJZcTRIdm9nWmZEVzRScnJVbHo4dFdoKzZBQUFBZU5wallHUmdZQURpdjF1U3JPUDViYjR5TUxNd2dNQmpQcGQ2QlAzL0hmTkVKbUVnbDRPQkNTUUtBQ1V6Q2Y4QWVOcGpZR1JnWUZiOFl3UWtKeklVTXhRejNXRUFpcUFBWmdCYW93T3dBQUFEa1FBQUFWc0Fjd09SQUxNQUFBQUFBQm9BVkhqYVkyQmtZR0JnWmxCaUFORU1VQklKQUFBRUNnQXBBSGphVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9GUmlZMkZnWW1YcUF0aWdESEdRSFNKRnFqcnl1M3U0SG5yRDZYay83b0NTSHpLZWsvRWE5M055Q2xGL1hQRENXK0twcUVYaWtnK1dUTWp5bVRoek5vbHpTYjRTRjd4elNUd1YvenR4eVNlUGJkZmU3cjMxYXQ4WjY5MjVEZVA2WUgxb09xZFd1b3A2WjUzMXg5NGFkUnFWR1pvd1hGdFY2MHJYYk9sb3VYR254K0pSN01VeGtSMW55UUlqYXc3UkNUU1NPbW10MEZULzhwM2tMbmFPOFpPUnpra1NKVFRJVlpCOWxiYWlqcGVhK2hmemVUQlBBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1jQUFvQUFBQUFBNFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVeDFHMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNFWjJ4NVpnQUFBV1FBQUFCa0FBQUFaREZ1QXJKb1pXRmtBQUFCeUFBQUFDMEFBQUEyS0lUTXBtaG9aV0VBQUFINEFBQUFIZ0FBQUNRRnl3TFdhRzEwZUFBQUFoZ0FBQUFJQUFBQUNBWUtBSkpzYjJOaEFBQUNJQUFBQUFZQUFBQUdBRElBQUcxaGVIQUFBQUlvQUFBQUZ3QUFBQ0FBQkFBZ2JtRnRaUUFBQWtBQUFBREtBQUFCTXVzSWtlWndiM04wQUFBRERBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVptV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9hTWhneU0vd0g4cGtoMGtocS9nT0ZBYU4zREZnQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpRy8vOUR5UDhYd0h3R0FGRkhCbzBBQUFBQUFRQ1NBQUFDTndLckFCNEFBQUVSQmhZN0FSVW1KeU1HQnpVek1qWW5FUTRCSnlNMU14WS9BVFkzTmhZQm1BUWlUak1zT3RFNkxETk9JUU11VkJNU0VoSStCejg1R0E0Q2kvM05GeFF0QXdFQkF5MFVGd0lBRWd3QkxRSUtBZ291QVFrQWVOcGpZR1JnWUFEaUgxY2VaOGJ6MjN4bFlHWmhBSUhIZkM3MXlEUnpFTk5xSU1YQndBVGlBUUF0UmdrMUFBQUFlTnBqWUdSZ1lHYjR6d0FrZ3hnbU1UUXltVE1BUlZBQUV3QkMzQUtvQUFBRFVnQUFBcmdBa2dBQUFBQUFNZ0FBZU5wallHUmdZR0Jpa0djQTBReFFFZ2tBQUFPa0FDVUFlTm85akRHcndqQVVoYjlpRmUwYkhBU0hOMGp3QjRSS241dWJnNU9ydzl1c0NkS2hxYVMxNkNMK2RHOUQ4QVlPM3ozbjNBQVpMeEtHU1pnSEhTYVZONDg4NW9kRjVJbjRxOGdadjZ3WmthUXpjVmJzSXFkTStZODhaa2taZVNMK0kzTEdIKzk5VTkvdW5mWHEyQmpyM2FYMjI1UDFiZFU0dGRINXNCNnNzLzdjV2FQS3B6SjkxZmJYV2hVNjF3VjdHbXB1M09td2VCUkhjVXhneDBVeXo1WlQyRnNxeVp4ME5tanliM3FRMUlYR09meGlwRkh5RkRYMGN0T0tYcVdyS01LZHB2Z0FWVEl1UXdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzBBQUFBMko3UEwrMmhvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaXp6dnJ3K1A1YmI0eU1MTXdnTUJqUHBkNkJQMmZnYW1CR2NUbFlHQUNVUUFlVmdraEFBQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJZQUFvQUFBQUFCUGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDEvV050WVhBQUFBRTRBQUFBTVFBQUFEd0FyUUJ4WjJ4NVpnQUFBV3dBQUFHVEFBQUJ5TFBhU3NCb1pXRmtBQUFEQUFBQUFDOEFBQUEyS1ByTXpXaG9aV0VBQUFNd0FBQUFId0FBQUNRSEpRT0VhRzEwZUFBQUExQUFBQUFNQUFBQURBcitBTVZzYjJOaEFBQURYQUFBQUFnQUFBQUlBR1lBNUcxaGVIQUFBQU5rQUFBQUdBQUFBQ0FBQmdCVWJtRnRaUUFBQTN3QUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRVRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVhzVTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWk1oalp2Z1A1RE5EcEpIVS9BY0tBd0RvUVExS2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS09qTGsvZjhQNUlQcC93ZitUd0dyQWdJQWxTVUpHQUFBQUhqYUhZOC9iOU5RRk1YZnVlL3hudjg4Mi9HZjJHa1RRdDBVVzZsb25LVEZWaEJ5UWxRRkloQkRodzRWQ3hJTEF3dEl6SXlJa1kvQnpDZGdLZUk3c0RId0JSaHBzTG5uTHVlZTRaNGZJL1o2dCtQWDlKTXQyRVBHRUE1eFdzWkpyQXA0eVBJYVNWeFdCVklsUFpKcWlDcUpFeGR0ZUpqbFdWblZxRkJqSGl1ZTB1LzM2RTN0RU5oZnJiZm5BUkJxNDRGdy9Kc2ZvZUJQdFFSbGhxMEFYNzQ3bXdpYm9Oelplb2pQcW5Pb3IzNWhSTi8rZnZJZFNOMG5EbkIwdWlhZy9NMFZTTHlKYkRPd1FGdzNSd0d1TE5vampDYTBzYlYrZS9PVk5RUDJZdmVISCtPYVhUQzI1T1g5TXN2ZDVnbEdlZE8xS2x2RlNkTjRIbmVsaDNhN3N2VTFUaHVzU01sR0UrVC9xY3E4ZGRMamJrdGFmVThkUzhMZlA4ZzBtZG94R2dvckhDNE9MbFgvNVdiN25Mb2ljUzFCYWJiMGhOSG10M1ZuZkY0c2ljendoR2o3Yk43ejd4cHFiSnFEZmd6NTZ1UDBKSGI4STlEamlXVVNXYmVLd2FBUWRGd2ZyZWpSNHQ3S3J0T0IzUmx4ckF1dnllMW9GZ1dGd0hTOEZ4UWZpaWNrWm5IdkxFcSszQW05SUJpeWZ3NjZPbTBBZU5wallHUmdZQURpSzR3QzVmSDhObDhabUZrWVFPQXhuMHM5Z3Y3L2xmazQwMTBnbDRPQkNTUUtBQVl2Q2hRQWVOcGpZR1JnWUdiNHo4REF3S0xLRU1NUXpYeWNBU2lDQXBnQlFWNENzZ0FEVkFBQUJDVUFhUU9GQUZ3QUFBQUFBR1lBNUhqYVkyQmtZR0JnWmdobVlHSUFBVVlHTkFBQUNPb0FXM2phVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9NRGFoWUdKbGFrTFlCZGxzSTJjRUFtcDZ0amYzWWZ4MERkY25mdGhBelUvRk55dllKYjBmaVdWdUFkWFRKbG5ub2g3eTF5ejRKMG5pdkpaa2xjK01wZlNmR2F1ZU9FcjgwVHk3OHcxSzM0M3dWMnVnNDFxRjR5Ti91UmN0OTdiMkhmQnE2VnVrdDlhYitOaHNFWWRiOHFNWFQrZW5XcDFvMXMyQkJ3WHJneFlJb3FkSkNheDV5U2RvMlBOUGlXOWNKQmNzVVRUL091MzB2dTBPYVNmakd5TzNFUU5veXg2MGJOc0ZXMTZxV24vQU1nUkwrOEFBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWUlBQW9BQUFBQUIxd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVkMHdtTnRZWEFBQUFFNEFBQUFRZ0FBQUZRQW13RkJaMng1WmdBQUFYd0FBQU1WQUFBRDlEbXBVUGxvWldGa0FBQUVsQUFBQUM4QUFBQTJLV0RNRW1ob1pXRUFBQVRFQUFBQUhnQUFBQ1FIVkFLWmFHMTBlQUFBQk9RQUFBQWNBQUFBSEJIT0FWTnNiMk5oQUFBRkFBQUFBQkFBQUFBUUFpUURQRzFoZUhBQUFBVVFBQUFBR0FBQUFDQUFDZ0JkYm1GdFpRQUFCU2dBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGL0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtNm1hY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcnFNQVF4TS93SDhwa2gwa2hxL2dPRkFkYnBEUGtBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0J5QU5BOERCMUNPaFVHSFFZL0JrY0dQSWVqL2Y2QW9oT2NMNHYyLyt2L0svMFAvdC8vZkF0WUhCd0N1SWcvVEFBQjQybFdTejR2Y1pCekc4N3p2bXplVHljOUpaaEpuWnpLenU3T2J0TE03WGR6Skp1eHFwOGl3VnBCS0ViYmRvaWRCdDRJOTZTcnN4VldrdGFnVXZQbC9DRjZLdDRySG9uaFVVQThpbmdTdm1maE54Z29OeVp2M044L24rendLbE9QeVFIbXMzRkU2aXBKTEJ6YVNPSjhoVHpVNXVvUTB5NFBIWWlRM0FuQm5aUXpodDd0UjFMMkNtMm56V1pqTVhqbmU5NFNEMWUwaGhFSVBsRnYwUFZMZVVScDBuNDMxT00xMmcwY1lUb2IwWmtIVkRta2ZVemJLa3YzS2ZsWjJsRjNhaVN6ZkRVSy9IVXl6UU81QVMrSWt6Y0lneTNld3BzbDJFR2FoRFpxdnBxY2tiOHEvd1p1eWJVbk1na2tIcHZyZWVVT0ZaZmdwMTdWRitZclY5eTBPU3owNU5tSHE2N092L2xwN245MXdvVHZGZWVEd1NBUG5ZQTFIQTh6d3JjTlAyaHN1bUdQTGFycnBTSXkreDZ0TG51MnlGQlAyclhLVkJ0ekJBRmt0NUgrQlBxUVc3eG1RSFJrTUVYVHFWVWxycE5MUGtxcEhUS0dQR2FxT1RHTEp2LzVVQUp2N3BPLzh3NllLMXpvWXFGOHUzcEF0NTlabkFyMHR3ckxGMnllV0pTNXZ5N3VZRDF6bmM5L0VkWncyYk85ZUQ0NlhSK3hPOFl1bldWTFVMSXpJSk9BUDJNdkZCN2JnSFhaVy9HRHJmaGRndWwzVDlxZ2RyN0sreTNsRVc3Vlc4WkM5VkJIM3FRaWRtdlZDV2ZDNzdLRnl1V0sxTVpJSlQzZ0ZGaTVkV1U4SW91S0tkL0FFckljOGl4TkpLMFBrVkFFS2tBMHVIM0JWTnhxbGZrL0Z5cFpmNDVpQW9STFFmUkZ0UkxaNzN6WGtiNmRBZjh2aFpPRHQyenBqTU1YekUzYTkrTTV1OElDOTdoVy8yM3ByaGJGK1JXQTRTNEpOalMxRmExYnhKMzQwV2owU3UyUVVzdnBmclBJMUx2L2dLckc0eW1zVlRSV2FHZlpJZUZ5RjNCOGdiRHUxYVZNeU1jdkRvQjVyNUU5bDdSV3lhNCs0Umx3ang5dFBSZEpQUjdXdGEzUUhIY0Q1L04zREkzL1FFMmxuZjIvbU5COTBEN25RQkx4bi9JeWlLVlVFZG5SZ2puM3ZvbEFOcWJQSjRkbWNrLzlXNCtPUEtMVzJUZlovMFkrcEpoaWRuREh4NGxWMnV2Z0htOEhxVVgvdWFTWUQ4eFkvYWZsellmZGd2UnV0SWNsTnpwaHVqYjBMS211cVJ2Q0MyNzNrSjFZMFk0dS92U2VaK0MvZmxJbjlGcXNMZGpTL2xrNy9CUU83ak1jQUFBQjQybU5nWkdCZ0FPS3NiNUh1OGZ3Mlh4bVlXUmhBNERHZlN6MkMvbS9Gb3N0MEY4amxZR0FDaVFJQUQvY0paQUI0Mm1OZ1pHQmdadmpQQUNRZk1xajgzOENpeXdBVVFRSHNBR0FsQS9RQUFBSjJBQUFCSEFCWUFSd0FXUU1BQUNRRDRRQXNBellBS0FNSkFDb0FBQUFBQUNnQVBBQ1FBUVlCYkFINmVOcGpZR1JnWUdCbmlHRmdZZ0FCUmdZMEFBQUtOd0JvZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTU1BQW9BQUFBQUEzZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MG8yTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUJZQUFBQVdPYStkQlZvWldGa0FBQUJ2QUFBQUN3QUFBQTJLQVhNcEdob1pXRUFBQUhvQUFBQUlBQUFBQ1FGVmdJNWFHMTBlQUFBQWdnQUFBQUlBQUFBQ0FVYUFIQnNiMk5oQUFBQ0VBQUFBQVlBQUFBR0FDd0FBRzFoZUhBQUFBSVlBQUFBRndBQUFDQUFCQUFiYm1GdFpRQUFBakFBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFDL0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtNm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd5TS93SDhwa2gwa2hxL2dPRkFkU0JETjhBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy85RHlQOFh3SHdHQUZGSEJvMEFBQUFBQVFCd0FBQUI1QUtwQUJrQUFBRVJCaFk3QVJVdkFROEJOVE15TmljUkRnRW5OUlkyTnpZV0FWY0RJRWtuWjFCd1JpZEpJQU1zVkJRaGRETVZDd0tML2NrYUZTVURBUUlDSlJVYUFnb1VDUUVrQWhZdUFRb0FlTnBqWUdSZ1lBRGlQaGJtOG5oK202OE16Q3dNSVBDWXo2VWVtV2E2ekxRU1NIRXdNSUY0QU5mZUI2ZDQybU5nWkdCZ1p2alB3TURBZEptaGdDR1o4UWtEVUFRRk1BRUFWcG9EbEFMVEFBQUNSd0J3QUFBQUFBQXNBQUI0Mm1OZ1pHQmdZR0tRWWdEUkRGQVNDUUFBQXljQUlBQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVRnQUFvQUFBQUFCZXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZSjA4bU50WVhBQUFBRTRBQUFBTWdBQUFEd0Fod0MvWjJ4NVpnQUFBV3dBQUFJUkFBQUN0UGIwK2pob1pXRmtBQUFEZ0FBQUFDOEFBQUEySi9uTDcyaG9aV0VBQUFPd0FBQUFJQUFBQUNRRjBBSHRhRzEwZUFBQUE5QUFBQUFRQUFBQUVBcC9BS2xzYjJOaEFBQUQ0QUFBQUFvQUFBQUtBY2dBNG0xaGVIQUFBQVBzQUFBQUdBQUFBQ0FBQndCUmJtRnRaUUFBQkFRQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRTFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbW1zODRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWjhoalp2Z1A1RE5EcEpIVS9BY0tBd0RvZmcxa2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS1pqRGsvZjhQNUtlRDZQK3ovazhGcXdJQ0FKbmhDVUFBQUhqYWpkRTliOU5RRkFiZ2U4NTFmQnQvM1RpMjc0WFdOWEUrN0VDRGt6YUpUWlhnMUUyRVZDcmFpb0dxQ0xHeEl5RWtCSUxmZ1BnSlRHek03SWorSXlTV0ZMc0RBd05DNzNxRzl6a3ZRVEs0dW9zOStFNFNzaVFFcUFWTWplSWN4bnRDdWlxVFlpelNMSWNGcUN5Qk9NMnFCQ0J6eU1vRHVvQTBqdUpJWlNxelFNaTk2aFREbC9WWGI0YlBGZWdJVzREVjlPM1FuWGQ4d1dSMlZGd2dMYmg5ZE5HZm1uU3phWHJ3YVVqQjlTYWJ5NWJYc0NHS2cwUGZZUEIyWFF5ZlV2UUcyNkhqNklGV1E5RDltNlBXczdFQzUyY3ZUaHkrb3RBVkRRRU5lLzNyRzlkN0hRWDYwNmc0T00yZzErSW1LVEhrMGRWUGZJZVg1TGlTbFpVRFpDcUhxcXVuVm1YVHNReEtiNWwyRkU5S1RNV0w0dW9IWExHZ2s4QTBjM0tJT3UzcmwyU3BZRkNjK0kvM0gwd01RQmNkdzlTb2YydmVSRnRUUWVwMkorL2ZBMnBhUWlDSy92enNCcTg1cmZxR0p1dE51L1pSUWQ2dE53QXN0aHIwQUwrc0w4TXgxSVlUTTVtcnM2MHd0TnU0dU45RWxDTXBFbVY0MjlCYjNjUGxycmVMdU93TC9lR0hhSXZyNEpnQ1Z5YlhGSTF2TUlVYXBYTlVPai9ERDNKS3lJS20wOGsxd1lJaEpDVXBSMUhObFFyNVgzYkswYUpSL0g3SDBGWHVCRzI5eGpSZEJkZXV4OHNWaytjSGd5ZjBENzAxKzR0dThJcnU3dXdmNzFoczI2M1ZQZCtGNHVzb2tRM1BCemhJWEIwUWVSRTRYYnd6RFdlSXlkRy85YzB4eFhrZWJyOCtjN2xWcmsxK0F5dS9XTnNBQUFCNDJtTmdaR0JnQU9LQTVSc1d4L1BiZkdWZ1ptRUFnY2Q4THZVSStyOHUwekdtNDBBdUJ3TVRTQlFBSWNRS0lnQjQybU5nWkdCZ1p2alB3TURBZEpsQmgwR1VhUkVEVUFRRnNBQUFSVWdDd3dMR0FBQUNPZ0FzQXF3QVRRTFRBREFBQUFBQUFHNEE0Z0ZhQUFCNDJtTmdaR0JnWUdFSVlHQmlBQUZHQmpRQUFBaTZBRmw0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01OC41MTQxMzgsLTYzLjM3MjYyOClzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC05LjIzMDksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU4LjUxNDEzOCwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01OC41MTQxMzgnIHk9Jy02My4zNzI2MjgnPk08dHNwYW4geD0nLTQ3Ljc2Mjc5NSc+UjwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04LjM5NzU1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTguNTE0MTM4LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU4LjUxNDEzOCcgeT0nLTYzLjM3MjYyOCc+Tjx0c3BhbiB4PSctNDkuNDIzMjQ4Jz5SPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNy40MTYzMiwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01OC41MTQxMzgsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTguNTE0MTM4JyB5PSctNjMuMzcyNjI4Jz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjQ5Nzc2LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01OC41MTQxMzgsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTguNTE0MTM4JyB5PSctNjMuMzcyNjI4Jz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny43NjI3OTUnIHk9Jy02My4zNzI2MjgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQzLjg4ODQyMicgeT0nLTYzLjM3MjYyOCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzYuNDE2NDIzJyB5PSctNjEuODc4MjQ3Jz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0zMS45NDcwNTMnIHk9Jy02My4zNzI2MjgnPiw8dHNwYW4geD0nLTI3LjUxOTI0NSc+LjwvdHNwYW4+PHRzcGFuIHg9Jy0yMy4wOTE0MzcnPi48L3RzcGFuPjx0c3BhbiB4PSctMTguNjYzNjI5Jz4uPC90c3Bhbj48dHNwYW4geD0nLTE0LjIzNTgyMSc+LDwvdHNwYW4+PHRzcGFuIHg9Jy05LjgwODAxMyc+QTwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yLjMzNjAxNCcgeT0nLTYxLjg3ODI0Nyc+bjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSczLjA4Njk3OCcgeT0nLTYzLjM3MjYyOCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1My4zMzExLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTguNTE0MTM4LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU4LjUxNDEzOCcgeT0nLTYzLjM3MjYyOCc+TjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDkuNDIzMjQ4JyB5PSctNjMuMzcyNjI4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00NS41NDg4NzQnIHk9Jy02My4zNzI2MjgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTM4LjA3Njg3NScgeT0nLTYxLjg3ODI0Nyc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMzMuNjA3NTA2JyB5PSctNjMuMzcyNjI4Jz4sPHRzcGFuIHg9Jy0yOS4xNzk2OTgnPi48L3RzcGFuPjx0c3BhbiB4PSctMjQuNzUxODknPi48L3RzcGFuPjx0c3BhbiB4PSctMjAuMzI0MDgyJz4uPC90c3Bhbj48dHNwYW4geD0nLTE1Ljg5NjI3NCc+LDwvdHNwYW4+PHRzcGFuIHg9Jy0xMS40Njg0NjYnPkE8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMy45OTY0NjcnIHk9Jy02MS44NzgyNDcnPm48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMS40MjY1MjYnIHk9Jy02My4zNzI2MjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTE1Ljk4NjQzIDBINDcuNDQyMjEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTYuMjM2NDMsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ny42OTIyMSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMwLjg2NDMyLDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01OC41MTQxMzgsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004NS4zNTgyNi04LjkwOTczVi00Ny40OTU3NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDg1LjM1ODI2LC00Ny43NDU3NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODguNjIyMTUsLTMwLjIwMjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTguNTE0MTM4LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU4LjUxNDEzOCcgeT0nLTYzLjM3MjYyOCc+aDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTMuODQ5ODgnIHk9Jy02Mi4zNzA4MTUnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTQ4LjY4ODU5OScgeT0nLTYwLjg3NjQxOSc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNDIuNDg4MDM3JyB5PSctNjMuMzcyNjI4Jz7Dlzx0c3BhbiB4PSctMzQuNDQ3MTc3Jz7CtzwvdHNwYW4+PHRzcGFuIHg9Jy0zMC43MjA0Jz7CtzwvdHNwYW4+PHRzcGFuIHg9Jy0yNi45OTM2MjMnPsK3PC90c3Bhbj48dHNwYW4geD0nLTIyLjgxMzM0NCc+w5c8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTQuNzcyNDg0JyB5PSctNjMuMzcyNjI4Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xMC4xMDgyMjYnIHk9Jy02Mi4zNzA4MTUnPkE8dHNwYW4geT0nLTYxLjM3NDU2Nic+bjwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xNS4xNTMwOS01Ni45MDU1SDQ4LjI3NTU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDE1LjQwMzA5LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC41MjU1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzAuODY0MzIsLTU5LjcxNzMyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTguNTE0MTM4LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \DiagramSquare {
              width = 3cm,
              nw = {MR},
              ne = {M(A_{1},\ldots ,A_{n})},
              sw = {NR},
              se = {N(A_{1},\ldots ,A_{n})},
              north/style = {>->},
              south/style = {>->},
              east = {h_{A_{1}} \times  \cdots  \times  h_{A_{n}}},
              west = {g},
            }
          ]]></fr:resource-source></fr:resource></fr:figure></fr:li></fr:ul>
    </html:td>

  </html:tr>

</html:table>
<fr:p>Composition and identities are defined componentwise from those in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>885</fr:anchor><fr:addr
type="user">log-0003</fr:addr><fr:route>log-0003.xml</fr:route><fr:title
text="Formulas">Formulas</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The collection of <fr:em><fr:strong>infinitary first-order formulas</fr:strong></fr:em> over a <fr:link
type="local"
href="log-0001.xml"
addr="log-0001"
title="Signature">signature</fr:link> <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> is defined inductively by the following rules:</fr:p><fr:ol><fr:li>For each relation symbol <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1},\ldots ,A_{n}]]></fr:tex> and terms <fr:tex
display="inline"><![CDATA[t_{1}\colon A_{1},\ldots ,t_{n}\colon A_{n}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[R(t_{1},\ldots ,t_{n})]]></fr:tex> is a formula.</fr:li>
  <fr:li>For any two terms of the same sort <fr:tex
display="inline"><![CDATA[s,t\colon A]]></fr:tex>, <fr:tex
display="inline"><![CDATA[s = t]]></fr:tex> is a formula.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[\top ]]></fr:tex> is a formula.</fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\psi ]]></fr:tex> are formulas, then <fr:tex
display="inline"><![CDATA[\varphi  \wedge  \psi ]]></fr:tex> is a formula.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[\bot ]]></fr:tex> is a formula.</fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\psi ]]></fr:tex> are formulas, then <fr:tex
display="inline"><![CDATA[\varphi  \vee  \psi ]]></fr:tex> is a formula.</fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\psi ]]></fr:tex> are formulas, then <fr:tex
display="inline"><![CDATA[\varphi  \Rightarrow  \psi ]]></fr:tex> is a formula.</fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> is a formula, then <fr:tex
display="inline"><![CDATA[\lnot \varphi ]]></fr:tex> is a formula.</fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> is a formula and <fr:tex
display="inline"><![CDATA[x\colon A]]></fr:tex> is a variable, then <fr:tex
display="inline"><![CDATA[\exists x\colon A.\mkern 5mu\varphi ]]></fr:tex> is a formula.</fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> is a formula and <fr:tex
display="inline"><![CDATA[x\colon A]]></fr:tex> is a variable, then <fr:tex
display="inline"><![CDATA[\forall x\colon A.\mkern 5mu\varphi ]]></fr:tex> is a formula.</fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[I]]></fr:tex> is a set and for each <fr:tex
display="inline"><![CDATA[i \in  I]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\varphi _{i}]]></fr:tex> is a formula, then <fr:tex
display="inline"><![CDATA[\bigvee _{i \in  I}\varphi _{i}]]></fr:tex> is a formula.</fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[I]]></fr:tex> is a set and for each <fr:tex
display="inline"><![CDATA[i \in  I]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\varphi _{i}]]></fr:tex> is a formula, then <fr:tex
display="inline"><![CDATA[\bigwedge _{i \in  I}\varphi _{i}]]></fr:tex> is a formula.</fr:li></fr:ol><fr:p>Fragments of this collection are defined as follows:</fr:p><fr:ul><fr:li>The collection of <fr:em><fr:strong>atomic formulas</fr:strong></fr:em> over <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> is inductively generated by 1 and 2.</fr:li>
  <fr:li>The collection of <fr:em><fr:strong>Horn formulas</fr:strong></fr:em> over <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> is inductively generated by 1 through 4.</fr:li>
  <fr:li>The collection of <fr:em><fr:strong>regular formulas</fr:strong></fr:em> over <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> is inductively generated by 1 through 4 and 9.</fr:li>
  <fr:li>The collection of <fr:em><fr:strong>coherent formulas</fr:strong></fr:em> over <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> is inductively generated by 1 through 6 and 9.</fr:li>
  <fr:li>The collection of <fr:em><fr:strong>first-order formulas</fr:strong></fr:em> over <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> is inductive generated by 1 through 10.</fr:li>
  <fr:li>The collection of <fr:em><fr:strong>geometric formulas</fr:strong></fr:em> over <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> is inductively generated by 1 through 6, 9, and 11.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>886</fr:anchor><fr:addr
type="user">ct-0019</fr:addr><fr:route>ct-0019.xml</fr:route><fr:title
text="Heyting category">Heyting category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="ct-000X.xml"
addr="ct-000X"
title="Coherent category">coherent category</fr:link> <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a <fr:em><fr:strong>Heyting category</fr:strong></fr:em> if for every morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the pullback functor <fr:tex
display="inline"><![CDATA[f^{*}\colon \mathsf {Sub}(B)\to \mathsf {Sub}(A)]]></fr:tex> admits a right adjoint <fr:tex
display="inline"><![CDATA[\forall _{f}\colon \mathsf {Sub}(A)\to \mathsf {Sub}(B)]]></fr:tex>.
  A <fr:em><fr:strong>Heyting functor</fr:strong></fr:em> between Heyting categories is a coherent functor such that for any morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> and any subobject <fr:tex
display="inline"><![CDATA[m\colon A'\rightarrowtail A]]></fr:tex>, <fr:tex
display="inline"><![CDATA[F\forall _{f}(m) \cong  \forall _{Ff}(Fm)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(FB)]]></fr:tex>.
  Note that this definition makes sense since coherent functors preserve monomorphisms.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>