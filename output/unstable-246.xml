<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>335</fr:anchor><fr:addr
type="machine">#246</fr:addr><fr:route>unstable-246.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Suppose that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is a cover.
    Let <fr:tex
display="inline"><![CDATA[e = (b,a)\colon E\to B \times  A]]></fr:tex> be the interpretation of <fr:tex
display="inline"><![CDATA[f(x) = y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
    Note that <fr:tex
display="inline"><![CDATA[a]]></fr:tex> is an isomorphism since the following is also an equalizer diagram.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="2fecb3601b3ac0b6315dc7b2727f23d1"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5NC41OTM0OTRwdCcgaGVpZ2h0PSc0Mi4xNjY3NDVwdCcgdmlld0JveD0nLTcyIC03MiAxMjkuNzI4OTk2IDI4LjExMTE2Myc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT3dBQW9BQUFBQUJCZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFV4MUFtTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ0ZaMng1WmdBQUFXUUFBQUQwQUFBQTlOdSsrWkpvWldGa0FBQUNXQUFBQUMwQUFBQTJLSVRNd0dob1pXRUFBQUtJQUFBQUhnQUFBQ1FGdWdLeWFHMTBlQUFBQXFnQUFBQUtBQUFBQ2dabkFKSnNiMk5oQUFBQ3RBQUFBQWdBQUFBSUFESUFlbTFoZUhBQUFBSzhBQUFBRndBQUFDQUFCUUF0Ym1GdFpRQUFBdFFBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEb0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtZXMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUTBaREJpWnZnUDVETkRwSkhVL0FjS0F3RDJ4QTArZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhHLy84RFNjUC8vLzlmQVBNWkFGRllCbzRBQVFDU0FBQUNOd0tyQUI0QUFBRVJCaFk3QVJVbUp5TUdCelV6TWpZbkVRNEJKeU0xTXhZL0FUWTNOaFlCbUFRaVRqTXNPdEU2TEROT0lRTXVWQk1TRWhJK0J6ODVHQTRDaS8zTkZ4UXRBd0VCQXkwVUZ3SUFFZ3dCTFFJS0Fnb3VBUWtBQUFFQVhRQUFBbHNDcWdBckFBQWxCeUUxTkQ4Q1BnRTNMZ0VuSWdZSEhnRVhEZ0VqQmlZblBnRTNNaFlYRGdFSEJnOEJKVFkzUGdFM0Fsc2kvaVFEQ2ZvOVRRRUNhRTAwVWhZWUlRRUJKaFVPTEFJQ2hHcHdtd01DYUVndk5Xa0JBaW9LRFE4Q3hzWWZCUUlKMURGcVAweFRBU29qQWg4YklCMEJHU2ROWlFKcFkxQnBMaUFuVGdFQkJBdEJFZ0FBZU5wallHUmdZQURpeFRNK2VNZnoyM3hsWUdaaEFJSEhmQzQ5eURSekVOTnFJTVhCd0FUaUFRQVMvQWl0QUFBQWVOcGpZR1JnWUdiNHp3QWtneGhpR1dLWm9obUFJaWlBQ1FBOTBRSnpBQUFEVWdBQUFyZ0FrZ0JkQUFBQUFBQUFBRElBZW5qYVkyQmtZR0JnWnRCaEFORU1VQklKQUFBRkJBQXpBSGphUFl3eHE4SXdGSVcvWWhYdEd4d0VoemRJOEFlRVNwK2JtNE9UcThQYnJBblNvYW1rdGVnaS9uUnZRL0FHRHQ4OTU5d0FHUzhTaGttWUJ4MG1sVGVQUE9hSFJlU0orS3ZJR2Irc0daR2tNM0ZXN0NLblRQbVBQR1pKR1hraS9pTnl4aC92ZlZQZjdwMzE2dGdZNjkybDl0dVQ5VzNWT0xYUitiQWVyTFArM0ZtanlxY3lmZFgyMTFvVk90Y0ZleHBxYnR6cHNIZ1VSM0ZNWU1kRk1zK1dVOWhiS3NtY2REWm84bTk2a05TRnhqbjhZcVJSOGhRMTlITFRpbDZscXlqQ25hYjRBRlV5TGtNQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSa0FBb0FBQUFBQlJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY2QzNW1OdFlYQUFBQUU4QUFBQU13QUFBRVFBZWdSV1oyeDVaZ0FBQVhBQUFBR1RBQUFCMU9oL1RiRm9aV0ZrQUFBREJBQUFBQzhBQUFBMkovbk1GV2hvWldFQUFBTTBBQUFBSUFBQUFDUUZ4QUdiYUcxMGVBQUFBMVFBQUFBUUFBQUFFQWtIQU94c2IyTmhBQUFEWkFBQUFBb0FBQUFLQVJRQWtHMWhlSEFBQUFOd0FBQUFGd0FBQUNBQUJnQkNibUZ0WlFBQUE0Z0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUVXQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1jbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBycU1COWdadmdQNURNek1JS0VHUkVxL2dPRkFlSlhEYUFBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnTWdEUUhFSUxrZEJqU21BLzgvNDlnL2IvNmY4NGZaN0JhTUFBQTlDd0x6UUI0MmtXUXNXN1RVQlNHNzMvdDNoc25qcS9yeE5ja05IWWNPOWV0S21JU043YVVJcnRBdTFBa3hCUjE2czRLWWtTSUIyQ0JvU084Um1kZWdJMEhJU3ZoV2d5YzdkY25uZlA5aDRDODNXL0lqcndua3BDS003N0FXVm1GOEprQTR5b3JxeHEvN043Z0tKcU8wOVNjVzNQUk04Q0t5TzF3SUY3RlFMM2NydnNyMEQ0L1dONFNQU0RYKzV5K29UL0poUTVHdThnQm42bXNSaUVEeWJpTVVLTXhFcWJLb0tpaFR4UXJHVGhJVktiS1N1VndxRUJSU3BiaCs4WTEzYkgxZEhtOEFWSmZHUkNSRUNLTmpjbEN2QXpwUUx3V3ZpT2ZKU2RQZ0VScTdvWkNlRjdZN1l4dlc0eXZmMzY4T0x3NEd6NDNWQkpPYWNxeW5rVmhYdnQzdTYweDQ5amVQTXpVUFAyUE1GS1BQcHV6RHY1MVdleDM5QXZ1U2FrRGJ4M1hqYmF2RXNVNHk5R1cwdjVCWE1wQTB5elJmd3NSeUxZeDAzVmFqTG81RE1QVUdENjRIRGZlcTVNRHA4dEFUMlc4RHZGSkhNRXdnOUhITHFYd1hRdVllSDNmN21rTEcrOStYMTJaRTVFOS9yYWxRV0dEd3JMT2gxTWZzSHhoZWJTSzh1Wm1ZbmVISTJBd241NDNIM0t0L0JkY25EczdBSGphWTJCa1lHQUE0c0twek0vaitXMitNakN6TUlEQVl6NlhIZ1Q5WDUvcEdOTkZJSmVEZ1Fra0NnQVZHZ251QUhqYVkyQmtZR0JtK00vQXdNQjBqRUh2L3dXbXlReEFFUlRBQWdCb1ZRUmpBc1lBQUFGYkFITUNPZ0JMQXF3QUxnQUFBQUFBS2dDUUFPb0FBSGphWTJCa1lHQmdZWEJrQU5FTVVCSUpBQUFITEFCSkFIamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b0NDeGRXRmdZbVhxQXRoRkdXd2pKMFJDcWpyMmQvZGhQUFFOVitkKzJFRE5Ed1gzSzVnbHZWOUpKZTdCRlZQbW1TZmkzakxYTEhqbmlhSjhsdVNWajh5bE5KK1pLMTc0eWp5Ui9EdHp6WXJmVFhDWDYyQ2oyZ1Zqb3o4NTE2MzNOdlpkOEdxcG0rUzMxdHQ0R0t4Ung1c3lZOWVQWjZkYTNlaVdEUUhIaFNzRGxvaGlKNGxKN0RsSjUraFlzMDlKTHh3a1Z5elJOUC82cmZRK2JRN3BKeU9iSXpkUnd5aUxYdlFzVzBXYlhtcmFQOHVoTC9jQUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9JQUFvQUFBQUFBL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDE0bU50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNVWjJ4NVpnQUFBV1FBQUFESkFBQUF6RFZtV2Zob1pXRmtBQUFDTUFBQUFDOEFBQUEyS1ByTThXaG9aV0VBQUFKZ0FBQUFId0FBQUNRSE1nT0dhRzEwZUFBQUFvQUFBQUFJQUFBQUNBZDVBR2xzYjJOaEFBQUNpQUFBQUFZQUFBQUdBR1lBQUcxaGVIQUFBQUtRQUFBQUZnQUFBQ0FBQlFBK2JtRnRaUUFBQXFnQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTNzTTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCa1p2Z1A1RE5EcEpIVS9BY0tBd0Rwc2cwdmVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpTy8vOUR5UDhId0h3R0FGS1hCcDBBQUFCNDJoWEpRV3JDUUJRRzRQZS9HZWFwTTBaajZrUmJDS2dRZDJxckpGUWtpQlJCdklFMzZLSWJCUS9oc21mcENib1JlZ2QzTG5xSnFuWDdmY1QwZnIycUk1L29sV1pFaUJLTU14OTdHYUtHdEY4ZzlsaytSRWRNalkwa3lHTWZCN2huTisybldWNGdSNEVYTDZyRHYzdTBSallDSHVlTDFWc0RpRnhwcXF2aDVTZlNhdTBNT0MxWkFVS3ptd3kwWlVqd3ZFandLZld1MjV6UjQrKy9RMWlGY1Urc0FJVjZzd3hJdU55QTljZURMVGNxWU9YK1VVTkpoZHVNM29DWDFybnQ1WXVJYnRGM0c5a0FBQUI0Mm1OZ1pHQmdBT0tiTW44bXgvUGJmR1ZnWm1FQWdjZDhMajBJK3Y5LzV1Tk1kNEZjRGdZbWtDZ0FQQVFMWUFCNDJtTmdaR0JnWnZqUHdNREFvc3FReVJESGZKd0JLSUlDbUFCQ3h3TEJBQU5VQUFBRUpRQnBBQUFBQUFCbUFBQjQybU5nWkdCZ1lHS3dCV0lRWUdSQUF3QUdxUUJFQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDMEFBQUEyS0FiTUZtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhNaXZQTHgvRFpmR1poWkdFRGdNWjlMRDRMK3o4aDBtUm5FNVdCZ0FsRUE0eWdJRlFBQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTkFBQW9BQUFBQUE2UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJnaU9SekcyTnRZWEFBQUFGQUFBQUFLUUFBQURRQURBRXFaMng1WmdBQUFXd0FBQUI0QUFBQWVKTVNQSkZvWldGa0FBQUI1QUFBQUMwQUFBQTJLRTdNRFdob1pXRUFBQUlVQUFBQUhnQUFBQ1FHTmYvZGFHMTBlQUFBQWpRQUFBQUdBQUFBQmdPd0FBQnNiMk5oQUFBQ1BBQUFBQVlBQUFBR0FEd0FBRzFoZUhBQUFBSkVBQUFBRndBQUFDQUFCQUFrYm1GdFpRQUFBbHdBQUFEVEFBQUJQcTgzZGVGd2IzTjBBQUFETUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtbG1HY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRVRBeEpJS1M1TEIwcGVaN2pPTFBWSGs0R0JXWXI1T2xDWUVhSGkvMzhHQmdEcm5RN3ZBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4Q0MrTmYvLzRlUS83WEFmQVlBWHVVSE13QUFBQUFCQUpRQUNRS0dBZmdBSWdBQUFUYzJGeFlYQmc4Q0h3RVdCd1lISmk4QkJ3NEJJeVluSmo4Qkp5WTNOamN5RndHT3l3NEtFd0VDQXhxN3BUSUVBUUVUQ3dYVXl3a0lCaEVEQXhETnpSQURBeEVHQkFFZHloRUJBaE1LQXhxN3BUSUlBeE1DQWdUVXl3b0ZBaE1IRGM3T0RRY1RBZ0lBQUhqYVkyQmtZR0FBNGxVbUd6L0g4OXQ4WldCbVlRQ0J4M3d1UGNnMHN3empEeURGd2NBRTRnRUFGSk1JendBQUFIamFZMkJrWUdDVytxTUpKR1VZcGpCTVkycGpBSXFnQUVZQVRNb0RGd0FBQXh3QUFBQ1VBQUFBQUFBQUFEd0FBSGphWTJCa1lHQmdZbEJtQU5FTVVCSUpBQUFFQ0FBcEFIamFUWTZ4YXNNd0VJWS9VOGRRSjVDcEhUb1VUUm1GamZNQWhReVpzbVlzSkpFSURsZ09rbVB3VXZJQWZlaGVGQTA5d2ZIcHYrK0VnSklmTWg2VnNZejlVVG1GM0o0OFk4NWI0a0tPU2x6eXdZb1hzdnhWa2srK0V1Y3MrRTQ4NDUxTDRrTHllK0tTTmIrYnZydmVCdXZWcmpmV3UxTVhwcnJhV3gvYTNxbGFWODlnYTUzMWg4RWFkWnlVR2Rzd25qdlY2RW8zYk9qcHVISmp3T0xsWnp0SlRHVEhTV2FCaVpxS2Zjd0NyY3lkZURWYTB2L0dWZ3dYclVOOHpZaDFsSmtTR21VdlNEK0xyMmppcnFiNUF3bFJNUk1BZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5RQUFvQUFBQUFBN3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZcDBMMk50WVhBQUFBRTRBQUFBTVFBQUFEd0FnQUM4WjJ4NVpnQUFBV3dBQUFDTUFBQUFqQ3dWdUtkb1pXRmtBQUFCK0FBQUFDOEFBQUEySjRQTTBtaG9aV0VBQUFJb0FBQUFId0FBQUNRRkRBR2phRzEwZUFBQUFrZ0FBQUFNQUFBQURBV0VBSEpzYjJOaEFBQUNWQUFBQUFnQUFBQUlBRElBUm0xaGVIQUFBQUpjQUFBQUdBQUFBQ0FBQmdBZGJtRnRaUUFBQW5RQUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRFJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXZNWTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWWNoazV2NFA1RE56TTZLcCtROFVCZ0Q5UFEyb2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS3BqQmsvdjhQNUlQcC8zUC96d1NyQWdJQW1ORUpOZ0FBQUFBQ0FDWC85Z0hhQXNjQUVBQWJBQUFCRVNNMURnRUhMZ0VuUGdFM05oWVhFUU0xSmlNbUJnY2VBVGMyQWRwWkhsUXdVV2NDQW1sU0dGZ3lBeWcrT0dJREFsYzRTd0xIL1RrMUdpUUJBNFprWllZREFSVWlBU3o5dU5vMEFVMWZXRklCQXdBQUFnQk5BQUFBdEFLK0FBTUFCd0FBRXhVak5SY1JJeEcwWjE5V0FyNW5aL2YrT1FISEFBQUFlTnBqWUdSZ1lBRGlzeGZjbytQNWJiNHlNTE13Z01CalBwY2VCUDMvRzFNQTAzRWdsNE9CQ1NRS0FDbHFDb1FBZU5wallHUmdZT2IrejhEQXdCVEFvTXJnejNpTEFTaUNBcGdCUWdZQ3RBQUNVQUFBQWpFQUpRRURBRTBBQUFBQUFESUFSbmphWTJCa1lHQmdacEJoWUdJQUFVWUdOQUFBQTRzQUpIamFUWXc5YjhJd0VJYWZxQWxTdzhDQ09qQzBIanBiUVdGZ1ltRmdZbVZpQWV5aURIR1FIU0loVlIzNTNUMk1CODdTNlhrL3prREpIeG1QeVpqRS9aaWNRdFNUQzhaTUU0OUVmU1V1bWZITkcxbitMczRucThTNUpQdkVCUi84SkI2Si81dTRaTUY5M2JXWGEyKzkybmJHZW5kcVExanVyQTlONTlSY1YxRnZyTFArMEZ1ampqZGxoaVlNNTFiVnV0STFhenBhTGx6cHNYZ1VXM0ZNWk1kSnNpQnZ5UzQ2Z1VaU0o2MDVtdW9sMzBqdVl1Y1FmekxTT1hLVGJSamtLc2crUzF0UngwdE4vUS9xYlRBN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktEbk03MmhvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRyYmYyOWJHODl0OFpXQm1ZUUNCeDN3dVBRajYvMTltTnFhN1FDNEhBeE5JRkFCQ3VBcjlBSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjMuOTc0NTU4LC01Ni44NDQzOSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTU2Ljg0NDM5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My45NzQ1NTgnIHk9Jy01Ni44NDQzOSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0My4wMDEwMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC01Ni44NDQzOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjMuOTc0NTU4JyB5PSctNTYuODQ0MzknPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUzLjcwNDA4MycgeT0nLTU2Ljg0NDM5Jz7DlzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDMuNzQxNDcnIHk9Jy01Ni44NDQzOSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDkuNzY3NjEsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjk3NDU1OCcgeT0nLTU2Ljg0NDM5Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMC41MDU1NCAwSDM3Ljk0NTQ4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDEwLjc1NTU0LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguMTk1NDgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMC42MDU3Myw0LjU2MTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC01Ni44NDQzOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNjMuOTc0NTU4JyB5PSctNTYuODQ0MzknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYwLjg2MTIxNScgeT0nLTU2Ljg0NDM5Jz5mPHRzcGFuIHg9Jy01Ni42MjM1NzknPiw8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTIuODk2ODAyJyB5PSctNTYuODQ0MzknPmlkPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny4zMDMxMzknIHk9Jy01NS44NDI1NzcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQxLjY0MzcyOCcgeT0nLTU2Ljg0NDM5Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J003NS4zNjU1MiAzLjYxNjYySDEwNC43MTIwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDQuOTYyMDcsMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODMuNjU3MTgsNy43ODk1NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYzLjk3NDU1OCcgeT0nLTU2Ljg0NDM5Jz5mPHRzcGFuIHg9Jy01OS4zMDc5NzMnPs+APC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTU0LjY0OTEyOScgeT0nLTU1Ljg0ODEyNic+MjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNzUuMzY1NTItMy42MTY2MkgxMDQuNzEyMDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA0Ljk2MjA3LC0zLjYxNjYyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4NS45OTkyMiwtOS40NDIzMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYzLjk3NDU1OCcgeT0nLTU2Ljg0NDM5Jz7PgDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTkuMzE1NzEzJyB5PSctNTUuODQ4MTI2Jz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$A$};
      \node  (2) [right = of 1] {$B \times  A$};
      \node  (3) [right = of 2] {$B$};
      \draw  [>->,morphism] (1) to node {$(f,\mathsf {id}_{A})$} (2);
      \draw  [->,morphism,offset=-1.5] (2) to node {$f\pi _{2}$} (3);
      \draw  [->,morphism,offset=1.5] (2) to node [swap] {$\pi _{1}$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By <fr:ref
addr="log-0008"
href="log-0008.xml"
taxon="Definition" />, <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket y\colon B.\exists x\colon A.\mkern 5muf(x) = y\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> is the <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">image</fr:link> of the following composite.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="0021f07569b7a823d1e143f26fa9d369"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5NC45MzU5NXB0JyBoZWlnaHQ9JzEwOC4yNzMwODZwdCcgdmlld0JveD0nLTcyIC03MiAxMjkuOTU3MyA3Mi4xODIwNTcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVTBBQW9BQUFBQUJod0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MDBtTnRZWEFBQUFFNEFBQUFOUUFBQUVRQVdnRDJaMng1WmdBQUFYQUFBQUpaQUFBQzBLeVFkaGhvWldGa0FBQUR6QUFBQUM4QUFBQTJLRVBNN1dob1pXRUFBQVA4QUFBQUhnQUFBQ1FHTmdIVGFHMTBlQUFBQkJ3QUFBQVVBQUFBRkEwMEFKbHNiMk5oQUFBRU1BQUFBQXdBQUFBTUFYWUNHRzFoZUhBQUFBUThBQUFBR0FBQUFDQUFDUUJNYm1GdFpRQUFCRlFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGS0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtV3NJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaUEJrWnZnUDVETkRwSkhVL0FjS0F3RGhoQTBlZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVNjR0Z3WlBQLy9CN0ljSWF6L0IvN3YrNzhickJZTUFPRVdDMG9BQUFCNDJqMlN6MHNVVVFESDMvZTltZmZjM1psNXE3TTdvem5Pc3EzT2lLYkcvbmpiYnJSU3FZV1NXRUo0a0lvZ2hhQU9ZWHJNZzVSSkhTSUlPblhwVnBkT0VYVHExRC9RTVNFNlJZUkhUN3ZiR3luZjZmRjk3L0Q1OFAwU1NvYTdYZnFEZmlkVHBFeElIYXBlOW53MzUxV1V4NmNnNGlpdUt0OVQ5U2tVQmM5NXZ2SWQ2RHlKS3kzVUsrd2o3dkNjemRIeUp2S3d6STN0SGhOMnhxMnlsT2gwRiszQXRSbHNjMzNGZ3BVNjJYcjl1N2hKcjJlUmt1MXRUN0loQWNaQWU2UUFMSDl0ZGljM25BV1ZEay9pdE9Rb2ZjVTFvZzhqNDkwMjQvUXpDY2tZT2FOSjNXb3A1cHF0R0NMdlFJVHd1UVFYUlg3RTZ5WndLb3BMRVJmcy81M3BENVczendmaklTbXhzbnFiYlM4dkxJTmV5bDU1MkhrWk9FNHpmUFBxNWdiRjVNV2RnbXZlZjdhNlNlbnB5MS9tRE1CWm9vMWV5Z0lCZXJVNXZ5N1RpNDJGQzA3TFNBemdZcFk5bUJ1ZW9aQUQ3WGRzYTNGa2lYVis5dkUwSVNDeDVzN1NUMlNla0JIaG9QUVBzTzVPWXhKSEFzcVR5RVhUdEtZaW9Ya2xLdnBaZWI3Z1VhMWFWL0V4dWwrZTF2Mm9jZ0gwMnczRHlyYi9ERWtOYlQ3UmdDTU5tYVZtbjhWeUFXRFE4NnN2dE1LNVd6TTFtL2s0YS9TemxLWnZyYzBtTHUrM2xDeVBJVTl4c0crWkxPUmFJYVJocjdDRm9RMlJjajhFUnRvTlRyUnFRSGJnRUJNTkY1a0RqNlVOTVM3Y1FYUithVGxNT3VwdXh1RGFzZFR0b3EyN0dkWENUUEFDMU5GSWpzZmpxcmdhQ2Q1Q0FYWGY4M004ampnZVBUVlljS3BJYmJIM09HVkM5alVMeGg1RFZBeGc4OTFkSFRsdXMwRHZ0ZmY3SmFVSjVmRlU4Z0VkelpoNkhra2hTWnJTaTBHZWtMODFsRzk1QUFBQWVOcGpZR1JnWUFEaUtSMnkwdkg4Tmw4Wm1Ga1lRT0F4bjBzM2d2Ny9sMW1BNlM2UXk4SEFCQklGQVA1NENYVUFlTnBqWUdSZ1lHYjR6d0FrT1JpVS94OWxGbUFBaXFBQVZnQktXUU1QQUFBQ2RnQUFBd0FBSkFNSUFDc0M5QUFuQWNJQUl3QUFBQUFBVkFDd0FTSUJhSGphWTJCa1lHQmdaZkJtWUdZQUFVWUdOQUFBQ0c4QVZuamFUWTZ4YXNNd0VJWS9VOGRRcDlDcEhUb1VUUm1GamZzQWdReVpzbVlzSkpFSURrZ0tzbVBJRXZvQWZlaGVGQTA5d2ZIZGQ3K0VnSm9iQmZjcWVFMzlYaVdWVEErZU1lY3RjeVZIWmE3NVlNRVRSZmtzNXBObDVwSVh2alBQZU9lVXVSTC9rN25taTk5VmNPZkxhS1BhQkdPalB6alh0ODNXeHFFUFhyVzZlWWkxOVRidVJtdlUvcXJNMUEvVDBhbE9ON3BqUmNCeDVzS0lKY3JQTm1KTVlzOUJkbzZlbG9adGNvTk1RVFpLbkJiN1A3R1doRStwWFhyTlNHclBWYnBoa3N3Zy9TaHBSWmZ1YXJvLzMvUXd1d0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktEL01DV2hvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaTQrRGtuZkg4Tmw4Wm1Ga1lRT0F4bjBzM2d2NnZ6OHpEZEJ6STVXQmdBb2tDQVAwVENOc0FlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNY0FBb0FBQUFBQTRRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVXgxRzJOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDRVoyeDVaZ0FBQVdRQUFBQmtBQUFBWkRGdUFySm9aV0ZrQUFBQnlBQUFBQzBBQUFBMktJVE12bWhvWldFQUFBSDRBQUFBSGdBQUFDUUZ5d0xXYUcxMGVBQUFBaGdBQUFBSUFBQUFDQVlLQUpKc2IyTmhBQUFDSUFBQUFBWUFBQUFHQURJQUFHMWhlSEFBQUFJb0FBQUFGd0FBQUNBQUJBQWdibUZ0WlFBQUFrQUFBQURLQUFBQk11c0lrZVp3YjNOMEFBQUREQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1abVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvYU1oZ3lNL3dIOHBraDBraHEvZ09GQWFOM0RGZ0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aUcvLzlEeVA4WHdId0dBRkZIQm8wQUFBQUFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FlTnBqWUdSZ1lBRGlIMWNlVzhiejIzeGxZR1poQUlISGZDN2R5RFJ6RU5OcUlNWEJ3QVRpQVFBblhna2RBQUFBZU5wallHUmdZR2I0endBa2d4Z21NVFF5bVRNQVJWQUFFd0JDM0FLb0FBQURVZ0FBQXJnQWtnQUFBQUFBTWdBQWVOcGpZR1JnWUdCaWtHY0EwUXhRRWdrQUFBT2tBQ1VBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktuNXViZzVPcnc5dXNDZEtocWFTMTZDTCtkRzlEOEFZTzN6M24zQUFaTHhLR1NaZ0hIU2FWTjQ4ODVvZEY1SW40cThnWnY2d1prYVF6Y1Zic0lxZE0rWTg4WmtrWmVTTCtJM0xHSCs5OVU5L3VuZlhxMkJqcjNhWDIyNVAxYmRVNHRkSDVzQjZzcy83Y1dhUEtweko5MWZiWFdoVTYxd1Y3R21wdTNPbXdlQlJIY1V4Z3gwVXl6NVpUMkZzcXlaeDBObWp5YjNxUTFJWEdPZnhpcEZIeUZEWDBjdE9LWHFXcktNS2RwdmdBVlRJdVF3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5BQUFvQUFBQUFBNlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ2lPUnpHMk50WVhBQUFBRkFBQUFBS1FBQUFEUUFEQUVxWjJ4NVpnQUFBV3dBQUFCNEFBQUFlSk1TUEpGb1pXRmtBQUFCNUFBQUFDMEFBQUEyS0U3TUMyaG9aV0VBQUFJVUFBQUFIZ0FBQUNRR05mL2RhRzEwZUFBQUFqUUFBQUFHQUFBQUJnT3dBQUJzYjJOaEFBQUNQQUFBQUFZQUFBQUdBRHdBQUcxaGVIQUFBQUpFQUFBQUZ3QUFBQ0FBQkFBa2JtRnRaUUFBQWx3QUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRE1BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWxtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVUQXhKSUtTNUxCMHBlWjdqT0xQVkhrNEdCV1lyNU9sQ1lFYUhpLzM4R0JnRHJuUTd2QUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeENDK05mLy80ZVEvN1hBZkFZQVh1VUhNd0FBQUFBQkFKUUFDUUtHQWZnQUlnQUFBVGMyRnhZWEJnOENId0VXQndZSEppOEJCdzRCSXlZbkpqOEJKeVkzTmpjeUZ3R095dzRLRXdFQ0F4cTdwVElFQVFFVEN3WFV5d2tJQmhFREF4RE56UkFEQXhFR0JBRWR5aEVCQWhNS0F4cTdwVElJQXhNQ0FnVFV5d29GQWhNSERjN09EUWNUQWdJQUFIamFZMkJrWUdBQTRsVW1HNy9IODl0OFpXQm1ZUUNCeDN3dTNjZzBzd3pqRHlERndjQUU0Z0VBRlJFSTBRQUFBSGphWTJCa1lHQ1crcU1KSkdVWXBqQk1ZMnBqQUlxZ0FFWUFUTW9ERndBQUF4d0FBQUNVQUFBQUFBQUFBRHdBQUhqYVkyQmtZR0JnWWxCbUFORU1VQklKQUFBRUNBQXBBSGphVFk2eGFzTXdFSVkvVThkUUo1Q3BIVG9VVFJtRmpmTUFoUXlac21Zc0pKRUlEbGdPa21Qd1V2SUFmZWhlRkEwOXdmSHB2KytFZ0pJZk1oNlZzWXo5VVRtRjNKNDhZODViNGtLT1Nsenl3WW9Yc3Z4VmtrKytFdWNzK0U0ODQ1MUw0a0x5ZStLU05iK2J2cnZlQnV2VnJqZld1MU1YcHJyYVd4L2EzcWxhVjg5Z2E1MzFoOEVhZFp5VUdkc3duanZWNkVvM2JPanB1SEpqd09MbFp6dEpUR1RIU1dhQmlacUtmY3dDcmN5ZGVEVmEwdi9HVmd3WHJVTjh6WWgxbEprU0dtVXZTRCtMcjJqaXJxYjVBd2xSTVJNQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDMEFBQUEyS0FiTUZHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhNaXZNcngvRFpmR1poWkdFRGdNWjlMTjRMK3o4aDBtUm5FNVdCZ0FsRUE0NllJRndBQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTZ0FBb0FBQUFBQlZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZjE0REdOdFlYQUFBQUU4QUFBQU13QUFBRVFBZVFTTVoyeDVaZ0FBQVhBQUFBSFBBQUFDRU41RDlxOW9aV0ZrQUFBRFFBQUFBQzhBQUFBMkovbk16MmhvWldFQUFBTndBQUFBSUFBQUFDUUZ3d0hrYUcxMGVBQUFBNUFBQUFBUUFBQUFFQW1mQUxac2IyTmhBQUFEb0FBQUFBb0FBQUFLQVdBQXJtMWhlSEFBQUFPc0FBQUFHQUFBQUNBQUJ3QTRibUZ0WlFBQUE4UUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUVsQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1TbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBvbU1SOWdadmdQNURNek1JS0VHUkVxL2dPRkFmYXZEZndBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnTWdEUUhFSUxra2hoU21RLzgvNDlnL1ovL2YrNGZaN0JhTUFBQS9Lc01BZ0I0MmlXUXYyN1RVQlRHNzNmdFhNZU9ZNmVwLzhRVk1ZbWQyZzRwY1JSanV5S3BuUllIVUpkV2FxVXFIYnF6TUtCdWxSRHdDcndBSXkvQUFETVM3d0ZpWUFjV0JPV20zYzUzdmpQOHpvOVE4dWo2Tjc3U0w4UWpHU0VRQ3VTWlpUTWRUQm9qREVxK0NId3ZDQXNrdkpEV2ZZRjBETitUTlBBcjA3Q2dQYllQb3QwTFFkanZINjcyVHdGMmY2d3dxZy9rRFVDWHFwMEI4bWk1MmVsaTVNNExyUzY2OVNGOS8rK2I1UUVucTJmSGZpVmdkZFR5UG42NFp6Y1ZVZEhya2lpb2Y4OHhEeWRYL29PNDBuWHRLbkxHRHdtaFpNbDUvK0F6Q2RhOHVjOUpYU1JXaVN6UFhKakdMWGpLVTU0bFU4dTJtTVNrTUxIV09lZllBWS9zKzBJR1JSYTM5dHFMbWRKc1RMZUt5L01MOGFuWk9Ubk5ud0QrN3M3azliUTczL1pTRWJGdkpWb3ovUkdaYmxGUXRkWmFOS0F5YmRpS1JQcjgrRVZsNk9sazFOa3pOZEVCcTJsRzd2WUVRMUo2QkdSOC9ZdSt4YWNiczF5WEg2UWx1RUEvNEF3eDFsSzVUTHZQaGZNMnZQM0Z0dmdzc1NDOHFWR1VHNjQ3RUl4T3RWVzJqNFkxVFdHZ0k2dWZ1bmlqMzRFZzJzNHJoVktZTFJub3RwdW0yZ0FjRlpjL2wwdXhxNGVUZDJmVVRsVCtyaXpQako0SnlLWXV0MmwrTnk1WFhWVXhIR0J6dXpjclg4YUVrUDlqUTB5T0FIamFZMkJrWUdBQTR1YWJheWZHODl0OFpXQm1ZUUNCeDN3dTNRajYvMWVtWTB6SGdWd09CaWFRS0FBK0RndFNBSGphWTJCa1lHQm0rTS9Bd01CMGpFR1BRWkpwTWdOUUJBV3dBQUJEYUFLdEFzWUFBQUlDQUVNQ0t3QkZBcXdBTGdBQUFBQUFXQUN1QVFnQUFIamFZMkJrWUdCZ1lUQm5ZR0lBQVVZR05BQUFCa2tBUUhqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuOTc5MTYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkU8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDMuMDAxMDIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUzLjQ3NTc4MycgeT0nLTYyLjY0NzU2NCc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQzLjUxMzE3JyB5PSctNjIuNjQ3NTY0Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwOS43Njc2MSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjc0NjI1NycgeT0nLTYyLjY0NzU2NCc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1NC4zMTUyMywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjczNDcgMEgzNy45NDU0OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMC45ODQ3LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguMTk1NDgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMS41OTMwMywyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYzLjc0NjI1NycgeT0nLTYyLjY0NzU2NCc+ZTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNzUuMzY1NTIgMEgxMDQuNzEyMDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA0Ljk2MjA3LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODUuOTk5MjIsMy44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPs+APC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01OS4wODc0MTMnIHk9Jy02MS42NTEzJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002LjQwNDU0LTYuNDA5NzNMNDcuMDkyMzktNDcuMDk2NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzEsLTAuNzA3MDksMC43MDcwOSwwLjcwNzEsNDcuMDA0MDEsLTQ3LjAwODIyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPHBhdGggZD0nTTY1LjYwNjktNDguMjA4NzZMMTA3LjA1MTQ1LTYuNzYzMjgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNzA3MDksLTAuNzA3MSwwLjcwNzEsLTAuNzA3MDksNjUuNzgzNjgsLTQ4LjAzMTk4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzA5LDAuNzA3MSwtMC43MDcxLDAuNzA3MDksMTA3LjIyODIzLC02LjU4NjUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4Ljk5MjAzLC0zNi4xNDg4OCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTEuOTk1OTE4JyB5PSctNjIuNjQ3NTY0Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00OC44ODI1NzUnIHk9Jy02Mi42NDc1NjQnPmI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ1LjM3OTAzNycgeT0nLTYyLjY0NzU2NCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$E$};
      \node  (2) [right = of 1] {$B \times  A$};
      \node  (3) [right = of 2] {$B$};
      \node  (4) [below = of 2] {$I$};
      \draw  [>->,morphism] (1) to node {$e$} (2);
      \draw  [->,morphism] (2) to node {$\pi _{1}$} (3);
      \draw  [cover,morphism] (1) to (4);
      \draw  [>->,morphism] (4) to node[swap] {$\mathsf {Img}(b)$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By assumption, <fr:tex
display="inline"><![CDATA[fa = b]]></fr:tex>.
    Thus, the image of <fr:tex
display="inline"><![CDATA[b]]></fr:tex> coincides with that of <fr:tex
display="inline"><![CDATA[fa]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="cf3296da579bb485744d3cb260f07009"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5NC45MzU5NXB0JyBoZWlnaHQ9JzExMS41NzMxOTFwdCcgdmlld0JveD0nLTcyIC03MiAxMjkuOTU3MyA3NC4zODIxMjcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDMEFBQUEyS0FiTDlHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhNaXZNbngvRFpmR1poWkdFRGdNWjlMTllMK3o4aDBtUm5FNVdCZ0FsRUE2NFlJTndBQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktEL0w2V2hvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaTQrRGtuL0g4Tmw4Wm1Ga1lRT0F4bjBzMWd2NnZ6OHpEZEJ6STVXQmdBb2tDQUFVQ0NQc0FlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVE1BQW9BQUFBQUJZZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFh4MHFtTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWZRQzdaMng1WmdBQUFXd0FBQUgrQUFBQ1VFcE9qTEJvWldGa0FBQURiQUFBQUM4QUFBQTJKL25MODJob1pXRUFBQU9jQUFBQUlBQUFBQ1FGcXdHYmFHMTBlQUFBQTd3QUFBQVFBQUFBRUFsOEFNeHNiMk5oQUFBRHpBQUFBQW9BQUFBS0FaSUF3bTFoZUhBQUFBUFlBQUFBR0FBQUFDQUFCd0JDYm1GdFpRQUFBL0FBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFd0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtaW1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb21NcVF4TS93SDhwa2gwa2hxL2dPRkFjK2NEUllBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLSmpHay9mOFA1Q2VDNlA4TC9zOEZxd0lDQUpnL0NUSUFBSGphUlpFL2I5TlFGTVY5M25OdHh4Uy9KSTZmYWRNNnFaLzduSmJHcFRqWXFGUk9rN2FSK2srMEFxbEt4WitKQWI1Q0Z6WTJKZ1pXTmtZV0J2WktiRWg4QWlUNERHVWo0YmtNM0x2ZGM0ZmZPVWNqV2pHOUl2dTQxTHJhdHFhaHdGM3VNK0xBYTNDL1FCOVpDOXh2R0taYUdUc3dFOFJaWG00QW1tZXhqS1ZocW5PQXZFQ2U0ZFBNWXJPQnVzZk5DblBid3JKMDJ6YmcxcHFaUDZ3Ris2czdaOUQ3ekQwNFgrNXRwR2g0cVQ4U2JnaXNCV0hQa25qRDNXcnQ1UGlKbHpoOEFXUXZiaG9neEo0WnRGT0taamZvQUUrUFhweTY5UkZGT1BueGJYWTUwa25uZ1hqZHpST1FscldncVNIYXp2UTNmcEt2V3FobHloTXR5Ymh2TUJnbHZ1eXJneFNoakF1a1NqQkx2Y0M5QkNKVVZ0U1g4ZzVuNUE4Nzk1OVJPbGc2R0E4ZUEwWTNzUTNDb2tvTllPYnVXb1M4cytmZVdzVHRZS3R3TEQyd1Zzakh5Uyt1ekR3YXZ6d1J1eFRqaDlYd3krZFYvNmF0Mjh3eWRUcjc1eHhiOFowTDBWdmZaY3k1Nk13bG13cFFPNXl1azFmayszVUR0TVJVaWY3ajR6NDNUTjVTdmZTcE1HVG1wOWV3cVdySmdWRHBaN2xjaDBNWTBvd2JNVDVzVnZYcWZHV3cwZGtFSWs5U3NCWmpMRnFpaXdrN0NvakxUcG5uOEtGWTJRSUVWM28xWUt4ZUQyeHIvbmtwNDkzazhxQzIzV3ZzVUNtQ05vbU0rRWFGUUQvMDNsK2QwZERFMmJnWnkrWG92NFE1Mlgycmh4WlU5SDhCbG5kVG1BQUFlTnBqWUdSZ1lBRGlOUmNteU1mejIzeGxZR1poQUlISGZDN1ZDUHEvUHRNeHBvdEFMZ2NERTBnVUFCMnBDZ2NBZU5wallHUmdZR2I0ejhEQXdIU013ZTcvQmFZc0JxQUlDbUFCQUdhNkJFb0N4Z0FBQW5vQVBnSUNBRU1DT2dCTEFBQUFBQUJxQU1JQktBQUFlTnBqWUdSZ1lHQmhjR1JnWWdBQlJnWTBBQUFIUXdCS2VOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVMEFBb0FBQUFBQmh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwMG1OdFlYQUFBQUU0QUFBQU5RQUFBRVFBV2dEMloyeDVaZ0FBQVhBQUFBSlpBQUFDMEt5UWRoaG9aV0ZrQUFBRHpBQUFBQzhBQUFBMktFUE16V2hvWldFQUFBUDhBQUFBSGdBQUFDUUdOZ0hUYUcxMGVBQUFCQndBQUFBVUFBQUFGQTAwQUpsc2IyTmhBQUFFTUFBQUFBd0FBQUFNQVhZQ0dHMWhlSEFBQUFROEFBQUFHQUFBQUNBQUNRQk1ibUZ0WlFBQUJGUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZLQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1Xc0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpQQmtadmdQNURORHBKSFUvQWNLQXdEaGhBMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1U2NHRndaUFAvL0I3SWNJYXovQi83dis3OGJyQllNQU9FV0Mwb0FBQUI0MmoyU3owc1VVUURIMy9lOW1mZmMzWmw1cTdNN296bk9zcTNPaUtiRy9uamJiclJTcVlXU1dFSjRrSW9naGFBT1lYck1nNVJKSFNJSU9uWHBWcGRPRVhUcTFEL1FNU0U2UllSSFQ3dmJHeW5mNmZGOTcvRDU4UDBTU29hN1hmcURmaWRUcEV4SUhhcGU5bnczNTFXVXg2Y2c0aWl1S3Q5VDlTa1VCYzk1dnZJZDZEeUpLeTNVSyt3ajd2Q2N6ZEh5SnZLd3pJM3RIaE4yeHEyeWxPaDBGKzNBdFJsc2MzM0ZncFU2MlhyOXU3aEpyMmVSa3UxdFQ3SWhBY1pBZTZRQUxIOXRkaWMzbkFXVkRrL2l0T1FvZmNVMW9nOGo0OTAyNC9RekNja1lPYU5KM1dvcDVwcXRHQ0x2UUlUd3VRUVhSWDdFNnlad0tvcExFUmZzLzUzcEQ1VzN6d2ZqSVNteHNucWJiUzh2TElOZXlsNTUySGtaT0U0emZQUHE1Z2JGNU1XZGdtdmVmN2E2U2VucHkxL21ETUJab28xZXlnSUJlclU1dnk3VGk0MkZDMDdMU0F6Z1lwWTltQnVlb1pBRDdYZHNhM0ZraVhWKzl2RTBJU0N4NXM3U1QyU2VrQkhob1BRUHNPNU9ZeEpIQXNxVHlFWFR0S1lpb1hrbEt2cFplYjdnVWExYVYvRXh1bCtlMXYyb2NnSDAydzNEeXJiL0RFa05iVDdSZ0NNTm1hVm1uOFZ5QVdEUTg2c3Z0TUs1V3pNMW0vazRhL1N6bEtadnJjMG1MdSszbEN5UElVOXhzRytaTE9SYUlhUmhyN0NGb1EyUmNqOEVSdG9OVHJScVFIYmdFQk1ORjVrRGo2VU5NUzdjUVhSK2FUbE1PdXB1eHVEYXNkVHRvcTI3R2RYQ1RQQUMxTkZJanNmanFyZ2FDZDVDQVhYZjgzTThqamdlUFRWWWNLcEliYkgzT0dWQzlqVUx4aDVEVkF4Zzg5MWRIVGx1czBEdnRmZjdKYVVKNWZGVThnRWR6Wmg2SGtraFNaclNpMEdla0w4MWxHOTVBQUFBZU5wallHUmdZQURpS1IyeTBmSDhObDhabUZrWVFPQXhuMHMxZ3Y3L2wxbUE2UzZReThIQUJCSUZBQVpuQ1pVQWVOcGpZR1JnWUdiNHp3QWtPUmlVL3g5bEZtQUFpcUFBVmdCS1dRTVBBQUFDZGdBQUF3QUFKQU1JQUNzQzlBQW5BY0lBSXdBQUFBQUFWQUN3QVNJQmFIamFZMkJrWUdCZ1pmQm1ZR1lBQVVZR05BQUFDRzhBVm5qYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjk3OTE2LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5FPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUzLjE1NTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02My43NDYyNTcnIHk9Jy02MC40NDc1MDEnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA5Ljc2NzYxLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU0LjMxNTIzLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYzLjc0NjI1NycgeT0nLTYwLjQ0NzUwMSc+STwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC41MzQ3IDBINDguMDk5OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMzQ5OTYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNi4zOTg1LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5hPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002NS4yMTEwNCAwSDEwMS40Mzk5NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDEuMzE0OTQsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODIuODY5NSw0LjE3MjkxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjc0NjI1NycgeT0nLTYwLjQ0NzUwMSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNi40MDQ1NC02LjQwOTczTDQ3LjA5MjM5LTQ3LjA5NjYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxLC0wLjcwNzA5LDAuNzA3MDksMC43MDcxLDQ3LjAwNDAxLC00Ny4wMDgyMiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lam9pbj0nbWl0ZXInPgogPHBhdGggZD0nTTMuMzk3MTMgMEwuMjUgMS44NzQ5NFYwVi0xLjg3NDk0WicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J002NS42MDY5LTQ4LjIwODc2TDEwNy4wNTE0NS02Ljc2MzI4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjcwNzA5LC0wLjcwNzEsMC43MDcxLC0wLjcwNzA5LDY1Ljc4MzY4LC00OC4wMzE5OCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcwOSwwLjcwNzEsLTAuNzA3MSwwLjcwNzA5LDEwNy4yMjgyMywtNi41ODY1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OC45OTIwMywtMzYuMTQ4ODgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUxLjk5NTkxOCcgeT0nLTYwLjQ0NzUwMSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDguODgyNTc1JyB5PSctNjAuNDQ3NTAxJz5iPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00NS4zNzkwMzcnIHk9Jy02MC40NDc1MDEnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$E$};
      \node  (2) [right = of 1] {$A$};
      \node  (3) [right = of 2] {$B$};
      \node  (4) [below = of 2] {$I$};
      \draw  [->,morphism] (1) to node {$a$} (2);
      \draw  [cover,morphism] (2) to node {$f$} (3);
      \draw  [cover,morphism] (1) to (4);
      \draw  [>->,morphism] (4) to node[swap] {$\mathsf {Img}(b)$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Since <fr:tex
display="inline"><![CDATA[a]]></fr:tex> is an isomorphism, it follows that the image of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is isomorphic to <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex>.
    Thus, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex> is an isomorphism.</fr:p>
  <fr:p>Assume the converse.
    Then the identity morphism factors through <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex>, i.e., <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex> is an isomorphism.
    Thus, it follows that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is a cover.</fr:p>
</fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>336</fr:anchor><fr:addr
type="user">log-000W</fr:addr><fr:route>log-000W.xml</fr:route><fr:title
text="Covers in the internal language of a category"><fr:link
type="local"
href="ct-000M.xml"
addr="ct-000M"
title="Extremal epimorphism">Covers</fr:link> in the <fr:link
type="local"
href="log-000P.xml"
addr="log-000P"
title="Internal language of a category">internal language</fr:link> of a category</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>.
  <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> is a cover iff <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> satisfies <fr:tex
display="inline"><![CDATA[y\colon B|\top  \vdash  \exists x\colon A.\mkern 5muf(x) = y]]></fr:tex> in its internal language.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>328</fr:anchor><fr:addr
type="machine">#246</fr:addr><fr:route>unstable-246.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Suppose that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is a cover.
    Let <fr:tex
display="inline"><![CDATA[e = (b,a)\colon E\to B \times  A]]></fr:tex> be the interpretation of <fr:tex
display="inline"><![CDATA[f(x) = y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
    Note that <fr:tex
display="inline"><![CDATA[a]]></fr:tex> is an isomorphism since the following is also an equalizer diagram.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="2fecb3601b3ac0b6315dc7b2727f23d1"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5NC41OTM0OTRwdCcgaGVpZ2h0PSc0Mi4xNjY3NDVwdCcgdmlld0JveD0nLTcyIC03MiAxMjkuNzI4OTk2IDI4LjExMTE2Myc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT3dBQW9BQUFBQUJCZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFV4MUFtTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ0ZaMng1WmdBQUFXUUFBQUQwQUFBQTlOdSsrWkpvWldGa0FBQUNXQUFBQUMwQUFBQTJLSVRNd0dob1pXRUFBQUtJQUFBQUhnQUFBQ1FGdWdLeWFHMTBlQUFBQXFnQUFBQUtBQUFBQ2dabkFKSnNiMk5oQUFBQ3RBQUFBQWdBQUFBSUFESUFlbTFoZUhBQUFBSzhBQUFBRndBQUFDQUFCUUF0Ym1GdFpRQUFBdFFBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEb0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtZXMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUTBaREJpWnZnUDVETkRwSkhVL0FjS0F3RDJ4QTArZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhHLy84RFNjUC8vLzlmQVBNWkFGRllCbzRBQVFDU0FBQUNOd0tyQUI0QUFBRVJCaFk3QVJVbUp5TUdCelV6TWpZbkVRNEJKeU0xTXhZL0FUWTNOaFlCbUFRaVRqTXNPdEU2TEROT0lRTXVWQk1TRWhJK0J6ODVHQTRDaS8zTkZ4UXRBd0VCQXkwVUZ3SUFFZ3dCTFFJS0Fnb3VBUWtBQUFFQVhRQUFBbHNDcWdBckFBQWxCeUUxTkQ4Q1BnRTNMZ0VuSWdZSEhnRVhEZ0VqQmlZblBnRTNNaFlYRGdFSEJnOEJKVFkzUGdFM0Fsc2kvaVFEQ2ZvOVRRRUNhRTAwVWhZWUlRRUJKaFVPTEFJQ2hHcHdtd01DYUVndk5Xa0JBaW9LRFE4Q3hzWWZCUUlKMURGcVAweFRBU29qQWg4YklCMEJHU2ROWlFKcFkxQnBMaUFuVGdFQkJBdEJFZ0FBZU5wallHUmdZQURpeFRNK2VNZnoyM3hsWUdaaEFJSEhmQzQ5eURSekVOTnFJTVhCd0FUaUFRQVMvQWl0QUFBQWVOcGpZR1JnWUdiNHp3QWtneGhpR1dLWm9obUFJaWlBQ1FBOTBRSnpBQUFEVWdBQUFyZ0FrZ0JkQUFBQUFBQUFBRElBZW5qYVkyQmtZR0JnWnRCaEFORU1VQklKQUFBRkJBQXpBSGphUFl3eHE4SXdGSVcvWWhYdEd4d0VoemRJOEFlRVNwK2JtNE9UcThQYnJBblNvYW1rdGVnaS9uUnZRL0FHRHQ4OTU5d0FHUzhTaGttWUJ4MG1sVGVQUE9hSFJlU0orS3ZJR2Irc0daR2tNM0ZXN0NLblRQbVBQR1pKR1hraS9pTnl4aC92ZlZQZjdwMzE2dGdZNjkybDl0dVQ5VzNWT0xYUitiQWVyTFArM0ZtanlxY3lmZFgyMTFvVk90Y0ZleHBxYnR6cHNIZ1VSM0ZNWU1kRk1zK1dVOWhiS3NtY2REWm84bTk2a05TRnhqbjhZcVJSOGhRMTlITFRpbDZscXlqQ25hYjRBRlV5TGtNQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSa0FBb0FBQUFBQlJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY2QzNW1OdFlYQUFBQUU4QUFBQU13QUFBRVFBZWdSV1oyeDVaZ0FBQVhBQUFBR1RBQUFCMU9oL1RiRm9aV0ZrQUFBREJBQUFBQzhBQUFBMkovbk1GV2hvWldFQUFBTTBBQUFBSUFBQUFDUUZ4QUdiYUcxMGVBQUFBMVFBQUFBUUFBQUFFQWtIQU94c2IyTmhBQUFEWkFBQUFBb0FBQUFLQVJRQWtHMWhlSEFBQUFOd0FBQUFGd0FBQUNBQUJnQkNibUZ0WlFBQUE0Z0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUVXQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1jbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBycU1COWdadmdQNURNek1JS0VHUkVxL2dPRkFlSlhEYUFBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnTWdEUUhFSUxrZEJqU21BLzgvNDlnL2IvNmY4NGZaN0JhTUFBQTlDd0x6UUI0MmtXUXNXN1RVQlNHNzMvdDNoc25qcS9yeE5ja05IWWNPOWV0S21JU043YVVJcnRBdTFBa3hCUjE2czRLWWtTSUIyQ0JvU084Um1kZWdJMEhJU3ZoV2d5YzdkY25uZlA5aDRDODNXL0lqcndua3BDS003N0FXVm1GOEprQTR5b3JxeHEvN043Z0tKcU8wOVNjVzNQUk04Q0t5TzF3SUY3RlFMM2NydnNyMEQ0L1dONFNQU0RYKzV5K29UL0poUTVHdThnQm42bXNSaUVEeWJpTVVLTXhFcWJLb0tpaFR4UXJHVGhJVktiS1N1VndxRUJSU3BiaCs4WTEzYkgxZEhtOEFWSmZHUkNSRUNLTmpjbEN2QXpwUUx3V3ZpT2ZKU2RQZ0VScTdvWkNlRjdZN1l4dlc0eXZmMzY4T0x3NEd6NDNWQkpPYWNxeW5rVmhYdnQzdTYweDQ5amVQTXpVUFAyUE1GS1BQcHV6RHY1MVdleDM5QXZ1U2FrRGJ4M1hqYmF2RXNVNHk5R1cwdjVCWE1wQTB5elJmd3NSeUxZeDAzVmFqTG81RE1QVUdENjRIRGZlcTVNRHA4dEFUMlc4RHZGSkhNRXdnOUhITHFYd1hRdVllSDNmN21rTEcrOStYMTJaRTVFOS9yYWxRV0dEd3JMT2gxTWZzSHhoZWJTSzh1Wm1ZbmVISTJBd241NDNIM0t0L0JkY25EczdBSGphWTJCa1lHQUE0c0twek0vaitXMitNakN6TUlEQVl6NlhIZ1Q5WDUvcEdOTkZJSmVEZ1Fra0NnQVZHZ251QUhqYVkyQmtZR0JtK00vQXdNQjBqRUh2L3dXbXlReEFFUlRBQWdCb1ZRUmpBc1lBQUFGYkFITUNPZ0JMQXF3QUxnQUFBQUFBS2dDUUFPb0FBSGphWTJCa1lHQmdZWEJrQU5FTVVCSUpBQUFITEFCSkFIamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b0NDeGRXRmdZbVhxQXRoRkdXd2pKMFJDcWpyMmQvZGhQUFFOVitkKzJFRE5Ed1gzSzVnbHZWOUpKZTdCRlZQbW1TZmkzakxYTEhqbmlhSjhsdVNWajh5bE5KK1pLMTc0eWp5Ui9EdHp6WXJmVFhDWDYyQ2oyZ1Zqb3o4NTE2MzNOdlpkOEdxcG0rUzMxdHQ0R0t4Ung1c3lZOWVQWjZkYTNlaVdEUUhIaFNzRGxvaGlKNGxKN0RsSjUraFlzMDlKTHh3a1Z5elJOUC82cmZRK2JRN3BKeU9iSXpkUnd5aUxYdlFzVzBXYlhtcmFQOHVoTC9jQUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9JQUFvQUFBQUFBL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDE0bU50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNVWjJ4NVpnQUFBV1FBQUFESkFBQUF6RFZtV2Zob1pXRmtBQUFDTUFBQUFDOEFBQUEyS1ByTThXaG9aV0VBQUFKZ0FBQUFId0FBQUNRSE1nT0dhRzEwZUFBQUFvQUFBQUFJQUFBQUNBZDVBR2xzYjJOaEFBQUNpQUFBQUFZQUFBQUdBR1lBQUcxaGVIQUFBQUtRQUFBQUZnQUFBQ0FBQlFBK2JtRnRaUUFBQXFnQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTNzTTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCa1p2Z1A1RE5EcEpIVS9BY0tBd0Rwc2cwdmVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpTy8vOUR5UDhId0h3R0FGS1hCcDBBQUFCNDJoWEpRV3JDUUJRRzRQZS9HZWFwTTBaajZrUmJDS2dRZDJxckpGUWtpQlJCdklFMzZLSWJCUS9oc21mcENib1JlZ2QzTG5xSnFuWDdmY1QwZnIycUk1L29sV1pFaUJLTU14OTdHYUtHdEY4ZzlsaytSRWRNalkwa3lHTWZCN2huTisybldWNGdSNEVYTDZyRHYzdTBSallDSHVlTDFWc0RpRnhwcXF2aDVTZlNhdTBNT0MxWkFVS3ptd3kwWlVqd3ZFandLZld1MjV6UjQrKy9RMWlGY1Urc0FJVjZzd3hJdU55QTljZURMVGNxWU9YK1VVTkpoZHVNM29DWDFybnQ1WXVJYnRGM0c5a0FBQUI0Mm1OZ1pHQmdBT0tiTW44bXgvUGJmR1ZnWm1FQWdjZDhMajBJK3Y5LzV1Tk1kNEZjRGdZbWtDZ0FQQVFMWUFCNDJtTmdaR0JnWnZqUHdNREFvc3FReVJESGZKd0JLSUlDbUFCQ3h3TEJBQU5VQUFBRUpRQnBBQUFBQUFCbUFBQjQybU5nWkdCZ1lHS3dCV0lRWUdSQUF3QUdxUUJFQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDMEFBQUEyS0FiTUZtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhNaXZQTHgvRFpmR1poWkdFRGdNWjlMRDRMK3o4aDBtUm5FNVdCZ0FsRUE0eWdJRlFBQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTkFBQW9BQUFBQUE2UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJnaU9SekcyTnRZWEFBQUFGQUFBQUFLUUFBQURRQURBRXFaMng1WmdBQUFXd0FBQUI0QUFBQWVKTVNQSkZvWldGa0FBQUI1QUFBQUMwQUFBQTJLRTdNRFdob1pXRUFBQUlVQUFBQUhnQUFBQ1FHTmYvZGFHMTBlQUFBQWpRQUFBQUdBQUFBQmdPd0FBQnNiMk5oQUFBQ1BBQUFBQVlBQUFBR0FEd0FBRzFoZUhBQUFBSkVBQUFBRndBQUFDQUFCQUFrYm1GdFpRQUFBbHdBQUFEVEFBQUJQcTgzZGVGd2IzTjBBQUFETUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtbG1HY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRVRBeEpJS1M1TEIwcGVaN2pPTFBWSGs0R0JXWXI1T2xDWUVhSGkvMzhHQmdEcm5RN3ZBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4Q0MrTmYvLzRlUS83WEFmQVlBWHVVSE13QUFBQUFCQUpRQUNRS0dBZmdBSWdBQUFUYzJGeFlYQmc4Q0h3RVdCd1lISmk4QkJ3NEJJeVluSmo4Qkp5WTNOamN5RndHT3l3NEtFd0VDQXhxN3BUSUVBUUVUQ3dYVXl3a0lCaEVEQXhETnpSQURBeEVHQkFFZHloRUJBaE1LQXhxN3BUSUlBeE1DQWdUVXl3b0ZBaE1IRGM3T0RRY1RBZ0lBQUhqYVkyQmtZR0FBNGxVbUd6L0g4OXQ4WldCbVlRQ0J4M3d1UGNnMHN3empEeURGd2NBRTRnRUFGSk1JendBQUFIamFZMkJrWUdDVytxTUpKR1VZcGpCTVkycGpBSXFnQUVZQVRNb0RGd0FBQXh3QUFBQ1VBQUFBQUFBQUFEd0FBSGphWTJCa1lHQmdZbEJtQU5FTVVCSUpBQUFFQ0FBcEFIamFUWTZ4YXNNd0VJWS9VOGRRSjVDcEhUb1VUUm1GamZNQWhReVpzbVlzSkpFSURsZ09rbVB3VXZJQWZlaGVGQTA5d2ZIcHYrK0VnSklmTWg2VnNZejlVVG1GM0o0OFk4NWI0a0tPU2x6eXdZb1hzdnhWa2srK0V1Y3MrRTQ4NDUxTDRrTHllK0tTTmIrYnZydmVCdXZWcmpmV3UxTVhwcnJhV3gvYTNxbGFWODlnYTUzMWg4RWFkWnlVR2Rzd25qdlY2RW8zYk9qcHVISmp3T0xsWnp0SlRHVEhTV2FCaVpxS2Zjd0NyY3lkZURWYTB2L0dWZ3dYclVOOHpZaDFsSmtTR21VdlNEK0xyMmppcnFiNUF3bFJNUk1BZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5RQUFvQUFBQUFBN3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZcDBMMk50WVhBQUFBRTRBQUFBTVFBQUFEd0FnQUM4WjJ4NVpnQUFBV3dBQUFDTUFBQUFqQ3dWdUtkb1pXRmtBQUFCK0FBQUFDOEFBQUEySjRQTTBtaG9aV0VBQUFJb0FBQUFId0FBQUNRRkRBR2phRzEwZUFBQUFrZ0FBQUFNQUFBQURBV0VBSEpzYjJOaEFBQUNWQUFBQUFnQUFBQUlBRElBUm0xaGVIQUFBQUpjQUFBQUdBQUFBQ0FBQmdBZGJtRnRaUUFBQW5RQUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRFJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXZNWTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWWNoazV2NFA1RE56TTZLcCtROFVCZ0Q5UFEyb2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS3BqQmsvdjhQNUlQcC8zUC96d1NyQWdJQW1ORUpOZ0FBQUFBQ0FDWC85Z0hhQXNjQUVBQWJBQUFCRVNNMURnRUhMZ0VuUGdFM05oWVhFUU0xSmlNbUJnY2VBVGMyQWRwWkhsUXdVV2NDQW1sU0dGZ3lBeWcrT0dJREFsYzRTd0xIL1RrMUdpUUJBNFprWllZREFSVWlBU3o5dU5vMEFVMWZXRklCQXdBQUFnQk5BQUFBdEFLK0FBTUFCd0FBRXhVak5SY1JJeEcwWjE5V0FyNW5aL2YrT1FISEFBQUFlTnBqWUdSZ1lBRGlzeGZjbytQNWJiNHlNTE13Z01CalBwY2VCUDMvRzFNQTAzRWdsNE9CQ1NRS0FDbHFDb1FBZU5wallHUmdZT2IrejhEQXdCVEFvTXJnejNpTEFTaUNBcGdCUWdZQ3RBQUNVQUFBQWpFQUpRRURBRTBBQUFBQUFESUFSbmphWTJCa1lHQmdacEJoWUdJQUFVWUdOQUFBQTRzQUpIamFUWXc5YjhJd0VJYWZxQWxTdzhDQ09qQzBIanBiUVdGZ1ltRmdZbVZpQWV5aURIR1FIU0loVlIzNTNUMk1CODdTNlhrL3prREpIeG1QeVpqRS9aaWNRdFNUQzhaTUU0OUVmU1V1bWZITkcxbitMczRucThTNUpQdkVCUi84SkI2Si81dTRaTUY5M2JXWGEyKzkybmJHZW5kcVExanVyQTlONTlSY1YxRnZyTFArMEZ1ampqZGxoaVlNNTFiVnV0STFhenBhTGx6cHNYZ1VXM0ZNWk1kSnNpQnZ5UzQ2Z1VaU0o2MDVtdW9sMzBqdVl1Y1FmekxTT1hLVGJSamtLc2crUzF0UngwdE4vUS9xYlRBN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktEbk03MmhvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRyYmYyOWJHODl0OFpXQm1ZUUNCeDN3dVBRajYvMTltTnFhN1FDNEhBeE5JRkFCQ3VBcjlBSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjMuOTc0NTU4LC01Ni44NDQzOSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTU2Ljg0NDM5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My45NzQ1NTgnIHk9Jy01Ni44NDQzOSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0My4wMDEwMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC01Ni44NDQzOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjMuOTc0NTU4JyB5PSctNTYuODQ0MzknPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUzLjcwNDA4MycgeT0nLTU2Ljg0NDM5Jz7DlzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDMuNzQxNDcnIHk9Jy01Ni44NDQzOSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDkuNzY3NjEsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjk3NDU1OCcgeT0nLTU2Ljg0NDM5Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMC41MDU1NCAwSDM3Ljk0NTQ4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDEwLjc1NTU0LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguMTk1NDgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMC42MDU3Myw0LjU2MTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC01Ni44NDQzOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNjMuOTc0NTU4JyB5PSctNTYuODQ0MzknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYwLjg2MTIxNScgeT0nLTU2Ljg0NDM5Jz5mPHRzcGFuIHg9Jy01Ni42MjM1NzknPiw8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTIuODk2ODAyJyB5PSctNTYuODQ0MzknPmlkPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny4zMDMxMzknIHk9Jy01NS44NDI1NzcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQxLjY0MzcyOCcgeT0nLTU2Ljg0NDM5Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J003NS4zNjU1MiAzLjYxNjYySDEwNC43MTIwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDQuOTYyMDcsMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODMuNjU3MTgsNy43ODk1NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYzLjk3NDU1OCcgeT0nLTU2Ljg0NDM5Jz5mPHRzcGFuIHg9Jy01OS4zMDc5NzMnPs+APC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTU0LjY0OTEyOScgeT0nLTU1Ljg0ODEyNic+MjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNzUuMzY1NTItMy42MTY2MkgxMDQuNzEyMDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA0Ljk2MjA3LC0zLjYxNjYyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4NS45OTkyMiwtOS40NDIzMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYzLjk3NDU1OCcgeT0nLTU2Ljg0NDM5Jz7PgDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTkuMzE1NzEzJyB5PSctNTUuODQ4MTI2Jz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$A$};
      \node  (2) [right = of 1] {$B \times  A$};
      \node  (3) [right = of 2] {$B$};
      \draw  [>->,morphism] (1) to node {$(f,\mathsf {id}_{A})$} (2);
      \draw  [->,morphism,offset=-1.5] (2) to node {$f\pi _{2}$} (3);
      \draw  [->,morphism,offset=1.5] (2) to node [swap] {$\pi _{1}$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By <fr:ref
addr="log-0008"
href="log-0008.xml"
taxon="Definition" />, <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket y\colon B.\exists x\colon A.\mkern 5muf(x) = y\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> is the <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">image</fr:link> of the following composite.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="0021f07569b7a823d1e143f26fa9d369"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5NC45MzU5NXB0JyBoZWlnaHQ9JzEwOC4yNzMwODZwdCcgdmlld0JveD0nLTcyIC03MiAxMjkuOTU3MyA3Mi4xODIwNTcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVTBBQW9BQUFBQUJod0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MDBtTnRZWEFBQUFFNEFBQUFOUUFBQUVRQVdnRDJaMng1WmdBQUFYQUFBQUpaQUFBQzBLeVFkaGhvWldGa0FBQUR6QUFBQUM4QUFBQTJLRVBNN1dob1pXRUFBQVA4QUFBQUhnQUFBQ1FHTmdIVGFHMTBlQUFBQkJ3QUFBQVVBQUFBRkEwMEFKbHNiMk5oQUFBRU1BQUFBQXdBQUFBTUFYWUNHRzFoZUhBQUFBUThBQUFBR0FBQUFDQUFDUUJNYm1GdFpRQUFCRlFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGS0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtV3NJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaUEJrWnZnUDVETkRwSkhVL0FjS0F3RGhoQTBlZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVNjR0Z3WlBQLy9CN0ljSWF6L0IvN3YrNzhickJZTUFPRVdDMG9BQUFCNDJqMlN6MHNVVVFESDMvZTltZmZjM1psNXE3TTdvem5Pc3EzT2lLYkcvbmpiYnJSU3FZV1NXRUo0a0lvZ2hhQU9ZWHJNZzVSSkhTSUlPblhwVnBkT0VYVHExRC9RTVNFNlJZUkhUN3ZiR3luZjZmRjk3L0Q1OFAwU1NvYTdYZnFEZmlkVHBFeElIYXBlOW53MzUxV1V4NmNnNGlpdUt0OVQ5U2tVQmM5NXZ2SWQ2RHlKS3kzVUsrd2o3dkNjemRIeUp2S3d6STN0SGhOMnhxMnlsT2gwRiszQXRSbHNjMzNGZ3BVNjJYcjl1N2hKcjJlUmt1MXRUN0loQWNaQWU2UUFMSDl0ZGljM25BV1ZEay9pdE9Rb2ZjVTFvZzhqNDkwMjQvUXpDY2tZT2FOSjNXb3A1cHF0R0NMdlFJVHd1UVFYUlg3RTZ5WndLb3BMRVJmcy81M3BENVczendmaklTbXhzbnFiYlM4dkxJTmV5bDU1MkhrWk9FNHpmUFBxNWdiRjVNV2RnbXZlZjdhNlNlbnB5MS9tRE1CWm9vMWV5Z0lCZXJVNXZ5N1RpNDJGQzA3TFNBemdZcFk5bUJ1ZW9aQUQ3WGRzYTNGa2lYVis5dkUwSVNDeDVzN1NUMlNla0JIaG9QUVBzTzVPWXhKSEFzcVR5RVhUdEtZaW9Ya2xLdnBaZWI3Z1VhMWFWL0V4dWwrZTF2Mm9jZ0gwMnczRHlyYi9ERWtOYlQ3UmdDTU5tYVZtbjhWeUFXRFE4NnN2dE1LNVd6TTFtL2s0YS9TemxLWnZyYzBtTHUrM2xDeVBJVTl4c0crWkxPUmFJYVJocjdDRm9RMlJjajhFUnRvTlRyUnFRSGJnRUJNTkY1a0RqNlVOTVM3Y1FYUithVGxNT3VwdXh1RGFzZFR0b3EyN0dkWENUUEFDMU5GSWpzZmpxcmdhQ2Q1Q0FYWGY4M004ampnZVBUVlljS3BJYmJIM09HVkM5alVMeGg1RFZBeGc4OTFkSFRsdXMwRHZ0ZmY3SmFVSjVmRlU4Z0VkelpoNkhra2hTWnJTaTBHZWtMODFsRzk1QUFBQWVOcGpZR1JnWUFEaUtSMnkwdkg4Tmw4Wm1Ga1lRT0F4bjBzM2d2Ny9sMW1BNlM2UXk4SEFCQklGQVA1NENYVUFlTnBqWUdSZ1lHYjR6d0FrT1JpVS94OWxGbUFBaXFBQVZnQktXUU1QQUFBQ2RnQUFBd0FBSkFNSUFDc0M5QUFuQWNJQUl3QUFBQUFBVkFDd0FTSUJhSGphWTJCa1lHQmdaZkJtWUdZQUFVWUdOQUFBQ0c4QVZuamFUWTZ4YXNNd0VJWS9VOGRRcDlDcEhUb1VUUm1GamZzQWdReVpzbVlzSkpFSURrZ0tzbVBJRXZvQWZlaGVGQTA5d2ZIZGQ3K0VnSm9iQmZjcWVFMzlYaVdWVEErZU1lY3RjeVZIWmE3NVlNRVRSZmtzNXBObDVwSVh2alBQZU9lVXVSTC9rN25taTk5VmNPZkxhS1BhQkdPalB6alh0ODNXeHFFUFhyVzZlWWkxOVRidVJtdlUvcXJNMUEvVDBhbE9ON3BqUmNCeDVzS0lKY3JQTm1KTVlzOUJkbzZlbG9adGNvTk1RVFpLbkJiN1A3R1doRStwWFhyTlNHclBWYnBoa3N3Zy9TaHBSWmZ1YXJvLzMvUXd1d0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktEL01DV2hvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaTQrRGtuZkg4Tmw4Wm1Ga1lRT0F4bjBzM2d2NnZ6OHpEZEJ6STVXQmdBb2tDQVAwVENOc0FlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNY0FBb0FBQUFBQTRRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVXgxRzJOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDRVoyeDVaZ0FBQVdRQUFBQmtBQUFBWkRGdUFySm9aV0ZrQUFBQnlBQUFBQzBBQUFBMktJVE12bWhvWldFQUFBSDRBQUFBSGdBQUFDUUZ5d0xXYUcxMGVBQUFBaGdBQUFBSUFBQUFDQVlLQUpKc2IyTmhBQUFDSUFBQUFBWUFBQUFHQURJQUFHMWhlSEFBQUFJb0FBQUFGd0FBQUNBQUJBQWdibUZ0WlFBQUFrQUFBQURLQUFBQk11c0lrZVp3YjNOMEFBQUREQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1abVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvYU1oZ3lNL3dIOHBraDBraHEvZ09GQWFOM0RGZ0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aUcvLzlEeVA4WHdId0dBRkZIQm8wQUFBQUFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FlTnBqWUdSZ1lBRGlIMWNlVzhiejIzeGxZR1poQUlISGZDN2R5RFJ6RU5OcUlNWEJ3QVRpQVFBblhna2RBQUFBZU5wallHUmdZR2I0endBa2d4Z21NVFF5bVRNQVJWQUFFd0JDM0FLb0FBQURVZ0FBQXJnQWtnQUFBQUFBTWdBQWVOcGpZR1JnWUdCaWtHY0EwUXhRRWdrQUFBT2tBQ1VBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktuNXViZzVPcnc5dXNDZEtocWFTMTZDTCtkRzlEOEFZTzN6M24zQUFaTHhLR1NaZ0hIU2FWTjQ4ODVvZEY1SW40cThnWnY2d1prYVF6Y1Zic0lxZE0rWTg4WmtrWmVTTCtJM0xHSCs5OVU5L3VuZlhxMkJqcjNhWDIyNVAxYmRVNHRkSDVzQjZzcy83Y1dhUEtweko5MWZiWFdoVTYxd1Y3R21wdTNPbXdlQlJIY1V4Z3gwVXl6NVpUMkZzcXlaeDBObWp5YjNxUTFJWEdPZnhpcEZIeUZEWDBjdE9LWHFXcktNS2RwdmdBVlRJdVF3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5BQUFvQUFBQUFBNlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ2lPUnpHMk50WVhBQUFBRkFBQUFBS1FBQUFEUUFEQUVxWjJ4NVpnQUFBV3dBQUFCNEFBQUFlSk1TUEpGb1pXRmtBQUFCNUFBQUFDMEFBQUEyS0U3TUMyaG9aV0VBQUFJVUFBQUFIZ0FBQUNRR05mL2RhRzEwZUFBQUFqUUFBQUFHQUFBQUJnT3dBQUJzYjJOaEFBQUNQQUFBQUFZQUFBQUdBRHdBQUcxaGVIQUFBQUpFQUFBQUZ3QUFBQ0FBQkFBa2JtRnRaUUFBQWx3QUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRE1BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWxtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVUQXhKSUtTNUxCMHBlWjdqT0xQVkhrNEdCV1lyNU9sQ1lFYUhpLzM4R0JnRHJuUTd2QUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeENDK05mLy80ZVEvN1hBZkFZQVh1VUhNd0FBQUFBQkFKUUFDUUtHQWZnQUlnQUFBVGMyRnhZWEJnOENId0VXQndZSEppOEJCdzRCSXlZbkpqOEJKeVkzTmpjeUZ3R095dzRLRXdFQ0F4cTdwVElFQVFFVEN3WFV5d2tJQmhFREF4RE56UkFEQXhFR0JBRWR5aEVCQWhNS0F4cTdwVElJQXhNQ0FnVFV5d29GQWhNSERjN09EUWNUQWdJQUFIamFZMkJrWUdBQTRsVW1HNy9IODl0OFpXQm1ZUUNCeDN3dTNjZzBzd3pqRHlERndjQUU0Z0VBRlJFSTBRQUFBSGphWTJCa1lHQ1crcU1KSkdVWXBqQk1ZMnBqQUlxZ0FFWUFUTW9ERndBQUF4d0FBQUNVQUFBQUFBQUFBRHdBQUhqYVkyQmtZR0JnWWxCbUFORU1VQklKQUFBRUNBQXBBSGphVFk2eGFzTXdFSVkvVThkUUo1Q3BIVG9VVFJtRmpmTUFoUXlac21Zc0pKRUlEbGdPa21Qd1V2SUFmZWhlRkEwOXdmSHB2KytFZ0pJZk1oNlZzWXo5VVRtRjNKNDhZODViNGtLT1Nsenl3WW9Yc3Z4VmtrKytFdWNzK0U0ODQ1MUw0a0x5ZStLU05iK2J2cnZlQnV2VnJqZld1MU1YcHJyYVd4L2EzcWxhVjg5Z2E1MzFoOEVhZFp5VUdkc3duanZWNkVvM2JPanB1SEpqd09MbFp6dEpUR1RIU1dhQmlacUtmY3dDcmN5ZGVEVmEwdi9HVmd3WHJVTjh6WWgxbEprU0dtVXZTRCtMcjJqaXJxYjVBd2xSTVJNQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDMEFBQUEyS0FiTUZHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhNaXZNcngvRFpmR1poWkdFRGdNWjlMTjRMK3o4aDBtUm5FNVdCZ0FsRUE0NllJRndBQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTZ0FBb0FBQUFBQlZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZjE0REdOdFlYQUFBQUU4QUFBQU13QUFBRVFBZVFTTVoyeDVaZ0FBQVhBQUFBSFBBQUFDRU41RDlxOW9aV0ZrQUFBRFFBQUFBQzhBQUFBMkovbk16MmhvWldFQUFBTndBQUFBSUFBQUFDUUZ3d0hrYUcxMGVBQUFBNUFBQUFBUUFBQUFFQW1mQUxac2IyTmhBQUFEb0FBQUFBb0FBQUFLQVdBQXJtMWhlSEFBQUFPc0FBQUFHQUFBQUNBQUJ3QTRibUZ0WlFBQUE4UUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUVsQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1TbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBvbU1SOWdadmdQNURNek1JS0VHUkVxL2dPRkFmYXZEZndBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnTWdEUUhFSUxra2hoU21RLzgvNDlnL1ovL2YrNGZaN0JhTUFBQS9Lc01BZ0I0MmlXUXYyN1RVQlRHNzNmdFhNZU9ZNmVwLzhRVk1ZbWQyZzRwY1JSanV5S3BuUllIVUpkV2FxVXFIYnF6TUtCdWxSRHdDcndBSXkvQUFETVM3d0ZpWUFjV0JPV20zYzUzdmpQOHpvOVE4dWo2Tjc3U0w4UWpHU0VRQ3VTWlpUTWRUQm9qREVxK0NId3ZDQXNrdkpEV2ZZRjBETitUTlBBcjA3Q2dQYllQb3QwTFFkanZINjcyVHdGMmY2d3dxZy9rRFVDWHFwMEI4bWk1MmVsaTVNNExyUzY2OVNGOS8rK2I1UUVucTJmSGZpVmdkZFR5UG42NFp6Y1ZVZEhya2lpb2Y4OHhEeWRYL29PNDBuWHRLbkxHRHdtaFpNbDUvK0F6Q2RhOHVjOUpYU1JXaVN6UFhKakdMWGpLVTU0bFU4dTJtTVNrTUxIV09lZllBWS9zKzBJR1JSYTM5dHFMbWRKc1RMZUt5L01MOGFuWk9Ubk5ud0QrN3M3azliUTczL1pTRWJGdkpWb3ovUkdaYmxGUXRkWmFOS0F5YmRpS1JQcjgrRVZsNk9sazFOa3pOZEVCcTJsRzd2WUVRMUo2QkdSOC9ZdSt4YWNiczF5WEg2UWx1RUEvNEF3eDFsSzVUTHZQaGZNMnZQM0Z0dmdzc1NDOHFWR1VHNjQ3RUl4T3RWVzJqNFkxVFdHZ0k2dWZ1bmlqMzRFZzJzNHJoVktZTFJub3RwdW0yZ0FjRlpjL2wwdXhxNGVUZDJmVVRsVCtyaXpQako0SnlLWXV0MmwrTnk1WFhWVXhIR0J6dXpjclg4YUVrUDlqUTB5T0FIamFZMkJrWUdBQTR1YWJheWZHODl0OFpXQm1ZUUNCeDN3dTNRajYvMWVtWTB6SGdWd09CaWFRS0FBK0RndFNBSGphWTJCa1lHQm0rTS9Bd01CMGpFR1BRWkpwTWdOUUJBV3dBQUJEYUFLdEFzWUFBQUlDQUVNQ0t3QkZBcXdBTGdBQUFBQUFXQUN1QVFnQUFIamFZMkJrWUdCZ1lUQm5ZR0lBQVVZR05BQUFCa2tBUUhqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuOTc5MTYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkU8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDMuMDAxMDIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUzLjQ3NTc4MycgeT0nLTYyLjY0NzU2NCc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQzLjUxMzE3JyB5PSctNjIuNjQ3NTY0Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwOS43Njc2MSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjc0NjI1NycgeT0nLTYyLjY0NzU2NCc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1NC4zMTUyMywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjczNDcgMEgzNy45NDU0OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMC45ODQ3LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguMTk1NDgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMS41OTMwMywyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYzLjc0NjI1NycgeT0nLTYyLjY0NzU2NCc+ZTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNzUuMzY1NTIgMEgxMDQuNzEyMDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA0Ljk2MjA3LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODUuOTk5MjIsMy44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPs+APC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01OS4wODc0MTMnIHk9Jy02MS42NTEzJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002LjQwNDU0LTYuNDA5NzNMNDcuMDkyMzktNDcuMDk2NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzEsLTAuNzA3MDksMC43MDcwOSwwLjcwNzEsNDcuMDA0MDEsLTQ3LjAwODIyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPHBhdGggZD0nTTY1LjYwNjktNDguMjA4NzZMMTA3LjA1MTQ1LTYuNzYzMjgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNzA3MDksLTAuNzA3MSwwLjcwNzEsLTAuNzA3MDksNjUuNzgzNjgsLTQ4LjAzMTk4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzA5LDAuNzA3MSwtMC43MDcxLDAuNzA3MDksMTA3LjIyODIzLC02LjU4NjUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4Ljk5MjAzLC0zNi4xNDg4OCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTEuOTk1OTE4JyB5PSctNjIuNjQ3NTY0Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00OC44ODI1NzUnIHk9Jy02Mi42NDc1NjQnPmI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ1LjM3OTAzNycgeT0nLTYyLjY0NzU2NCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$E$};
      \node  (2) [right = of 1] {$B \times  A$};
      \node  (3) [right = of 2] {$B$};
      \node  (4) [below = of 2] {$I$};
      \draw  [>->,morphism] (1) to node {$e$} (2);
      \draw  [->,morphism] (2) to node {$\pi _{1}$} (3);
      \draw  [cover,morphism] (1) to (4);
      \draw  [>->,morphism] (4) to node[swap] {$\mathsf {Img}(b)$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By assumption, <fr:tex
display="inline"><![CDATA[fa = b]]></fr:tex>.
    Thus, the image of <fr:tex
display="inline"><![CDATA[b]]></fr:tex> coincides with that of <fr:tex
display="inline"><![CDATA[fa]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="cf3296da579bb485744d3cb260f07009"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5NC45MzU5NXB0JyBoZWlnaHQ9JzExMS41NzMxOTFwdCcgdmlld0JveD0nLTcyIC03MiAxMjkuOTU3MyA3NC4zODIxMjcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDMEFBQUEyS0FiTDlHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhNaXZNbngvRFpmR1poWkdFRGdNWjlMTllMK3o4aDBtUm5FNVdCZ0FsRUE2NFlJTndBQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktEL0w2V2hvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaTQrRGtuL0g4Tmw4Wm1Ga1lRT0F4bjBzMWd2NnZ6OHpEZEJ6STVXQmdBb2tDQUFVQ0NQc0FlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVE1BQW9BQUFBQUJZZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFh4MHFtTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWZRQzdaMng1WmdBQUFXd0FBQUgrQUFBQ1VFcE9qTEJvWldGa0FBQURiQUFBQUM4QUFBQTJKL25MODJob1pXRUFBQU9jQUFBQUlBQUFBQ1FGcXdHYmFHMTBlQUFBQTd3QUFBQVFBQUFBRUFsOEFNeHNiMk5oQUFBRHpBQUFBQW9BQUFBS0FaSUF3bTFoZUhBQUFBUFlBQUFBR0FBQUFDQUFCd0JDYm1GdFpRQUFBL0FBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFd0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtaW1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb21NcVF4TS93SDhwa2gwa2hxL2dPRkFjK2NEUllBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLSmpHay9mOFA1Q2VDNlA4TC9zOEZxd0lDQUpnL0NUSUFBSGphUlpFL2I5TlFGTVY5M25OdHh4Uy9KSTZmYWRNNnFaLzduSmJHcFRqWXFGUk9rN2FSK2srMEFxbEt4WitKQWI1Q0Z6WTJKZ1pXTmtZV0J2WktiRWg4QWlUNERHVWo0YmtNM0x2ZGM0ZmZPVWNqV2pHOUl2dTQxTHJhdHFhaHdGM3VNK0xBYTNDL1FCOVpDOXh2R0taYUdUc3dFOFJaWG00QW1tZXhqS1ZocW5PQXZFQ2U0ZFBNWXJPQnVzZk5DblBid3JKMDJ6YmcxcHFaUDZ3Ris2czdaOUQ3ekQwNFgrNXRwR2g0cVQ4U2JnaXNCV0hQa25qRDNXcnQ1UGlKbHpoOEFXUXZiaG9neEo0WnRGT0taamZvQUUrUFhweTY5UkZGT1BueGJYWTUwa25uZ1hqZHpST1FscldncVNIYXp2UTNmcEt2V3FobHloTXR5Ymh2TUJnbHZ1eXJneFNoakF1a1NqQkx2Y0M5QkNKVVZ0U1g4ZzVuNUE4Nzk1OVJPbGc2R0E4ZUEwWTNzUTNDb2tvTllPYnVXb1M4cytmZVdzVHRZS3R3TEQyd1Zzakh5Uyt1ekR3YXZ6d1J1eFRqaDlYd3krZFYvNmF0Mjh3eWRUcjc1eHhiOFowTDBWdmZaY3k1Nk13bG13cFFPNXl1azFmayszVUR0TVJVaWY3ajR6NDNUTjVTdmZTcE1HVG1wOWV3cVdySmdWRHBaN2xjaDBNWTBvd2JNVDVzVnZYcWZHV3cwZGtFSWs5U3NCWmpMRnFpaXdrN0NvakxUcG5uOEtGWTJRSUVWM28xWUt4ZUQyeHIvbmtwNDkzazhxQzIzV3ZzVUNtQ05vbU0rRWFGUUQvMDNsK2QwZERFMmJnWnkrWG92NFE1Mlgycmh4WlU5SDhCbG5kVG1BQUFlTnBqWUdSZ1lBRGlOUmNteU1mejIzeGxZR1poQUlISGZDN1ZDUHEvUHRNeHBvdEFMZ2NERTBnVUFCMnBDZ2NBZU5wallHUmdZR2I0ejhEQXdIU013ZTcvQmFZc0JxQUlDbUFCQUdhNkJFb0N4Z0FBQW5vQVBnSUNBRU1DT2dCTEFBQUFBQUJxQU1JQktBQUFlTnBqWUdSZ1lHQmhjR1JnWWdBQlJnWTBBQUFIUXdCS2VOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVMEFBb0FBQUFBQmh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwMG1OdFlYQUFBQUU0QUFBQU5RQUFBRVFBV2dEMloyeDVaZ0FBQVhBQUFBSlpBQUFDMEt5UWRoaG9aV0ZrQUFBRHpBQUFBQzhBQUFBMktFUE16V2hvWldFQUFBUDhBQUFBSGdBQUFDUUdOZ0hUYUcxMGVBQUFCQndBQUFBVUFBQUFGQTAwQUpsc2IyTmhBQUFFTUFBQUFBd0FBQUFNQVhZQ0dHMWhlSEFBQUFROEFBQUFHQUFBQUNBQUNRQk1ibUZ0WlFBQUJGUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZLQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1Xc0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpQQmtadmdQNURORHBKSFUvQWNLQXdEaGhBMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1U2NHRndaUFAvL0I3SWNJYXovQi83dis3OGJyQllNQU9FV0Mwb0FBQUI0MmoyU3owc1VVUURIMy9lOW1mZmMzWmw1cTdNN296bk9zcTNPaUtiRy9uamJiclJTcVlXU1dFSjRrSW9naGFBT1lYck1nNVJKSFNJSU9uWHBWcGRPRVhUcTFEL1FNU0U2UllSSFQ3dmJHeW5mNmZGOTcvRDU4UDBTU29hN1hmcURmaWRUcEV4SUhhcGU5bnczNTFXVXg2Y2c0aWl1S3Q5VDlTa1VCYzk1dnZJZDZEeUpLeTNVSyt3ajd2Q2N6ZEh5SnZLd3pJM3RIaE4yeHEyeWxPaDBGKzNBdFJsc2MzM0ZncFU2MlhyOXU3aEpyMmVSa3UxdFQ3SWhBY1pBZTZRQUxIOXRkaWMzbkFXVkRrL2l0T1FvZmNVMW9nOGo0OTAyNC9RekNja1lPYU5KM1dvcDVwcXRHQ0x2UUlUd3VRUVhSWDdFNnlad0tvcExFUmZzLzUzcEQ1VzN6d2ZqSVNteHNucWJiUzh2TElOZXlsNTUySGtaT0U0emZQUHE1Z2JGNU1XZGdtdmVmN2E2U2VucHkxL21ETUJab28xZXlnSUJlclU1dnk3VGk0MkZDMDdMU0F6Z1lwWTltQnVlb1pBRDdYZHNhM0ZraVhWKzl2RTBJU0N4NXM3U1QyU2VrQkhob1BRUHNPNU9ZeEpIQXNxVHlFWFR0S1lpb1hrbEt2cFplYjdnVWExYVYvRXh1bCtlMXYyb2NnSDAydzNEeXJiL0RFa05iVDdSZ0NNTm1hVm1uOFZ5QVdEUTg2c3Z0TUs1V3pNMW0vazRhL1N6bEtadnJjMG1MdSszbEN5UElVOXhzRytaTE9SYUlhUmhyN0NGb1EyUmNqOEVSdG9OVHJScVFIYmdFQk1ORjVrRGo2VU5NUzdjUVhSK2FUbE1PdXB1eHVEYXNkVHRvcTI3R2RYQ1RQQUMxTkZJanNmanFyZ2FDZDVDQVhYZjgzTThqamdlUFRWWWNLcEliYkgzT0dWQzlqVUx4aDVEVkF4Zzg5MWRIVGx1czBEdnRmZjdKYVVKNWZGVThnRWR6Wmg2SGtraFNaclNpMEdla0w4MWxHOTVBQUFBZU5wallHUmdZQURpS1IyeTBmSDhObDhabUZrWVFPQXhuMHMxZ3Y3L2wxbUE2UzZReThIQUJCSUZBQVpuQ1pVQWVOcGpZR1JnWUdiNHp3QWtPUmlVL3g5bEZtQUFpcUFBVmdCS1dRTVBBQUFDZGdBQUF3QUFKQU1JQUNzQzlBQW5BY0lBSXdBQUFBQUFWQUN3QVNJQmFIamFZMkJrWUdCZ1pmQm1ZR1lBQVVZR05BQUFDRzhBVm5qYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjk3OTE2LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5FPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUzLjE1NTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02My43NDYyNTcnIHk9Jy02MC40NDc1MDEnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA5Ljc2NzYxLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU0LjMxNTIzLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYzLjc0NjI1NycgeT0nLTYwLjQ0NzUwMSc+STwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC41MzQ3IDBINDguMDk5OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMzQ5OTYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNi4zOTg1LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5hPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002NS4yMTEwNCAwSDEwMS40Mzk5NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDEuMzE0OTQsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODIuODY5NSw0LjE3MjkxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjc0NjI1NycgeT0nLTYwLjQ0NzUwMSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNi40MDQ1NC02LjQwOTczTDQ3LjA5MjM5LTQ3LjA5NjYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxLC0wLjcwNzA5LDAuNzA3MDksMC43MDcxLDQ3LjAwNDAxLC00Ny4wMDgyMiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lam9pbj0nbWl0ZXInPgogPHBhdGggZD0nTTMuMzk3MTMgMEwuMjUgMS44NzQ5NFYwVi0xLjg3NDk0WicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J002NS42MDY5LTQ4LjIwODc2TDEwNy4wNTE0NS02Ljc2MzI4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjcwNzA5LC0wLjcwNzEsMC43MDcxLC0wLjcwNzA5LDY1Ljc4MzY4LC00OC4wMzE5OCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcwOSwwLjcwNzEsLTAuNzA3MSwwLjcwNzA5LDEwNy4yMjgyMywtNi41ODY1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OC45OTIwMywtMzYuMTQ4ODgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUxLjk5NTkxOCcgeT0nLTYwLjQ0NzUwMSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDguODgyNTc1JyB5PSctNjAuNDQ3NTAxJz5iPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00NS4zNzkwMzcnIHk9Jy02MC40NDc1MDEnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$E$};
      \node  (2) [right = of 1] {$A$};
      \node  (3) [right = of 2] {$B$};
      \node  (4) [below = of 2] {$I$};
      \draw  [->,morphism] (1) to node {$a$} (2);
      \draw  [cover,morphism] (2) to node {$f$} (3);
      \draw  [cover,morphism] (1) to (4);
      \draw  [>->,morphism] (4) to node[swap] {$\mathsf {Img}(b)$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Since <fr:tex
display="inline"><![CDATA[a]]></fr:tex> is an isomorphism, it follows that the image of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is isomorphic to <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex>.
    Thus, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex> is an isomorphism.</fr:p>
  <fr:p>Assume the converse.
    Then the identity morphism factors through <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex>, i.e., <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex> is an isomorphism.
    Thus, it follows that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is a cover.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>