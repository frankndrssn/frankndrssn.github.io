<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1365</fr:anchor><fr:addr
type="user">ct-000H</fr:addr><fr:route>ct-000H.xml</fr:route><fr:title
text="Locally cartesian categories have pullbacks"><fr:link
type="local"
href="ct-000G.xml"
addr="ct-000G"
title="Locally cartesian category">Locally cartesian categories</fr:link> have pullbacks</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is locally cartesian iff it has pullbacks.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>612</fr:anchor><fr:addr
type="machine">#283</fr:addr><fr:route>unstable-283.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>If <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is locally cartesian, then <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> has products for any object <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>. But, products in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> are pullbacks over <fr:tex
display="inline"><![CDATA[A]]></fr:tex>. Thus, <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has pullbacks.</fr:p>
  <fr:p>Conversely, assume that <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has pullbacks. Then since the forgetful functor <fr:tex
display="inline"><![CDATA[\Sigma _{A}\colon {{\mathcal {C}}_{/{A}}}\to \mathcal {C}]]></fr:tex> creates connected limits for any object <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>, the slice <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> has pullbacks. Moreover, <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A}]]></fr:tex> is the terminal object in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>. Thus, <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> is cartesian.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1366</fr:anchor><fr:addr
type="user">fnd-0007</fr:addr><fr:route>fnd-0007.xml</fr:route><fr:title
text="Cartesian category">Cartesian category</fr:title><fr:taxon>Section</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="frankndrssn.xml"
addr="frankndrssn"
title="Frank Tsai">Frank Tsai</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>611</fr:anchor><fr:addr
type="user">ct-000H</fr:addr><fr:route>ct-000H.xml</fr:route><fr:title
text="Locally cartesian categories have pullbacks"><fr:link
type="local"
href="ct-000G.xml"
addr="ct-000G"
title="Locally cartesian category">Locally cartesian categories</fr:link> have pullbacks</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is locally cartesian iff it has pullbacks.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>612</fr:anchor><fr:addr
type="machine">#283</fr:addr><fr:route>unstable-283.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>If <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is locally cartesian, then <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> has products for any object <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>. But, products in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> are pullbacks over <fr:tex
display="inline"><![CDATA[A]]></fr:tex>. Thus, <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has pullbacks.</fr:p>
  <fr:p>Conversely, assume that <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has pullbacks. Then since the forgetful functor <fr:tex
display="inline"><![CDATA[\Sigma _{A}\colon {{\mathcal {C}}_{/{A}}}\to \mathcal {C}]]></fr:tex> creates connected limits for any object <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>, the slice <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> has pullbacks. Moreover, <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A}]]></fr:tex> is the terminal object in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>. Thus, <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> is cartesian.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>613</fr:anchor><fr:addr
type="user">ct-000J</fr:addr><fr:route>ct-000J.xml</fr:route><fr:title
text="Slice comparison functor of a locally cartesian category admits a right adjoint"><fr:link
type="local"
href="ct-000I.xml"
addr="ct-000I"
title="Slice comparison functor">Slice comparison functor</fr:link> of a <fr:link
type="local"
href="ct-000G.xml"
addr="ct-000G"
title="Locally cartesian category">locally cartesian category</fr:link> admits a right adjoint</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is locally cartesian iff for all morphisms <fr:tex
display="inline"><![CDATA[f]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the functor <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> constructed in <fr:ref
addr="ct-000I"
href="ct-000I.xml"
taxon="Lemma" /> admits a right adjoint <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>. Moreover, <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> is (isomorphic to) the pullback functor.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>614</fr:anchor><fr:addr
type="machine">#281</fr:addr><fr:route>unstable-281.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By <fr:ref
addr="ct-000H"
href="ct-000H.xml"
taxon="Lemma" />, locally cartesian categories are precisely those categories with pullbacks.</fr:p>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>615</fr:anchor><fr:addr
type="machine">#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex> for any <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. We show that the following diagram</fr:p>
    
      
      <fr:figure><fr:resource
hash="3bdf29e3ca5a6afa1fb82198dbd9d32b"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNC43NjA3MDdwdCcgaGVpZ2h0PScxMTcuODQ5NjI0cHQnIHZpZXdCb3g9Jy03MiAtNzIgNzYuNTA3MTM4IDc4LjU2NjQxNic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9VQUFvQUFBQUFBL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFYR050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFEWUFBQUEyTlZxTFR0b1pXRmtBQUFDUEFBQUFDOEFBQUEyS0kvQlZtaG9aV0VBQUFKc0FBQUFIZ0FBQUNRRjhRS2FhRzEwZUFBQUFvd0FBQUFJQUFBQUNBWWhBR1ZzYjJOaEFBQUNsQUFBQUFZQUFBQUdBR3dBQUcxaGVIQUFBQUtjQUFBQUZnQUFBQ0FBQlFCRmJtRnRaUUFBQXJRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGhBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTZRek0vd0g4cGtoMGtocS9nT0ZBYlFlRE04QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOUR5UCt6d0h3R0FGVzFCc01BQUFBQUFnQmwveXdDaWdIRkFDNEFRd0FBQVFNT0FTTUdMd0VtSno0Qk1oWVZGQVlIRmg4QkZqNENQd0VPQVFjdUFTYzJOelkzTmpjeUZoYzJOeDRCRlFjM05pOEJKaWNPQVFjT0FSVWVBVGMrQVRjK0FRS0ZiQlNQYXk4MUN6TUVBU1V5RmdvUUFpSXRGejlIR0FZWUVrd3lTMllDQTBVUkVsQmhJa0FaRVNJVEU1WXRBUlVFRnp3cFNCWWRIQUk1SUNoRkhRNEpBWFgrVEV0SUFna0REQzhkSlJvUENCd1BCUUlCQVFvd01CeGhFQ1VDQVZ4U1kwd1REMElER3lJbkFRRVZEdnU0Q2lNR0lnUUJNQ012ZFNFN0xBRUJKeDBQRHdCNDJtTmdaR0JnQU9KNVIvTkw0L2x0dmpJd3N6Q0F3R01oK3kwSStyOE9jd2pqVVNDWGc0RUpKQW9BSlprS0VnQjQybU5nWkdCZ1p2alBBQ1JER0ZJWm5KbTZHSUFpS0lBSkFFQVdBcElBQUFOVUFBQUN6UUJsQUFBQUFBQnNBQUI0Mm1OZ1pHQmdZR0p3QVdJUVlHUkFBd0FIV0FCTEFBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVHdBQW9BQUFBQUJid0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGMzhtTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SEZmMTJaMng1WmdBQUFYQUFBQUllQUFBQ2hCTEZ2RVpvWldGa0FBQURrQUFBQUM4QUFBQTJLQUhDWTJob1pXRUFBQVBBQUFBQUlBQUFBQ1FGbVFHYmFHMTBlQUFBQStBQUFBQVFBQUFBRUFsaUFLZHNiMk5oQUFBRDhBQUFBQW9BQUFBS0FhZ0ExRzFoZUhBQUFBUDhBQUFBR0FBQUFDQUFCd0JGYm1GdFpRQUFCQlFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFNUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtaW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZkI1RGVZQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlxWXpiLzMvSDhoUEE5SC9aLy94QTZzQ0FnQ2lKd21KQUFCNDJrWFJQVy9UUUJ3R2NEOTM3amx2OXRteGZXNlQxSGx4YklmU3htbmNPaWl0OHRKV1FtMFJwVUtpS2tJZ2hpNmRrQmhBZkFnRzFJR1ZsVy9BM2gzeEhSaVJtQmhZVXM3dHdKMTB3ejAzL0gvM0tGQ09ieEp5U1g0b00wVUI1V0NhQWEwVHhST2t3aE5NRTAxTU1LVUJpekl2bldBazc0ZkNNeEJFY1pTTm9nUUc0VWd6d1dKOEdadXFXU3ZPTjN0am9PdEdGTHpKT2UrMjZXcWZQL0tKelUrNWE0aTk0TjR1RUFpWm16N24xYXBmS3RSZTVUR3VGdGRIMW16TDJhZFI0TGRJbDhYbElvRjY3SDcrYzBZN0dzN082M0VVZHY5SFdJazJQcXFkQWhTNWlMSitzMEZDWEN0OVpUL1hTQW03bGNpSkhhWjVJaFdaQkV3bHNvODRHK1hiaHlkVjhnR2RJb3NsaW1uNUZ3aHZtRDhsN1RmRnQrK1RsNnFjMXhJd3FnMnI3ZXdHRGFGNW84UDVPYUZ6YmgyZTk3WjFXcXZxTGo0bEZJNjdWZHR2dWFhRktQYjNHaFVOSHhiejVEa2w3dnBxMjdiTGZtbUpvTnhZR2JSZXBDck9ubHc4dHZrQlJWZVlBcWExK1B1Tmw4TkFSVzg3bXM5T1JnaGJYTCsxRFc1KzRUZStLenU1YldUQVk1N3NabmhuNEhja0tiazdNK0ZKbUNGSDZNczJaWXNTNldWNWJ6R0x4WlFrWUYvVEVOaFpiYVluRDZ0cVFTYzljL1B5MlFYSWd5WU5pSHIxdWpKc1cxM0FGYVZnckorK295U01kaXJ0QWVpa2NiL3NMNGZPOG5MeXN6NjExK29sUXVxK0J0VGpTcVRpYUR6WXF5SnN6cDRDekdDdXFkdEVjMHJZWE92WVJnSFFuVVlaYXJna1V4VkUwdjRCLzFCVW5BQUFlTnBqWUdSZ1lBQmkza05PdmZIOE5sOFptRmtZUU9DeGtQMFdCUDFmbCtrWTAwVWdsNE9CQ1NRS0FBMnJDZWdBZU5wallHUmdZR2I0ejhEQXdIU01RZWYvQmFZc0JxQUlDbUFCQUdVY0JEZ0N4Z0FBQWpvQVN3STZBQ3dDS0FBd0FBQUFBQUJtQU5RQlFnQUFlTnBqWUdSZ1lHQmhjR0ZnWWdBQlJnWTBBQUFIamdCTmVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS012Q29XaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZHF6NDlqT2UzK2NyQXpNSUFBbytGN0xjZzA4d1RtV3lBRkFjREU0Z0hBRGwyQ1kwQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzBBQUFBMktBN0NabWhvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRoTXNDdlh4L0RaZkdaaFpHRURnc1pEOUZnVDluNUhwTWpPSXk4SEFCS0lBK3NRSXhnQUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWS9DUVdob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMm9OM044YnoyM3hsWUdaaEFJSEhRdlpia0dtV1VNWTdRSXFEZ1FuRUF3QXFod21GQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLRUhEUDJob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0cmJYcDNqaitXMitNakN6TUlEQVl5SDdMUWo2LzE5bU5xYTdRQzRIQXhOSUZBQXZnQXF2QUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU1LjEwNTAxMycgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTcuOTEwNDI4JyB5PSctNjQuNjg1NTE1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUzLjc0NTQ1OScgeT0nLTYxLjY3ODk5Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTAuNjMyMTE2JyB5PSctNjEuNjc4OTk3Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ni40OTUxNjUnIHk9Jy02MS42Nzg5OTcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTEuNDU5MzIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU0LjUyMDQwNCcgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjg2MjEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuNjc4OTk3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINDYuNDAzNzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNjUzNzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4zMjU4Miw0Ljc4NDAxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+zrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU4LjgxMjk5JyB5PSctNjAuNjgyNzMzJz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        
    \SpliceDiagramSquare {
      sw = A,
      se = B,
      nw = A',
      ne = B',
      south = f,
      east = g,
      west = f^{*}(g),
      west/node/style = {right},
      north = \varepsilon _{g},
    }
  
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>is a pullback, where <fr:tex
display="inline"><![CDATA[\varepsilon _{g}]]></fr:tex> is the counit of the adjunction. Note that since <fr:tex
display="inline"><![CDATA[f \circ  f^{*}(g) = \Sigma _{f}(f^{*}(g))]]></fr:tex> by construction, the component <fr:tex
display="inline"><![CDATA[\varepsilon _{g}]]></fr:tex> makes the diagram commute.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[h'\colon C\to A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h\colon C\to B']]></fr:tex> be morphisms such that <fr:tex
display="inline"><![CDATA[fh' = gh]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="2eb932eee263ecd4d313f468c72b28ee"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3Ni40MjcyMjhwdCcgaGVpZ2h0PScxNzQuNDQ0ODM3cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE3LjYxODE1MiAxMTYuMjk2NTU4Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLSS9CT0dob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0o1Ui9NM3h2UGJmR1ZnWm1FQWdjZEM5a3NSOUg4ZDVoREdvMEF1QndNVFNCUUFMUHNLTUFCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0E3Q1NHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhNc0NydmorVzIrTWpDek1JREFZeUg3cFFqNlB5UFRaV1lRbDRPQkNVUUJBQUkxQ09RQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSc0FBb0FBQUFBQlF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUZFQUFBQmdxR3ppWldOdFlYQUFBQUZJQUFBQU5BQUFBRVFpTEFDNloyeDVaZ0FBQVh3QUFBR05BQUFCek1VV0kxZG9aV0ZrQUFBRERBQUFBQzhBQUFBMktaRENQV2hvWldFQUFBTThBQUFBSHdBQUFDUUY3Z0RiYUcxMGVBQUFBMXdBQUFBUUFBQUFFQXUwQVd4c2IyTmhBQUFEYkFBQUFBb0FBQUFLQVZZQXhHMWhlSEFBQUFONEFBQUFGd0FBQUNBQUJnQktibUZ0WlFBQUE1QUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUVZQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc3M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lBR0lCWmdZSENBY2hsU2lzdlNHZGdVRkI0WU1HdjlzV1JnWU5aaVBnNFVabVNBZy8vL0dSZ0FXVUVRVHdBQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUFMbEZCU1V4QjhZL1ArUFlOMS9lUGUxL0dXd1dqQUFBUHpGREFGNDJqV1F3VzdUUUJDRzk1KzFkK3ZFanAxNGJjZHRhamRyWXplcVNHaEliSVFxNThxQkk0aExSWVNxNWs3VkV4eTRVNGxIS0JJM2VBVmVvOGMrQzdCRmNKblJQL09QOVAzRHdENzkxdlNZN3RnTHhwQWpReVI4Q1BsUTJtcUJxbDQxR3pSckh3TVVjNnlhZHBuemFrSFZ1a1BTeE1sZjh3WWRubVpRUW1wemdrdnVPUmFFTFRtWGJrSjh6NUt3K3oyZXpzSzVtZ2JCTkJyUGp2ZkpsbjJiU2lGS2doMEkydisvVmZOd2hoOVplM3lpUDF5OXZFajJDQmdGbDgrdWI4ckZreFBmNHozUm84TFhKQnpIbXVURm1UNG9BNktnUEN6Tzg0bmxDSWUwWDVCeE1ST0pmV0VGWGVDZXJZeG9tMldzREhLY3hNa0FoalUzOUNiVkJsTFV1aks5cXF1Nnd6SkhYYTFOMkRpUitQelZUZFZRZkgvek9pU28xUG5tQ2RMRFVMZzNqNFFYamMxY0VhS3hkK3VLY0tpcGo0T3RvL1NBdXNPcEhJOFV4THZkODR4amxKenVYa1ZRT3ZpM2NMYTcwNTQzQXVWdkh6aTNyTVpIT21PQkVWd1VocU1OTzdSTDgyT0o5M2ZDalVOdTNmSTBTeXZBd3Yydjg2R1VYb0NmZ3lNY1RWeVgvUUdZQWpjc0FBQUFlTnBqWUdSZ1lBRGlad3J6bHNiejIzeGxZR1poQUlISFF2WkxFZlIvSlpaUXBpdEFMZ2NERTBnVUFDTXdDZjRBZU5wallHUmdZTmI2WThuQXdCTEtFTS9nd1pUTUFCUkJBU3dBU0hZQ3pnQUVWUUFBQXFvQWZ3THlBSTRCd3dCZkFBQUFBQUJ3QU1RQTVnQUFlTnBqWUdSZ1lHQmg4R1FBMFF4UUVna0FBQWYwQUZFQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS012Q2cyaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZHF6N0x4dlBiZkdWZ1ptRUFnY2RDOWt1UmFlYUpURFpBaW9PQkNjUURBQllFQ0t3QUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV3NBQW9BQUFBQUJxZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGNEEyTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SEZmMTRaMng1WmdBQUFYQUFBQUxXQUFBRGJIeEhsQjlvWldGa0FBQUVTQUFBQUM4QUFBQTJLQUhDUldob1pXRUFBQVI0QUFBQUlBQUFBQ1FGcWdHY2FHMTBlQUFBQkpnQUFBQVVBQUFBRkF3T0FQUnNiMk5oQUFBRXJBQUFBQXdBQUFBTUFhNENpbTFoZUhBQUFBUzRBQUFBR0FBQUFDQUFDQUJOYm1GdFpRQUFCTkFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGb0FBQUFBd0FBQUFnQUFNQUFIamFZMkJteW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZmFtRGZjQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXltWXdiLzMvSDhoUEE5SC9aLy94QjZzQ0FnQ2lTUW1MQUFCNDJrV1NQVy9iVmhTRytSNVNwRVNLdlB3UUx4MUxwa1JSSkpYVUVTVlRwbEpibFN6TFNCRzd6VWNMMUhBUUpPaVFKVk9CRGkxYW9EK2hDSUlNV2JNVi9RZlpBMlFNOGg4eUZ1alVBbDNzWGxaRDd3SHVjTThkem5PZVY0SjBkcFhUTS9vZ0hVa1NaQVpWczZEMTAyeUJnZ2RjMVhnWEN5emxXRTNMb0ZoZ0p0NzNlR0FoVHJPMG5LVTVMR0lvU3E1bWVIMWdLL1oyWXpVWkhnQURQNVhCdW95eFFTVHZqTmdYSVhuc0FmTXRmaHhmbndNeEYzMDdaTXgxUTcyKy9hUnE0K1hsMjFQbmFOcGF5MmtjOW1pZ1prYURvSno1ci80Nmwvc2F6aS9hV1pvTS9tL2hXbnJ6VjZWZmh5UU9TYnRYTnluQlcya2tyU3NhUWFMK1J5SW1icWxhd0F0ZUNvQ2xnQndoSzJkVmhRZ0VsZmdnTDFGbUFrclZxaFh3WUsvNlN0RjNqZTkvekI4cllsNkh3M0k3VHRTYXh4MnVCYk03cXd1U1Y4eTVjekhjTitWdDEvVHhJcGZSOHFmYjY1NXZPMGl6OExqVDFQRFQ1U3AvS0pPL3V4TjVuaEhxTllMUnVUYnVQU29Vbk45L2V0ZGpKeklHM09hd25jdC8zakFqaVJVTTk5UFYwYjBaa2g0ekJSdWtMNi8rcHAvcG5YUldrWW1SUTlMVWpTNWZyWVl0aXlBVXZLS0V2YW1BcWZEU3JOb0JVNFN2RWZabjNnSnB2SkU3SzdtRzFkM09WNS9lbmpaQkxmS2FwaTUzdW5PWEhGMUZZRGp4WW5nTHNtbHhUc1NIOC90YnJPYjFHblU5YUxoTzdibENiTkN3QVVzNzJVMUF2MTIraXdyVThxazVtcXVIN1NoeStyVDh6Q1VLeGdFZktmbjFwdEViSEs4bi9vUm9QZVRHNlM5cG14bndURTRuSnRNVm5kVTFSVzRLaCtPclAvQW4za3VIbGNPWmhVQU5SQWIzTnE3WVJwM0EzOXdsRjlBaWpXazJFcWtWYVJVeWc3TEtaNlptZkVrNTFOK0xCRGpjNlJiM1BuZVZ1a2xEZS9Mc202ZWdXMTA1SnVYbHQ4Mjl5QmtBUHRmakEvUEJEeklsNldFekdvc2RkejR4d3Eya3RiV1ZmMnd2dlJ0dG5hZ2Rha0E3YTZZS1RnL0d4eTZTN3RIWGdHcXB2bTE2cExWMFRHNzBQYXNPbUsyT0FTV3BpYTRDRWdyL0JZRzFjU0lBQUhqYVkyQmtZR0FBWWxPejl1WjRmcHV2RE13c0RDRHdXTWgrS1lMK3I4dDBqT2tpa012QndBUVNCUUFEdXdtaEFIamFZMkJrWUdCbStNL0F3TUIwakVIbi93V21hZ2FnQ0FwZ0JRQm1ZQVJLQXNZQUFBSTZBRXNDT2dBc0Fxd0FUUUlvQURBQUFBQUFBR1lBMUFGSUFiWjQybU5nWkdCZ1lHWHdZV0JpQUFGR0JqUUFBQWh4QUZaNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVMwQUFvQUFBQUFCVlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDAvbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNXWjJ4NVpnQUFBV1FBQUFIcUFBQUNIUFQvRXp0b1pXRmtBQUFEVUFBQUFDOEFBQUEyS0ViRERXaG9aV0VBQUFPQUFBQUFIZ0FBQUNRR01nSGRhRzEwZUFBQUE2QUFBQUFRQUFBQUVBdFpBSUpzYjJOaEFBQURzQUFBQUFvQUFBQUtBV0lBc0cxaGVIQUFBQU84QUFBQUdBQUFBQ0FBQ0FBNmJtRnRaUUFBQTlRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRXFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzWTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCbVp2Z1A1RE5EcEpIVS9BY0tBd0R6QUExS2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqTy8vOERTY2YvLy84ZkFQTVpBRks1QnA5NDJqWFF6Mm9UVVJRRzhQdmRrN25USkpPWjZLUXpsYVpUMHZ5WnRwS2tkSWFadG9zb2pZazF4YlEyVUlJRWdvSVdCQVUxUmhjdXNvZ0xRVmRDUVZ5NGNlY0R1SEhscWcvZzFvVzRFaDlCa25oSDZMbWJ3OGRkL0w3RE9Ddk1adnduLzhHcWJKT3hFRUc0YWRsbXh2SUNTMVNodWlYWEQyd3JDS3ZJcVNKajJZR3RRK1pSN05VUWV2UUY5MFFtSlZDenl2UFFsTUZvVGtFcWFmb1VWNmV6ZGlwcnBnZ3A1YVNyUVl1djFONy95UTM1Y1JweFl6S3lERnBTUVFRK1o2aUFadDl2akRPRk5MaWhpeWhPR0FMNU14d3hPY1F1enlZaytGZm1zSFcySmFXbW4zZUZ0T1Vjek90UUhkakNnRkJ6NHIvWGpIQkJ5YzJYaEVybk84a1AzcWUzaSs2U1lhRGJ1MHVqem40SC9IcjY1clBwdTZ5dTd6Z2ZUL3NEamtwOXZHd3FqOTcwaHB4djdIMXJ4Z0Q5a0c5ZjRKUlZ3Vy90dEU2TVJIdDdmMWV2eGFJR01OR2dKODNDTlE3ajB1UXpQVzhYRDJuNjY2SklNQWJtelg1VGtuK1B6Q0FkZVhuUksvQkxyalJIWU50QktNOGJDWmZoeUFJeXI4QU53dWhadG1XSHNnNGxycEpJeEJWd0hCODBYbTAwRjRXRjJNc2JxLzNBTDR0WVhGV28zRng3WEgveGdhamp0NTZPTzJ1cllrK0h4cyttZjNWcFZvM1M3UWRBZmF2YlgraVZoM2M0VnRZcnZZVWt3TFdIdTBVUGREcDZQV2o1UnhRckZQVURuUk5qL3dBZDBscitBQUI0Mm1OZ1pHQmdBR0lPVFliQWVINmJyd3pNTEF3ZzhGaklmaW1DL3YrU21adnBMcERMd2NBRUVnVUEyOG9JdkFCNDJtTmdaR0JnWnZqUEFDUTVHRlQrWDJEbVpnQ0tvQUFXQUVyM0F4VUFBQUoyQUFBREFBQWtBd2dBS3dMYkFETUFBQUFBQUZRQXNBRU9BQUI0Mm1OZ1pHQmdZR0d3WkdCbUFBRkdCalFBQUFhU0FFTjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTEzLjk5Mzk5NycgeT0nLTI3LjU2NDIyMSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTYuNzk5NDEyJyB5PSctMjYuOTU1Mzc1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTEyLjYzNDQ0MycgeT0nLTIzLjk0ODg1OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS41MjExJyB5PSctMjMuOTQ4ODU4Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01LjM4NDE0OScgeT0nLTIzLjk0ODg1OCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTMuNDA5Mzg4JyB5PSctMjcuNTY0MjIxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg0Ni40MDM3OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni42NTM3OCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0LjMyNTgyLDQuNzg0MDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTcuNzAxOTc0JyB5PSctMjIuOTUyNTk0Jz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ0LjE2OTU0LDM3LjczODMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDEuMDgxMTggMzMuODI4NTdDLTQ2LjQ3NDQ5LTEuMTM0MzUtMzUuODg3Ni0yOC4zODUzLTguNjk1MzYtNTAuMjI0NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjc3OTY1LC0wLjYyNjE2LDAuNjI2MTYsMC43Nzk2NSwtOC41MDA0NiwtNTAuMzgxMDQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00Ny43MDk2MywtMjEuNzY1ODUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xNi44MDE3MzgnIHk9Jy0yNi45NTUzNzUnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTMxLjc1MTUxIDQxLjM1NDMxQzIuMzI5ODYgNDYuMzc0MjggMjguNjcyNDkgMzUuOTMyODUgNDkuNzUwMjcgOS4zMTk0OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjYyMDgyLC0wLjc4Mzg3LDAuNzgzODcsMC42MjA4Miw0OS45MDU0Nyw5LjEyMzUyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNy4xNzg0LDM5Ljk2MjE5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+aDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2UtZGFzaGFycmF5PSczLjAsMi4wJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KPHBhdGggZD0nTS0zMy44MjgwOCAzMy44Mjg1N0wtOS4yNzcxNiA5LjI4MTA3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTQsLTAuNzA3MDUsMC43MDcwNSwwLjcwNzE0LC05LjEwMDM3LDkuMTA0MzEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTS0yOC42MzMzOSAxNi42MjgwN0gtMTQuMTE4MjlWMjkuMTE4MDZILTI4LjYzMzM5Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTI1LjYzMzM5LDE5LjYyODA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+aDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTYuODAxNzM4JyB5PSctMjYuOTU1Mzc1Jz7igKA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        
    \SpliceDiagramSquare {
      sw = A,
      se = B,
      nw = A',
      ne = B',
      south = f,
      east = g,
      west = f^{*}(g),
      west/node/style = {right},
      north = \varepsilon _{g},
    }
  
        \node  [above left = of nw] (c) {$C$};
        \draw  [->,morphism,bend right] (c) to node[swap] {$h'$} (sw);
        \draw  [->,morphism,bend left] (c) to node {$h$} (ne);
        \draw  [->,morphism,exists] (c) to node[desc] {$h^{\dag }$} (nw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Note that <fr:tex
display="inline"><![CDATA[h]]></fr:tex> is a morphism <fr:tex
display="inline"><![CDATA[h\colon \Sigma _{f}(h')\to g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. Thus, it corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[h^{\dag }\colon h'\to f^{*}(g)]]></fr:tex> under the adjunction.</fr:p><fr:p>The transpose of <fr:tex
display="inline"><![CDATA[h^{\dag }]]></fr:tex> can be computed as <fr:tex
display="inline"><![CDATA[\varepsilon _{g} \circ  \Sigma _{f}(h^{\dag })]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> is the identity on morphisms, we have
      <fr:tex
display="block"><![CDATA[         (h^{\dag })^{\dag } = \varepsilon _{g} \circ  \Sigma _{f}(h^{\dag }) = \varepsilon _{g} \circ  h^{\dag } = h       ]]></fr:tex>
      Thus, the top triangle also commutes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>616</fr:anchor><fr:addr
type="machine">#280</fr:addr><fr:route>unstable-280.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has pullbacks. Then we can take <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> to be the pullback functor. It remains to check that <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex>.</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
      
  <html:tr>
        
  <html:th>Unit</html:th>

        
  <html:th>Counit</html:th>

      </html:tr>

      
  <html:tr>
        
  <html:td>
          Let <fr:tex
display="inline"><![CDATA[h \in  {{\mathcal {C}}_{/{A}}}]]></fr:tex> be an object, we take <fr:tex
display="inline"><![CDATA[\eta _{h}\colon h\to f^{*}(\Sigma _{f}(h))]]></fr:tex> to be the unique morphism given by the following pullback:
          
    
      
      <fr:figure><fr:resource
hash="c09b8b07b92837716709f79f64e26dcc"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI0My4yNTI3NDdwdCcgaGVpZ2h0PScxODEuMzgwMTM0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTYyLjE2ODQ5OCAxMjAuOTIwMDknPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSb0FBb0FBQUFBQlF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWUYxYkdOdFlYQUFBQUU0QUFBQU1RQUFBRHdBZkFEQloyeDVaZ0FBQVd3QUFBR2lBQUFCM1A1M2IwVm9aV0ZrQUFBREVBQUFBQzhBQUFBMktJL0NQV2hvWldFQUFBTkFBQUFBSGdBQUFDUUdjUUpQYUcxMGVBQUFBMkFBQUFBTUFBQUFEQWxmQVBwc2IyTmhBQUFEYkFBQUFBZ0FBQUFJQUhJQTdtMWhlSEFBQUFOMEFBQUFGd0FBQUNBQUJRQlJibUZ0WlFBQUE0d0FBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUVYQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1sbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBxbU1XUXdNL3dIOHBraDBraHEvZ09GQWJtUERONEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtwakZrL1A4UDVJUHAvN1AvendLckFnSUFtUElKTndBQUFIamFIZEJOVHR0QUZBZHd2emYyakJPUHgxOHp0b2xJU3V6SVRsSklpaEljMGFaSnF5Q0VRSHd0RVJJSFFPSUFWUmZkVnFyYVhvRmJkRitwNmdGNkNBNkF1Z1hHMGJ6RnpMeTNlTCsvQWNibjV4MzhnLytNSThNQTRnRmxBaGd0eWdWTTRrUlNGcitDQmN5cUpWU3puQlo3MHlxWjFQZjFpUk1CZVZFVzFhd1lROGFvQjVNcWxvd3llTmgzRzBFci9MaVRuUklZcUNHUnloTlJ1MmNGNFdiZ1hMbVI5RzRFTlZQYnpTLzd4M29rSGhMZ0hkK0xXa21UcDNldXRJa0ozNTUrTGJMNW9EVkJ5RVpaUnNxZzIyU0FXS25sN2YzdFc2Q3ViTUJGZDJ2cUIyTVRldHYxQ0MyRmpaRDZ5NTlBTnh3Q2htWVpYNTcvNHlQK05jNXJvK1owUU9sbDYxSTAwVytOVGJSV2IwN1pDTXFwRnRiSWFaSHJNQVI0dUhiT0l2MnBwVHFkYXAxSXJHTDRkQkhmbkp5ZFlHVEpwc2V3V3k2RWFYUGVnRFlQK3F2eEJ5QStWNmgwWTM2OUpVVXpZOWFtbjV2bWR4UEJGcmtUSWxKaS9lQVM4UDdwZDN0RllGVU4zL0g5dEpSK1R2QmcyMnNnT25KWGhwcjRac0Nkc3ZPZXprZFpIdzkzTy9ucnIybWtvSmZnWGtncEJkU1JjSTNtWUxubUM0KzFPLzBBQUhqYVkyQmtZR0FBWWhlWGU0bngvRFpmR1poWkdFRGdzWkQ5QWdUOVg1YzVoT2t5a012QndBUVNCUUFMbFFsNkFIamFZMkJrWUdCbStNOEFKRU1ZcXY5L1ovck1BQlJCQWN3QWJvb0V4UUFBQTFRQUFBSzhBSHNEVHdCL0FBQUFBQUJ5QU81NDJtTmdaR0JnWUdZSVlBRFJERkFTQ1FBQUNJZ0FWd0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLRUhERjJob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0cmJYcDJMaitXMitNakN6TUlEQVl5SDdCUWo2LzE5bU5xYTdRQzRIQXhOSUZBQTVXQXJYQUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFQNEFBb0FBQUFBQkd3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY04zOG1OdFlYQUFBQUU4QUFBQU1nQUFBRHdITC8wTVoyeDVaZ0FBQVhBQUFBRXBBQUFCT05DV0tlRm9aV0ZrQUFBQ25BQUFBQzRBQUFBMktEWENQbWhvWldFQUFBTE1BQUFBSGdBQUFDUUdRd0tSYUcxMGVBQUFBdXdBQUFBUUFBQUFFQW1vQVFOc2IyTmhBQUFDL0FBQUFBb0FBQUFLQU13QVlHMWhlSEFBQUFNSUFBQUFGd0FBQUNBQUJnQWlibUZ0WlFBQUF5QUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQUQ3QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm15bUtjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBwcU1DOW1admdQNURNek1JS0VHUkVxL2dPRkFlMTNEYWdBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeW1veUwvNy9IOGpYQU5IL2IvNUpBS3NDQWdDWW13azVBQUI0MmlYT3ZVNENRUlFGNEh0bU5qUE95cytDdUJzMUVaYVZSUXRJRk5pTkZLS05XbEFTQzRPRmtsaWhDVWJ0VU9OUFkrSkQwUG9NbHNaSDhBMG9qSW0yYXVMcUVISlBjYXJ2WEFLZC9nRlhuR2lXQ0k2ZGtTSUpJWVd0YXhKK1VWL29OeENnRzVkeW95NVhPWFlPVFJtL3F5VW1DNHlWRWdFbk1FdFV1MWJ2NWVGN1Qxa01CMzAzMSsrYzNCU3VOVW5iMm0rTi9TbXRPcmJNQ0ptQUgxWWJXRU5ZUnRHdkJXSDdOaGlCUy9uZ2VBNDgyV3FEOXpZVkJLZXh0anRZMys4d2t4dXA1dWZnZVZnM2hXSkVJMytMaVAyd0o4b1JLYmo2Vloyd0l0MjhYd3NWL01CeEhhOE02ZXB4aWNmb0F5dWx4Y3F5WGJhODdPOTlMTVV3SGIwaGxtYm5XYys2NkVmUjBPQkFNeHFDWThaYU9Qc3l6QW5NNHlpdDhIN1pOS0pYb1NUUlA1TGNPMFFBQUFCNDJtTmdaR0JnQU9KNUxZdHV4L1BiZkdWZ1ptRUFnY2RDOWdzUTlIOUdwbC9NSUM0SEF4T0lBZ0F0OWduNUFBQjQybU5nWkdCZ1p2alBBQ1NkR2R3WlBKbCtNUUJGVUFBTEFFU0xBdHNBQUFMVEFBQUJ5UUIwQWNrQVNBTkRBRWNBQUFBQUFEQUFZQUNjQUFCNDJtTmdaR0JnWUdGUVpBRFJERkFTQ1FBQUJBd0FLUUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5vQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDMEFBQUEyS1kvQ0dXaG9aV0VBQUFKQUFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFtQUFBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNhQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUp3QUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9nQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFdBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaTJvUDNHT1A1YmI0eU1MTXdnTUJqSWZzRnlEUkxLT01kSU1YQndBVGlBUUFKaXdpdUFBQUFlTnBqWUdSZ1lOYjZZOG5Bd0JMSzBNZlF6NVRNQUJSQkFVd0FVb0FEUWdBRVZRQUFBdklBamdBQUFBQUFWQUFBZU5wallHUmdZR0JpTUdVQTBReFFFZ2tBQUFYS0FEc0FlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ2xKV0ZnWW1WcVF0Z2d6TEVRWGFJRktucXlPL3U0WHJvRGFmbi9iZ0RTbjdJZUU3R2E5elB5U2xFL1hIQkMyK0pwNklXaVVzK1dESWh5MmZpek5ra3ppWDVTbHp3emlYeFZQenZ4Q1dmUExaZGU3djMxcXQ5WjZ4MzV6YU02NFAxb2VtY1d1a3E2cDExMWg5N2E5UnBWR1pvd25CdFZhMHJYYk9sbytYR25SNkxSN0VYeDBSMm5DVUxqS3c1UkNmUVNPcWt0VUpUL2N0M2tydllPY1pQUmpvblNaVFFJRmRCOWxYYWlqcGVhdXBmNytrd1J3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRUUFBb0FBQUFBQkpRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVjQUFBQmdoY040Wm1OdFlYQUFBQUU4QUFBQU1nQUFBRHdITC8wTVoyeDVaZ0FBQVhBQUFBRkNBQUFCWUJvUGlGRm9aV0ZrQUFBQ3RBQUFBQzRBQUFBMktLekNQV2hvWldFQUFBTGtBQUFBSGdBQUFDUUcxQU05YUcxMGVBQUFBd1FBQUFBUUFBQUFFQXQ3QVY1c2IyTmhBQUFERkFBQUFBb0FBQUFLQU9ZQWFHMWhlSEFBQUFNZ0FBQUFGd0FBQUNBQUJnQXFibUZ0WlFBQUF6Z0FBQURLQUFBQk11c0lrZVp3YjNOMEFBQUVCQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lOR0JpU1FVbHlXRHBUVVlGN016UEFmeUdkbVlBUUpNeUpVL0FjS0F3QVhxZzRjQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeW1veUwvNy9IOGpYQU5IL2IvNUpBS3NDQWdDWW13azVBQUI0MmkyUFBVdkRVQlNHNzV1YjNIemFENjJKcmFRMEtTUkN0WUttYVVGaTZXaGRSS0hTUWdjcGlxUEZSUjBGOTg3K2d2Nklqb0tMZy9nTEJBYzNGM0VRTmZXYWVzNXkzdVY5emtOQWJxY0U5NVNRSWlGSVFXYVdtV3lPdVg0VnZ1ZUg5VzNVd3cxemtlRnUvMGFpcnFLdFhTaGdoWmJUTGtXaUdKWGFUcXZBSUx5R0g1UCs1WkoxZFN4cW9oYll2ZWhzUEI1R1hUdlFSSlh3QVJsdzFvaXpsbmxnOGgvTlcwZVFBT1k5MytPSFZZUmxZdlRmU2dYSlAvUnFPRG1YS1owQlFXYWRrQlJGdEFlZGF4Uysrcm91SVFGeXh0RjBTb2ZDaEt3UW9zSXhtMGdFTnFuRHZKcFhWMUZGTFFndHh5cHp1eXJLem9JcG0vaU1uM0JnTlBKYmxYeVVycmcvZ1pFVE1saU5IMldhVFFzUGJzVm9sT3pUWnZ6OHJZTmlOMzREZnkyajdIVzRFRE1VSFZsMG1hcGtaTHp2ZEZKelJ2eGl5QkpYL2dWck9FSFZBQUI0Mm1OZ1pHQmdBR0xPMVEvWHgvUGJmR1ZnWm1FQWdjZEM5Z3NROUg4RzVrSm1FSmVEZ1FsRUFRQVdoUWtWQUFCNDJtTmdaR0JnWnZqUEFDU3ZNaVF5SkRNWE1nQkZVQUFMQUUwdUF4a0FBQU5TQUFBQ0tnQ2FBaW9BWXdQVkFHRUFBQUFBQURZQWFBQ3dBQUI0Mm1OZ1pHQmdZR0hRWkFEUkRGQVNDUUFBQk5RQU1RQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVxZm01dURrNnZEMjZ3SjBxR3BwTFhvSXY1MGIwUHdCZzdmUGVmY0FCa3ZFb1pKbUFjZEpwVTNqenptaDBYa2lmaXJ5Qm0vckJtUnBETnhWdXdpcDB6NWp6eG1TUmw1SXY0amNzWWY3MzFUMys2ZDllcllHT3ZkcGZiYmsvVnQxVGkxMGZtd0hxeXovdHhabzhxbk1uM1Y5dGRhRlRyWEJYc2FhbTdjNmJCNEZFZHhUR0RIUlRMUGxsUFlXeXJKbkhRMmFQSnZlcERVaGNZNS9HS2tVZklVTmZSeTA0cGVwYXNvd3AybStBQlZNaTVEQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLTXZDZVdob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0xkcXo0Ynh2UGJmR1ZnWm1FQWdjZEM5Z3VRYWVhSlREWkFpb09CQ2NRREFCaDZDTFlBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFXWUFBb0FBQUFBQnFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0QzJOdFlYQUFBQUU4QUFBQU93QUFBRXdFUFFTTloyeDVaZ0FBQVhnQUFBSzdBQUFEVk9MVDN6aG9aV0ZrQUFBRU5BQUFBQzhBQUFBMktBSENNMmhvWldFQUFBUmtBQUFBSUFBQUFDUUZyZ0djYUcxMGVBQUFCSVFBQUFBVUFBQUFGQXd1QVBoc2IyTmhBQUFFbUFBQUFBd0FBQUFNQWE0Q2hHMWhlSEFBQUFTa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUJMd0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZqQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm15bWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1XOW5admdQNURNek1JS0VHUkVxL2dPRkFma09EZjhBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1Jnc2dEUVhBd2RRam9raGpTR0RlU3Z6OXYvL2dXSnc5di9aLzJmOThmdmpDOVlCQlFCNWJRN0hBSGphUlpJOWI5dFdGSWI1SGxLWEVyOHVKWktYaWlWVEh4UkoyVWtweVZMSTJGSWt4d29TMUc2Ymp3SU4yaVhJa0NWTGxoUVpBdlFuRkIweWRNMFdkT21mQ0pJbFFOSC8wTEZBcDNhMGUyVUZ5RDNBSGM2N25PYzhSNEZ5ZGpHaVovU25jcXdvVURtWTdrRHZwOWtTVXhFS3Bvc09sbGlwTVV1TGNMcEVLZnNISW5RUXAxbGFsT2tJRG5GTUM4RXl2RGx5TlhlbmRtc3lQQUlHUWFxQ2R6am5nNTY2bS9Pdkl2TDRBeDQ0NGlUZVd3Q3hrTGtiY2Q1b1JFWjE1L0VteHV2emQ2ZjE0NW0vVnRNNDZ0S0FaV2FOb0owRnYvNzdTTzNyZVBSOUswdVR3ZWNJVjlJdmZ0YjZWU2p5UWZuNjRqOTZSUitVc3cyTEhEWWluVzJSQWhZZUZHVXhEU1BvVEpZa25LMGdPMldSWnBLWWNVMHk1YmhlZWt1azhYWUJaU0YwM1BxbS9mRHd6c3dDK2VSWnRxRzJPNHNHMVEyRzBLekh5K0VOcUxZakJKRVlMdTQzZWNYcjFxcEdXR3ZVSzc5b3hBYzFGM0QwMjljUzBOdnpENzBwS3FPWm5TL1l2TlhyMWZ1MHV0a2dDc2VoeUxYUm5tVjJCeWZyU1RBaFdnK0ZlZnBUMnVJbVBGdlFiWnNibXNHcnVxWmFDaW5qaTcveEQvNVE1c3BhVVVvSElRdWxwdzFnR1dFRG5FUE9YMjcvUWtob2FTek5jbWxXR2cyWENJdU53NHhsWWtVanNOK21DVERmN1V6djNXMW9WWnVHN3VUWmQwOUJOenBxVE5ycko5WkJyejRBQW1IRVIvYURseW9sNmR6cWplV08yMWZOcUpuNHplYm9yOWJLMjI4WlJLMUlCMXFabFdvNFBScWZOSkIwanI4Rm1NTUMxL1pJOXcxTTl2dWVVd1ZzdjIxQ1N5b3kxVUJiaCtPTGhPN2d2WEp6NDNCN2k5SUpYVnB5d01sUjAyeWxGdGRubnpvajVOTGpraTZ4SW5tTXRIaE93WTdqUTN1aHFTVDI1dEtLb2UvNmxWclE5bUZjdFV6R3ZhaHZWblREWkJEY3lnNi9yRTUvNk42VmpvSHdmR1hGNU5ZRGZMU2J3MHNUd1U3MDQzMmZPM0RyKzcrUDg5QU4yc0J4N3BzZ2N0ZHQwYVhrY0Q2Z2pkaVdSUGdmRjZSb2dRQjQybU5nWkdCZ0FPTGM5c2Y1OGZ3Mlh4bVlXUmhBNExHUS9RSUUvVitWNlJqVFJTQ1hnNEVKSkFvQUp4NEtZQUI0Mm1OZ1pHQmdadmpQd01EQWRJekI0UDhGcG1vR29BZ0tZQVVBWnJ3RVRnTEdBQUFDT2dCTEFxd0FUUUlvQURBQ1dnQXdBQUFBQUFCbUFOb0JTQUdxZU5wallHUmdZR0JsOEdGZ1lnQUJSZ1kwQUFBSWNRQldlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjE1Mjc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0xNC43MjQ3NDcnIHk9Jy0yMi45NDA2OTEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzLjI2Mzg5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE3LjUzMDE2MScgeT0nLTIyLjMzMTg0NCc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xMy4zNjUxOTInIHk9Jy0xOS4zMjUzMjcnPijOozwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNC41NjQ4MTQnIHk9Jy0xOC4yNjgxOCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctLjA3MTIxMycgeT0nLTE5LjMyNTMyNyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczLjA0MjEzJyB5PSctMTkuMzI1MzI3Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzcuNzA2Mzg5JyB5PSctMTkuMzI1MzI3Jz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3OS45MTIwOCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTQuMTQwMTM3JyB5PSctMjIuOTQwNjkxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODEuMzE0ODcsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINzQuODU2NTQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzUuMTA2NTQsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzMC45NjUwMSw2Ljg3MjkxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+zrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTE4LjQzMjcyNCcgeT0nLTE3Ljk5MTQzMSc+zqM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTEzLjY1ODg3OScgeT0nLTE2LjI0Nzk2OSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctOS4xNjUyNzgnIHk9Jy0xNy45OTE0MzEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYuNDY3MDIzJyB5PSctMTcuOTkxNDMxJz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yLjM0NDY5NCcgeT0nLTE3Ljk5MTQzMSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNODUuMzU4MjYtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw4NS4zNTgyNiwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4LjYyMjE1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPs6jPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xNi41MDk3MScgeT0nLTE4LjI2ODE4Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xMi4wMTYxMDknIHk9Jy0xOS4zMjUzMjcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTguOTAyNzY2JyB5PSctMTkuMzI1MzI3Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00LjIzODUwOCcgeT0nLTE5LjMyNTMyNyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NC01Ni45MDU1SDc2LjI1OTMyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDc2LjUwOTMyLC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MC4xOTAzOCwtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00NS42ODQ0OCwzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTQuMTQwMTM3JyB5PSctMjIuOTQwNjkxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC42OTUzNi01MC4yMjQ1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzc5NjUsLTAuNjI2MTYsMC42MjYxNiwwLjc3OTY1LC04LjUwMDQ2LC01MC4zODEwNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ1LjAwNDczLC0yMC44MzEzOCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPmg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScxLjYnPgo8cGF0aCBkPSdNLTMwLjIzNjU3IDQyLjQwNTI2QzEyLjY1NzEyIDUyLjA3MjIgNDcuNDM2MzcgNDEuMjQxMDEgNzcuMjU1MTQgOC45Mjc1NScgZmlsbD0nbm9uZScvPgo8ZyBzdHJva2Utd2lkdGg9JzAuNic+CjxnIHN0cm9rZT0nI2ZmZic+CjxwYXRoIGQ9J00tMzAuMjM2NTcgNDIuNDA1MjZDMTIuNjU3MTIgNTIuMDcyMiA0Ny40MzYzNyA0MS4yNDEwMSA3Ny4yNTUxNCA4LjkyNzU1JyBmaWxsPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzMuMCwyLjAnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNLTMzLjgyODA4IDMzLjgyODU3TC05LjI3NzE2IDkuMjgxMDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNCwtMC43MDcwNSwwLjcwNzA1LDAuNzA3MTQsLTkuMTAwMzcsOS4xMDQzMSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNLTI4Ljc1NDgyIDE1LjI2Njk4SC0xMy45OTY4NVYyNS42NDE5NUgtMjguNzU0ODJaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjUuNzU0ODIsMTkuNjI4MDcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz7OtzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTguMDkxOTU4JyB5PSctMTguMjY4MTgnPmg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                width = 3cm,
                sw = A,
                nw/style = pullback,
                se = B,
                nw = A',
                ne = B',
                south = f,
                east = \Sigma _{f}(h),
                west = f^{*}(\Sigma _{f}(h)),
                west/node/style = {right},
                north = \varepsilon _{\Sigma _{f}(h)},
              }
              \node  [above left of = nw] (c) {$B'$};
              \draw  [->,morphism,bend right] (c) to node[swap] {$h$} (sw);
              \draw  [double,morphism,bend left] (c) to (ne);
              \draw  [->,morphism,exists] (c) to node[desc] {$\eta _{h}$} (nw);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          <fr:p>where <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> is the counit defined on the right. Then naturality is a consequence of uniqueness.</fr:p>
        </html:td>

        
  <html:td>Let <fr:tex
display="inline"><![CDATA[g \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex> be an object. We take <fr:tex
display="inline"><![CDATA[\varepsilon _{g}\colon \Sigma _{f}(f^{*}(g))\to g]]></fr:tex> to be the following morphism.
          
    
      
      <fr:figure><fr:resource
hash="713a053a883955433c0f73df139f72b9"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzOC44MDA0NDNwdCcgaGVpZ2h0PScxMTcuODQ5NjI0cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTIuNTMzNjI5IDc4LjU2NjQxNic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9VQUFvQUFBQUFBL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFYR050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFEWUFBQUEyTlZxTFR0b1pXRmtBQUFDUEFBQUFDOEFBQUEyS0kvQldHaG9aV0VBQUFKc0FBQUFIZ0FBQUNRRjhRS2FhRzEwZUFBQUFvd0FBQUFJQUFBQUNBWWhBR1ZzYjJOaEFBQUNsQUFBQUFZQUFBQUdBR3dBQUcxaGVIQUFBQUtjQUFBQUZnQUFBQ0FBQlFCRmJtRnRaUUFBQXJRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGhBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTZRek0vd0g4cGtoMGtocS9nT0ZBYlFlRE04QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOUR5UCt6d0h3R0FGVzFCc01BQUFBQUFnQmwveXdDaWdIRkFDNEFRd0FBQVFNT0FTTUdMd0VtSno0Qk1oWVZGQVlIRmg4QkZqNENQd0VPQVFjdUFTYzJOelkzTmpjeUZoYzJOeDRCRlFjM05pOEJKaWNPQVFjT0FSVWVBVGMrQVRjK0FRS0ZiQlNQYXk4MUN6TUVBU1V5RmdvUUFpSXRGejlIR0FZWUVrd3lTMllDQTBVUkVsQmhJa0FaRVNJVEU1WXRBUlVFRnp3cFNCWWRIQUk1SUNoRkhRNEpBWFgrVEV0SUFna0REQzhkSlJvUENCd1BCUUlCQVFvd01CeGhFQ1VDQVZ4U1kwd1REMElER3lJbkFRRVZEdnU0Q2lNR0lnUUJNQ012ZFNFN0xBRUJKeDBQRHdCNDJtTmdaR0JnQU9KNVIvTUw0L2x0dmpJd3N6Q0F3R01oKzYwSStyOE9jd2pqVVNDWGc0RUpKQW9BSlJzS0VBQjQybU5nWkdCZ1p2alBBQ1JER0ZJWm5KbTZHSUFpS0lBSkFFQVdBcElBQUFOVUFBQUN6UUJsQUFBQUFBQnNBQUI0Mm1OZ1pHQmdZR0p3QVdJUVlHUkFBd0FIV0FCTEFBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzBBQUFBMktBN0NhR2hvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRoTXNDdFh4L0RaZkdaaFpHRURnc1pEOVZnVDluNUhwTWpPSXk4SEFCS0lBK2tZSXhBQUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWS9DUTJob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMm9OMzE4YnoyM3hsWUdaaEFJSEhRdlpia1dtV1VNWTdRSXFEZ1FuRUF3QXFDUW1EQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUd0FBb0FBQUFBQmJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0YzOG1OdFlYQUFBQUU4QUFBQU1nQUFBRHdIRmYxMloyeDVaZ0FBQVhBQUFBSWVBQUFDaEJMRnZFWm9aV0ZrQUFBRGtBQUFBQzhBQUFBMktBSENaV2hvWldFQUFBUEFBQUFBSUFBQUFDUUZtUUdiYUcxMGVBQUFBK0FBQUFBUUFBQUFFQWxpQUtkc2IyTmhBQUFEOEFBQUFBb0FBQUFLQWFnQTFHMWhlSEFBQUFQOEFBQUFHQUFBQUNBQUJ3QkZibUZ0WlFBQUJCUUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUU1QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1pbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1XOWxadmdQNURNek1JS0VHUkVxL2dPRkFmQjVEZVlBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZemIvMy9IOGhQQTlIL1ovL3hBNnNDQWdDaUp3bUpBQUI0MmtYUlBXL1RRQndHY0Q5MzdqbHY5dG14Zlc2VDFIbHhiSWZTeG1uY09paXQ4dEpXUW0wUnBVS2lLa0lnaGk2ZGtCaEFmQWdHMUlHVmxXL0EzaDN4SFJpUm1CaFlVczd0d0oxMHd6MDMvSC8zS0ZDT2J4SnlTWDRvTTBVQjVXQ2FBYTBUeFJPa3doTk1FMDFNTUtVQml6SXZuV0FrNzRmQ014QkVjWlNOb2dRRzRVZ3p3V0o4R1p1cVdTdk9OM3Rqb090R0ZMekpPZSsyNldxZlAvS0p6VSs1YTRpOTRONHVFQWlabXo3bjFhcGZLdFJlNVRHdUZ0ZEgxbXpMMmFkUjRMZElsOFhsSW9GNjdINytjMFk3R3M3TzYzRVVkdjlIV0lrMlBxcWRBaFM1aUxKK3MwRkNYQ3Q5WlQvWFNBbTdsY2lKSGFaNUloV1pCRXdsc284NEcrWGJoeWRWOGdHZElvc2xpbW41Rndodm1EOGw3VGZGdCsrVGw2cWMxeEl3cWcycjdld0dEYUY1bzhQNU9hRnpiaDJlOTdaMVdxdnFMajRsRkk2N1ZkdHZ1YWFGS1BiM0doVU5IeGJ6NURrbDd2cHEyN2JMZm1tSm9OeFlHYlJlcENyT25sdzh0dmtCUlZlWUFxYTErUHVObDhOQVJXODdtczlPUmdoYlhMKzFEVzUrNFRlK0t6dTViV1RBWTU3c1puaG40SGNrS2JrN00rRkptQ0ZINk1zMlpZc1M2V1Y1YnpHTHhaUWtZRi9URU5oWmJhWW5ENnRxUVNjOWMvUHkyUVhJZ3lZTmlIcjF1akpzVzEzQUZhVmdySisrb3lTTWRpcnRBZWlrY2Ivc0w0Zk84bkx5c3o2MTErb2xRdXErQnRUalNxVGlhRHpZcXlKc3pwNEN6R0N1cWR0RWMwcllYT3ZZUmdIUW5VWVphcmdrVXhWRTB2NEIvMUJVbkFBQWVOcGpZR1JnWUFCaTNrTk9uZkg4Tmw4Wm1Ga1lRT0N4a1AxV0JQMWZsK2tZMDBVZ2w0T0JDU1FLQUEwdENlWUFlTnBqWUdSZ1lHYjR6OERBd0hTTVFlZi9CYVlzQnFBSUNtQUJBR1VjQkRnQ3hnQUFBam9BU3dJNkFDd0NLQUF3QUFBQUFBQm1BTlFCUWdBQWVOcGpZR1JnWUdCaGNHRmdZZ0FCUmdZMEFBQUhqZ0JOZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLTXZDbzJob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0xkcXo3ZGplZTMrY3JBek1JQUFvK0Y3TGNpMDh3VG1XeUFGQWNERTRnSEFEajRDWXNBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLRUhEUVdob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0cmJYcHpqaitXMitNakN6TUlEQVl5SDdyUWo2LzE5bU5xYTdRQzRIQXhOSUZBQXZBZ3F0QUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00Ni41NTA1MTgnIHk9Jy02MS42Nzg5OTcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTM5LjA3ODUxOScgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMi41MzEwNCwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ni41NTA1MTgsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDYuNTUwNTE4JyB5PSctNjEuNjc4OTk3Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00MS44ODM5MzQnIHk9Jy02NC42ODU1MTUnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzcuNzE4OTY1JyB5PSctNjEuNjc4OTk3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zNC42MDU2MjEnIHk9Jy02MS42Nzg5OTcnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTMwLjQ2ODY3MScgeT0nLTYxLjY3ODk5Nyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzguNDkzOTEnIHk9Jy02NS4yOTQzNjEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOS43MDgzMyAwSDQ2LjQwMzc4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjY1Mzc4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjQuMzI1ODIsNC43ODQwMSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Ni41NTA1MTgnIHk9Jy02MS42Nzg5OTcnPs61PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Mi43ODY0OTYnIHk9Jy02MC42ODI3MzMnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NC01Ni45MDU1SDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNS45NjQsLTY0LjU3ODQxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \DiagramSquare {
              sw = A,
              nw/style = pullback,
              se = B,
              nw = A',
              ne = B',
              south = f,
              east = g,
              west = f^{*}(g),
              north = \varepsilon _{g},
            }
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          Let <fr:tex
display="inline"><![CDATA[\alpha \colon g\to g']]></fr:tex> be a morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. By the construction of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>, we have the following commutative diagram.
          
    
      
      <fr:figure><fr:resource
hash="1ee8ae6f4500f08dd08da5314907b5d1"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5OC4yMjM2MjFwdCcgaGVpZ2h0PScxNzUuNDY3NzY2cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTMyLjE0OTA4MSAxMTYuOTc4NTExJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLSS9CT0dob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0o1Ui9NM3h2UGJmR1ZnWm1FQWdjZEM5a3NSOUg4ZDVoREdvMEF1QndNVFNCUUFMUHNLTUFCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLRUhESVdob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0cmJYcHp6aitXMitNakN6TUlEQVl5SDdwUWo2LzE5bU5xYTdRQzRIQXhOSUZBQTI0Z3JOQUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzRBQUFBMktBN0NTR2hvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRoTXNDcnZqK1cyK01qQ3pNSURBWXlIN3BRajZQeVBUWldZUWw0T0JDVVFCQUFJMUNPUUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV1FBQW9BQUFBQUJwZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGNEVtTnRZWEFBQUFFOEFBQUFOUUFBQUVRRHhnU0haMng1WmdBQUFYUUFBQUs0QUFBRFZLVWdxMlJvWldGa0FBQUVMQUFBQUM4QUFBQTJLQUhDUldob1pXRUFBQVJjQUFBQUlBQUFBQ1FGNHdIT2FHMTBlQUFBQkh3QUFBQVVBQUFBRkF4YUFPWnNiMk5oQUFBRWtBQUFBQXdBQUFBTUFhSUNmbTFoZUhBQUFBU2NBQUFBR0FBQUFDQUFDQUJGYm1GdFpRQUFCTFFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGaEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZndaRGdZQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUlMazBwazNNbS85L3gvSVNvT3cvcy8rRS9USEg2d1dEQUFJREF4TkFBQUFlTnBOMHMxUDAyQWNCL0IrZnkzdDZGNzZzdllwYktOajY5cE9CRFpXNkFqZ3hzQ2d2QWdTaldURStKWWdFUzhtSmtxOCtROFlRemg0OWVyWmkzZnV4di9CbzRrWFBYZ0JuNDZEdGtrUHorOUordjA4MzBlQXNIblJvQ1A2Sml3TEFrUU5zcEtEVWczQ0RpTG1NRmxoWlhUUUZUMDVpSjJvZ3paZmJ6RW5CeThJZzdnZE5KQWpEVkhNNUJBZkYzUkpMd3ozWnVvTFFNME9SR2hsVGROcUZYRnNXdHR5S2EvdGFuYU9yWGhYbGdDUDhibnVhcHBwdW1xcThEQVo0L1Q4Yk1OWW5yVld4Y0J6eDZrbWgrbGhnclJwZi9pOUoxWVY3UFdMWWVEWC9vMHdHa3k5azZvcENQd2hZZkppaW55Y0NkUENhcUxoRW5rZzRZa3RXWEZZeEdJTzZITGtOTUs0bmJ3dUhLN2lHOFF1NHBDalpDVTVBdWEwa3ExVWVUSDg4cmp4UU9KNURZYWNXVElxMXBKWFlvclRYdS8xU2V4cHhucS9QcGNWQzJiV3hrbERoR1hQRmxiSGJkMUFFTG9ycFl5Q04rZTl4cjVJOXVSWUpaOVB1K29RSVYwYWJZN2ZqeVRzM1Q3WXptdlhSZFNZenFBYjUzKythR25mazFDZkMzckxPMjM0NDFwMllPdGUvS0xQQXh0dnluZlI1cGJaeUJuSXVKSmIvemZ4MnBMOFpiaElPdVV3UGcwU21XUHhYbU5xU2l5dDFqS21LaU9hR3UxWWs4YzM5eCtSdEdaWXU0ZmJ6eklFV2kwTktTb2ZGNGJMSnhLa29lYTE0aTAvNUQrT3lxL2U3OWNsbUtVMFNEVWpJaS8ySXREaCtwTWRTK2VXL2ExMHBYWDNxYTZDeUY0ejFwLzNHMTZyTDhLYm1uOWJuTDBHcW5KUDgrSUhmdUtyc0poMDFlYTU1Q1IwNnpLL2Rsa1JiK2J5R3pPSG8zSklHRXFWMzBwZW1oTW45ekNVUTlhbEJ1UlBrUThzanBXam5SdW1sTXBTWFo4NXVuY0FtaStMSGttbmp6T3RpbEVEYktaNkM5bmQxeUw1d1dLbTBvVFlLVjFOdXlPK05UTFMrRjdzNWllS0tsSFJWWUJpbUFra2JDdzBWMHo0NWVVN2dKeVRiVDJiSjhWU01UTlJ6ZWRTUU5iaXh5RDVRM3dxZ1hoVmZ3RyszbktBZU5wallHUmdZQURpbDBiZW92SDhObDhabUZrWVFPQ3hrUDFTQlAxZmwra1kwMFVnbDRPQkNTUUtBQWFWQ2FjQWVOcGpZR1JnWUdiNHo4REF3UFNEUWVmL0JhWXRERUFSRk1BS0FHOTlCTFVDeGdBQUFqb0FTd0k2QUN3QytBQS9BaWdBTUFBQUFBQUFaZ0RVQVR3QnFuamFZMkJrWUdCZ1pYQmhZR0lBQVVZR05BQUFCNmtBVG5qYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT3NBQW9BQUFBQUJCd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFMEFBQUJncW1OaWUyTnRZWEFBQUFGRUFBQUFNd0FBQUR5ZVdtUmJaMng1WmdBQUFYZ0FBQURnQUFBQTdEME5RbHRvWldGa0FBQUNXQUFBQUN3QUFBQTJLWS9DZzJob1pXRUFBQUtFQUFBQUh3QUFBQ1FGN2dEYWFHMTBlQUFBQXFRQUFBQU1BQUFBREFrS0FPMXNiMk5oQUFBQ3NBQUFBQWdBQUFBSUFGUUFkbTFoZUhBQUFBSzRBQUFBRndBQUFDQUFCUUEyYm1GdFpRQUFBdEFBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEb0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtWm1hY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFBNE1EakoxU1hKYk93S1lrL3NDQVdldVBKUU1Ec3hiemNhQXdJMEwxLy84TURBRG90dzdmQUFBQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWm1SZ1VoSi9ZUEQvUHdNRGhMNzdTdjRTV0JVUUFBQ25pUW15QUhqYUxZNVBTc1F3SEVienBjTXZWTlBhUDJuU29rN0hES2E3a1NsMUNpTDFFb29ic1lqUXZXdHZvT0FSUm5EbkdieUd5em1MbU1Xc0h0LzdObytCZmJBbGY4YU9kWXloMzdSYTBSRzAwU2FHdTBBTkVpdDBOeERVV09mcEd0Y01hR3MwN3JMYjlOb0l2SDNLU3FYMGZYK1hjNmdxL0lxSTJ6UW4rWDVPVVZGNnJ6aUtNdHBLeWxQTEQzRThoc3JHZkRnOUUyV21RRS9UMVR4QVp0YlRiUUZsay8wUmp0UDZJTXJBNjBlZnhrYlc0SlZmczhTUGdKYStvODhIOUswMkpQRHlTMUxud1d3YlZQUEtBVFBzL2g1U0lhSUVQL0VDaXhNcDJUOXVmQi9RZU5wallHUmdZQUJpUnBlRkYrUDViYjR5TUxNd2dNQmpJZnVseURSTEtKTU5rT0pnWUFMeEFPL0JCN040Mm1OZ1pHQmcxdnBqeWNEQUVzb1F6K0RCbE13QUZFRUJ6QUJJZFFMTkFBUlZBQUFDOGdDT0FjTUFYd0FBQUFBQVZBQjJlTnBqWUdSZ1lHQm1NR1VBMFF4UUVna0FBQVhsQUR3QWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS012Q2cyaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZHF6N0x4dlBiZkdWZ1ptRUFnY2RDOWt1UmFlYUpURFpBaW9PQkNjUURBQllFQ0t3QUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNi4zMDU1NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIuMTU3ODU5JyB5PSctMjYuODgyMjY5Jz7ugLDugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC05LjYyOTg1OCwtMjMuMjY2OTA2KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy05LjYyOTg1OCcgeT0nLTIzLjI2NjkwNic+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQuOTYzMjc0JyB5PSctMjYuMjczNDIzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS43OTgzMDQnIHk9Jy0yMy4yNjY5MDYnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMi4zMTUwMzknIHk9Jy0yMy4yNjY5MDYnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNi40NTE5ODknIHk9Jy0yNi4yNzM0MjMnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc5LjE0Njc2MycgeT0nLTIzLjI2NjkwNic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MC4zMDY1NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTEuNTczMjUnIHk9Jy0yNi44ODIyNjknPu6AsO6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjg2MTEgMEg0NS4yNTEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDUuNTAxLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjIuOTczMzksNS42MjI5NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS44NjU4MzYnIHk9Jy0yMS40MzQ4NjMnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTIuMTk3Mjc5JyB5PSctMjIuOTAxNTkyJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNDkyOTA4JyB5PSctMjYuMjczNDIzJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00NS4zOTEwOCwzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIuMTU3ODU5JyB5PSctMjYuODgyMjY5Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC42OTUzNi01MC4yMjQ1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzc5NjUsLTAuNjI2MTYsMC42MjYxNiwwLjc3OTY1LC04LjUwMDQ2LC01MC4zODEwNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTU5LjU5MDE1LC0yMS4zMTQ0NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00Ljk2MzI3NCcgeT0nLTI2LjI3MzQyMyc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0uNzk4MzA0JyB5PSctMjMuMjY2OTA2Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzIuMzE1MDM5JyB5PSctMjMuMjY2OTA2Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzYuNDUxOTg5JyB5PSctMjMuMjY2OTA2Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tMzAuNTI5OTcgNDEuNTE0OTRDMy4wNzcyOSA0Ni4yMjg4OCAyOS4xNzQ1OSAzNS42NzUyNSA0OS43NTI5OCA5LjMyMTYyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNjE1NDMsLTAuNzg4MTYsMC43ODgxNiwwLjYxNTQzLDQ5LjkwNjgzLDkuMTI0NTkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE3Ljc5OTY1LDQxLjgwMzM0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPs6xzrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLS42ODY0OTQnIHk9Jy0yMi4yNzA2NDInPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00tMzMuODI4MDggMzMuODI4NTdMLTkuMjc3MTYgOS4yODEwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE0LC0wLjcwNzA1LDAuNzA3MDUsMC43MDcxNCwtOS4xMDAzNyw5LjEwNDMxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00tMzQuNTMyNTYgMTQuODc4MDdILTguMjE5MTFWMjcuOTcyMjJILTM0LjUzMjU2Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMxLjUzMjU2LDE5LjYyODA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQuOTYzMjc0JyB5PSctMjYuMjczNDIzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS43OTgzMDQnIHk9Jy0yMy4yNjY5MDYnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMi4zMTUwMzknIHk9Jy0yMy4yNjY5MDYnPs6xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzcuNDk0MzgnIHk9Jy0yMy4yNjY5MDYnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                nw = A'',
                nw/style = pullback,
                ne = B'',
                sw = A,
                se = B,
                north = \varepsilon _{g'},
                west = f^{*}(g'),
                west/node/style = {right},
                south = f,
                east = g',
              }
              \node  [above left of = nw] (a') {$A'$};
              \draw  [->,morphism,bend right] (a') to node[swap] {$f^{*}(g)$} (sw);
              \draw  [->,morphism,bend left] (a') to node {$\alpha \varepsilon _{g}$} (ne);
              \draw  [->,morphism,exists] (a') to node[desc] {$f^{*}(\alpha )$} (nw);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          Thus, <fr:tex
display="inline"><![CDATA[\varepsilon _{g'}\Sigma _{f}(f^{*}(\alpha )) = \varepsilon _{g'}f^{*}(\alpha ) = \alpha \varepsilon _{g}]]></fr:tex> as required.
        </html:td>

      </html:tr>

    </html:table>
<fr:p>By construction, <fr:tex
display="inline"><![CDATA[\varepsilon _{\Sigma _{f}}\eta  = \mathsf {id}_{\Sigma _{f}}]]></fr:tex>. Thus, it remains to verify the other triangle equality.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[g \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex> be an object. We need to show that <fr:tex
display="inline"><![CDATA[f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} = \mathsf {id}_{f^{*}(g)}]]></fr:tex>. Note that <fr:tex
display="inline"><![CDATA[f^{*}(g)f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} = f^{*}(g)]]></fr:tex> by the construction of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>. Moreover, we also have the following equation.</fr:p><fr:tex
display="block"><![CDATA[       \begin {align*}         \varepsilon _{g}f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} &= \varepsilon _{g}\varepsilon _{f \circ  f^{*}(g)}\eta _{f^{*}(g)} && \text {by the construction of } f^{*}\\                                                     &= \varepsilon _{g}\mathsf {id} && \text {by the construction of } \eta \\                                                     &= \varepsilon _{g}       \end {align*}     ]]></fr:tex><fr:p>Thus, <fr:tex
display="inline"><![CDATA[f^{*}(\varepsilon _{g})\eta _{f^{*}(g)}]]></fr:tex> corresponds to the same cone over <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> as <fr:tex
display="inline"><![CDATA[\mathsf {id}_{f^{*}(g)}]]></fr:tex>. Then uniqueness implies that they are equal.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Backlinks">Backlinks</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1368</fr:anchor><fr:addr
type="user">log-000R</fr:addr><fr:route>log-000R.xml</fr:route><fr:title
text="Comprehension schema via syntactic category"><fr:link
type="local"
href="log-000I.xml"
addr="log-000I"
title="Comprehension schema">Comprehension schema</fr:link> via syntactic category</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[T\colon \mathcal {C}^\mathrm {op}\to \mathsf {Lat}]]></fr:tex> be a <fr:link
type="local"
href="log-000C.xml"
addr="log-000C"
title="Doctrine">doctrine</fr:link> with those structures listed in <fr:ref
addr="log-000H"
href="log-000H.xml"
taxon="Lemma" />.
  Additionally, assume that <fr:tex
display="inline"><![CDATA[T]]></fr:tex> satisfies <fr:link
type="local"
href="log-000D.xml"
addr="log-000D"
title="Frobenius reciprocity">Frobenius reciprocity</fr:link>.
  Then there is a doctrine <fr:tex
display="inline"><![CDATA[T^{\flat }\colon \mathsf {Elts}(T)^\mathrm {op}\to \mathsf {Lat}]]></fr:tex> indexed by the syntactic category of <fr:tex
display="inline"><![CDATA[T]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[T^{\flat }]]></fr:tex> admits comprehension schema.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>685</fr:anchor><fr:addr
type="machine">#250</fr:addr><fr:route>unstable-250.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>This proof is adopted from Errol Yuksel's proof.
    Any error should be attributed to me.</fr:p>
  <fr:p>Let us define the action on objects by <fr:tex
display="inline"><![CDATA[T^{\flat }(\Gamma .\varphi ) = {{T(\Gamma )}_{/{\varphi }}}]]></fr:tex>.
    That is, <fr:tex
display="inline"><![CDATA[T^{\flat }]]></fr:tex> sends each formula-in-context <fr:tex
display="inline"><![CDATA[\Gamma .\varphi ]]></fr:tex> to its downward closure ordered by entailment.
    By assumption, each <fr:tex
display="inline"><![CDATA[T(\Gamma )]]></fr:tex> is cartesian.
    Thus, each slice <fr:tex
display="inline"><![CDATA[{{T(\Gamma )}_{/{\varphi }}}]]></fr:tex> is also cartesian by <fr:ref
addr="ct-000H"
href="ct-000H.xml"
taxon="Lemma" />.</fr:p>
  <fr:p>For each morphism <fr:tex
display="inline"><![CDATA[f\colon \Gamma .\varphi \to \Delta .\psi ]]></fr:tex>, we define <fr:tex
display="inline"><![CDATA[T^{\flat }(f)]]></fr:tex> to be the following composite:</fr:p>
  <fr:tex
display="block"><![CDATA[{{T(\Delta )}_{/{\psi }}} \xrightarrow {{{T(f)}_{/{\psi }}}} {{T(\Gamma )}_{/{T(f)(\psi )}}} \xrightarrow {\varphi  \wedge  \mathord {\hspace {1pt}\text {--}\hspace {1pt}}} {{T(\Gamma )}_{/{\varphi }}}]]></fr:tex>
  <fr:p>where <fr:tex
display="inline"><![CDATA[{{T(f)}_{/{\psi }}}]]></fr:tex> sends each <fr:tex
display="inline"><![CDATA[\chi  \vdash  \psi ]]></fr:tex> to <fr:tex
display="inline"><![CDATA[T(f)(\chi ) \vdash  T(f)(\psi )]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\varphi  \wedge  \mathord {\hspace {1pt}\text {--}\hspace {1pt}}]]></fr:tex> is the usual pullback functor along the morphism <fr:tex
display="inline"><![CDATA[\varphi  \vdash  T(f)(\psi )]]></fr:tex>.</fr:p>
  <fr:p>This composite admits a left adjoint <fr:tex
display="inline"><![CDATA[\exists ^{\flat }_{f}]]></fr:tex> defined as the composite of the top morphisms of the following diagram:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="4863ea188a85adfaccec22bd95b694a5"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMxNi4yNTY0NDNwdCcgaGVpZ2h0PSc1Mi43NDc5MnB0JyB2aWV3Qm94PSctNzIgLTcyIDIxMC44Mzc2MjkgMzUuMTY1MjgnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFWUUFBb0FBQUFBQmpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY3A1QVdOdFlYQUFBQUU4QUFBQU93QUFBRXdFbVFRcFoyeDVaZ0FBQVhnQUFBSnpBQUFDNUFoRHpjeG9aV0ZrQUFBRDdBQUFBQzBBQUFBMktLRENXMmhvWldFQUFBUWNBQUFBSGdBQUFDUUd4UUsxYUcxMGVBQUFCRHdBQUFBVUFBQUFGQkJtQWNwc2IyTmhBQUFFVUFBQUFBd0FBQUFNQVRBQ0JHMWhlSEFBQUFSY0FBQUFHQUFBQUNBQUNBQlJibUZ0WlFBQUJIUUFBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUZSQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1kbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBycU0xOWxadmdQNURNek1JS0VHUkVxL2dPRkFlZWhEYjhBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1Jnc2dEUVhBd2RRam9sQm55R04rUVR6MWYvL2dXSnc5djlMLytmOHNmNmpEOVlCQlFCMjJRNi9BSGphSlpMUFR4TkJGTWZudmRudXIzYTczWFozdGhiYTB1M1NnY2EyeU5adGlyS0ZnSUJFcENpSmNwQ0RpVUdKSnBJUWcxR0pkNHdtSmw3MFltSk12R24wNE1FejhlVEpQOEovUXFtekpXOG1iK2FiTjIvbTg5NFFJSWNEZ3Z1VUVJTVFEV1NseG1zZENEdk1aYmg3c3FHNEJZb2FmRlpqajcvK3J1V1JGdENtMzRhZUVBTGt5YUNCeC9pYnJJZ05OVVdHTkNoeWpVY1FNTmVXRlZhR0NEcGhUK1NzeXJYejdkQU40dlhRbUp1R3FyZ3c3TlJhNENteUNVSEliRVZXNEUvWDBLeENkcjdoclZHWWRPclVkc3gwcnVnbnJPeW9sZHd5Y3JhNW5aYWx2R3BVTnlaV1JRaXJVMGlWTW1hdTRPcXAvQVBEVnFrRVJ5ZmZJKy9pWkNGQThKcWVSN2xWMFJWQURKM2U3dnZkR1pBTlc0TitaYXlkc1ZvUytHZmpFSm1uVllSOHB2Y0s1RE5KQ2tQR1c0TW12WU0veVhyTWVQcjRKbkF4WXJRaFpvek54YXp5R3U4SXBCaEtZTVhGT0JYYncxTWxjRzBodU1MblJJVmM1dUxyRDN0OXYzQUJZRFFwcHdDcXJqV0JqbG5xM25oWmJxQ1dTcW5RdUxhMExLSEZUWUNTMzdPb21qSlVLQ1V0dm5ndWdxeWZRZHljK3lnTlZmejA3NkVValpRdnoxYkdsWVJsc0hFQVBsMjhQUjRGSzJYNjFWQVI5Ui9vK3h1cGhlMngwUW1BK1haU0U1b1RaSzBwQ1FMTy9LMmUzZzBUK01ZVWVwSWcyUjlVNkJJY2t5a3lTMGpDaEdITGVsVEF0OE5PQkFMQmprWGhZNHRvekJqWFExWjRJTXJURk9HaXNRemVNazBxWmowSmxCRm41eG5XNjltTW80Z2YwK0lnemFUVGMxMjN1Yll6dTNnVDZKWmJ2UGRDZDk1OVFWeHRYVG9hMGFuK0tNd3g5TFI4ZjhXNjIrZFBweDJOb2s0bEszak1Gb3FhektRckIzdkxBTmRYNzIreTNCSzlLajFmbjI3QndlR01UTWgvZi9Wbm1nQjQybU5nWkdCZ0FHTHhOdGJhZUg2YnJ3ek1MQXdnOEZqSWZqMkMvcy9Bbk1vTTRuSXdNSUVvQU9aWkNBSUFBQUI0Mm1OZ1pHQmdadmpQQUNSM01NVCsvODZjeWdBVVFRR3NBR3NvQklBQUFBTlVBQUFDOGdCK0Fyd0Fld080QUYwRHJBQjBBQUFBQUFBZ0FKSUJFQUZ5ZU5wallHUmdZR0JsQ0dCZ1lnQUJSZ1kwQUFBSTFRQmFlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ3dOcUZnWW1WcVF0Z0YyV3dqWndRQ2FucTJOL2RoL0hRTjF5ZCsyRUROVDhVM0s5Z2x2UitKWlc0QjFkTW1XZWVpSHZMWExQZ25TZUs4bG1TVno0eWw5SjhacTU0NFN2elJQTHZ6RFVyZmpmQlhhNkRqV29YakkzKzVGeTMzdHZZZDhHcnBXNlMzMXB2NDJHd1JoMXZ5b3hkUDU2ZGFuV2pXellFSEJldURGZ2lpcDBrSnJIbkpKMmpZODArSmIxd2tGeXhSTlA4NjdmUys3UTVwSitNYkk3Y1JBMmpMSHJSczJ3VmJYcXBhZjhBeUJFdjd3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCSlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWtBQUFCZ2hjUVVXMk50WVhBQUFBRkFBQUFBTlFBQUFFUUR1Q0NuWjJ4NVpnQUFBWGdBQUFFOUFBQUJWQWFtVHJ4b1pXRmtBQUFDdUFBQUFDNEFBQUEyS0RYQ1hHaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR0JBSlRhRzEwZUFBQUF3Z0FBQUFVQUFBQUZBdnZBUXRzYjJOaEFBQURIQUFBQUF3QUFBQU1BTXdCQ20xaGVIQUFBQU1vQUFBQUZ3QUFBQ0FBQndBaWJtRnRaUUFBQTBBQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVNtYWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhRRUFEQTBNakF4SklLUzVMQjBwcUtBZ3pNL3dIOHBrWkdFSENqQWdWLzRIQ0FQa0NEYTRBQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWURJQTBCeENDNURTWkZ5c0kvLzhQWkdsQVdQOXYva200L3hHc0Znd0E2TkVMZkFBQUFIamFKYys5VGdKUkVBWGdPZmR1N21WWGZoYkVKV29VRm1UUkFoS0YzWTBraURacVFVa3NqQlpLWW9VbUdMVkRqVCtOaVE5QjZ6TllHaHQ3MzREQ21HaXJKcXhlSkhPS3FiNHpRNkNUWCtDU0UwMFJJV1VscFloQlNHR3BOUWFub01aMzZ2RFFqa2k1VnBYTEhGc0hob3pjdXRHeFBHUEZxTWNKekJTVnR0bDV2di9lMVUyRy9hNmQ2YmFPci9OWGlxUk41VGRIL3JoU1U1Wk1DaG1GNDFmcVdJRmZRc0Z4UFgvbnhodUNDMW52YUJvODF0d0I3NnpyRUp4RzJuWnZkYS9GREs3Rkc1KzlwMzdWRURvakd2b2JST3lIUFZLR1NJZXRUbFh4eTlMT09xNnZ3L0ZTZGlwWGdyUlZ1Y1JEOElHbDRueDUwU3FadWZUZ0xoeG5tQWplRUU2d3MzVE9QTzhHUVYvalFDUG9nMlBTbkR2OTBvd1FabkdZMFBGKzBkQ0NWNkhMLzk0UUdLc2hUZW8xMks3TmFvTVg1b0xOMEI4dVNENklBQUFBZU5wallHUmdZQUJpVTRkcnUrUDViYjR5TUxNd2dNQmpJZnYxQ1BvL0k5TXZaaENYZzRFSlJBRUFGV1lKZmdBQWVOcGpZR1JnWUdiNHp3QWtuUms0R0xpWWZqRUFSVkFBS3dBNXVBSmVBQUFDMHdBQUFja0FkQUhKQUVnRFF3QkhBa2NBQ0FBQUFBQUFNQUJnQUp3QXFuamFZMkJrWUdCZ1pWQmtBTkVNVUJJSkFBQUVKd0FxQUhqYVBZd3hxOEl3RklXL1loWHRHeHdFaHpkSThBZUVTaCs0dURrNHVUcTh6Wm9nSFpwS1dvc3U0ay8zTmdSdjRQRGRjODROa1BFaVlaaUVlZEJoVW5uenlHTitXRVNlaUwrS25QSExtaEZKT2hObnhTNXl5cFQveUdPV2xKRW40ajhpWi96eDNqZjE3ZDVacjQ2TnNkNWRhcjg5V2Q5V2pWTWJuUS9yd1Rycno1MDFxbndxMDFkdGY2MVZvWE5kc0tlaDVzYWREb3RIY1JUSEJIWmNKUE5zT1lXOXBaTE1TV2VESnYrbUIwbGRhSnpETDBZYUpVOVJReTgzcmVoVnVvb2kzR21LRDFpc0xrc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOd0FBb0FBQUFBQTlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUUwQUFBQmdxbkZpd1dOdFlYQUFBQUZFQUFBQU13QUFBRHllckdSS1oyeDVaZ0FBQVhnQUFBQ2VBQUFBb0o1VWlnUm9aV0ZrQUFBQ0dBQUFBQzhBQUFBMktNekREV2hvWldFQUFBSklBQUFBSGdBQUFDUUdOd0FUYUcxMGVBQUFBbWdBQUFBTUFBQUFEQWw1QUoxc2IyTmhBQUFDZEFBQUFBZ0FBQUFJQUNvQVVHMWhlSEFBQUFKOEFBQUFGd0FBQUNBQUJRQVZibUZ0WlFBQUFwUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQURaQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0xbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUE0TURqSjFTWEpiT3dLYWsvaUNSV2ZHUEVRTURzeUx6T2FBd0kwTDEvLzhNREFEN3l3OHpBQUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFabVJnVWxKL2tQai9Qd01EaEw1N1MzNGhXQlVRQUFDdkJnbnpBSGphSFl4ZENvSkFIQWYzOTA4Mk56OW9NVGRYNmNFMTFwNGpsQTRSMUNrNlNVR242S21yNUJVNlJIU0FRa3VidDJGZ0dOanUrNlNHaml4aVRFQ05lV0ZzS2NCTmFXdFV0Y0lOeVlTYzJQUEczYnY3aUpWREF0cU5ablJvRzBuYUQybmF2aEpOa3JZeFJxd0hiTTlBWjdvUFQwakZqYTFsenUybW11ZlNWbXRGSjdoTEYxMFI2RVdJeHlCMGJTOStsZ1lvL2drbVNMTis5UVA2WFJwdEFBQjQybU5nWkdCZ0FHSzdDREhSZUg2YnJ3ek1MQXdnOEZqSWZqMkMvditHZVNMVE1TQ1hnNEVKSkFvQTd6OEpnUUI0Mm1OZ1pHQmdWdnhqQkNRbk12Z3krREFkWndDS29BQm1BRkozQTA0QUFBT1JBQUFERXdCTkF0VUFVQUFBQUFBQUtnQlFlTnBqWUdSZ1lHQm1FR0VBMFF4UUVna0FBQUtzQUJzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnVkdKallXQmlaZW9DMktBTWNaQWRJa1dxT3ZLN2U3Z2Vlc1BwZVQvdWdKSWZNcDZUOFJyM2MzSUtVWDljOE1KYjRxbW9SZUtTRDVaTXlQS1pPSE0yaVhOSnZoSVh2SE5KUEJYL08zSEpKNDl0MTk3dXZmVnEzeG5yM2JrTjQvcGdmV2c2cDFhNmlucG5uZlhIM2hwMUdwVVptakJjVzFYclN0ZHM2V2k1Y2FmSDRsSHN4VEdSSFdmSkFpTnJEdEVKTkpJNmFhM1FWUC95bmVRdWRvN3hrNUhPU1JJbE5NaFZrSDJWdHFLT2w1cjZGL041TUU4QUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPQUFBb0FBQUFBQSt3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVzkwbjJOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDbloyeDVaZ0FBQVdRQUFBREFBQUFBd0owRlNhZG9aV0ZrQUFBQ0pBQUFBQzhBQUFBMktBekRFbWhvWldFQUFBSlVBQUFBSUFBQUFDUUY3UUQrYUcxMGVBQUFBblFBQUFBSUFBQUFDQVRNQUJsc2IyTmhBQUFDZkFBQUFBWUFBQUFHQUdBQUFHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJBQStibUZ0WlFBQUFwd0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQURjQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1TbU9jd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBxR01JUXdNL3dIOHBraDBraHEvZ09GQWM2S0RQNEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2Z2gvLzlEeVA5cndYd0dBRlFtQnJBQUFBQUFBUUFaLy84QzBRSzRBRHdBQUFFREJ4UVdId0UyQnhRR0x3RUhKeVluSmpZWE1qWTNFelkzTmlZckFTWUhCZ2NHQndZbUp6OEJQZ0VYSVRZWEJ3WW1Qd00wSmdjakJ3NEJBYldJQkJBV1FTWUREZ2l1cXd3RkFRRVNHazhvQTRrREFRRUpGQ2hpTEF3S0pDSUZGd0VHUFFRTUVRSTRHd0VlQVJzQkF3WUNTVTBsR3drS0FtNzk0QllNQ0FJQ0F3OE9Cd0VEQXdJQkNROEdBUlVjQWlNSURRWUhBeGtIQ1NWbkZnSUtFN1FPQndFRERzUVhBZ3NVTFNVNUhRSURBZzk0Mm1OZ1pHQmdBT0lUVW9zNTQvbHR2akl3c3pDQXdHTWgrL1VJK3Y5L3BvdE1PNEJjRGdZbWtDZ0FGeUVLa2dCNDJtTmdaR0JnWnZqUHdNREFWTVlnK2IrVjZTSURVQVFGTUFFQVhSTUQ3d0oyQUFBQ1ZnQVpBQUFBQUFCZ0FBQjQybU5nWkdCZ1lHS3daUURSREZBU0NRQUFCcElBUXdCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUVFBQW9BQUFBQUJKUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFZ0FBQUJnaGdPV05HTnRZWEFBQUFFOEFBQUFOUUFBQUVRRHFDS2FaMng1WmdBQUFYUUFBQUUzQUFBQlVBbFdVNGRvWldGa0FBQUNyQUFBQUMwQUFBQTJLR0RDVzJob1pXRUFBQUxjQUFBQUhRQUFBQ1FHU1FKYmFHMTBlQUFBQXZ3QUFBQVVBQUFBRkF0REFPNXNiMk5oQUFBREVBQUFBQXdBQUFBTUFMSUEvbTFoZUhBQUFBTWNBQUFBR0FBQUFDQUFDQUFmYm1GdFpRQUFBelFBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFFQkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtOG1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpFRHZBT0NuRlplbEFTUTBsTm1hRy8wQStNd01qU0pnUm9mdy9VQmdBM3hNTlNYamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUlMa05Ka25LN0g5L3c5a2FVQlkvMi8rS2JqN0Q2d1dEQURrekF0aEFBQUFlTm90MEx0T3dnQVlCZUQvL0lXQ0RSZmJRTnRna1V0akN6RkNRR21EQmdlanhoaVp3TVJGR3k1aWpFL2dBeGlmZzhuRUoyQTNUajZBazRPTGs0T1RreTAyNkhtQTc1d2NBbzNuaEw1QXBCRkZNMlhMcnNHMUhIY1h6VFJTMEVTbEFCVTlkZFNvR29CaE5TWXFFaGRINEgwdkxYeExRKy9zc2JNM1BSMWRKcFlIUC9lM1FUQ1dJeFFHMUE3ZDZwOExWWXlsVUc2RnFyMWwxV0c1VGxQVlZvSEtRc3dtejQrNWQ2SUlRSGJSUS8vaTBMK2JmbldWQ0M5NlFyTk14SDJlVVQ0ME5iT0dtR21KbWl5cU84amFacXkxMlhSczJiSFcwV0kzbjRzZjNGeWJNb1RDWWFuMzBOWGJPZVpjVytmWng5VUFVSFQvZlVVdENrSXhZN0J1WkF2aFpxYjZQQkRXK0kwa1NoSXRRYlZMb292d2loaEtlSVlIM2QvV0FTOHE2UnZCSjFmNHhlOUl6QkkvU2ZHSi94b1N2NGRPUHcwQWVOcGpZR1JnWUFCaWxyb3ArZkg4Tmw4Wm1Ga1lRT0N4a1AxNkJQMmZnVm1WR2NUbFlHQUNVUUQwZ1Fnb0FBQUFlTnBqWUdSZ1lHYjR6d0FrUXhtVWdLUXFBMUFFQmJBQ0FDMURBYXdBQUFBQ2dBQUFBWTBBWkFHTkFEa0NWQUFpQTFVQUx3QUFBQUFBTEFCV0FJWUFxSGphWTJCa1lHQmdaWkJqWUdJQUFVWUdOQUFBQS9NQUtIamFSWXd4YjhJd0VJVy9pQVNKZE9oU2RXQUFEOHhXb2pCM1lXQmlaV0lCYktJTWNaQVRJaUdoanYzZFBZd2xibmo2N3IxM0IrVDhrdkNjaE0rZ3owbkpaSHR4eGdkZmthZXlMU1BuekZreElVbG40aXo0aVp4S2NvaWM4YzBsOGxUOFIrU2NOWCticnIzZUJ1dlZyalBXdTNQcnkySnZmZDkwVHBXNkNQdldPdXVQZ3pYcWRGZG1iUHF4YmxXbEMxMnhvYVBseW8wQmkwZXhFOGNFZHB3bDg1UVU3SVBUMDBqcXBGV2l4WDNuVzhsZDZCekRKeU9kRTNkUnd5aFh2V2d0YlVVVkxqWFZQMk05THc4QUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVh3QUFvQUFBQUFCdndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hjcDRaMk50WVhBQUFBRThBQUFBUUFBQUFGUUVPZ1RzWjJ4NVpnQUFBWHdBQUFNR0FBQURvTCtKc0RCb1pXRmtBQUFFaEFBQUFDMEFBQUEyS0dUQ1cyaG9aV0VBQUFTMEFBQUFIZ0FBQUNRR1dBR1ZhRzEwZUFBQUJOUUFBQUFZQUFBQUdCQVBBVHhzYjJOaEFBQUU3QUFBQUE0QUFBQU9BdHdCOG0xaGVIQUFBQVQ4QUFBQUdBQUFBQ0FBQ1FCUGJtRnRaUUFBQlJRQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRjVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVdzczRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFRVWjc3S3pQQWZ5R2RtWUFRSk15SlUvQWNLQXdBTVlBNGtBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdjZ0RRUEF3ZFFqb1ZCbnlHRUlZMzVCUFBWLy8rQm9raTgvNWYrci9zLzk0L05Id093UGpnQUFQWjBFU040MmtXU3oyOGJWUkRIMzNmZWVwLzNoM2ZYUC9hSDdkVHhycDFkdTA1aU56RzdTWlN1MjZTeVcwcmFRbFVxcENBRUFhRlc1Y29GQ1VvdmNFQ2NFT0xBaFFzY3VNQUZ3VDBTWEJGL0FEZitBQ1J1dE9hdFZRbk5ZZWJOekh1YXo1c3ZBN3UxWktSeHhrekdOS2dpU3VJTU9YeVA4T3lKRWpRVUNIeFlHaWxFZi95NzhIbUxPL3lYd2pIR3dEYVhTejZrbjltUlBIQWJxcmVPSGMrMU1DYXhqUmZpMVBmU3JKN0dJOFJDbFdaQlptZkY2MkhxaTRhYVpPa01hWnpFWThnYS92NlVBNVhtb1YrSEkxNDkvY0VRY0ZzbkEvNFpERzkwTnJITVFWOHB1MnJwcW1MVzZQME8xdm9nRlVDMVd3L2Vhem9HUFhyNmw2VnJaU0pGcndwd0tOQzVET0N1MFVSdzNoQkc5TURTWmJMMmt5MmcxTTREMkVaU2JhOWROSXAzWUJaTU41ZGpla2kvc3l2UG1lUmtJb3FUSEx1ZTc2bENJdWFZOFo0cTZYWnpaREsvNC9rV2VoSWp6U1NKUlRaMlUwOU44TTJCb3pndDdlcWx3UUhRZDJNT2U5MjI3WDdJTDJ6YkwzV29icjlzdTVaMzFCc2VBajFQMXAyT2JkZHFIYjNjZXFNbzQ0dG41eTlXcjB3Ynh6enVkYnJVVnhOREl5ZzMzYS8rdWM4amdmdXZ0Wk40by85L0NjMTQ2M01sS29PdDlqTlpidEdmOUNzN0tWalNyTEJ0SkFWTWxoWkRyM2FTQ0hXTU9Ka2hMbHhjTkUxRkpQZlZrNTNUMVNWSldIVDZubCtYdk5MUjFyY1BGa2w3QjJoWGRBVlJvelRpOE0wTG02ODg3bTVTWFZOUkNmZHliNjlFMVkwYW11dUhkVlRsSC90bXRaY1A5Z0JybzByMDBYZGNOV1VyZmYvMDNWSWVKdGYzd3FHaEJHNElhdTNIYjdlUFJ5Y2gvekVnSXUzZ0NacVY3bTNqK1BXTDNRM01ja2ZtckludmJwY21nMlo0T3RmZXNlanJpZzdTSlRleHhUS2kzM0RPSml4bnJDUXNMcmxtaGZpbWFWWm8yL2VFS2xmcmQrQkxBYTRRWmFpdVJKcjRoU2l6cWJ4U2lQSmFVRGFEV2hQUUoyZG53NUZsT2xJcTJvSERiYUszN3RVQ1orQjEwcnVITjhEdkJPMDNQM0REeDNmdEU4clNPNHRlUi90azB6TlFjWG4wcGY5dzN2dDQzeEZ5YmtWYjVQcGxaZitHdVgvOTBpSU9MNWR3ZS83b1h0T2Q4em1VbVhsMGF5ajFjam8ra3lqL0FZUkdlODRBQUhqYVkyQmtZR0FBNGhWaHRsUGorVzIrTWpDek1JREFZeUg3OVFqNlB3T3pKak9JeThIQUJLSUFBcUlJZHdBQUFIamFZMkJrWUdCbStNOEFKRmtaZFA1M01tc3lBRVZRQUJzQVI4MEM4d0FBQXNZQUFBSlhBRTRDc2dBc0Fqb0FTd01GQURBREFRQkhBQUFBQUFBZUFJZ0E3Z0ZxQWRBQUFIamFZMkJrWUdCZ1kvQmpZR0lBQVVZR05BQUFDTDRBV1hqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUxLjAzMTE1MiwtNTQuNTA4Njk3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE2Ljc0MTk0LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS4wMzExNTIsLTU0LjUwODY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuMDMxMTUyJyB5PSctNTQuNTA4Njk3Jz5UPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00My44MjU1MDknIHk9Jy01NC41MDg2OTcnPijiiIYpPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yNy43NzQ1NTMnIHk9Jy01MS41MTk5Mic+L8+IPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU4LjE2NjA5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS4wMzExNTIsLTU0LjUwODY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuMDMxMTUyJyB5PSctNTQuNTA4Njk3Jz5UPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00My44MjU1MDknIHk9Jy01NC41MDg2OTcnPijOkyk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTI5Ljg1MDExMycgeT0nLTUxLjUxOTkyJz4vVDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMTkuOTkwMTgnIHk9Jy01MS41MTk5Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTYuODc2ODM3JyB5PSctNTEuNTE5OTInPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTEyLjIxMDI1MycgeT0nLTUxLjUxOTkyJz4pKDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNS45ODM1NjcnIHk9Jy01MS41MTk5Mic+z4g8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS40NjE0MTInIHk9Jy01MS41MTk5Mic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNTUuMTU3OCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuMDMxMTUyLC01NC41MDg2OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUxLjAzMTE1MicgeT0nLTU0LjUwODY5Nyc+VDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDMuODI1NTA5JyB5PSctNTQuNTA4Njk3Jz4ozpMpPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yOS44NTAxMTMnIHk9Jy01MS41MTk5Mic+L8+VPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00yMS4yOTc0OS0zLjYxNjYySDUzLjExMDU1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUzLjM2MDU1LC0zLjYxNjYyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC41ODA3MiwtMTEuNjc4NDQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS4wMzExNTIsLTU0LjUwODY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTEuMDMxMTUyJyB5PSctNTQuNTA4Njk3Jz5UPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00NS4yNTMxNTUnIHk9Jy01NC41MDg2OTcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQyLjEzOTgxMicgeT0nLTU0LjUwODY5Nyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzcuNDczMjI4JyB5PSctNTQuNTA4Njk3Jz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zNC4zNTk5MDUnIHk9Jy01Mi4yNjcxMDMnPi/PiDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTE3LjEwNTk3LTMuNjE2NjJIMTUwLjEwMjI2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE1MC4zNTIyNiwtMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTIzLjcxNTc0LC0xMC4zMTczNCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjAzMTE1MiwtNTQuNTA4Njk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01MS4wMzExNTInIHk9Jy01NC41MDg2OTcnPs+VPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy00My45NzY4NjknIHk9Jy01NC41MDg2OTcnPuKIpzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzUuNzk3NjQyJyB5PSctNTQuNTA4Njk3Jz7igJM8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTE1MC42MDIyNiAzLjYxNjYySDExNy42MDU5NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMTcuMzU1OTcsMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTI4LjQ1NDc5LDguNDAwNjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS4wMzExNTIsLTU0LjUwODY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNTEuMDMxMTUyJyB5PSctNTQuNTA4Njk3Jz7OozwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDUuMzQ0MTE3JyB5PSctNTMuNTEyNDMzJz7PlTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTMuNjEwNTUgMy42MTY2MkgyMS43OTc0OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwyMS41NDc0OSwzLjYxNjYyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNy44MzgyMSwxMC4yMTE3NiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjAzMTE1MiwtNTQuNTA4Njk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01MS4wMzExNTInIHk9Jy01NC41MDg2OTcnPs6jPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00NS4zNDQxMTcnIHk9Jy01My40NTE1NDknPmY8dHNwYW4geD0nLTQwLjg1MDUxOCcgeT0nLTUxLjk4NDgzNic+L8+IPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwzNS43MDQwMywyLjQ3OTE3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuMDMxMTUyLC01NC41MDg2OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjAzMTE1MicgeT0nLTU0LjUwODY5Nyc+7oGhPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMTMyLjEwNDEzLDIuNDc5MTcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS4wMzExNTIsLTU0LjUwODY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTEuMDMxMTUyJyB5PSctNTQuNTA4Njk3Jz7ugaE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram,node distance=3cm]
      \node  (1) {${{T(\Delta )}_{/{\psi }}}$};
      \node  [right = of 1] (2) {${{T(\Gamma )}_{/{T(f)(\psi )}}}$};
      \node  [right = of 2] (3) {${{T(\Gamma )}_{/{\varphi }}}$};
      \draw  [->,morphism,offset=1.5] (1) to node[swap] (r1) {${{T(f)}_{/{\psi }}}$} (2);
      \draw  [->,morphism,offset=1.5] (2) to node[swap] (r2) {$\varphi  \wedge  \mathord {\hspace {1pt}\text {--}\hspace {1pt}}$} (3);
      \draw  [->,morphism,offset=1.5] (3) to node[swap] (l2) {$\Sigma _{\varphi }$} (2);
      \draw  [->,morphism,offset=1.5] (2) to node[swap] (l1) {${{\Sigma _{f}}_{/{\psi }}}$} (1);
      \draw  [adjoint] (l1) to (r1);
      \draw  [adjoint] (l2) to (r2);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>where <fr:tex
display="inline"><![CDATA[\Sigma _{\varphi }]]></fr:tex> is the left adjoint in <fr:ref
addr="ct-000J"
href="ct-000J.xml"
taxon="Lemma" /> and <fr:tex
display="inline"><![CDATA[{{\Sigma _{f}}_{/{\psi }}}]]></fr:tex> is the functor given by the action on morphisms of the left adjoint <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  T(f)]]></fr:tex>.</fr:p>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[\Gamma |\chi  \vdash  \varphi ]]></fr:tex>.
    And assume the following pullback square.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="c544bcd7073229ee2ed975db85021a4f"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI3OC4xMzcxMjFwdCcgaGVpZ2h0PScxMTQuOTAyMzMxcHQnIHZpZXdCb3g9Jy03MiAtNzIgMTg1LjQyNDc0NyA3Ni42MDE1NTQnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBYUFBQW9BQUFBQUIvZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGNsMzhXTnRZWEFBQUFFOEFBQUFSQUFBQUZ3RTdnUzRaMng1WmdBQUFZQUFBQU9KQUFBRWlIWmxubXBvWldGa0FBQUZEQUFBQUM4QUFBQTJLQXpDT21ob1pXRUFBQVU4QUFBQUlBQUFBQ1FGN1FFcmFHMTBlQUFBQlZ3QUFBQWNBQUFBSEErREFURnNiMk5oQUFBRmVBQUFBQkFBQUFBUUF0UUVHRzFoZUhBQUFBV0lBQUFBR0FBQUFDQUFDZ0JTYm1GdFpRQUFCYUFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFHZEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtTW1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcnFNVjlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZUZVRGEwQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzhnRFFmQXdkUWpvMUJqeUdFSVlNaG0va0U4OVgvLzRIaUtQei9sLyt2K3ovNy84dy90bjhNd2JxUkFBQ1BLUk9nZU5wdGswK1AyMFFZeHYyK1kzdHN4M0hpeFBia3I1T05OM1kyYlp4dEhNWkpHemJkbGwxdEZtZ2l0UWdRb3FCcUVSVXRTRDF3Z0F0Q1FnZzRWdUxBQllrREI2RGFFMGhJdlhhRk9QSU4rQVJjZ0dNSjQvVEFnV3BHbzVsNTUvRDgzdWNaQ2FSWEpaRE9wTHVTSmttcEJaMXd6RWZlR2JRR0xURzVsNjB0U1JKdnF1czEvb1kvU3pOeElOVHhXc0Nwb3c2QlJtRVVjamJpYVptblBEd0hJVld6RVVaejJBTzJ4Wm5ZejhrNHBBRzFBSDc2VEM1Nit5R3h0Tk1mVEFXZ1ZGdjJ5T2NFUUhkNnQ4NmJ4blpIWWFBK0s1czJUdXJnUXgySWlvc1h1M1hkd1BjZS8rNlpHaUlwV0JRSVFkQUxLcmdORExTOFNrbVY2dDIzUFRUS1AyWlY2eEhEbkRQb1RwdElzQ0QwcCt1L2NZaS9TQWVaZnA3NjRLb0ZGRHJUUFJBellaNnowUjFETk02RUM1U09LZ1FYaUVvN2dqQXRpNXRBRFhtUzhzUmpFSzRtYjA1bjZDaUJqVkRySnpsWm9WUXA1VXJ0dEJ1RHJMczdDSlg5QzNhdFI4eGUyV2hvTG9EeUpZSGlkZ1VzZGI3ajZvZ1AvM240dkF5WFJ2R1YvRWtuQ29Dc3pwc1UwQjVXYTdFTWNkY3kvZEduZzJiZnRkaWVIbjl6cllJNVc3WHhtcU1acEVHcERQS0c2eS9VQk5jcTQ5cXdNTUZtUVl3OEhZSUZnb0g2d0Z6QjVtVllMZkN5dlJvSjBwUm41a1ViOEtkQzN2R245WFRoZFFMbzlFdkFPamszUE9xV0J0V3JOMEFSU2kvM0xUUTFSZGZMbmVIT0dHU2hxSC9Panl6WlpFL25YZVdmYWM2MkVLS3Ezd2EzMmxNMUFtbmY2VnZhYUpRdk5meEVQcGk2Q0tnRjdlMFVnTWZiZVcxVUtzSFhVOTJCLzhGdmN1bXZCL2dGL2lvdE0zNlBaM1lLTWhIamxIdE1zR2NtQ3NJQ3FGRVdTVDZIckN5cTRoa05zMm9nV3BGbUYxa214Sms1VFBRaDRReisrSzUrNjJyem9qRFlzSHluMEFUd2RHdDIvSUVmb3FMS2lvNkdtU1A2Q3ljSWhVREl0bWs5OVVSZWhMZ3NDSk5vZ0hxdmhPOS9yeENhUTN6dytBM1MzUGZmU2JwOXpRaGFBSzErOTRSZE9GNXVrYS9NdkMwK2c1cU11c1dlL056Q09MaVpkQ3NHd09USVZBR0x1N1hLVUliZG9PWGNQamJmc3ZEYkVrRXI0MGNwV2JmeFF6aVRZbWt1U1N4ajV4c1lqM3FDeFhVOHh2K0QyeGdkUGVtSk1EeDlVaHFIa1FnNnFza3B2LzQ2b0o4ejI2NkZhTVRSUzlmRDNhS1QzcHpPeU1KcnZuTFBNMnNVOVlvaTNMaC9iMlVhUnlRZUg5NnRpazlaT0gzZzNGNWNQcXl6U3dRMU1DOStYSjBzN1UvZURScXZ5YkRjdS9OeWt5MEkzbytJYllCWi9KUHM2OGJoaldpTytOSEpsWUg4TDBMNG1IUUFBQUI0Mm1OZ1pHQmdBT0lQOVFmajQvbHR2akl3c3pDQXdHTWgrMVVJK3I4QzAwV21rMEF1QndNVFNCUUFObkFLdXdCNDJtTmdaR0JnWnZqUHdNREFOSTlCOG44cjAwVUdvQWdLWUFjQVlRQUVIQUoyQUFBQkhBQlpBbFlBR1FKT0FEY0NGQUEzQXBzQUhnS2VBRE1BQUFBQUFCUUFkQURnQVdBQjRBSkVlTnBqWUdSZ1lHQm5DR1JnWWdBQlJnWTBBQUFKSkFCZGVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTWNBQW9BQUFBQUE0QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW5LVU1tTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSjZaMng1WmdBQUFXd0FBQUJVQUFBQVZBc29hMzlvWldGa0FBQUJ3QUFBQUM4QUFBQTJLRmZDbkdob1pXRUFBQUh3QUFBQUhnQUFBQ1FGeHY5K2FHMTBlQUFBQWhBQUFBQUlBQUFBQ0FYR0FEZHNiMk5oQUFBQ0dBQUFBQVlBQUFBR0FDb0FBRzFoZUhBQUFBSWdBQUFBRndBQUFDQUFCQUFXYm1GdFpRQUFBamdBQUFEVEFBQUJQcTgzZGVGd2IzTjBBQUFEREFBQUFCQUFBQUFnQUFNQUFYamFZMkJtZXN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1cEk2czlRZlRRWUdaaW5tNjBCaFJvVFMvLzhaR0FBZDd3N1hBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJxLy85RHlMdTN3UElNQUZOaEJxVUFBQUFCQURmLzVRSjBBbVlBRkFBQUFSTVdJd1lIQmlZbkN3RUdKeVluSmpjVE5qTTJBVzMvQ0FJQ0V3TU5CL0h4REFzVEFnRUkvd2NRREFKUC9iOFFFZ01CQ0E4Q0gvM2hHZ1FERWdRUUFqMFZBZ0FBQUhqYVkyQmtZR0FBNHVMMWo3Zkc4OXQ4WldCbVlRQ0J4MEwycXhEMC82Zk1Na3hwUUM0SEF4TklGQUE2MndxVUFIamFZMkJrWUdDVytxTUpKR1VZekJuTW1Fb1lnQ0lvZ0FrQU96b0NTUUFBQXh3QUFBS3FBRGNBQUFBQUFDb0FBSGphWTJCa1lHQmdZaEJsQU5FTVVCSUpBQUFDcWdBYkFIamFUWTZ4YXNNd0VJWS9VOGRRSjVDcEhUb1VUUm1GamZNQWhReVpzbVlzSkpFSURsZ09rbVB3VXZJQWZlaGVGQTA5d2ZIcHYrK0VnSklmTWg2VnNZejlVVG1GM0o0OFk4NWI0a0tPU2x6eXdZb1hzdnhWa2srK0V1Y3MrRTQ4NDUxTDRrTHllK0tTTmIrYnZydmVCdXZWcmpmV3UxTVhwcnJhV3gvYTNxbGFWODlnYTUzMWg4RWFkWnlVR2Rzd25qdlY2RW8zYk9qcHVISmp3T0xsWnp0SlRHVEhTV2FCaVpxS2Zjd0NyY3lkZURWYTB2L0dWZ3dYclVOOHpZaDFsSmtTR21VdlNEK0xyMmppcnFiNUF3bFJNUk1BZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS012Q2pXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZHF6NXp4dlBiZkdWZ1ptRUFnY2RDOXF1UWFlYUpURFpBaW9PQkNjUURBQk9PQ0tJQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV1VBQW9BQUFBQUJ0Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMHgyTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWdnRENaMng1WmdBQUFXd0FBQUxDQUFBRG5QS3JaMlJvWldGa0FBQUVNQUFBQUM4QUFBQTJLQUhDVDJob1pXRUFBQVJnQUFBQUlBQUFBQ1FGcWdHY2FHMTBlQUFBQklBQUFBQVVBQUFBRkF4VUFSRnNiMk5oQUFBRWxBQUFBQXdBQUFBTUFhNENvbTFoZUhBQUFBU2dBQUFBR0FBQUFDQUFDQUJZYm1GdFpRQUFCTGdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGaUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtS21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F6TS93SDhwa2gwa2hxL2dPRkFkbUFEVGdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLWmpCay8vOFA1S2VCNlArei84OEVxd0lDQUptTkNUNEFBSGphYmROTGI5TkFFQWR3ejZ3ZnNSTjc0OWU2VFZJM2laMTFxcVpKMjZST1cwTGFOQVdwN3hZSlNoR0NFeUJ4UXVLQ1FPSVRJSVFRQjY3YytBcmNLL1hNaHdHSlM4dWE4amhRNzIxbkQvT2IvMWdDYWVlaWcwL3hxN1F1U1VBb3FKb0ZXcDBuUStpeWdLa2FtNFlockpGSTVXblFIVUpmM0MreXdJS0lKenp0OHc1WVNLR2JNaldCVDZ0RnVWalNSd3ZOVllEWTV3VG9OS1UwcnBHcE50ME4wYVZIMUxmWVJqUXpBSWlZcUJkRFNoMG5OSEtsaDFrWlBweWZidHZyUFc5TWVCUldNVmFUdkk0ZzcvZ2Z2eDJUdWdiSEorV0VOK0ovSlpqa2MyL2xlZzRrOGFIVXVwakRCcHhLYldtY2FZUkUvU1VSSFh1cUZyQXVTd1ZnVFNEYmtLVDk3SVFRQ0pWNFFOWWdUUVJLMWJJUnNHQXhlNHExWi9yekY1MEhzdWpYWm1BNUZidm1EYUlLMDRMKzF1Z0V5WWphV3lmTkpaT1VITk9IOXgwQ250OHJqYXQrMFFhZWhCdVZnZ1l2ejBlZGV3VDkxbFROZGZPaG9TRGtLNVB6MWZ0ZEdZNFBIKzI3ZEpOQXpJb01pdmI1ank4MDM0aGthQzd4MGZwQkh4cFZhZ29iU0hzWDMvRVZua2s3bVV5MEhLS21Yc2JscTFtemFUY0loVmNja1Y1UFlESWVUN0laVUZuazFZYWx2anNFSGwyRzIwK1pCcVA5eXEyVm03MENvSWR1d1RSSVpYcmdvRzJvRU9UdGFOaGNCbUphakNHeTV1QndnaXB1VmM4WmdlN1l5anNaYWF3WEFTeHRzOVVBL0h4K1Z1dUMwdW1aN1lGNnJWeXIyWFZjdSs0Z0J2TUJhOHVkbVVLK0dtK01GL3dGeEhHVDViZGY4ekxOZzJzeTNEU3BJUnMwcDhtazhOdDVRemp2Wk00c2cwWG0vMTAzb2MzTVlqUEY4U2p4V0hDNWs5bkZIenp2cDRuSWw0SUZkWDRGK3ZIMDNlVG9OaGNqRnlzWVZDMXY5aURod1VTMVIrbThqRVFCNnZGWmcyaUdyZ0lVRGEreWtvd1JGQUt3dlJ4Uk9lQlg4WjlZdTQybGxvQmpiTVU1QzJDVjF6elJncUt6RlVNM3k2NzRrZVM5bUJxSWh0SXVWOXB5TjdVY1MyMG15cHRWWitLL1FValNUd3l3ZFJJQUFIamFZMkJrWUdBQTRqQ3VleWZqK1cyK01qQ3pNSURBWXlIN1ZRajZ2eTdUTWFhTFFDNEhBeE5JRkFBZGlRbzlBSGphWTJCa1lHQm0rTS9Bd01CMGpFSG4vd1dtYWdhZ0NBcGdCUUJtWUFSS0FzWUFBQUk2QUVzQ09nQXNBcXdBVFFKdUFFMEFBQUFBQUdZQTFBRklBYzU0Mm1OZ1pHQmdZR1VJWjJCaUFBRkdCalFBQUFtRUFHRjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFRQUFvQUFBQUFCSlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWdBQUFCZ2hnT1dOR050WVhBQUFBRThBQUFBTlFBQUFFUURxQ0thWjJ4NVpnQUFBWFFBQUFFM0FBQUJVQWxXVTRkb1pXRmtBQUFDckFBQUFDMEFBQUEyS0dEQ1VXaG9aV0VBQUFMY0FBQUFIUUFBQUNRR1NRSmJhRzEwZUFBQUF2d0FBQUFVQUFBQUZBdERBTzVzYjJOaEFBQURFQUFBQUF3QUFBQU1BTElBL20xaGVIQUFBQU1jQUFBQUdBQUFBQ0FBQ0FBZmJtRnRaUUFBQXpRQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRUJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbThtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqRUR2QU9DbkZaZWxBU1EwbE5tYUcvMEErTXdNalNKZ1JvZncvVUJnQTN4TU5TWGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtOSmtuSzdIOS93OWthVUJZLzIvK0tiajdENndXREFEa3pBdGhBQUFBZU5vdDBMdE93Z0FZQmVELy9JV0NEUmZiUU50Z2tVdGpDekZDUUdtREJnZWp4aGlad01SRkd5NWlqRS9nQXhpZmc4bkVKMkEzVGo2QWs0T0xrNE9Ua3kwMjZIbUE3NXdjQW8zbmhMNUFwQkZGTTJYTHJzRzFISGNYelRSUzBFU2xBQlU5ZGRTb0dvQmhOU1lxRWhkSDRIMHZMWHhMUSsvc3NiTTNQUjFkSnBZSFAvZTNRVENXSXhRRzFBN2Q2cDhMVll5bFVHNkZxcjFsMVdHNVRsUFZWb0hLUXN3bXo0KzVkNklJUUhiUlEvL2kwTCtiZm5XVkNDOTZRck5NeEgyZVVUNDBOYk9HbUdtSm1peXFPOGphWnF5MTJYUnMyYkhXMFdJM240c2YzRnliTW9UQ1lhbjMwTlhiT2VaY1crZlp4OVVBVUhUL2ZVVXRDa0l4WTdCdVpBdmhacWI2UEJEVytJMGtTaEl0UWJWTG9vdndpaGhLZUlZSDNkL1dBUzhxNlJ2QkoxZjR4ZTlJekJJL1NmR0oveG9TdjRkT1B3MEFlTnBqWUdSZ1lBQmlscm9wemZIOE5sOFptRmtZUU9DeGtQMHFCUDJmZ1ZtVkdjVGxZR0FDVVFEMjl3Z3lBQUFBZU5wallHUmdZR2I0endBa1F4bVVnS1FxQTFBRUJiQUNBQzFEQWF3QUFBQUNnQUFBQVkwQVpBR05BRGtDVkFBaUExVUFMd0FBQUFBQUxBQldBSVlBcUhqYVkyQmtZR0JnWlpCallHSUFBVVlHTkFBQUEvTUFLSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5MTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE2LjAwMzkzNSwtNjEuODAzNTMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTEuOTAwNTEsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE2LjAwMzkzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE2LjAwMzkzNScgeT0nLTYxLjgwMzUzJz7OkzwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctOS43NzcyNjYnIHk9Jy02NS40MTg4OTQnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNi45ODIxOScgeT0nLTYxLjgwMzUzJz4uPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00LjIxNDc4MicgeT0nLTYxLjgwMzUzJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0uMzQwNDA4JyB5PSctNjEuODAzNTMnPlQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNi44NjUyMzUnIHk9Jy02MS44MDM1Myc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScxMC43Mzk2MDknIHk9Jy02MS44MDM1Myc+azwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxNi4yMzk4MjgnIHk9Jy02MS44MDM1Myc+KSg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMjMuOTg4NTc2JyB5PSctNjEuODAzNTMnPs+VPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzMwLjUwNTgwOCcgeT0nLTYxLjgwMzUzJz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzM2LjU5NDA0OCcgeT0nLTYxLjgwMzUzJz7iiKc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNDUuNDQ5Njk2JyB5PSctNjEuODAzNTMnPlQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNTIuNjU1MzM5JyB5PSctNjEuODAzNTMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNTYuNTI5NzEzJyB5PSctNjEuODAzNTMnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNjIuMjY5NzgyJyB5PSctNjEuODAzNTMnPikoPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzcwLjAxODUzJyB5PSctNjEuODAzNTMnPs+IPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc2Ljg2NTU1MycgeT0nLTY1LjQxODg5NCc+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jzc5LjY2MDYyOScgeT0nLTYxLjgwMzUzJz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNy43ODQ3MywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE2LjAwMzkzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE2LjAwMzkzNScgeT0nLTYxLjgwMzUzJz7OkzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS43NzcyNjYnIHk9Jy02MS44MDM1Myc+Ls+VPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTguOTA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTcuNjg0MDUsLTMwLjUzNjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTYuMDAzOTM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTYuMDAzOTM1JyB5PSctNjEuODAzNTMnPms8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTAyLjAxMzU1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNi4wMDM5MzUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xNi4wMDM5MzUnIHk9Jy02MS44MDM1Myc+4oiGPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy03LjcwMTcwOScgeT0nLTY1LjQxODg5NCc+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00LjkwNjYzNCcgeT0nLTYxLjgwMzUzJz4uz4g8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNC43MDc3OTgnIHk9Jy02NS40MTg4OTQnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDQuODE5MSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE2LjAwMzkzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE2LjAwMzkzNScgeT0nLTYxLjgwMzUzJz7iiIY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTcuNzAxNzA5JyB5PSctNjEuODAzNTMnPi7PiDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuNDU2MDUgMEg5Ni45NTgwMScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5Ny4yMDgwMSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDc0LjYxNjE3LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNi4wMDM5MzUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xNi4wMDM5MzUnIHk9Jy02MS44MDM1Myc+aDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTEzLjgxMTAyLTguMzU0MTZWLTQ4LjA1MTMzJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMTEzLjgxMTAyLC00OC4zMDEzMyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTE3LjA3NDksLTMwLjIwMjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTYuMDAzOTM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTYuMDAzOTM1JyB5PSctNjEuODAzNTMnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEyLjM0MDI3LTU2LjkwNTVIOTkuNzYzNTcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTAwLjAxMzU3LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1NC4yMjU3LC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTYuMDAzOTM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTYuMDAzOTM1JyB5PSctNjEuODAzNTMnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      width = 4cm,
      nw = \Gamma '.(T(k)(\varphi ) \wedge  T(h)(\psi ')),
      nw/style = {pullback},
      ne = \Delta '.\psi ',
      sw = \Gamma .\varphi ,
      se = \Delta .\psi ,
      north = h,
      south = g,
      west = k,
      east = f,
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>We wish to show that <fr:tex
display="inline"><![CDATA[T^{\flat }(f)\exists ^{\flat }_{g}(\chi ) \cong  \exists ^{\flat }_{h}T^{\flat }(k)(\chi )]]></fr:tex>.
    The left-hand side computes to <fr:tex
display="inline"><![CDATA[\psi ' \wedge  T(f){{\Sigma _{g}}_{/{\psi }}}(\chi )]]></fr:tex>, while the right-hand side computes to <fr:tex
display="inline"><![CDATA[{{\Sigma _{h}}_{/{g}}}(T(k)(\varphi ) \wedge  T(h)(\psi ') \wedge  T(k)(\chi ))]]></fr:tex>.
    This is isomorphic to <fr:tex
display="inline"><![CDATA[\psi ' \wedge  {{\Sigma _{h}}_{/{\psi '}}}(T(k)(\varphi ) \wedge  T(k)(\chi ))]]></fr:tex> by Frobenius reciprocity.
    <fr:tex
display="inline"><![CDATA[T(k)]]></fr:tex>, as a right adjoint, commutes with pullbacks.
    Thus, the right-hand side is isomorphic to <fr:tex
display="inline"><![CDATA[\psi ' \wedge  {{\Sigma _{h}}_{/{\psi '}}}T(k)(\varphi  \wedge  \chi )]]></fr:tex>.
    Further, since <fr:tex
display="inline"><![CDATA[\chi  \vdash  \psi ]]></fr:tex>, this is isomorphic to <fr:tex
display="inline"><![CDATA[\psi ' \wedge  {{\Sigma _{h}}_{/{\psi '}}}T(k)(\chi )]]></fr:tex>.
    Then, <fr:tex
display="inline"><![CDATA[\exists ^{\flat }_{f}]]></fr:tex> inherits the <fr:link
type="local"
href="log-000E.xml"
addr="log-000E"
title="Beck-Chevalley condition">Beck-Chevalley</fr:link> condition from <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex>.</fr:p>
  <fr:p>Since <fr:tex
display="inline"><![CDATA[T^{\flat }]]></fr:tex> has all the structures listed in <fr:ref
addr="log-000H"
href="log-000H.xml"
taxon="Lemma" />, it admits a naming functor.
    Let us define <fr:tex
display="inline"><![CDATA[{\mathopen {}\{\Gamma .\varphi \colon \mathord {\hspace {1pt}\text {--}\hspace {1pt}}\}\mathclose {}}\colon T^{\flat }(\Gamma .\varphi )\to {{\mathsf {Elts}(T)}_{/{\Gamma .\varphi }}}]]></fr:tex> by</fr:p>
  <fr:tex
display="block"><![CDATA[     {\mathopen {}\{\Gamma .\varphi \colon \chi  \vdash  \varphi \}\mathclose {}} := (\mathsf {id}_{\Gamma }, \chi  \vdash  \varphi )   ]]></fr:tex>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[\gamma \colon \Delta .\chi \to \Gamma .\varphi ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\psi  \in  T(\Gamma )]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\psi  \vdash  \varphi ]]></fr:tex>.
    Then <fr:tex
display="inline"><![CDATA[{\mathopen {}[\gamma ]\mathclose {}}_{\Gamma .\varphi } \leq  \psi ]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[\exists _{\gamma }(\chi ) \leq  \psi ]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[\chi  \leq  T^{\flat }(\gamma )(\psi )]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[\chi  \leq  T(\gamma )(\psi )]]></fr:tex>.
    But there is a morphism <fr:tex
display="inline"><![CDATA[\gamma  \to  {\mathopen {}\{\Gamma .\varphi \colon \psi  \vdash  \varphi \}\mathclose {}}]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[\chi  \leq  T(\gamma )(\psi )]]></fr:tex>.
    Thus,</fr:p>
  <fr:tex
display="block"><![CDATA[     {\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{\Gamma .\varphi } \dashv  {\mathopen {}\{\Gamma .\varphi \colon \mathord {\hspace {1pt}\text {--}\hspace {1pt}}\}\mathclose {}}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1369</fr:anchor><fr:addr
type="user">ct-000J</fr:addr><fr:route>ct-000J.xml</fr:route><fr:title
text="Slice comparison functor of a locally cartesian category admits a right adjoint"><fr:link
type="local"
href="ct-000I.xml"
addr="ct-000I"
title="Slice comparison functor">Slice comparison functor</fr:link> of a <fr:link
type="local"
href="ct-000G.xml"
addr="ct-000G"
title="Locally cartesian category">locally cartesian category</fr:link> admits a right adjoint</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is locally cartesian iff for all morphisms <fr:tex
display="inline"><![CDATA[f]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the functor <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> constructed in <fr:ref
addr="ct-000I"
href="ct-000I.xml"
taxon="Lemma" /> admits a right adjoint <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>. Moreover, <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> is (isomorphic to) the pullback functor.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>614</fr:anchor><fr:addr
type="machine">#281</fr:addr><fr:route>unstable-281.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By <fr:ref
addr="ct-000H"
href="ct-000H.xml"
taxon="Lemma" />, locally cartesian categories are precisely those categories with pullbacks.</fr:p>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>615</fr:anchor><fr:addr
type="machine">#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex> for any <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. We show that the following diagram</fr:p>
    
      
      <fr:figure><fr:resource
hash="3bdf29e3ca5a6afa1fb82198dbd9d32b"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNC43NjA3MDdwdCcgaGVpZ2h0PScxMTcuODQ5NjI0cHQnIHZpZXdCb3g9Jy03MiAtNzIgNzYuNTA3MTM4IDc4LjU2NjQxNic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9VQUFvQUFBQUFBL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFYR050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFEWUFBQUEyTlZxTFR0b1pXRmtBQUFDUEFBQUFDOEFBQUEyS0kvQlZtaG9aV0VBQUFKc0FBQUFIZ0FBQUNRRjhRS2FhRzEwZUFBQUFvd0FBQUFJQUFBQUNBWWhBR1ZzYjJOaEFBQUNsQUFBQUFZQUFBQUdBR3dBQUcxaGVIQUFBQUtjQUFBQUZnQUFBQ0FBQlFCRmJtRnRaUUFBQXJRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGhBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTZRek0vd0g4cGtoMGtocS9nT0ZBYlFlRE04QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOUR5UCt6d0h3R0FGVzFCc01BQUFBQUFnQmwveXdDaWdIRkFDNEFRd0FBQVFNT0FTTUdMd0VtSno0Qk1oWVZGQVlIRmg4QkZqNENQd0VPQVFjdUFTYzJOelkzTmpjeUZoYzJOeDRCRlFjM05pOEJKaWNPQVFjT0FSVWVBVGMrQVRjK0FRS0ZiQlNQYXk4MUN6TUVBU1V5RmdvUUFpSXRGejlIR0FZWUVrd3lTMllDQTBVUkVsQmhJa0FaRVNJVEU1WXRBUlVFRnp3cFNCWWRIQUk1SUNoRkhRNEpBWFgrVEV0SUFna0REQzhkSlJvUENCd1BCUUlCQVFvd01CeGhFQ1VDQVZ4U1kwd1REMElER3lJbkFRRVZEdnU0Q2lNR0lnUUJNQ012ZFNFN0xBRUJKeDBQRHdCNDJtTmdaR0JnQU9KNVIvTkw0L2x0dmpJd3N6Q0F3R01oK3kwSStyOE9jd2pqVVNDWGc0RUpKQW9BSlprS0VnQjQybU5nWkdCZ1p2alBBQ1JER0ZJWm5KbTZHSUFpS0lBSkFFQVdBcElBQUFOVUFBQUN6UUJsQUFBQUFBQnNBQUI0Mm1OZ1pHQmdZR0p3QVdJUVlHUkFBd0FIV0FCTEFBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVHdBQW9BQUFBQUJid0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGMzhtTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SEZmMTJaMng1WmdBQUFYQUFBQUllQUFBQ2hCTEZ2RVpvWldGa0FBQURrQUFBQUM4QUFBQTJLQUhDWTJob1pXRUFBQVBBQUFBQUlBQUFBQ1FGbVFHYmFHMTBlQUFBQStBQUFBQVFBQUFBRUFsaUFLZHNiMk5oQUFBRDhBQUFBQW9BQUFBS0FhZ0ExRzFoZUhBQUFBUDhBQUFBR0FBQUFDQUFCd0JGYm1GdFpRQUFCQlFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFNUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtaW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZkI1RGVZQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlxWXpiLzMvSDhoUEE5SC9aLy94QTZzQ0FnQ2lKd21KQUFCNDJrWFJQVy9UUUJ3R2NEOTM3amx2OXRteGZXNlQxSGx4YklmU3htbmNPaWl0OHRKV1FtMFJwVUtpS2tJZ2hpNmRrQmhBZkFnRzFJR1ZsVy9BM2gzeEhSaVJtQmhZVXM3dHdKMTB3ejAzL0gvM0tGQ09ieEp5U1g0b00wVUI1V0NhQWEwVHhST2t3aE5NRTAxTU1LVUJpekl2bldBazc0ZkNNeEJFY1pTTm9nUUc0VWd6d1dKOEdadXFXU3ZPTjN0am9PdEdGTHpKT2UrMjZXcWZQL0tKelUrNWE0aTk0TjR1RUFpWm16N24xYXBmS3RSZTVUR3VGdGRIMW16TDJhZFI0TGRJbDhYbElvRjY3SDcrYzBZN0dzN082M0VVZHY5SFdJazJQcXFkQWhTNWlMSitzMEZDWEN0OVpUL1hTQW03bGNpSkhhWjVJaFdaQkV3bHNvODRHK1hiaHlkVjhnR2RJb3NsaW1uNUZ3aHZtRDhsN1RmRnQrK1RsNnFjMXhJd3FnMnI3ZXdHRGFGNW84UDVPYUZ6YmgyZTk3WjFXcXZxTGo0bEZJNjdWZHR2dWFhRktQYjNHaFVOSHhiejVEa2w3dnBxMjdiTGZtbUpvTnhZR2JSZXBDck9ubHc4dHZrQlJWZVlBcWExK1B1Tmw4TkFSVzg3bXM5T1JnaGJYTCsxRFc1KzRUZStLenU1YldUQVk1N3NabmhuNEhja0tiazdNK0ZKbUNGSDZNczJaWXNTNldWNWJ6R0x4WlFrWUYvVEVOaFpiYVluRDZ0cVFTYzljL1B5MlFYSWd5WU5pSHIxdWpKc1cxM0FGYVZnckorK295U01kaXJ0QWVpa2NiL3NMNGZPOG5MeXN6NjExK29sUXVxK0J0VGpTcVRpYUR6WXF5SnN6cDRDekdDdXFkdEVjMHJZWE92WVJnSFFuVVlaYXJna1V4VkUwdjRCLzFCVW5BQUFlTnBqWUdSZ1lBQmkza05PdmZIOE5sOFptRmtZUU9DeGtQMFdCUDFmbCtrWTAwVWdsNE9CQ1NRS0FBMnJDZWdBZU5wallHUmdZR2I0ejhEQXdIU01RZWYvQmFZc0JxQUlDbUFCQUdVY0JEZ0N4Z0FBQWpvQVN3STZBQ3dDS0FBd0FBQUFBQUJtQU5RQlFnQUFlTnBqWUdSZ1lHQmhjR0ZnWWdBQlJnWTBBQUFIamdCTmVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS012Q29XaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZHF6NDlqT2UzK2NyQXpNSUFBbytGN0xjZzA4d1RtV3lBRkFjREU0Z0hBRGwyQ1kwQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzBBQUFBMktBN0NabWhvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRoTXNDdlh4L0RaZkdaaFpHRURnc1pEOUZnVDluNUhwTWpPSXk4SEFCS0lBK3NRSXhnQUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWS9DUVdob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMm9OM044YnoyM3hsWUdaaEFJSEhRdlpia0dtV1VNWTdRSXFEZ1FuRUF3QXFod21GQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLRUhEUDJob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0cmJYcDNqaitXMitNakN6TUlEQVl5SDdMUWo2LzE5bU5xYTdRQzRIQXhOSUZBQXZnQXF2QUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU1LjEwNTAxMycgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTcuOTEwNDI4JyB5PSctNjQuNjg1NTE1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUzLjc0NTQ1OScgeT0nLTYxLjY3ODk5Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTAuNjMyMTE2JyB5PSctNjEuNjc4OTk3Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ni40OTUxNjUnIHk9Jy02MS42Nzg5OTcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTEuNDU5MzIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU0LjUyMDQwNCcgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjg2MjEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuNjc4OTk3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINDYuNDAzNzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNjUzNzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4zMjU4Miw0Ljc4NDAxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+zrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU4LjgxMjk5JyB5PSctNjAuNjgyNzMzJz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        
    \SpliceDiagramSquare {
      sw = A,
      se = B,
      nw = A',
      ne = B',
      south = f,
      east = g,
      west = f^{*}(g),
      west/node/style = {right},
      north = \varepsilon _{g},
    }
  
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>is a pullback, where <fr:tex
display="inline"><![CDATA[\varepsilon _{g}]]></fr:tex> is the counit of the adjunction. Note that since <fr:tex
display="inline"><![CDATA[f \circ  f^{*}(g) = \Sigma _{f}(f^{*}(g))]]></fr:tex> by construction, the component <fr:tex
display="inline"><![CDATA[\varepsilon _{g}]]></fr:tex> makes the diagram commute.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[h'\colon C\to A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h\colon C\to B']]></fr:tex> be morphisms such that <fr:tex
display="inline"><![CDATA[fh' = gh]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="2eb932eee263ecd4d313f468c72b28ee"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3Ni40MjcyMjhwdCcgaGVpZ2h0PScxNzQuNDQ0ODM3cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE3LjYxODE1MiAxMTYuMjk2NTU4Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLSS9CT0dob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0o1Ui9NM3h2UGJmR1ZnWm1FQWdjZEM5a3NSOUg4ZDVoREdvMEF1QndNVFNCUUFMUHNLTUFCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0E3Q1NHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhNc0NydmorVzIrTWpDek1JREFZeUg3cFFqNlB5UFRaV1lRbDRPQkNVUUJBQUkxQ09RQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSc0FBb0FBQUFBQlF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUZFQUFBQmdxR3ppWldOdFlYQUFBQUZJQUFBQU5BQUFBRVFpTEFDNloyeDVaZ0FBQVh3QUFBR05BQUFCek1VV0kxZG9aV0ZrQUFBRERBQUFBQzhBQUFBMktaRENQV2hvWldFQUFBTThBQUFBSHdBQUFDUUY3Z0RiYUcxMGVBQUFBMXdBQUFBUUFBQUFFQXUwQVd4c2IyTmhBQUFEYkFBQUFBb0FBQUFLQVZZQXhHMWhlSEFBQUFONEFBQUFGd0FBQUNBQUJnQktibUZ0WlFBQUE1QUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUVZQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc3M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lBR0lCWmdZSENBY2hsU2lzdlNHZGdVRkI0WU1HdjlzV1JnWU5aaVBnNFVabVNBZy8vL0dSZ0FXVUVRVHdBQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUFMbEZCU1V4QjhZL1ArUFlOMS9lUGUxL0dXd1dqQUFBUHpGREFGNDJqV1F3VzdUUUJDRzk1KzFkK3ZFanAxNGJjZHRhamRyWXplcVNHaEliSVFxNThxQkk0aExSWVNxNWs3VkV4eTRVNGxIS0JJM2VBVmVvOGMrQzdCRmNKblJQL09QOVAzRHdENzkxdlNZN3RnTHhwQWpReVI4Q1BsUTJtcUJxbDQxR3pSckh3TVVjNnlhZHBuemFrSFZ1a1BTeE1sZjh3WWRubVpRUW1wemdrdnVPUmFFTFRtWGJrSjh6NUt3K3oyZXpzSzVtZ2JCTkJyUGp2ZkpsbjJiU2lGS2doMEkydisvVmZOd2hoOVplM3lpUDF5OXZFajJDQmdGbDgrdWI4ckZreFBmNHozUm84TFhKQnpIbXVURm1UNG9BNktnUEN6Tzg0bmxDSWUwWDVCeE1ST0pmV0VGWGVDZXJZeG9tMldzREhLY3hNa0FoalUzOUNiVkJsTFV1aks5cXF1Nnd6SkhYYTFOMkRpUitQelZUZFZRZkgvek9pU28xUG5tQ2RMRFVMZzNqNFFYamMxY0VhS3hkK3VLY0tpcGo0T3RvL1NBdXNPcEhJOFV4THZkODR4amxKenVYa1ZRT3ZpM2NMYTcwNTQzQXVWdkh6aTNyTVpIT21PQkVWd1VocU1OTzdSTDgyT0o5M2ZDalVOdTNmSTBTeXZBd3Yydjg2R1VYb0NmZ3lNY1RWeVgvUUdZQWpjc0FBQUFlTnBqWUdSZ1lBRGlad3J6bHNiejIzeGxZR1poQUlISFF2WkxFZlIvSlpaUXBpdEFMZ2NERTBnVUFDTXdDZjRBZU5wallHUmdZTmI2WThuQXdCTEtFTS9nd1pUTUFCUkJBU3dBU0hZQ3pnQUVWUUFBQXFvQWZ3THlBSTRCd3dCZkFBQUFBQUJ3QU1RQTVnQUFlTnBqWUdSZ1lHQmg4R1FBMFF4UUVna0FBQWYwQUZFQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS012Q2cyaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZHF6N0x4dlBiZkdWZ1ptRUFnY2RDOWt1UmFlYUpURFpBaW9PQkNjUURBQllFQ0t3QUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV3NBQW9BQUFBQUJxZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGNEEyTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SEZmMTRaMng1WmdBQUFYQUFBQUxXQUFBRGJIeEhsQjlvWldGa0FBQUVTQUFBQUM4QUFBQTJLQUhDUldob1pXRUFBQVI0QUFBQUlBQUFBQ1FGcWdHY2FHMTBlQUFBQkpnQUFBQVVBQUFBRkF3T0FQUnNiMk5oQUFBRXJBQUFBQXdBQUFBTUFhNENpbTFoZUhBQUFBUzRBQUFBR0FBQUFDQUFDQUJOYm1GdFpRQUFCTkFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGb0FBQUFBd0FBQUFnQUFNQUFIamFZMkJteW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZmFtRGZjQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXltWXdiLzMvSDhoUEE5SC9aLy94QjZzQ0FnQ2lTUW1MQUFCNDJrV1NQVy9iVmhTRytSNVNwRVNLdlB3UUx4MUxwa1JSSkpYVUVTVlRwbEpibFN6TFNCRzd6VWNMMUhBUUpPaVFKVk9CRGkxYW9EK2hDSUlNV2JNVi9RZlpBMlFNOGg4eUZ1alVBbDNzWGxaRDd3SHVjTThkem5PZVY0SjBkcFhUTS9vZ0hVa1NaQVpWczZEMTAyeUJnZ2RjMVhnWEN5emxXRTNMb0ZoZ0p0NzNlR0FoVHJPMG5LVTVMR0lvU3E1bWVIMWdLL1oyWXpVWkhnQURQNVhCdW95eFFTVHZqTmdYSVhuc0FmTXRmaHhmbndNeEYzMDdaTXgxUTcyKy9hUnE0K1hsMjFQbmFOcGF5MmtjOW1pZ1prYURvSno1ci80Nmwvc2F6aS9hV1pvTS9tL2hXbnJ6VjZWZmh5UU9TYnRYTnluQlcya2tyU3NhUWFMK1J5SW1icWxhd0F0ZUNvQ2xnQndoSzJkVmhRZ0VsZmdnTDFGbUFrclZxaFh3WUsvNlN0RjNqZTkvekI4cllsNkh3M0k3VHRTYXh4MnVCYk03cXd1U1Y4eTVjekhjTitWdDEvVHhJcGZSOHFmYjY1NXZPMGl6OExqVDFQRFQ1U3AvS0pPL3V4TjVuaEhxTllMUnVUYnVQU29Vbk45L2V0ZGpKeklHM09hd25jdC8zakFqaVJVTTk5UFYwYjBaa2g0ekJSdWtMNi8rcHAvcG5YUldrWW1SUTlMVWpTNWZyWVl0aXlBVXZLS0V2YW1BcWZEU3JOb0JVNFN2RWZabjNnSnB2SkU3SzdtRzFkM09WNS9lbmpaQkxmS2FwaTUzdW5PWEhGMUZZRGp4WW5nTHNtbHhUc1NIOC90YnJPYjFHblU5YUxoTzdibENiTkN3QVVzNzJVMUF2MTIraXdyVThxazVtcXVIN1NoeStyVDh6Q1VLeGdFZktmbjFwdEViSEs4bi9vUm9QZVRHNlM5cG14bndURTRuSnRNVm5kVTFSVzRLaCtPclAvQW4za3VIbGNPWmhVQU5SQWIzTnE3WVJwM0EzOXdsRjlBaWpXazJFcWtWYVJVeWc3TEtaNlptZkVrNTFOK0xCRGpjNlJiM1BuZVZ1a2xEZS9Mc202ZWdXMTA1SnVYbHQ4Mjl5QmtBUHRmakEvUEJEeklsNldFekdvc2RkejR4d3Eya3RiV1ZmMnd2dlJ0dG5hZ2Rha0E3YTZZS1RnL0d4eTZTN3RIWGdHcXB2bTE2cExWMFRHNzBQYXNPbUsyT0FTV3BpYTRDRWdyL0JZRzFjU0lBQUhqYVkyQmtZR0FBWWxPejl1WjRmcHV2RE13c0RDRHdXTWgrS1lMK3I4dDBqT2tpa012QndBUVNCUUFEdXdtaEFIamFZMkJrWUdCbStNL0F3TUIwakVIbi93V21hZ2FnQ0FwZ0JRQm1ZQVJLQXNZQUFBSTZBRXNDT2dBc0Fxd0FUUUlvQURBQUFBQUFBR1lBMUFGSUFiWjQybU5nWkdCZ1lHWHdZV0JpQUFGR0JqUUFBQWh4QUZaNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVMwQUFvQUFBQUFCVlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDAvbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNXWjJ4NVpnQUFBV1FBQUFIcUFBQUNIUFQvRXp0b1pXRmtBQUFEVUFBQUFDOEFBQUEyS0ViRERXaG9aV0VBQUFPQUFBQUFIZ0FBQUNRR01nSGRhRzEwZUFBQUE2QUFBQUFRQUFBQUVBdFpBSUpzYjJOaEFBQURzQUFBQUFvQUFBQUtBV0lBc0cxaGVIQUFBQU84QUFBQUdBQUFBQ0FBQ0FBNmJtRnRaUUFBQTlRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRXFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzWTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCbVp2Z1A1RE5EcEpIVS9BY0tBd0R6QUExS2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqTy8vOERTY2YvLy84ZkFQTVpBRks1QnA5NDJqWFF6Mm9UVVJRRzhQdmRrN25USkpPWjZLUXpsYVpUMHZ5WnRwS2tkSWFadG9zb2pZazF4YlEyVUlJRWdvSVdCQVUxUmhjdXNvZ0xRVmRDUVZ5NGNlY0R1SEhscWcvZzFvVzRFaDlCa25oSDZMbWJ3OGRkL0w3RE9Ddk1adnduLzhHcWJKT3hFRUc0YWRsbXh2SUNTMVNodWlYWEQyd3JDS3ZJcVNKajJZR3RRK1pSN05VUWV2UUY5MFFtSlZDenl2UFFsTUZvVGtFcWFmb1VWNmV6ZGlwcnBnZ3A1YVNyUVl1djFONy95UTM1Y1JweFl6S3lERnBTUVFRK1o2aUFadDl2akRPRk5MaWhpeWhPR0FMNU14d3hPY1F1enlZaytGZm1zSFcySmFXbW4zZUZ0T1Vjek90UUhkakNnRkJ6NHIvWGpIQkJ5YzJYaEVybk84a1AzcWUzaSs2U1lhRGJ1MHVqem40SC9IcjY1clBwdTZ5dTd6Z2ZUL3NEamtwOXZHd3FqOTcwaHB4djdIMXJ4Z0Q5a0c5ZjRKUlZ3Vy90dEU2TVJIdDdmMWV2eGFJR01OR2dKODNDTlE3ajB1UXpQVzhYRDJuNjY2SklNQWJtelg1VGtuK1B6Q0FkZVhuUksvQkxyalJIWU50QktNOGJDWmZoeUFJeXI4QU53dWhadG1XSHNnNGxycEpJeEJWd0hCODBYbTAwRjRXRjJNc2JxLzNBTDR0WVhGV28zRng3WEgveGdhamp0NTZPTzJ1cllrK0h4cyttZjNWcFZvM1M3UWRBZmF2YlgraVZoM2M0VnRZcnZZVWt3TFdIdTBVUGREcDZQV2o1UnhRckZQVURuUk5qL3dBZDBscitBQUI0Mm1OZ1pHQmdBR0lPVFliQWVINmJyd3pNTEF3ZzhGaklmaW1DL3YrU21adnBMcERMd2NBRUVnVUEyOG9JdkFCNDJtTmdaR0JnWnZqUEFDUTVHRlQrWDJEbVpnQ0tvQUFXQUVyM0F4VUFBQUoyQUFBREFBQWtBd2dBS3dMYkFETUFBQUFBQUZRQXNBRU9BQUI0Mm1OZ1pHQmdZR0d3WkdCbUFBRkdCalFBQUFhU0FFTjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTEzLjk5Mzk5NycgeT0nLTI3LjU2NDIyMSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTYuNzk5NDEyJyB5PSctMjYuOTU1Mzc1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTEyLjYzNDQ0MycgeT0nLTIzLjk0ODg1OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS41MjExJyB5PSctMjMuOTQ4ODU4Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01LjM4NDE0OScgeT0nLTIzLjk0ODg1OCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTMuNDA5Mzg4JyB5PSctMjcuNTY0MjIxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg0Ni40MDM3OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni42NTM3OCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0LjMyNTgyLDQuNzg0MDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTcuNzAxOTc0JyB5PSctMjIuOTUyNTk0Jz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ0LjE2OTU0LDM3LjczODMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDEuMDgxMTggMzMuODI4NTdDLTQ2LjQ3NDQ5LTEuMTM0MzUtMzUuODg3Ni0yOC4zODUzLTguNjk1MzYtNTAuMjI0NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjc3OTY1LC0wLjYyNjE2LDAuNjI2MTYsMC43Nzk2NSwtOC41MDA0NiwtNTAuMzgxMDQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00Ny43MDk2MywtMjEuNzY1ODUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xNi44MDE3MzgnIHk9Jy0yNi45NTUzNzUnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTMxLjc1MTUxIDQxLjM1NDMxQzIuMzI5ODYgNDYuMzc0MjggMjguNjcyNDkgMzUuOTMyODUgNDkuNzUwMjcgOS4zMTk0OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjYyMDgyLC0wLjc4Mzg3LDAuNzgzODcsMC42MjA4Miw0OS45MDU0Nyw5LjEyMzUyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNy4xNzg0LDM5Ljk2MjE5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+aDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2UtZGFzaGFycmF5PSczLjAsMi4wJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KPHBhdGggZD0nTS0zMy44MjgwOCAzMy44Mjg1N0wtOS4yNzcxNiA5LjI4MTA3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTQsLTAuNzA3MDUsMC43MDcwNSwwLjcwNzE0LC05LjEwMDM3LDkuMTA0MzEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTS0yOC42MzMzOSAxNi42MjgwN0gtMTQuMTE4MjlWMjkuMTE4MDZILTI4LjYzMzM5Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTI1LjYzMzM5LDE5LjYyODA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+aDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTYuODAxNzM4JyB5PSctMjYuOTU1Mzc1Jz7igKA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        
    \SpliceDiagramSquare {
      sw = A,
      se = B,
      nw = A',
      ne = B',
      south = f,
      east = g,
      west = f^{*}(g),
      west/node/style = {right},
      north = \varepsilon _{g},
    }
  
        \node  [above left = of nw] (c) {$C$};
        \draw  [->,morphism,bend right] (c) to node[swap] {$h'$} (sw);
        \draw  [->,morphism,bend left] (c) to node {$h$} (ne);
        \draw  [->,morphism,exists] (c) to node[desc] {$h^{\dag }$} (nw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Note that <fr:tex
display="inline"><![CDATA[h]]></fr:tex> is a morphism <fr:tex
display="inline"><![CDATA[h\colon \Sigma _{f}(h')\to g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. Thus, it corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[h^{\dag }\colon h'\to f^{*}(g)]]></fr:tex> under the adjunction.</fr:p><fr:p>The transpose of <fr:tex
display="inline"><![CDATA[h^{\dag }]]></fr:tex> can be computed as <fr:tex
display="inline"><![CDATA[\varepsilon _{g} \circ  \Sigma _{f}(h^{\dag })]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> is the identity on morphisms, we have
      <fr:tex
display="block"><![CDATA[         (h^{\dag })^{\dag } = \varepsilon _{g} \circ  \Sigma _{f}(h^{\dag }) = \varepsilon _{g} \circ  h^{\dag } = h       ]]></fr:tex>
      Thus, the top triangle also commutes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>616</fr:anchor><fr:addr
type="machine">#280</fr:addr><fr:route>unstable-280.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has pullbacks. Then we can take <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> to be the pullback functor. It remains to check that <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex>.</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
      
  <html:tr>
        
  <html:th>Unit</html:th>

        
  <html:th>Counit</html:th>

      </html:tr>

      
  <html:tr>
        
  <html:td>
          Let <fr:tex
display="inline"><![CDATA[h \in  {{\mathcal {C}}_{/{A}}}]]></fr:tex> be an object, we take <fr:tex
display="inline"><![CDATA[\eta _{h}\colon h\to f^{*}(\Sigma _{f}(h))]]></fr:tex> to be the unique morphism given by the following pullback:
          
    
      
      <fr:figure><fr:resource
hash="c09b8b07b92837716709f79f64e26dcc"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI0My4yNTI3NDdwdCcgaGVpZ2h0PScxODEuMzgwMTM0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTYyLjE2ODQ5OCAxMjAuOTIwMDknPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSb0FBb0FBQUFBQlF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWUYxYkdOdFlYQUFBQUU0QUFBQU1RQUFBRHdBZkFEQloyeDVaZ0FBQVd3QUFBR2lBQUFCM1A1M2IwVm9aV0ZrQUFBREVBQUFBQzhBQUFBMktJL0NQV2hvWldFQUFBTkFBQUFBSGdBQUFDUUdjUUpQYUcxMGVBQUFBMkFBQUFBTUFBQUFEQWxmQVBwc2IyTmhBQUFEYkFBQUFBZ0FBQUFJQUhJQTdtMWhlSEFBQUFOMEFBQUFGd0FBQUNBQUJRQlJibUZ0WlFBQUE0d0FBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUVYQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1sbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBxbU1XUXdNL3dIOHBraDBraHEvZ09GQWJtUERONEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtwakZrL1A4UDVJUHAvN1AvendLckFnSUFtUElKTndBQUFIamFIZEJOVHR0QUZBZHd2emYyakJPUHgxOHp0b2xJU3V6SVRsSklpaEljMGFaSnF5Q0VRSHd0RVJJSFFPSUFWUmZkVnFyYVhvRmJkRitwNmdGNkNBNkF1Z1hHMGJ6RnpMeTNlTCsvQWNibjV4MzhnLytNSThNQTRnRmxBaGd0eWdWTTRrUlNGcitDQmN5cUpWU3puQlo3MHlxWjFQZjFpUk1CZVZFVzFhd1lROGFvQjVNcWxvd3llTmgzRzBFci9MaVRuUklZcUNHUnloTlJ1MmNGNFdiZ1hMbVI5RzRFTlZQYnpTLzd4M29rSGhMZ0hkK0xXa21UcDNldXRJa0ozNTUrTGJMNW9EVkJ5RVpaUnNxZzIyU0FXS25sN2YzdFc2Q3ViTUJGZDJ2cUIyTVRldHYxQ0MyRmpaRDZ5NTlBTnh3Q2htWVpYNTcvNHlQK05jNXJvK1owUU9sbDYxSTAwVytOVGJSV2IwN1pDTXFwRnRiSWFaSHJNQVI0dUhiT0l2MnBwVHFkYXAxSXJHTDRkQkhmbkp5ZFlHVEpwc2V3V3k2RWFYUGVnRFlQK3F2eEJ5QStWNmgwWTM2OUpVVXpZOWFtbjV2bWR4UEJGcmtUSWxKaS9lQVM4UDdwZDN0RllGVU4zL0g5dEpSK1R2QmcyMnNnT25KWGhwcjRac0Nkc3ZPZXprZFpIdzkzTy9ucnIybWtvSmZnWGtncEJkU1JjSTNtWUxubUM0KzFPLzBBQUhqYVkyQmtZR0FBWWhlWGU0bngvRFpmR1poWkdFRGdzWkQ5QWdUOVg1YzVoT2t5a012QndBUVNCUUFMbFFsNkFIamFZMkJrWUdCbStNOEFKRU1ZcXY5L1ovck1BQlJCQWN3QWJvb0V4UUFBQTFRQUFBSzhBSHNEVHdCL0FBQUFBQUJ5QU81NDJtTmdaR0JnWUdZSVlBRFJERkFTQ1FBQUNJZ0FWd0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLRUhERjJob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0cmJYcDJMaitXMitNakN6TUlEQVl5SDdCUWo2LzE5bU5xYTdRQzRIQXhOSUZBQTVXQXJYQUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFQNEFBb0FBQUFBQkd3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY04zOG1OdFlYQUFBQUU4QUFBQU1nQUFBRHdITC8wTVoyeDVaZ0FBQVhBQUFBRXBBQUFCT05DV0tlRm9aV0ZrQUFBQ25BQUFBQzRBQUFBMktEWENQbWhvWldFQUFBTE1BQUFBSGdBQUFDUUdRd0tSYUcxMGVBQUFBdXdBQUFBUUFBQUFFQW1vQVFOc2IyTmhBQUFDL0FBQUFBb0FBQUFLQU13QVlHMWhlSEFBQUFNSUFBQUFGd0FBQUNBQUJnQWlibUZ0WlFBQUF5QUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQUQ3QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm15bUtjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBwcU1DOW1admdQNURNek1JS0VHUkVxL2dPRkFlMTNEYWdBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeW1veUwvNy9IOGpYQU5IL2IvNUpBS3NDQWdDWW13azVBQUI0MmlYT3ZVNENRUlFGNEh0bU5qUE95cytDdUJzMUVaYVZSUXRJRk5pTkZLS05XbEFTQzRPRmtsaWhDVWJ0VU9OUFkrSkQwUG9NbHNaSDhBMG9qSW0yYXVMcUVISlBjYXJ2WEFLZC9nRlhuR2lXQ0k2ZGtTSUpJWVd0YXhKK1VWL29OeENnRzVkeW95NVhPWFlPVFJtL3F5VW1DNHlWRWdFbk1FdFV1MWJ2NWVGN1Qxa01CMzAzMSsrYzNCU3VOVW5iMm0rTi9TbXRPcmJNQ0ptQUgxWWJXRU5ZUnRHdkJXSDdOaGlCUy9uZ2VBNDgyV3FEOXpZVkJLZXh0anRZMys4d2t4dXA1dWZnZVZnM2hXSkVJMytMaVAyd0o4b1JLYmo2Vloyd0l0MjhYd3NWL01CeEhhOE02ZXB4aWNmb0F5dWx4Y3F5WGJhODdPOTlMTVV3SGIwaGxtYm5XYys2NkVmUjBPQkFNeHFDWThaYU9Qc3l6QW5NNHlpdDhIN1pOS0pYb1NUUlA1TGNPMFFBQUFCNDJtTmdaR0JnQU9KNUxZdHV4L1BiZkdWZ1ptRUFnY2RDOWdzUTlIOUdwbC9NSUM0SEF4T0lBZ0F0OWduNUFBQjQybU5nWkdCZ1p2alBBQ1NkR2R3WlBKbCtNUUJGVUFBTEFFU0xBdHNBQUFMVEFBQUJ5UUIwQWNrQVNBTkRBRWNBQUFBQUFEQUFZQUNjQUFCNDJtTmdaR0JnWUdGUVpBRFJERkFTQ1FBQUJBd0FLUUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5vQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDMEFBQUEyS1kvQ0dXaG9aV0VBQUFKQUFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFtQUFBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNhQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUp3QUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9nQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFdBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaTJvUDNHT1A1YmI0eU1MTXdnTUJqSWZzRnlEUkxLT01kSU1YQndBVGlBUUFKaXdpdUFBQUFlTnBqWUdSZ1lOYjZZOG5Bd0JMSzBNZlF6NVRNQUJSQkFVd0FVb0FEUWdBRVZRQUFBdklBamdBQUFBQUFWQUFBZU5wallHUmdZR0JpTUdVQTBReFFFZ2tBQUFYS0FEc0FlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ2xKV0ZnWW1WcVF0Z2d6TEVRWGFJRktucXlPL3U0WHJvRGFmbi9iZ0RTbjdJZUU3R2E5elB5U2xFL1hIQkMyK0pwNklXaVVzK1dESWh5MmZpek5ra3ppWDVTbHp3emlYeFZQenZ4Q1dmUExaZGU3djMxcXQ5WjZ4MzV6YU02NFAxb2VtY1d1a3E2cDExMWg5N2E5UnBWR1pvd25CdFZhMHJYYk9sbytYR25SNkxSN0VYeDBSMm5DVUxqS3c1UkNmUVNPcWt0VUpUL2N0M2tydllPY1pQUmpvblNaVFFJRmRCOWxYYWlqcGVhdXBmNytrd1J3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRUUFBb0FBQUFBQkpRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVjQUFBQmdoY040Wm1OdFlYQUFBQUU4QUFBQU1nQUFBRHdITC8wTVoyeDVaZ0FBQVhBQUFBRkNBQUFCWUJvUGlGRm9aV0ZrQUFBQ3RBQUFBQzRBQUFBMktLekNQV2hvWldFQUFBTGtBQUFBSGdBQUFDUUcxQU05YUcxMGVBQUFBd1FBQUFBUUFBQUFFQXQ3QVY1c2IyTmhBQUFERkFBQUFBb0FBQUFLQU9ZQWFHMWhlSEFBQUFNZ0FBQUFGd0FBQUNBQUJnQXFibUZ0WlFBQUF6Z0FBQURLQUFBQk11c0lrZVp3YjNOMEFBQUVCQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lOR0JpU1FVbHlXRHBUVVlGN016UEFmeUdkbVlBUUpNeUpVL0FjS0F3QVhxZzRjQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeW1veUwvNy9IOGpYQU5IL2IvNUpBS3NDQWdDWW13azVBQUI0MmkyUFBVdkRVQlNHNzV1YjNIemFENjJKcmFRMEtTUkN0WUttYVVGaTZXaGRSS0hTUWdjcGlxUEZSUjBGOTg3K2d2Nklqb0tMZy9nTEJBYzNGM0VRTmZXYWVzNXkzdVY5emtOQWJxY0U5NVNRSWlGSVFXYVdtV3lPdVg0VnZ1ZUg5VzNVd3cxemtlRnUvMGFpcnFLdFhTaGdoWmJUTGtXaUdKWGFUcXZBSUx5R0g1UCs1WkoxZFN4cW9oYll2ZWhzUEI1R1hUdlFSSlh3QVJsdzFvaXpsbmxnOGgvTlcwZVFBT1k5MytPSFZZUmxZdlRmU2dYSlAvUnFPRG1YS1owQlFXYWRrQlJGdEFlZGF4Uysrcm91SVFGeXh0RjBTb2ZDaEt3UW9zSXhtMGdFTnFuRHZKcFhWMUZGTFFndHh5cHp1eXJLem9JcG0vaU1uM0JnTlBKYmxYeVVycmcvZ1pFVE1saU5IMldhVFFzUGJzVm9sT3pUWnZ6OHJZTmlOMzREZnkyajdIVzRFRE1VSFZsMG1hcGtaTHp2ZEZKelJ2eGl5QkpYL2dWck9FSFZBQUI0Mm1OZ1pHQmdBR0xPMVEvWHgvUGJmR1ZnWm1FQWdjZEM5Z3NROUg4RzVrSm1FSmVEZ1FsRUFRQVdoUWtWQUFCNDJtTmdaR0JnWnZqUEFDU3ZNaVF5SkRNWE1nQkZVQUFMQUUwdUF4a0FBQU5TQUFBQ0tnQ2FBaW9BWXdQVkFHRUFBQUFBQURZQWFBQ3dBQUI0Mm1OZ1pHQmdZR0hRWkFEUkRGQVNDUUFBQk5RQU1RQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVxZm01dURrNnZEMjZ3SjBxR3BwTFhvSXY1MGIwUHdCZzdmUGVmY0FCa3ZFb1pKbUFjZEpwVTNqenptaDBYa2lmaXJ5Qm0vckJtUnBETnhWdXdpcDB6NWp6eG1TUmw1SXY0amNzWWY3MzFUMys2ZDllcllHT3ZkcGZiYmsvVnQxVGkxMGZtd0hxeXovdHhabzhxbk1uM1Y5dGRhRlRyWEJYc2FhbTdjNmJCNEZFZHhUR0RIUlRMUGxsUFlXeXJKbkhRMmFQSnZlcERVaGNZNS9HS2tVZklVTmZSeTA0cGVwYXNvd3AybStBQlZNaTVEQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLTXZDZVdob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0xkcXo0Ynh2UGJmR1ZnWm1FQWdjZEM5Z3VRYWVhSlREWkFpb09CQ2NRREFCaDZDTFlBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFXWUFBb0FBQUFBQnFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0QzJOdFlYQUFBQUU4QUFBQU93QUFBRXdFUFFTTloyeDVaZ0FBQVhnQUFBSzdBQUFEVk9MVDN6aG9aV0ZrQUFBRU5BQUFBQzhBQUFBMktBSENNMmhvWldFQUFBUmtBQUFBSUFBQUFDUUZyZ0djYUcxMGVBQUFCSVFBQUFBVUFBQUFGQXd1QVBoc2IyTmhBQUFFbUFBQUFBd0FBQUFNQWE0Q2hHMWhlSEFBQUFTa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUJMd0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZqQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm15bWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1XOW5admdQNURNek1JS0VHUkVxL2dPRkFma09EZjhBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1Jnc2dEUVhBd2RRam9raGpTR0RlU3Z6OXYvL2dXSnc5di9aLzJmOThmdmpDOVlCQlFCNWJRN0hBSGphUlpJOWI5dFdGSWI1SGxLWEVyOHVKWktYaWlWVEh4UkoyVWtweVZMSTJGSWt4d29TMUc2Ymp3SU4yaVhJa0NWTGxoUVpBdlFuRkIweWRNMFdkT21mQ0pJbFFOSC8wTEZBcDNhMGUyVUZ5RDNBSGM2N25PYzhSNEZ5ZGpHaVovU25jcXdvVURtWTdrRHZwOWtTVXhFS3Bvc09sbGlwTVV1TGNMcEVLZnNISW5RUXAxbGFsT2tJRG5GTUM4RXl2RGx5TlhlbmRtc3lQQUlHUWFxQ2R6am5nNTY2bS9Pdkl2TDRBeDQ0NGlUZVd3Q3hrTGtiY2Q1b1JFWjE1L0VteHV2emQ2ZjE0NW0vVnRNNDZ0S0FaV2FOb0owRnYvNzdTTzNyZVBSOUswdVR3ZWNJVjlJdmZ0YjZWU2p5UWZuNjRqOTZSUitVc3cyTEhEWWluVzJSQWhZZUZHVXhEU1BvVEpZa25LMGdPMldSWnBLWWNVMHk1YmhlZWt1azhYWUJaU0YwM1BxbS9mRHd6c3dDK2VSWnRxRzJPNHNHMVEyRzBLekh5K0VOcUxZakJKRVlMdTQzZWNYcjFxcEdXR3ZVSzc5b3hBYzFGM0QwMjljUzBOdnpENzBwS3FPWm5TL1l2TlhyMWZ1MHV0a2dDc2VoeUxYUm5tVjJCeWZyU1RBaFdnK0ZlZnBUMnVJbVBGdlFiWnNibXNHcnVxWmFDaW5qaTcveEQvNVE1c3BhVVVvSElRdWxwdzFnR1dFRG5FUE9YMjcvUWtob2FTek5jbWxXR2cyWENJdU53NHhsWWtVanNOK21DVERmN1V6djNXMW9WWnVHN3VUWmQwOUJOenBxVE5ycko5WkJyejRBQW1IRVIvYURseW9sNmR6cWplV08yMWZOcUpuNHplYm9yOWJLMjI4WlJLMUlCMXFabFdvNFBScWZOSkIwanI4Rm1NTUMxL1pJOXcxTTl2dWVVd1ZzdjIxQ1N5b3kxVUJiaCtPTGhPN2d2WEp6NDNCN2k5SUpYVnB5d01sUjAyeWxGdGRubnpvajVOTGpraTZ4SW5tTXRIaE93WTdqUTN1aHFTVDI1dEtLb2UvNmxWclE5bUZjdFV6R3ZhaHZWblREWkJEY3lnNi9yRTUvNk42VmpvSHdmR1hGNU5ZRGZMU2J3MHNUd1U3MDQzMmZPM0RyKzcrUDg5QU4yc0J4N3BzZ2N0ZHQwYVhrY0Q2Z2pkaVdSUGdmRjZSb2dRQjQybU5nWkdCZ0FPTGM5c2Y1OGZ3Mlh4bVlXUmhBNExHUS9RSUUvVitWNlJqVFJTQ1hnNEVKSkFvQUp4NEtZQUI0Mm1OZ1pHQmdadmpQd01EQWRJekI0UDhGcG1vR29BZ0tZQVVBWnJ3RVRnTEdBQUFDT2dCTEFxd0FUUUlvQURBQ1dnQXdBQUFBQUFCbUFOb0JTQUdxZU5wallHUmdZR0JsOEdGZ1lnQUJSZ1kwQUFBSWNRQldlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjE1Mjc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0xNC43MjQ3NDcnIHk9Jy0yMi45NDA2OTEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzLjI2Mzg5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE3LjUzMDE2MScgeT0nLTIyLjMzMTg0NCc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xMy4zNjUxOTInIHk9Jy0xOS4zMjUzMjcnPijOozwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNC41NjQ4MTQnIHk9Jy0xOC4yNjgxOCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctLjA3MTIxMycgeT0nLTE5LjMyNTMyNyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczLjA0MjEzJyB5PSctMTkuMzI1MzI3Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzcuNzA2Mzg5JyB5PSctMTkuMzI1MzI3Jz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3OS45MTIwOCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTQuMTQwMTM3JyB5PSctMjIuOTQwNjkxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODEuMzE0ODcsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINzQuODU2NTQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzUuMTA2NTQsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzMC45NjUwMSw2Ljg3MjkxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+zrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTE4LjQzMjcyNCcgeT0nLTE3Ljk5MTQzMSc+zqM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTEzLjY1ODg3OScgeT0nLTE2LjI0Nzk2OSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctOS4xNjUyNzgnIHk9Jy0xNy45OTE0MzEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYuNDY3MDIzJyB5PSctMTcuOTkxNDMxJz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yLjM0NDY5NCcgeT0nLTE3Ljk5MTQzMSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNODUuMzU4MjYtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw4NS4zNTgyNiwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4LjYyMjE1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPs6jPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xNi41MDk3MScgeT0nLTE4LjI2ODE4Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xMi4wMTYxMDknIHk9Jy0xOS4zMjUzMjcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTguOTAyNzY2JyB5PSctMTkuMzI1MzI3Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00LjIzODUwOCcgeT0nLTE5LjMyNTMyNyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NC01Ni45MDU1SDc2LjI1OTMyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDc2LjUwOTMyLC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MC4xOTAzOCwtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00NS42ODQ0OCwzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTQuMTQwMTM3JyB5PSctMjIuOTQwNjkxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC42OTUzNi01MC4yMjQ1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzc5NjUsLTAuNjI2MTYsMC42MjYxNiwwLjc3OTY1LC04LjUwMDQ2LC01MC4zODEwNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ1LjAwNDczLC0yMC44MzEzOCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPmg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScxLjYnPgo8cGF0aCBkPSdNLTMwLjIzNjU3IDQyLjQwNTI2QzEyLjY1NzEyIDUyLjA3MjIgNDcuNDM2MzcgNDEuMjQxMDEgNzcuMjU1MTQgOC45Mjc1NScgZmlsbD0nbm9uZScvPgo8ZyBzdHJva2Utd2lkdGg9JzAuNic+CjxnIHN0cm9rZT0nI2ZmZic+CjxwYXRoIGQ9J00tMzAuMjM2NTcgNDIuNDA1MjZDMTIuNjU3MTIgNTIuMDcyMiA0Ny40MzYzNyA0MS4yNDEwMSA3Ny4yNTUxNCA4LjkyNzU1JyBmaWxsPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzMuMCwyLjAnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNLTMzLjgyODA4IDMzLjgyODU3TC05LjI3NzE2IDkuMjgxMDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNCwtMC43MDcwNSwwLjcwNzA1LDAuNzA3MTQsLTkuMTAwMzcsOS4xMDQzMSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNLTI4Ljc1NDgyIDE1LjI2Njk4SC0xMy45OTY4NVYyNS42NDE5NUgtMjguNzU0ODJaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjUuNzU0ODIsMTkuNjI4MDcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz7OtzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTguMDkxOTU4JyB5PSctMTguMjY4MTgnPmg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                width = 3cm,
                sw = A,
                nw/style = pullback,
                se = B,
                nw = A',
                ne = B',
                south = f,
                east = \Sigma _{f}(h),
                west = f^{*}(\Sigma _{f}(h)),
                west/node/style = {right},
                north = \varepsilon _{\Sigma _{f}(h)},
              }
              \node  [above left of = nw] (c) {$B'$};
              \draw  [->,morphism,bend right] (c) to node[swap] {$h$} (sw);
              \draw  [double,morphism,bend left] (c) to (ne);
              \draw  [->,morphism,exists] (c) to node[desc] {$\eta _{h}$} (nw);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          <fr:p>where <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> is the counit defined on the right. Then naturality is a consequence of uniqueness.</fr:p>
        </html:td>

        
  <html:td>Let <fr:tex
display="inline"><![CDATA[g \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex> be an object. We take <fr:tex
display="inline"><![CDATA[\varepsilon _{g}\colon \Sigma _{f}(f^{*}(g))\to g]]></fr:tex> to be the following morphism.
          
    
      
      <fr:figure><fr:resource
hash="713a053a883955433c0f73df139f72b9"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzOC44MDA0NDNwdCcgaGVpZ2h0PScxMTcuODQ5NjI0cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTIuNTMzNjI5IDc4LjU2NjQxNic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9VQUFvQUFBQUFBL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFYR050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFEWUFBQUEyTlZxTFR0b1pXRmtBQUFDUEFBQUFDOEFBQUEyS0kvQldHaG9aV0VBQUFKc0FBQUFIZ0FBQUNRRjhRS2FhRzEwZUFBQUFvd0FBQUFJQUFBQUNBWWhBR1ZzYjJOaEFBQUNsQUFBQUFZQUFBQUdBR3dBQUcxaGVIQUFBQUtjQUFBQUZnQUFBQ0FBQlFCRmJtRnRaUUFBQXJRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGhBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTZRek0vd0g4cGtoMGtocS9nT0ZBYlFlRE04QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOUR5UCt6d0h3R0FGVzFCc01BQUFBQUFnQmwveXdDaWdIRkFDNEFRd0FBQVFNT0FTTUdMd0VtSno0Qk1oWVZGQVlIRmg4QkZqNENQd0VPQVFjdUFTYzJOelkzTmpjeUZoYzJOeDRCRlFjM05pOEJKaWNPQVFjT0FSVWVBVGMrQVRjK0FRS0ZiQlNQYXk4MUN6TUVBU1V5RmdvUUFpSXRGejlIR0FZWUVrd3lTMllDQTBVUkVsQmhJa0FaRVNJVEU1WXRBUlVFRnp3cFNCWWRIQUk1SUNoRkhRNEpBWFgrVEV0SUFna0REQzhkSlJvUENCd1BCUUlCQVFvd01CeGhFQ1VDQVZ4U1kwd1REMElER3lJbkFRRVZEdnU0Q2lNR0lnUUJNQ012ZFNFN0xBRUJKeDBQRHdCNDJtTmdaR0JnQU9KNVIvTUw0L2x0dmpJd3N6Q0F3R01oKzYwSStyOE9jd2pqVVNDWGc0RUpKQW9BSlJzS0VBQjQybU5nWkdCZ1p2alBBQ1JER0ZJWm5KbTZHSUFpS0lBSkFFQVdBcElBQUFOVUFBQUN6UUJsQUFBQUFBQnNBQUI0Mm1OZ1pHQmdZR0p3QVdJUVlHUkFBd0FIV0FCTEFBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzBBQUFBMktBN0NhR2hvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRoTXNDdFh4L0RaZkdaaFpHRURnc1pEOVZnVDluNUhwTWpPSXk4SEFCS0lBK2tZSXhBQUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWS9DUTJob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMm9OMzE4YnoyM3hsWUdaaEFJSEhRdlpia1dtV1VNWTdRSXFEZ1FuRUF3QXFDUW1EQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUd0FBb0FBQUFBQmJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0YzOG1OdFlYQUFBQUU4QUFBQU1nQUFBRHdIRmYxMloyeDVaZ0FBQVhBQUFBSWVBQUFDaEJMRnZFWm9aV0ZrQUFBRGtBQUFBQzhBQUFBMktBSENaV2hvWldFQUFBUEFBQUFBSUFBQUFDUUZtUUdiYUcxMGVBQUFBK0FBQUFBUUFBQUFFQWxpQUtkc2IyTmhBQUFEOEFBQUFBb0FBQUFLQWFnQTFHMWhlSEFBQUFQOEFBQUFHQUFBQUNBQUJ3QkZibUZ0WlFBQUJCUUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUU1QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1pbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1XOWxadmdQNURNek1JS0VHUkVxL2dPRkFmQjVEZVlBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZemIvMy9IOGhQQTlIL1ovL3hBNnNDQWdDaUp3bUpBQUI0MmtYUlBXL1RRQndHY0Q5MzdqbHY5dG14Zlc2VDFIbHhiSWZTeG1uY09paXQ4dEpXUW0wUnBVS2lLa0lnaGk2ZGtCaEFmQWdHMUlHVmxXL0EzaDN4SFJpUm1CaFlVczd0d0oxMHd6MDMvSC8zS0ZDT2J4SnlTWDRvTTBVQjVXQ2FBYTBUeFJPa3doTk1FMDFNTUtVQml6SXZuV0FrNzRmQ014QkVjWlNOb2dRRzRVZ3p3V0o4R1p1cVdTdk9OM3Rqb090R0ZMekpPZSsyNldxZlAvS0p6VSs1YTRpOTRONHVFQWlabXo3bjFhcGZLdFJlNVRHdUZ0ZEgxbXpMMmFkUjRMZElsOFhsSW9GNjdINytjMFk3R3M3TzYzRVVkdjlIV0lrMlBxcWRBaFM1aUxKK3MwRkNYQ3Q5WlQvWFNBbTdsY2lKSGFaNUloV1pCRXdsc284NEcrWGJoeWRWOGdHZElvc2xpbW41Rndodm1EOGw3VGZGdCsrVGw2cWMxeEl3cWcycjdld0dEYUY1bzhQNU9hRnpiaDJlOTdaMVdxdnFMajRsRkk2N1ZkdHZ1YWFGS1BiM0doVU5IeGJ6NURrbDd2cHEyN2JMZm1tSm9OeFlHYlJlcENyT25sdzh0dmtCUlZlWUFxYTErUHVObDhOQVJXODdtczlPUmdoYlhMKzFEVzUrNFRlK0t6dTViV1RBWTU3c1puaG40SGNrS2JrN00rRkptQ0ZINk1zMlpZc1M2V1Y1YnpHTHhaUWtZRi9URU5oWmJhWW5ENnRxUVNjOWMvUHkyUVhJZ3lZTmlIcjF1akpzVzEzQUZhVmdySisrb3lTTWRpcnRBZWlrY2Ivc0w0Zk84bkx5c3o2MTErb2xRdXErQnRUalNxVGlhRHpZcXlKc3pwNEN6R0N1cWR0RWMwcllYT3ZZUmdIUW5VWVphcmdrVXhWRTB2NEIvMUJVbkFBQWVOcGpZR1JnWUFCaTNrTk9uZkg4Tmw4Wm1Ga1lRT0N4a1AxV0JQMWZsK2tZMDBVZ2w0T0JDU1FLQUEwdENlWUFlTnBqWUdSZ1lHYjR6OERBd0hTTVFlZi9CYVlzQnFBSUNtQUJBR1VjQkRnQ3hnQUFBam9BU3dJNkFDd0NLQUF3QUFBQUFBQm1BTlFCUWdBQWVOcGpZR1JnWUdCaGNHRmdZZ0FCUmdZMEFBQUhqZ0JOZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLTXZDbzJob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0xkcXo3ZGplZTMrY3JBek1JQUFvK0Y3TGNpMDh3VG1XeUFGQWNERTRnSEFEajRDWXNBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLRUhEUVdob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0cmJYcHpqaitXMitNakN6TUlEQVl5SDdyUWo2LzE5bU5xYTdRQzRIQXhOSUZBQXZBZ3F0QUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00Ni41NTA1MTgnIHk9Jy02MS42Nzg5OTcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTM5LjA3ODUxOScgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMi41MzEwNCwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ni41NTA1MTgsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDYuNTUwNTE4JyB5PSctNjEuNjc4OTk3Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00MS44ODM5MzQnIHk9Jy02NC42ODU1MTUnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzcuNzE4OTY1JyB5PSctNjEuNjc4OTk3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zNC42MDU2MjEnIHk9Jy02MS42Nzg5OTcnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTMwLjQ2ODY3MScgeT0nLTYxLjY3ODk5Nyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzguNDkzOTEnIHk9Jy02NS4yOTQzNjEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOS43MDgzMyAwSDQ2LjQwMzc4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjY1Mzc4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjQuMzI1ODIsNC43ODQwMSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Ni41NTA1MTgnIHk9Jy02MS42Nzg5OTcnPs61PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Mi43ODY0OTYnIHk9Jy02MC42ODI3MzMnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NC01Ni45MDU1SDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNS45NjQsLTY0LjU3ODQxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \DiagramSquare {
              sw = A,
              nw/style = pullback,
              se = B,
              nw = A',
              ne = B',
              south = f,
              east = g,
              west = f^{*}(g),
              north = \varepsilon _{g},
            }
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          Let <fr:tex
display="inline"><![CDATA[\alpha \colon g\to g']]></fr:tex> be a morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. By the construction of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>, we have the following commutative diagram.
          
    
      
      <fr:figure><fr:resource
hash="1ee8ae6f4500f08dd08da5314907b5d1"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5OC4yMjM2MjFwdCcgaGVpZ2h0PScxNzUuNDY3NzY2cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTMyLjE0OTA4MSAxMTYuOTc4NTExJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLSS9CT0dob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0o1Ui9NM3h2UGJmR1ZnWm1FQWdjZEM5a3NSOUg4ZDVoREdvMEF1QndNVFNCUUFMUHNLTUFCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLRUhESVdob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0cmJYcHp6aitXMitNakN6TUlEQVl5SDdwUWo2LzE5bU5xYTdRQzRIQXhOSUZBQTI0Z3JOQUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzRBQUFBMktBN0NTR2hvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRoTXNDcnZqK1cyK01qQ3pNSURBWXlIN3BRajZQeVBUWldZUWw0T0JDVVFCQUFJMUNPUUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV1FBQW9BQUFBQUJwZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGNEVtTnRZWEFBQUFFOEFBQUFOUUFBQUVRRHhnU0haMng1WmdBQUFYUUFBQUs0QUFBRFZLVWdxMlJvWldGa0FBQUVMQUFBQUM4QUFBQTJLQUhDUldob1pXRUFBQVJjQUFBQUlBQUFBQ1FGNHdIT2FHMTBlQUFBQkh3QUFBQVVBQUFBRkF4YUFPWnNiMk5oQUFBRWtBQUFBQXdBQUFBTUFhSUNmbTFoZUhBQUFBU2NBQUFBR0FBQUFDQUFDQUJGYm1GdFpRQUFCTFFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGaEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZndaRGdZQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUlMazBwazNNbS85L3gvSVNvT3cvcy8rRS9USEg2d1dEQUFJREF4TkFBQUFlTnBOMHMxUDAyQWNCL0IrZnkzdDZGNzZzdllwYktOajY5cE9CRFpXNkFqZ3hzQ2d2QWdTaldURStKWWdFUzhtSmtxOCtROFlRemg0OWVyWmkzZnV4di9CbzRrWFBYZ0JuNDZEdGtrUHorOUordjA4MzBlQXNIblJvQ1A2Sml3TEFrUU5zcEtEVWczQ0RpTG1NRmxoWlhUUUZUMDVpSjJvZ3paZmJ6RW5CeThJZzdnZE5KQWpEVkhNNUJBZkYzUkpMd3ozWnVvTFFNME9SR2hsVGROcUZYRnNXdHR5S2EvdGFuYU9yWGhYbGdDUDhibnVhcHBwdW1xcThEQVo0L1Q4Yk1OWW5yVld4Y0J6eDZrbWgrbGhnclJwZi9pOUoxWVY3UFdMWWVEWC9vMHdHa3k5azZvcENQd2hZZkppaW55Y0NkUENhcUxoRW5rZzRZa3RXWEZZeEdJTzZITGtOTUs0bmJ3dUhLN2lHOFF1NHBDalpDVTVBdWEwa3ExVWVUSDg4cmp4UU9KNURZYWNXVElxMXBKWFlvclRYdS8xU2V4cHhucS9QcGNWQzJiV3hrbERoR1hQRmxiSGJkMUFFTG9ycFl5Q04rZTl4cjVJOXVSWUpaOVB1K29RSVYwYWJZN2ZqeVRzM1Q3WXptdlhSZFNZenFBYjUzKythR25mazFDZkMzckxPMjM0NDFwMllPdGUvS0xQQXh0dnluZlI1cGJaeUJuSXVKSmIvemZ4MnBMOFpiaElPdVV3UGcwU21XUHhYbU5xU2l5dDFqS21LaU9hR3UxWWs4YzM5eCtSdEdaWXU0ZmJ6eklFV2kwTktTb2ZGNGJMSnhLa29lYTE0aTAvNUQrT3lxL2U3OWNsbUtVMFNEVWpJaS8ySXREaCtwTWRTK2VXL2ExMHBYWDNxYTZDeUY0ejFwLzNHMTZyTDhLYm1uOWJuTDBHcW5KUDgrSUhmdUtyc0poMDFlYTU1Q1IwNnpLL2Rsa1JiK2J5R3pPSG8zSklHRXFWMzBwZW1oTW45ekNVUTlhbEJ1UlBrUThzanBXam5SdW1sTXBTWFo4NXVuY0FtaStMSGttbmp6T3RpbEVEYktaNkM5bmQxeUw1d1dLbTBvVFlLVjFOdXlPK05UTFMrRjdzNWllS0tsSFJWWUJpbUFra2JDdzBWMHo0NWVVN2dKeVRiVDJiSjhWU01UTlJ6ZWRTUU5iaXh5RDVRM3dxZ1hoVmZ3RyszbktBZU5wallHUmdZQURpbDBiZW92SDhObDhabUZrWVFPQ3hrUDFTQlAxZmwra1kwMFVnbDRPQkNTUUtBQWFWQ2FjQWVOcGpZR1JnWUdiNHo4REF3UFNEUWVmL0JhWXRERUFSRk1BS0FHOTlCTFVDeGdBQUFqb0FTd0k2QUN3QytBQS9BaWdBTUFBQUFBQUFaZ0RVQVR3QnFuamFZMkJrWUdCZ1pYQmhZR0lBQVVZR05BQUFCNmtBVG5qYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT3NBQW9BQUFBQUJCd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFMEFBQUJncW1OaWUyTnRZWEFBQUFGRUFBQUFNd0FBQUR5ZVdtUmJaMng1WmdBQUFYZ0FBQURnQUFBQTdEME5RbHRvWldGa0FBQUNXQUFBQUN3QUFBQTJLWS9DZzJob1pXRUFBQUtFQUFBQUh3QUFBQ1FGN2dEYWFHMTBlQUFBQXFRQUFBQU1BQUFBREFrS0FPMXNiMk5oQUFBQ3NBQUFBQWdBQUFBSUFGUUFkbTFoZUhBQUFBSzRBQUFBRndBQUFDQUFCUUEyYm1GdFpRQUFBdEFBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEb0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtWm1hY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFBNE1EakoxU1hKYk93S1lrL3NDQVdldVBKUU1Ec3hiemNhQXdJMEwxLy84TURBRG90dzdmQUFBQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWm1SZ1VoSi9ZUEQvUHdNRGhMNzdTdjRTV0JVUUFBQ25pUW15QUhqYUxZNVBTc1F3SEVienBjTXZWTlBhUDJuU29rN0hES2E3a1NsMUNpTDFFb29ic1lqUXZXdHZvT0FSUm5EbkdieUd5em1MbU1Xc0h0LzdObytCZmJBbGY4YU9kWXloMzdSYTBSRzAwU2FHdTBBTkVpdDBOeERVV09mcEd0Y01hR3MwN3JMYjlOb0l2SDNLU3FYMGZYK1hjNmdxL0lxSTJ6UW4rWDVPVVZGNnJ6aUtNdHBLeWxQTEQzRThoc3JHZkRnOUUyV21RRS9UMVR4QVp0YlRiUUZsay8wUmp0UDZJTXJBNjBlZnhrYlc0SlZmczhTUGdKYStvODhIOUswMkpQRHlTMUxud1d3YlZQUEtBVFBzL2g1U0lhSUVQL0VDaXhNcDJUOXVmQi9RZU5wallHUmdZQUJpUnBlRkYrUDViYjR5TUxNd2dNQmpJZnVseURSTEtKTU5rT0pnWUFMeEFPL0JCN040Mm1OZ1pHQmcxdnBqeWNEQUVzb1F6K0RCbE13QUZFRUJ6QUJJZFFMTkFBUlZBQUFDOGdDT0FjTUFYd0FBQUFBQVZBQjJlTnBqWUdSZ1lHQm1NR1VBMFF4UUVna0FBQVhsQUR3QWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS012Q2cyaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZHF6N0x4dlBiZkdWZ1ptRUFnY2RDOWt1UmFlYUpURFpBaW9PQkNjUURBQllFQ0t3QUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNi4zMDU1NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIuMTU3ODU5JyB5PSctMjYuODgyMjY5Jz7ugLDugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC05LjYyOTg1OCwtMjMuMjY2OTA2KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy05LjYyOTg1OCcgeT0nLTIzLjI2NjkwNic+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQuOTYzMjc0JyB5PSctMjYuMjczNDIzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS43OTgzMDQnIHk9Jy0yMy4yNjY5MDYnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMi4zMTUwMzknIHk9Jy0yMy4yNjY5MDYnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNi40NTE5ODknIHk9Jy0yNi4yNzM0MjMnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc5LjE0Njc2MycgeT0nLTIzLjI2NjkwNic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MC4zMDY1NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTEuNTczMjUnIHk9Jy0yNi44ODIyNjknPu6AsO6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjg2MTEgMEg0NS4yNTEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDUuNTAxLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjIuOTczMzksNS42MjI5NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS44NjU4MzYnIHk9Jy0yMS40MzQ4NjMnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTIuMTk3Mjc5JyB5PSctMjIuOTAxNTkyJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNDkyOTA4JyB5PSctMjYuMjczNDIzJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00NS4zOTEwOCwzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIuMTU3ODU5JyB5PSctMjYuODgyMjY5Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC42OTUzNi01MC4yMjQ1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzc5NjUsLTAuNjI2MTYsMC42MjYxNiwwLjc3OTY1LC04LjUwMDQ2LC01MC4zODEwNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTU5LjU5MDE1LC0yMS4zMTQ0NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00Ljk2MzI3NCcgeT0nLTI2LjI3MzQyMyc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0uNzk4MzA0JyB5PSctMjMuMjY2OTA2Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzIuMzE1MDM5JyB5PSctMjMuMjY2OTA2Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzYuNDUxOTg5JyB5PSctMjMuMjY2OTA2Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tMzAuNTI5OTcgNDEuNTE0OTRDMy4wNzcyOSA0Ni4yMjg4OCAyOS4xNzQ1OSAzNS42NzUyNSA0OS43NTI5OCA5LjMyMTYyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNjE1NDMsLTAuNzg4MTYsMC43ODgxNiwwLjYxNTQzLDQ5LjkwNjgzLDkuMTI0NTkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE3Ljc5OTY1LDQxLjgwMzM0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPs6xzrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLS42ODY0OTQnIHk9Jy0yMi4yNzA2NDInPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00tMzMuODI4MDggMzMuODI4NTdMLTkuMjc3MTYgOS4yODEwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE0LC0wLjcwNzA1LDAuNzA3MDUsMC43MDcxNCwtOS4xMDAzNyw5LjEwNDMxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00tMzQuNTMyNTYgMTQuODc4MDdILTguMjE5MTFWMjcuOTcyMjJILTM0LjUzMjU2Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMxLjUzMjU2LDE5LjYyODA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQuOTYzMjc0JyB5PSctMjYuMjczNDIzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS43OTgzMDQnIHk9Jy0yMy4yNjY5MDYnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMi4zMTUwMzknIHk9Jy0yMy4yNjY5MDYnPs6xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzcuNDk0MzgnIHk9Jy0yMy4yNjY5MDYnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                nw = A'',
                nw/style = pullback,
                ne = B'',
                sw = A,
                se = B,
                north = \varepsilon _{g'},
                west = f^{*}(g'),
                west/node/style = {right},
                south = f,
                east = g',
              }
              \node  [above left of = nw] (a') {$A'$};
              \draw  [->,morphism,bend right] (a') to node[swap] {$f^{*}(g)$} (sw);
              \draw  [->,morphism,bend left] (a') to node {$\alpha \varepsilon _{g}$} (ne);
              \draw  [->,morphism,exists] (a') to node[desc] {$f^{*}(\alpha )$} (nw);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          Thus, <fr:tex
display="inline"><![CDATA[\varepsilon _{g'}\Sigma _{f}(f^{*}(\alpha )) = \varepsilon _{g'}f^{*}(\alpha ) = \alpha \varepsilon _{g}]]></fr:tex> as required.
        </html:td>

      </html:tr>

    </html:table>
<fr:p>By construction, <fr:tex
display="inline"><![CDATA[\varepsilon _{\Sigma _{f}}\eta  = \mathsf {id}_{\Sigma _{f}}]]></fr:tex>. Thus, it remains to verify the other triangle equality.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[g \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex> be an object. We need to show that <fr:tex
display="inline"><![CDATA[f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} = \mathsf {id}_{f^{*}(g)}]]></fr:tex>. Note that <fr:tex
display="inline"><![CDATA[f^{*}(g)f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} = f^{*}(g)]]></fr:tex> by the construction of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>. Moreover, we also have the following equation.</fr:p><fr:tex
display="block"><![CDATA[       \begin {align*}         \varepsilon _{g}f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} &= \varepsilon _{g}\varepsilon _{f \circ  f^{*}(g)}\eta _{f^{*}(g)} && \text {by the construction of } f^{*}\\                                                     &= \varepsilon _{g}\mathsf {id} && \text {by the construction of } \eta \\                                                     &= \varepsilon _{g}       \end {align*}     ]]></fr:tex><fr:p>Thus, <fr:tex
display="inline"><![CDATA[f^{*}(\varepsilon _{g})\eta _{f^{*}(g)}]]></fr:tex> corresponds to the same cone over <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> as <fr:tex
display="inline"><![CDATA[\mathsf {id}_{f^{*}(g)}]]></fr:tex>. Then uniqueness implies that they are equal.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Related">Related</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1370</fr:anchor><fr:addr
type="user">ct-000G</fr:addr><fr:route>ct-000G.xml</fr:route><fr:title
text="Locally cartesian category">Locally cartesian category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is said to be <fr:em><fr:strong>locally cartesian</fr:strong></fr:em> if for any object <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>, the slice <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> is cartesian.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>