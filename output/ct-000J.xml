<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1993</fr:anchor><fr:addr
type="user">ct-000J</fr:addr><fr:route>ct-000J.xml</fr:route><fr:title
text="Slice comparison functor of a locally cartesian category admits a right adjoint"><fr:link
type="local"
href="ct-000I.xml"
addr="ct-000I"
title="Slice comparison functor">Slice comparison functor</fr:link> of a <fr:link
type="local"
href="ct-000G.xml"
addr="ct-000G"
title="Locally cartesian category">locally cartesian category</fr:link> admits a right adjoint</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is locally cartesian iff for all morphisms <fr:tex
display="inline"><![CDATA[f]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the functor <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> constructed in <fr:ref
addr="ct-000I"
href="ct-000I.xml"
taxon="Lemma" /> admits a right adjoint <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>. Moreover, <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> is (isomorphic to) the pullback functor.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1188</fr:anchor><fr:addr
type="machine">#330</fr:addr><fr:route>unstable-330.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By <fr:ref
addr="ct-000H"
href="ct-000H.xml"
taxon="Lemma" />, locally cartesian categories are precisely those categories with pullbacks.</fr:p>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1189</fr:anchor><fr:addr
type="machine">#328</fr:addr><fr:route>unstable-328.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex> for any <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. We show that the following diagram</fr:p>
    
      
      <fr:figure><fr:resource
hash="3bdf29e3ca5a6afa1fb82198dbd9d32b"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNC43NjA3MDdwdCcgaGVpZ2h0PScxMTcuODQ5NjI0cHQnIHZpZXdCb3g9Jy03MiAtNzIgNzYuNTA3MTM4IDc4LjU2NjQxNic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9VQUFvQUFBQUFBL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFYR050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFEWUFBQUEyTlZxTFR0b1pXRmtBQUFDUEFBQUFDOEFBQUEyS1J1Y2dHaG9aV0VBQUFKc0FBQUFIZ0FBQUNRRjhRS2FhRzEwZUFBQUFvd0FBQUFJQUFBQUNBWWhBR1ZzYjJOaEFBQUNsQUFBQUFZQUFBQUdBR3dBQUcxaGVIQUFBQUtjQUFBQUZnQUFBQ0FBQlFCRmJtRnRaUUFBQXJRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGhBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTZRek0vd0g4cGtoMGtocS9nT0ZBYlFlRE04QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOUR5UCt6d0h3R0FGVzFCc01BQUFBQUFnQmwveXdDaWdIRkFDNEFRd0FBQVFNT0FTTUdMd0VtSno0Qk1oWVZGQVlIRmg4QkZqNENQd0VPQVFjdUFTYzJOelkzTmpjeUZoYzJOeDRCRlFjM05pOEJKaWNPQVFjT0FSVWVBVGMrQVRjK0FRS0ZiQlNQYXk4MUN6TUVBU1V5RmdvUUFpSXRGejlIR0FZWUVrd3lTMllDQTBVUkVsQmhJa0FaRVNJVEU1WXRBUlVFRnp3cFNCWWRIQUk1SUNoRkhRNEpBWFgrVEV0SUFna0REQzhkSlJvUENCd1BCUUlCQVFvd01CeGhFQ1VDQVZ4U1kwd1REMElER3lJbkFRRVZEdnU0Q2lNR0lnUUJNQ012ZFNFN0xBRUJKeDBQRHdCNDJtTmdaR0JnQU9LNWEzY3F4dlBiZkdWZ1ptRUFnY2NSdXA0SStyOE9jd2pqVVNDWGc0RUpKQW9BRnVFSmdRQjQybU5nWkdCZ1p2alBBQ1JER0ZJWm5KbTZHSUFpS0lBSkFFQVdBcElBQUFOVUFBQUN6UUJsQUFBQUFBQnNBQUI0Mm1OZ1pHQmdZR0p3QVdJUVlHUkFBd0FIV0FCTEFBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDArMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNWWjJ4NVpnQUFBV1FBQUFGTEFBQUJZRG1Tc1RKb1pXRmtBQUFDc0FBQUFDOEFBQUEyS00yZWFXaG9aV0VBQUFMZ0FBQUFIZ0FBQUNRR0xBSU9hRzEwZUFBQUF3QUFBQUFNQUFBQURBaCtBRTlzYjJOaEFBQUREQUFBQUFnQUFBQUlBRlFBc0cxaGVIQUFBQU1VQUFBQUZnQUFBQ0FBQndBNmJtRnRaUUFBQXl3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaVp2Z1A1RE5EcEpIVS9BY0tBd0R5S1ExSGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoTy8vOERTY2YvLy84ZkFQTVpBRktvQnA1NDJqV1BNVS9DUUFDRjc5M0JIV0RiUTF2YUdBRlRRWnBvRkVOSkt3d01LbWcwRXBURU1KQ1ltQ2liZzBGY0dSaDFNakZ4Y25IekI3ZzRPZmtuSEl5anZ3R3dOZkZOTDEvZThEMUNTWDQ2cFYvMGt4UkppUkFmbmw4eUxkMHdYYy9rUlFpbjRKUTl5L1Q4SW16QkRkUHlMQTBCRDdGYmcrK3lWNXh6UStXb21Xc3BLTkgrTUJhRk9xT1hXVnhNcGswMXJhc01hclRYVWFERWwycVBQL2FBbmlRUmwrT2hLVmxHZ0RIUW1CU0FZbDNVUjBZK0NTbzFIdUtFNU1oOTRKZ0VZV1IxT21hY3ZwRXNXU0diZ2FsZXpqazhjTE96U0drUVdWaGNnZ3ViLy9ucW9aeFhjSElGTHRoL1o4SEFmYjViY0RKU290TTlZOFAyUVJ0ME4zbDRQYmxQYTFvMSsvUncycWRZM3g0dDZ0SEwyKzZBMG8yOTkwWUUwRnEwTWt0WldvQWVWZmQ3TXRHc0hHeHB0VWo0QURycTdLcVIzNkdROCtNWGR0TmNickhKOXh4UGtGK3p2VHVEQUhqYVkyQmtZR0FBNHRZcndqdmorVzIrTWpDek1JREE0d2hkVHdUOS95OHpHOU5kSUplRGdRa2tDZ0FmeVFvZUFIamFZMkJrWUdCbStNOEFKRGtZVkJpWW1Oa1lnQ0lvZ0JrQUk4Y0JRZ0FBQW5ZQUFBTUFBQ1FEQ0FBckFBQUFBQUJVQUxCNDJtTmdaR0JnWUdhd0JHSVFZR1JBQXdBR2R3QkNBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1BQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDd0FBQUEyS1ZlZHkyaG9aV0VBQUFIWUFBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmZ0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNBQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlJQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlBQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzhBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9KZGsyMTY0L2x0dmpJd3N6Q0F3T01JWFU5a21ua2lrdzJRNG1CZ0F2RUEvdHdIL1hqYVkyQmtZR0JXL0dNRUpDY3lHRExJTXBvd0FFVlFBQk1BUVJvQ2JnQUFBNUVBQUFGUkFERUFBQUFBQUNBQUFIamFZMkJrWUdCZ1l1Qm5BTkVNVUJJSkFBQUNGQUFWQUhqYVRZdzliOEl3RUlhZmlBU0pkT2hTZGVnQUhwaXRvRlJpWTJGZ1ltWHFBdGlnREhHUUhTSkZxanJ5dTN1NEhuckQ2WGsvN29DU0h6S2VrL0VhOTNOeUNsRi9YUERDVytLcHFFWGlrZytXVE1qeW1UaHpOb2x6U2I0U0Y3eHpTVHdWL3p0eHlTZVBiZGZlN3IzMWF0OFo2OTI1RGVQNllIMW9PcWRXdW9wNlo1MzF4OTRhZFJxVkdab3dYRnRWNjByWGJPbG91WEdueCtKUjdNVXhrUjFueVFJamF3N1JDVFNTT21tdDBGVC84cDNrTG5hTzhaT1J6a2tTSlRUSVZaQjlsYmFpanBlYStoZnplVEJQQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUMwQUFBQTJLSnFka0dob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0bU52c3JUaitXMitNakN6TUlEQTR3aGRUd1Q5bjVIcE1qT0l5OEhBQktJQUdPMEpOQUFBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5rQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDd0FBQUEyS2h1ZGEyaG9aV0VBQUFJOEFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFsd0FBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNaQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUpzQUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9RQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFZBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaW1sWHFzZkg4Tmw4Wm1Ga1lRT0J4aEs0bk1zMFN5bmdIU0hFd01JRjRBTy90Qi9WNDJtTmdaR0JnMXZwanljREFFc3JReDlEUGxNd0FGRUVCVEFCU2dBTkNBQVJWQUFBQzhnQ09BQUFBQUFCVUFBQjQybU5nWkdCZ1lHSXdaUURSREZBU0NRQUFCY29BT3dCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUNVbFlXQmlaV3BDMkNETXNSQmRvZ1VxZXJJNys3aGV1Z05wK2Y5dUFOS2ZzaDRUc1pyM00vSktVVDljY0VMYjRtbm9oYUpTejVZTWlITForTE0yU1RPSmZsS1hQRE9KZkZVL08vRUpaODh0bDE3dS9mV3EzMW5ySGZuTm96cmcvV2g2WnhhNlNycW5YWFdIM3RyMUdsVVptakNjRzFWclN0ZHM2V2o1Y2FkSG90SHNSZkhSSGFjSlF1TXJEbEVKOUJJNnFTMVFsUDl5M2VTdTlnNXhrOUdPaWRKbE5BZ1YwSDJWZHFLT2w1cTZsL3Y2VEJIQUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUd0FBb0FBQUFBQmJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0YzOG1OdFlYQUFBQUU4QUFBQU1nQUFBRHdIRmYxMloyeDVaZ0FBQVhBQUFBSWVBQUFDaEJMRnZFWm9aV0ZrQUFBRGtBQUFBQzhBQUFBMktJMmRqV2hvWldFQUFBUEFBQUFBSUFBQUFDUUZtUUdiYUcxMGVBQUFBK0FBQUFBUUFBQUFFQWxpQUtkc2IyTmhBQUFEOEFBQUFBb0FBQUFLQWFnQTFHMWhlSEFBQUFQOEFBQUFHQUFBQUNBQUJ3QkZibUZ0WlFBQUJCUUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUU1QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1pbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1XOWxadmdQNURNek1JS0VHUkVxL2dPRkFmQjVEZVlBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZemIvMy9IOGhQQTlIL1ovL3hBNnNDQWdDaUp3bUpBQUI0MmtYUlBXL1RRQndHY0Q5MzdqbHY5dG14Zlc2VDFIbHhiSWZTeG1uY09paXQ4dEpXUW0wUnBVS2lLa0lnaGk2ZGtCaEFmQWdHMUlHVmxXL0EzaDN4SFJpUm1CaFlVczd0d0oxMHd6MDMvSC8zS0ZDT2J4SnlTWDRvTTBVQjVXQ2FBYTBUeFJPa3doTk1FMDFNTUtVQml6SXZuV0FrNzRmQ014QkVjWlNOb2dRRzRVZ3p3V0o4R1p1cVdTdk9OM3Rqb090R0ZMekpPZSsyNldxZlAvS0p6VSs1YTRpOTRONHVFQWlabXo3bjFhcGZLdFJlNVRHdUZ0ZEgxbXpMMmFkUjRMZElsOFhsSW9GNjdINytjMFk3R3M3TzYzRVVkdjlIV0lrMlBxcWRBaFM1aUxKK3MwRkNYQ3Q5WlQvWFNBbTdsY2lKSGFaNUloV1pCRXdsc284NEcrWGJoeWRWOGdHZElvc2xpbW41Rndodm1EOGw3VGZGdCsrVGw2cWMxeEl3cWcycjdld0dEYUY1bzhQNU9hRnpiaDJlOTdaMVdxdnFMajRsRkk2N1ZkdHZ1YWFGS1BiM0doVU5IeGJ6NURrbDd2cHEyN2JMZm1tSm9OeFlHYlJlcENyT25sdzh0dmtCUlZlWUFxYTErUHVObDhOQVJXODdtczlPUmdoYlhMKzFEVzUrNFRlK0t6dTViV1RBWTU3c1puaG40SGNrS2JrN00rRkptQ0ZINk1zMlpZc1M2V1Y1YnpHTHhaUWtZRi9URU5oWmJhWW5ENnRxUVNjOWMvUHkyUVhJZ3lZTmlIcjF1akpzVzEzQUZhVmdySisrb3lTTWRpcnRBZWlrY2Ivc0w0Zk84bkx5c3o2MTErb2xRdXErQnRUalNxVGlhRHpZcXlKc3pwNEN6R0N1cWR0RWMwcllYT3ZZUmdIUW5VWVphcmdrVXhWRTB2NEIvMUJVbkFBQWVOcGpZR1JnWUFCaW5sVTlsdkg4Tmw4Wm1Ga1lRT0J4aEs0bmd2NnZ5M1NNNlNLUXk4SEFCQklGQVA3a0NWY0FlTnBqWUdSZ1lHYjR6OERBd0hTTVFlZi9CYVlzQnFBSUNtQUJBR1VjQkRnQ3hnQUFBam9BU3dJNkFDd0NLQUF3QUFBQUFBQm1BTlFCUWdBQWVOcGpZR1JnWUdCaGNHRmdZZ0FCUmdZMEFBQUhqZ0JOZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU1LjEwNTAxMycgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTcuOTEwNDI4JyB5PSctNjQuNjg1NTE1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUzLjc0NTQ1OScgeT0nLTYxLjY3ODk5Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTAuNjMyMTE2JyB5PSctNjEuNjc4OTk3Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ni40OTUxNjUnIHk9Jy02MS42Nzg5OTcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTEuNDU5MzIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU0LjUyMDQwNCcgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjg2MjEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuNjc4OTk3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINDYuNDAzNzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNjUzNzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4zMjU4Miw0Ljc4NDAxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+zrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU4LjgxMjk5JyB5PSctNjAuNjgyNzMzJz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        
    \SpliceDiagramSquare {
      sw = A,
      se = B,
      nw = A',
      ne = B',
      south = f,
      east = g,
      west = f^{*}(g),
      west/node/style = {right},
      north = \varepsilon _{g},
    }
  
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>is a pullback, where <fr:tex
display="inline"><![CDATA[\varepsilon _{g}]]></fr:tex> is the counit of the adjunction. Note that since <fr:tex
display="inline"><![CDATA[f \circ  f^{*}(g) = \Sigma _{f}(f^{*}(g))]]></fr:tex> by construction, the component <fr:tex
display="inline"><![CDATA[\varepsilon _{g}]]></fr:tex> makes the diagram commute.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[h'\colon C\to A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h\colon C\to B']]></fr:tex> be morphisms such that <fr:tex
display="inline"><![CDATA[fh' = gh]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="2eb932eee263ecd4d313f468c72b28ee"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3Ni40MjcyMjhwdCcgaGVpZ2h0PScxNzQuNDQ0ODM3cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE3LjYxODE1MiAxMTYuMjk2NTU4Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzBBQUFBMktKcWRjbWhvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRtTnZzdExqK1cyK01qQ3pNSURBNHdoZEt3VDluNUhwTWpPSXk4SEFCS0lBSUU4SlVnQUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLUnVjWW1ob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0s1YTNmR3h2UGJmR1ZnWm1FQWdjY1J1bFlJK3I4T2N3ampVU0NYZzRFSkpBb0FIa01KbndCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSc0FBb0FBQUFBQlF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUZFQUFBQmdxR3ppWldOdFlYQUFBQUZJQUFBQU5BQUFBRVFpTEFDNloyeDVaZ0FBQVh3QUFBR05BQUFCek1VV0kxZG9aV0ZrQUFBRERBQUFBQzhBQUFBMktoeWRaMmhvWldFQUFBTThBQUFBSHdBQUFDUUY3Z0RiYUcxMGVBQUFBMXdBQUFBUUFBQUFFQXUwQVd4c2IyTmhBQUFEYkFBQUFBb0FBQUFLQVZZQXhHMWhlSEFBQUFONEFBQUFGd0FBQUNBQUJnQktibUZ0WlFBQUE1QUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUVZQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc3M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lBR0lCWmdZSENBY2hsU2lzdlNHZGdVRkI0WU1HdjlzV1JnWU5aaVBnNFVabVNBZy8vL0dSZ0FXVUVRVHdBQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUFMbEZCU1V4QjhZL1ArUFlOMS9lUGUxL0dXd1dqQUFBUHpGREFGNDJqV1F3VzdUUUJDRzk1KzFkK3ZFanAxNGJjZHRhamRyWXplcVNHaEliSVFxNThxQkk0aExSWVNxNWs3VkV4eTRVNGxIS0JJM2VBVmVvOGMrQzdCRmNKblJQL09QOVAzRHdENzkxdlNZN3RnTHhwQWpReVI4Q1BsUTJtcUJxbDQxR3pSckh3TVVjNnlhZHBuemFrSFZ1a1BTeE1sZjh3WWRubVpRUW1wemdrdnVPUmFFTFRtWGJrSjh6NUt3K3oyZXpzSzVtZ2JCTkJyUGp2ZkpsbjJiU2lGS2doMEkydisvVmZOd2hoOVplM3lpUDF5OXZFajJDQmdGbDgrdWI4ckZreFBmNHozUm84TFhKQnpIbXVURm1UNG9BNktnUEN6Tzg0bmxDSWUwWDVCeE1ST0pmV0VGWGVDZXJZeG9tMldzREhLY3hNa0FoalUzOUNiVkJsTFV1aks5cXF1Nnd6SkhYYTFOMkRpUitQelZUZFZRZkgvek9pU28xUG5tQ2RMRFVMZzNqNFFYamMxY0VhS3hkK3VLY0tpcGo0T3RvL1NBdXNPcEhJOFV4THZkODR4amxKenVYa1ZRT3ZpM2NMYTcwNTQzQXVWdkh6aTNyTVpIT21PQkVWd1VocU1OTzdSTDgyT0o5M2ZDalVOdTNmSTBTeXZBd3Yydjg2R1VYb0NmZ3lNY1RWeVgvUUdZQWpjc0FBQUFlTnBqWUdSZ1lBRGlweHd2QXVQNWJiNHlNTE13Z01EakNGMHJCUDFmaVNXVTZRcVF5OEhBQkJJRkFCUjRDVzBBZU5wallHUmdZTmI2WThuQXdCTEtFTS9nd1pUTUFCUkJBU3dBU0hZQ3pnQUVWUUFBQXFvQWZ3THlBSTRCd3dCZkFBQUFBQUJ3QU1RQTVnQUFlTnBqWUdSZ1lHQmg4R1FBMFF4UUVna0FBQWYwQUZFQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdzQUFvQUFBQUFCcWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjRBMk50WVhBQUFBRThBQUFBTWdBQUFEd0hGZjE0WjJ4NVpnQUFBWEFBQUFMV0FBQURiSHhIbEI5b1pXRmtBQUFFU0FBQUFDOEFBQUEyS0kyZGIyaG9aV0VBQUFSNEFBQUFJQUFBQUNRRnFnR2NhRzEwZUFBQUJKZ0FBQUFVQUFBQUZBd09BUFJzYjJOaEFBQUVyQUFBQUF3QUFBQU1BYTRDaW0xaGVIQUFBQVM0QUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQk5BQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRm9BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXltU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVc5bFp2Z1A1RE16TUlLRUdSRXEvZ09GQWZhbURmY0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5bVl3Yi8zL0g4aFBBOUgvWi8veEI2c0NBZ0NpU1FtTEFBQjQya1dTUFcvYlZoU0crUjVTcEVTS3ZQd1FMeDFMcGtSUkpKWFVFU1ZUcGxKYmxTekxTQkc3elVjTDFIQVFKT2lRSlZPQkRpMWFvRCtoQ0lJTVdiTVYvUWZaQTJRTThoOHlGdWpVQWwzc1hsWkQ3d0h1Y004ZHpuT2VWNEowZHBYVE0vb2dIVWtTWkFaVnM2RDEwMnlCZ2dkYzFYZ1hDeXpsV0UzTG9GaGdKdDczZUdBaFRyTzBuS1U1TEdJb1NxNW1lSDFnSy9aMll6VVpIZ0FEUDVYQnVveXhRU1R2ak5nWElYbnNBZk10Zmh4Zm53TXhGMzA3Wk14MVE3MisvYVJxNCtYbDIxUG5hTnBheTJrYzltaWdaa2FEb0p6NXIvNDZsL3NhemkvYVdab00vbS9oV25yelY2VmZoeVFPU2J0WE55bkJXMmtrclNzYVFhTCtSeUltYnFsYXdBdGVDb0NsZ0J3aEsyZFZoUWdFbGZnZ0wxRm1Ba3JWcWhYd1lLLzZTdEYzamU5L3pCOHJZbDZIdzNJN1R0U2F4eDJ1QmJNN3F3dVNWOHk1Y3pIY04rVnQxL1R4SXBmUjhxZmI2NTV2TzBpejhMalQxUERUNVNwL0tKTy91eE41bmhIcU5ZTFJ1VGJ1UFNvVW5OOS9ldGRqSnpJRzNPYXduY3QvM2pBamlSVU05OVBWMGIwWmtoNHpCUnVrTDYvK3BwL3BuWFJXa1ltUlE5TFVqUzVmcllZdGl5QVV2S0tFdmFtQXFmRFNyTm9CVTRTdkVmWm4zZ0pwdkpFN0s3bUcxZDNPVjUvZW5qWkJMZkthcGk1M3VuT1hIRjFGWURqeFluZ0xzbWx4VHNTSDgvdGJyT2IxR25VOWFMaE83YmxDYk5Dd0FVczcyVTFBdjEyK2l3clU4cWs1bXF1SDdTaHkrclQ4ekNVS3hnRWZLZm4xcHRFYkhLOG4vb1JvUGVURzZTOXBteG53VEU0bkp0TVZuZFUxUlc0S2grT3JQL0FuM2t1SGxjT1poVUFOUkFiM05xN1lScDNBMzl3bEY5QWlqV2syRXFrVmFSVXlnN0xLWjZabWZFazUxTitMQkRqYzZSYjNQbmVWdWtsRGUvTHNtNmVnVzEwNUp1WGx0ODI5eUJrQVB0ZmpBL1BCRHpJbDZXRXpHb3NkZHo0eHdxMmt0YldWZjJ3dnZSdHRuYWdkYWtBN2E2WUtUZy9HeHk2Uzd0SFhnR3Fwdm0xNnBMVjBURzcwUGFzT21LMk9BU1dwaWE0Q0Vnci9CWUcxY1NJQUFIamFZMkJrWUdBQVloTzVpL3J4L0RaZkdaaFpHRURnY1lTdUZZTCtyOHQwak9raWtNdkJ3QVFTQlFEMDlBa1FBSGphWTJCa1lHQm0rTS9Bd01CMGpFSG4vd1dtYWdhZ0NBcGdCUUJtWUFSS0FzWUFBQUk2QUVzQ09nQXNBcXdBVFFJb0FEQUFBQUFBQUdZQTFBRklBYlo0Mm1OZ1pHQmdZR1h3WVdCaUFBRkdCalFBQUFoeEFGWjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS1ZlZHJXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9KZGsyMU94dlBiZkdWZ1ptRUFnY2NSdWxiSU5QTkVKaHNneGNIQUJPSUJBQVpOQ0JzQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVMwQUFvQUFBQUFCVlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDAvbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNXWjJ4NVpnQUFBV1FBQUFIcUFBQUNIUFQvRXp0b1pXRmtBQUFEVUFBQUFDOEFBQUEyS05LZU4yaG9aV0VBQUFPQUFBQUFIZ0FBQUNRR01nSGRhRzEwZUFBQUE2QUFBQUFRQUFBQUVBdFpBSUpzYjJOaEFBQURzQUFBQUFvQUFBQUtBV0lBc0cxaGVIQUFBQU84QUFBQUdBQUFBQ0FBQ0FBNmJtRnRaUUFBQTlRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRXFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzWTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCbVp2Z1A1RE5EcEpIVS9BY0tBd0R6QUExS2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqTy8vOERTY2YvLy84ZkFQTVpBRks1QnA5NDJqWFF6Mm9UVVJRRzhQdmRrN25USkpPWjZLUXpsYVpUMHZ5WnRwS2tkSWFadG9zb2pZazF4YlEyVUlJRWdvSVdCQVUxUmhjdXNvZ0xRVmRDUVZ5NGNlY0R1SEhscWcvZzFvVzRFaDlCa25oSDZMbWJ3OGRkL0w3RE9Ddk1adnduLzhHcWJKT3hFRUc0YWRsbXh2SUNTMVNodWlYWEQyd3JDS3ZJcVNKajJZR3RRK1pSN05VUWV2UUY5MFFtSlZDenl2UFFsTUZvVGtFcWFmb1VWNmV6ZGlwcnBnZ3A1YVNyUVl1djFONy95UTM1Y1JweFl6S3lERnBTUVFRK1o2aUFadDl2akRPRk5MaWhpeWhPR0FMNU14d3hPY1F1enlZaytGZm1zSFcySmFXbW4zZUZ0T1Vjek90UUhkakNnRkJ6NHIvWGpIQkJ5YzJYaEVybk84a1AzcWUzaSs2U1lhRGJ1MHVqem40SC9IcjY1clBwdTZ5dTd6Z2ZUL3NEamtwOXZHd3FqOTcwaHB4djdIMXJ4Z0Q5a0c5ZjRKUlZ3Vy90dEU2TVJIdDdmMWV2eGFJR01OR2dKODNDTlE3ajB1UXpQVzhYRDJuNjY2SklNQWJtelg1VGtuK1B6Q0FkZVhuUksvQkxyalJIWU50QktNOGJDWmZoeUFJeXI4QU53dWhadG1XSHNnNGxycEpJeEJWd0hCODBYbTAwRjRXRjJNc2JxLzNBTDR0WVhGV28zRng3WEgveGdhamp0NTZPTzJ1cllrK0h4cyttZjNWcFZvM1M3UWRBZmF2YlgraVZoM2M0VnRZcnZZVWt3TFdIdTBVUGREcDZQV2o1UnhRckZQVURuUk5qL3dBZDBscitBQUI0Mm1OZ1pHQmdBR0oyUWMrLzhmdzJYeG1ZV1JoQTRIR0VyaFdDL3YrU21adnBMcERMd2NBRUVnVUE5K1lKS2dCNDJtTmdaR0JnWnZqUEFDUTVHRlQrWDJEbVpnQ0tvQUFXQUVyM0F4VUFBQUoyQUFBREFBQWtBd2dBS3dMYkFETUFBQUFBQUZRQXNBRU9BQUI0Mm1OZ1pHQmdZR0d3WkdCbUFBRkdCalFBQUFhU0FFTjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTEzLjk5Mzk5NycgeT0nLTI3LjU2NDIyMSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTYuNzk5NDEyJyB5PSctMjYuOTU1Mzc1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTEyLjYzNDQ0MycgeT0nLTIzLjk0ODg1OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS41MjExJyB5PSctMjMuOTQ4ODU4Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01LjM4NDE0OScgeT0nLTIzLjk0ODg1OCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTMuNDA5Mzg4JyB5PSctMjcuNTY0MjIxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg0Ni40MDM3OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni42NTM3OCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0LjMyNTgyLDQuNzg0MDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTcuNzAxOTc0JyB5PSctMjIuOTUyNTk0Jz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ0LjE2OTU0LDM3LjczODMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDEuMDgxMTggMzMuODI4NTdDLTQ2LjQ3NDQ5LTEuMTM0MzUtMzUuODg3Ni0yOC4zODUzLTguNjk1MzYtNTAuMjI0NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjc3OTY1LC0wLjYyNjE2LDAuNjI2MTYsMC43Nzk2NSwtOC41MDA0NiwtNTAuMzgxMDQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00Ny43MDk2MywtMjEuNzY1ODUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xNi44MDE3MzgnIHk9Jy0yNi45NTUzNzUnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTMxLjc1MTUxIDQxLjM1NDMxQzIuMzI5ODYgNDYuMzc0MjggMjguNjcyNDkgMzUuOTMyODUgNDkuNzUwMjcgOS4zMTk0OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjYyMDgyLC0wLjc4Mzg3LDAuNzgzODcsMC42MjA4Miw0OS45MDU0Nyw5LjEyMzUyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNy4xNzg0LDM5Ljk2MjE5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+aDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2UtZGFzaGFycmF5PSczLjAsMi4wJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KPHBhdGggZD0nTS0zMy44MjgwOCAzMy44Mjg1N0wtOS4yNzcxNiA5LjI4MTA3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTQsLTAuNzA3MDUsMC43MDcwNSwwLjcwNzE0LC05LjEwMDM3LDkuMTA0MzEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTS0yOC42MzMzOSAxNi42MjgwN0gtMTQuMTE4MjlWMjkuMTE4MDZILTI4LjYzMzM5Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTI1LjYzMzM5LDE5LjYyODA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+aDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTYuODAxNzM4JyB5PSctMjYuOTU1Mzc1Jz7igKA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        
    \SpliceDiagramSquare {
      sw = A,
      se = B,
      nw = A',
      ne = B',
      south = f,
      east = g,
      west = f^{*}(g),
      west/node/style = {right},
      north = \varepsilon _{g},
    }
  
        \node  [above left = of nw] (c) {$C$};
        \draw  [->,morphism,bend right] (c) to node[swap] {$h'$} (sw);
        \draw  [->,morphism,bend left] (c) to node {$h$} (ne);
        \draw  [->,morphism,exists] (c) to node[desc] {$h^{\dag }$} (nw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Note that <fr:tex
display="inline"><![CDATA[h]]></fr:tex> is a morphism <fr:tex
display="inline"><![CDATA[h\colon \Sigma _{f}(h')\to g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. Thus, it corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[h^{\dag }\colon h'\to f^{*}(g)]]></fr:tex> under the adjunction.</fr:p><fr:p>The transpose of <fr:tex
display="inline"><![CDATA[h^{\dag }]]></fr:tex> can be computed as <fr:tex
display="inline"><![CDATA[\varepsilon _{g} \circ  \Sigma _{f}(h^{\dag })]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> is the identity on morphisms, we have
      <fr:tex
display="block"><![CDATA[         (h^{\dag })^{\dag } = \varepsilon _{g} \circ  \Sigma _{f}(h^{\dag }) = \varepsilon _{g} \circ  h^{\dag } = h       ]]></fr:tex>
      Thus, the top triangle also commutes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1190</fr:anchor><fr:addr
type="machine">#329</fr:addr><fr:route>unstable-329.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has pullbacks. Then we can take <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> to be the pullback functor. It remains to check that <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex>.</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
      
  <html:tr>
        
  <html:th>Unit</html:th>

        
  <html:th>Counit</html:th>

      </html:tr>

      
  <html:tr>
        
  <html:td>
          Let <fr:tex
display="inline"><![CDATA[h \in  {{\mathcal {C}}_{/{A}}}]]></fr:tex> be an object, we take <fr:tex
display="inline"><![CDATA[\eta _{h}\colon h\to f^{*}(\Sigma _{f}(h))]]></fr:tex> to be the unique morphism given by the following pullback:
          
    
      
      <fr:figure><fr:resource
hash="c09b8b07b92837716709f79f64e26dcc"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI0My4yNTI3NDdwdCcgaGVpZ2h0PScxODEuMzgwMTM0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTYyLjE2ODQ5OCAxMjAuOTIwMDknPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVA0QUFvQUFBQUFCR3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hjTjM4bU50WVhBQUFBRThBQUFBTWdBQUFEd0hMLzBNWjJ4NVpnQUFBWEFBQUFFcEFBQUJPTkNXS2VGb1pXRmtBQUFDbkFBQUFDMEFBQUEyS01HZGFHaG9aV0VBQUFMTUFBQUFIZ0FBQUNRR1F3S1JhRzEwZUFBQUF1d0FBQUFRQUFBQUVBbW9BUU5zYjJOaEFBQUMvQUFBQUFvQUFBQUtBTXdBWUcxaGVIQUFBQU1JQUFBQUZ3QUFBQ0FBQmdBaWJtRnRaUUFBQXlBQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRDdBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXltS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHBxTUM5bVp2Z1A1RE16TUlLRUdSRXEvZ09GQWUxM0RhZ0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5bW95TC83L0g4alhBTkgvYi81SkFLc0NBZ0NZbXdrNUFBQjQyaVhPdlU0Q1FSUUY0SHRtTmpQT3lzK0N1QnMxRVphVlJRdElGTmlORktLTldsQVNDNE9Ga2xpaENVYnRVT05QWStKRDBQb01sc1pIOEEwb2pJbTJhdUxxRUhKUGNhcnZYQUtkL2dGWG5HaVdDSTZka1NJSklZV3RheEorVVYvb054Q2dHNWR5b3k1WE9YWU9UUm0vcXlVbUM0eVZFZ0VuTUV0VXUxYnY1ZUY3VDFrTUIzMDMxKytjM0JTdU5VbmIybStOL1NtdE9yYk1DSm1BSDFZYldFTllSdEd2QldIN05oaUJTL25nZUE0ODJXcUQ5ellWQktleHRqdFkzKzh3a3h1cDV1ZmdlVmczaFdKRUkzK0xpUDJ3SjhvUktiajZWWjJ3SXQyOFh3c1YvTUJ4SGE4TTZlcHhpY2ZvQXl1bHhjcXlYYmE4N085OUxNVXdIYjBobG1ibldjKzY2RWZSME9CQU14cUNZOFphT1BzeXpBbk00eWl0OEg3Wk5LSlhvU1RSUDVMY08wUUFBQUI0Mm1OZ1pHQmdBT0s1T1cvYTQvbHR2akl3c3pDQXdPTUlYVk1FL1orUjZSY3ppTXZCd0FTaUFCOCtDV2dBQUFCNDJtTmdaR0JnWnZqUEFDU2RHZHdaUEpsK01RQkZVQUFMQUVTTEF0c0FBQUxUQUFBQnlRQjBBY2tBU0FOREFFY0FBQUFBQURBQVlBQ2NBQUI0Mm1OZ1pHQmdZR0ZRWkFEUkRGQVNDUUFBQkF3QUtRQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmtBQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUN3QUFBQTJLaHVkUTJob1pXRUFBQUk4QUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQWx3QUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ1pBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSnNBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb1FBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEVkFBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpbWxYcWErUDViYjR5TUxNd2dNRGpDRjFUWkpvbGxQRU9rT0pnWUFMeEFQbkZDQjE0Mm1OZ1pHQmcxdnBqeWNEQUVzclF4OURQbE13QUZFRUJUQUJTZ0FOQ0FBUlZBQUFDOGdDT0FBQUFBQUJVQUFCNDJtTmdaR0JnWUdJd1pRRFJERkFTQ1FBQUJjb0FPd0I0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQ1VsWVdCaVpXcEMyQ0RNc1JCZG9nVXFlckk3KzdoZXVnTnArZjl1QU5LZnNoNFRzWnIzTS9KS1VUOWNjRUxiNG1ub2hhSlN6NVlNaUhMWitMTTJTVE9KZmxLWFBET0pmRlUvTy9FSlo4OHRsMTd1L2ZXcTMxbnJIZm5Ob3pyZy9XaDZaeGE2U3JxblhYV0gzdHIxR2xVWm1qQ2NHMVZyU3RkczZXajVjYWRIb3RIc1JmSFJIYWNKUXVNckRsRUo5Qkk2cVMxUWxQOXkzZVN1OWc1eGs5R09pZEpsTkFnVjBIMlZkcUtPbDVxNmwvdjZUQkhBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdZQUFvQUFBQUFCcUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjRDMk50WVhBQUFBRThBQUFBT3dBQUFFd0VQUVNOWjJ4NVpnQUFBWGdBQUFLN0FBQURWT0xUM3pob1pXRmtBQUFFTkFBQUFDOEFBQUEyS0kyZFhXaG9aV0VBQUFSa0FBQUFJQUFBQUNRRnJnR2NhRzEwZUFBQUJJUUFBQUFVQUFBQUZBd3VBUGhzYjJOaEFBQUVtQUFBQUF3QUFBQU1BYTRDaEcxaGVIQUFBQVNrQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQkx3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRmpBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXltZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVc5blp2Z1A1RE16TUlLRUdSRXEvZ09GQWZrT0RmOEFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdzZ0RRWEF3ZFFqb2toalNHRGVTdno5di8vZ1dKdzl2L1ovMmY5OGZ2akM5WUJCUUI1YlE3SEFIamFSWkk5Yjl0V0ZJYjVIbEtYRXI4dUpaS1hpaVZUSHhSSjJVa3B5VkxJMkZJa3h3b1MxRzZiandJTjJpWElrQ1ZMbGhRWkF2UW5GQjB5ZE0wV2RPbWZDSklsUU5ILzBMRkFwM2EwZTJVRnlEM0FIYzY3bk9jOFI0RnlkakdpWi9TbmNxd29VRG1ZN2tEdnA5a1NVeEVLcG9zT2xsaXBNVXVMY0xwRUtmc0hJblFRcDFsYWxPa0lEbkZNQzhFeXZEbHlOWGVuZG1zeVBBSUdRYXFDZHpqbmc1NjZtL092SXZMNEF4NDQ0aVRlV3dDeGtMa2JjZDVvUkVaMTUvRW14dXZ6ZDZmMTQ1bS9WdE00NnRLQVpXYU5vSjBGdi83N1NPM3JlUFI5SzB1VHdlY0lWOUl2ZnRiNlZTanlRZm42NGo5NlJSK1VzdzJMSERZaW5XMlJBaFllRkdVeERTUG9USllrbkswZ08yV1JacEtZY1UweTViaGVla3VrOFhZQlpTRjAzUHFtL2ZEd3pzd0MrZVJadHFHMk80c0cxUTJHMEt6SHkrRU5xTFlqQkpFWUx1NDNlY1hyMXFwR1dHdlVLNzlveEFjMUYzRDAyOWNTME52ekQ3MHBLcU9ablMvWXZOWHIxZnUwdXRrZ0NzZWh5TFhSbm1WMkJ5ZnJTVEFoV2crRmVmcFQydUltUEZ2UWJac2Jtc0dydXFaYUNpbmppNy94RC81UTVzcGFVVW9ISVF1bHB3MWdHV0VEbkVQT1gyNy9Ra2hvYVN6TmNtbFdHZzJYQ0l1Tnc0eGxZa1Vqc04rbUNURGY3VXp2M1cxb1ZadUc3dVRaZDA5Qk56cHFUTnJySjlaQnJ6NEFBbUhFUi9hRGx5b2w2ZHpxamVXTzIxZk5xSm40emVib3I5YksyMjhaUksxSUIxcVpsV280UFJxZk5KQjBqcjhGbU1NQzEvWkk5dzFNOXZ1ZVV3VnN2MjFDU3lveTFVQmJoK09MaE83Z3ZYSno0M0I3aTlJSlhWcHl3TWxSMDJ5bEZ0ZG5uem9qNU5MamtpNnhJbm1NdEhoT3dZN2pRM3VocVNUMjV0S0tvZS82bFZyUTltRmN0VXpHdmFodlZuVERaQkRjeWc2L3JFNS82TjZWam9Id2ZHWEY1TllEZkxTYncwc1R3VTcwNDMyZk8zRHIrNytQODlBTjJzQng3cHNnY3RkdDBhWGtjRDZnamRpV1JQZ2ZGNlJvZ1FCNDJtTmdaR0JnQU9LY0FsM3BlSDZicnd6TUxBd2c4RGhDMXhSQi8xZGxPc1owRWNqbFlHQUNpUUlBN0lRSTBBQjQybU5nWkdCZ1p2alB3TURBZEl6QjRQOEZwbW9Hb0FnS1lBVUFacndFVGdMR0FBQUNPZ0JMQXF3QVRRSW9BREFDV2dBd0FBQUFBQUJtQU5vQlNBR3FlTnBqWUdSZ1lHQmw4R0ZnWWdBQlJnWTBBQUFJY1FCV2VOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUVFBQW9BQUFBQUJKUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaGNONFptTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SEwvME1aMng1WmdBQUFYQUFBQUZDQUFBQllCb1BpRkZvWldGa0FBQUN0QUFBQUMwQUFBQTJLVGlkWjJob1pXRUFBQUxrQUFBQUhnQUFBQ1FHMUFNOWFHMTBlQUFBQXdRQUFBQVFBQUFBRUF0N0FWNXNiMk5oQUFBREZBQUFBQW9BQUFBS0FPWUFhRzFoZUhBQUFBTWdBQUFBRndBQUFDQUFCZ0FxYm1GdFpRQUFBemdBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFFQkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdJTkdCaVNRVWx5V0RwVFVZRjdNelBBZnlHZG1ZQVFKTXlKVS9BY0tBd0FYcWc0Y0FIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXltb3lMLzcvSDhqWEFOSC9iLzVKQUtzQ0FnQ1ltd2s1QUFCNDJpMlBQVXZEVUJTRzc1dWIzSHphRDYySnJhUTBLU1JDdFlLbWFVRmk2V2hkUktIU1FnY3BpcVBGUlIwRjk4NytndjZJam9LTGcvZ0xCQWMzRjNFUU5mV2FlczV5M3VWOXprTkFicWNFOTVTUUlpRklRV2FXbVd5T3VYNFZ2dWVIOVczVXd3MXprZUZ1LzBhaXJxS3RYU2hnaFpiVExrV2lHSlhhVHF2QUlMeUdINVArNVpKMWRTeHFvaGJZdmVoc1BCNUdYVHZRUkpYd0FSbHcxb2l6bG5sZzhoL05XMGVRQU9ZOTMrT0hWWVJsWXZUZlNnWEpQL1JxT0RtWEtaMEJRV2Fka0JSRnRBZWRheFMrK3JvdUlRRnl4dEYwU29mQ2hLd1Fvc0l4bTBnRU5xbkR2SnBYVjFGRkxRZ3R4eXB6dXlyS3pvSXBtL2lNbjNCZ05QSmJsWHlVcnJnL2daRVRNbGlOSDJXYVRRc1Bic1ZvbE96VFp2ejhyWU5pTjM0RGZ5Mmo3SFc0RURNVUhWbDBtYXBrWkx6dmRGSnpSdnhpeUJKWC9nVnJPRUhWQUFCNDJtTmdaR0JnQUdLT0tkclI4ZncyWHhtWVdSaEE0SEdFcmltQy9zL0FYTWdNNG5Jd01JRW9BTnZyQjRVQUFBQjQybU5nWkdCZ1p2alBBQ1N2TWlReUpETVhNZ0JGVUFBTEFFMHVBeGtBQUFOU0FBQUNLZ0NhQWlvQVl3UFZBR0VBQUFBQUFEWUFhQUN3QUFCNDJtTmdaR0JnWUdIUVpBRFJERkFTQ1FBQUJOUUFNUUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS1ZlZG8yaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9KZGsyM3V4dlBiZkdWZ1ptRUFnY2NSdXFiSU5QTkVKaHNneGNIQUJPSUJBQWpEQ0NVQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUm9BQW9BQUFBQUJRd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMWJHTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWZBREJaMng1WmdBQUFXd0FBQUdpQUFBQjNQNTNiMFZvWldGa0FBQURFQUFBQUM0QUFBQTJLUnVkWjJob1pXRUFBQU5BQUFBQUhnQUFBQ1FHY1FKUGFHMTBlQUFBQTJBQUFBQU1BQUFBREFsZkFQcHNiMk5oQUFBRGJBQUFBQWdBQUFBSUFISUE3bTFoZUhBQUFBTjBBQUFBRndBQUFDQUFCUUJSYm1GdFpRQUFBNHdBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFFWEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtbG1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F3TS93SDhwa2gwa2hxL2dPRkFibVBETjRBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpGay9QOFA1SVBwLzdQL3p3S3JBZ0lBbVBJSk53QUFBSGphSGRCTlR0dEFGQWR3dnpmMmpCT1B4MTh6dG9sSVN1eklUbEpJaWhJYzBhWkpxeUNFUUh3dEVSSUhRT0lBVlJmZFZxcmFYb0ZiZEYrcDZnRjZDQTZBdWdYRzBiekZ6THkzZUwrL0FjYm41eDM4Zy8rTUk4TUE0Z0ZsQWhndHlnVk00a1JTRnIrQ0JjeXFKVlN6bkJaNzB5cVoxUGYxaVJNQmVWRVcxYXdZUThhb0I1TXFsb3d5ZU5oM0cwRXIvTGlUblJJWXFDR1J5aE5SdTJjRjRXYmdYTG1SOUc0RU5WUGJ6Uy83eDNva0hoTGdIZCtMV2ttVHAzZXV0SWtKMzU1K0xiTDVvRFZCeUVaWlJzcWcyMlNBV0tubDdmM3RXNkN1Yk1CRmQydnFCMk1UZXR2MUNDMkZqWkQ2eTU5QU54d0NobVlaWDU3LzR5UCtOYzVybytaMFFPbGw2MUkwMFcrTlRiUldiMDdaQ01xcEZ0YklhWkhyTUFSNHVIYk9JdjJwcFRxZGFwMUlyR0w0ZEJIZm5KeWRZR1RKcHNld1d5NkVhWFBlZ0RZUCtxdnhCeUErVjZoMFkzNjlKVVV6WTlhbW41dm1keFBCRnJrVElsSmkvZUFTOFA3cGQzdEZZRlVOMy9IOXRKUitUdkJnMjJzZ09uSlhocHI0WnNDZHN2T2V6a2RaSHc5M08vbnJyMm1rb0pmZ1hrZ3BCZFNSY0kzbVlMbm1DNCsxTy8wQUFIamFZMkJrWUdBQVltZGREZDU0ZnB1dkRNd3NEQ0R3T0VMWEZFSC8xMlVPWWJvTTVISXdNSUZFQWREN0Irb0FBSGphWTJCa1lHQm0rTThBSkVNWXF2OS9aL3JNQUJSQkFjd0Fib29FeFFBQUExUUFBQUs4QUhzRFR3Qi9BQUFBQUFCeUFPNTQybU5nWkdCZ1lHWUlZQURSREZBU0NRQUFDSWdBVndCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDArMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNWWjJ4NVpnQUFBV1FBQUFGTEFBQUJZRG1Tc1RKb1pXRmtBQUFDc0FBQUFDOEFBQUEyS00yZVFXaG9aV0VBQUFMZ0FBQUFIZ0FBQUNRR0xBSU9hRzEwZUFBQUF3QUFBQUFNQUFBQURBaCtBRTlzYjJOaEFBQUREQUFBQUFnQUFBQUlBRlFBc0cxaGVIQUFBQU1VQUFBQUZnQUFBQ0FBQndBNmJtRnRaUUFBQXl3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaVp2Z1A1RE5EcEpIVS9BY0tBd0R5S1ExSGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoTy8vOERTY2YvLy84ZkFQTVpBRktvQnA1NDJqV1BNVS9DUUFDRjc5M0JIV0RiUTF2YUdBRlRRWnBvRkVOSkt3d01LbWcwRXBURU1KQ1ltQ2liZzBGY0dSaDFNakZ4Y25IekI3ZzRPZmtuSEl5anZ3R3dOZkZOTDEvZThEMUNTWDQ2cFYvMGt4UkppUkFmbmw4eUxkMHdYYy9rUlFpbjRKUTl5L1Q4SW16QkRkUHlMQTBCRDdGYmcrK3lWNXh6UStXb21Xc3BLTkgrTUJhRk9xT1hXVnhNcGswMXJhc01hclRYVWFERWwycVBQL2FBbmlRUmwrT2hLVmxHZ0RIUW1CU0FZbDNVUjBZK0NTbzFIdUtFNU1oOTRKZ0VZV1IxT21hY3ZwRXNXU0diZ2FsZXpqazhjTE96U0drUVdWaGNnZ3ViLy9ucW9aeFhjSElGTHRoL1o4SEFmYjViY0RKU290TTlZOFAyUVJ0ME4zbDRQYmxQYTFvMSsvUncycWRZM3g0dDZ0SEwyKzZBMG8yOTkwWUUwRnEwTWt0WldvQWVWZmQ3TXRHc0hHeHB0VWo0QURycTdLcVIzNkdROCtNWGR0TmNickhKOXh4UGtGK3p2VHVEQUhqYVkyQmtZR0FBNHRZcklwengvRFpmR1poWkdFRGdjWVN1S1lMKy81ZVpqZWt1a012QndBUVNCUUQrdmdsSEFIamFZMkJrWUdCbStNOEFKRGtZVkJpWW1Oa1lnQ0lvZ0JrQUk4Y0JRZ0FBQW5ZQUFBTUFBQ1FEQ0FBckFBQUFBQUJVQUxCNDJtTmdaR0JnWUdhd0JHSVFZR1JBQXdBR2R3QkNBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTE0LjcyNDc0NycgeT0nLTIyLjk0MDY5MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTcuNTMwMTYxJyB5PSctMjIuMzMxODQ0Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTEzLjM2NTE5MicgeT0nLTE5LjMyNTMyNyc+KM6jPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00LjU2NDgxNCcgeT0nLTE4LjI2ODE4Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0uMDcxMjEzJyB5PSctMTkuMzI1MzI3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzMuMDQyMTMnIHk9Jy0xOS4zMjUzMjcnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nNy43MDYzODknIHk9Jy0xOS4zMjUzMjcnPikpPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDc5LjkxMjA4LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0xNC4xNDAxMzcnIHk9Jy0yMi45NDA2OTEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4MS4zMTQ4NywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg3NC44NTY1NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3NS4xMDY1NCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMwLjk2NTAxLDYuODcyOTEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMTguNDMyNzI0JyB5PSctMTcuOTkxNDMxJz7OozwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTMuNjU4ODc5JyB5PSctMTYuMjQ3OTY5Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy05LjE2NTI3OCcgeT0nLTE3Ljk5MTQzMSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNi40NjcwMjMnIHk9Jy0xNy45OTE0MzEnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTIuMzQ0Njk0JyB5PSctMTcuOTkxNDMxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004NS4zNTgyNi02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDg1LjM1ODI2LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODguNjIyMTUsLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+zqM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE2LjUwOTcxJyB5PSctMTguMjY4MTgnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTEyLjAxNjEwOScgeT0nLTE5LjMyNTMyNyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctOC45MDI3NjYnIHk9Jy0xOS4zMjUzMjcnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQuMjM4NTA4JyB5PSctMTkuMzI1MzI3Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0LTU2LjkwNTVINzYuMjU5MzInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzYuNTA5MzIsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQwLjE5MDM4LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ1LjY4NDQ4LDM3LjczODMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0xNC4xNDAxMzcnIHk9Jy0yMi45NDA2OTEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTQxLjA4MTE4IDMzLjgyODU3Qy00Ni40NzQ0OS0xLjEzNDM1LTM1Ljg4NzYtMjguMzg1My04LjY5NTM2LTUwLjIyNDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43Nzk2NSwtMC42MjYxNiwwLjYyNjE2LDAuNzc5NjUsLTguNTAwNDYsLTUwLjM4MTA0KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDUuMDA0NzMsLTIwLjgzMTM4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+aDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzEuNic+CjxwYXRoIGQ9J00tMzAuMjM2NTcgNDIuNDA1MjZDMTIuNjU3MTIgNTIuMDcyMiA0Ny40MzYzNyA0MS4yNDEwMSA3Ny4yNTUxNCA4LjkyNzU1JyBmaWxsPSdub25lJy8+CjxnIHN0cm9rZS13aWR0aD0nMC42Jz4KPGcgc3Ryb2tlPScjZmZmJz4KPHBhdGggZD0nTS0zMC4yMzY1NyA0Mi40MDUyNkMxMi42NTcxMiA1Mi4wNzIyIDQ3LjQzNjM3IDQxLjI0MTAxIDc3LjI1NTE0IDguOTI3NTUnIGZpbGw9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00tMzMuODI4MDggMzMuODI4NTdMLTkuMjc3MTYgOS4yODEwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE0LC0wLjcwNzA1LDAuNzA3MDUsMC43MDcxNCwtOS4xMDAzNyw5LjEwNDMxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00tMjguNzU0ODIgMTUuMjY2OThILTEzLjk5Njg1VjI1LjY0MTk1SC0yOC43NTQ4MlonIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yNS43NTQ4MiwxOS42MjgwNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPs63PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xOC4wOTE5NTgnIHk9Jy0xOC4yNjgxOCc+aDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                width = 3cm,
                sw = A,
                nw/style = pullback,
                se = B,
                nw = A',
                ne = B',
                south = f,
                east = \Sigma _{f}(h),
                west = f^{*}(\Sigma _{f}(h)),
                west/node/style = {right},
                north = \varepsilon _{\Sigma _{f}(h)},
              }
              \node  [above left of = nw] (c) {$B'$};
              \draw  [->,morphism,bend right] (c) to node[swap] {$h$} (sw);
              \draw  [double,morphism,bend left] (c) to (ne);
              \draw  [->,morphism,exists] (c) to node[desc] {$\eta _{h}$} (nw);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          <fr:p>where <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> is the counit defined on the right. Then naturality is a consequence of uniqueness.</fr:p>
        </html:td>

        
  <html:td>Let <fr:tex
display="inline"><![CDATA[g \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex> be an object. We take <fr:tex
display="inline"><![CDATA[\varepsilon _{g}\colon \Sigma _{f}(f^{*}(g))\to g]]></fr:tex> to be the following morphism.
          
    
      
      <fr:figure><fr:resource
hash="713a053a883955433c0f73df139f72b9"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzOC44MDA0NDNwdCcgaGVpZ2h0PScxMTcuODQ5NjI0cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTIuNTMzNjI5IDc4LjU2NjQxNic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9VQUFvQUFBQUFBL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFYR050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFEWUFBQUEyTlZxTFR0b1pXRmtBQUFDUEFBQUFDOEFBQUEyS1J1Y2dtaG9aV0VBQUFKc0FBQUFIZ0FBQUNRRjhRS2FhRzEwZUFBQUFvd0FBQUFJQUFBQUNBWWhBR1ZzYjJOaEFBQUNsQUFBQUFZQUFBQUdBR3dBQUcxaGVIQUFBQUtjQUFBQUZnQUFBQ0FBQlFCRmJtRnRaUUFBQXJRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGhBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTZRek0vd0g4cGtoMGtocS9nT0ZBYlFlRE04QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOUR5UCt6d0h3R0FGVzFCc01BQUFBQUFnQmwveXdDaWdIRkFDNEFRd0FBQVFNT0FTTUdMd0VtSno0Qk1oWVZGQVlIRmg4QkZqNENQd0VPQVFjdUFTYzJOelkzTmpjeUZoYzJOeDRCRlFjM05pOEJKaWNPQVFjT0FSVWVBVGMrQVRjK0FRS0ZiQlNQYXk4MUN6TUVBU1V5RmdvUUFpSXRGejlIR0FZWUVrd3lTMllDQTBVUkVsQmhJa0FaRVNJVEU1WXRBUlVFRnp3cFNCWWRIQUk1SUNoRkhRNEpBWFgrVEV0SUFna0REQzhkSlJvUENCd1BCUUlCQVFvd01CeGhFQ1VDQVZ4U1kwd1REMElER3lJbkFRRVZEdnU0Q2lNR0lnUUJNQ012ZFNFN0xBRUJKeDBQRHdCNDJtTmdaR0JnQU9LNWEzZkt4dlBiZkdWZ1ptRUFnY2NSdWw0SStyOE9jd2pqVVNDWGc0RUpKQW9BRm1NSmZ3QjQybU5nWkdCZ1p2alBBQ1JER0ZJWm5KbTZHSUFpS0lBSkFFQVdBcElBQUFOVUFBQUN6UUJsQUFBQUFBQnNBQUI0Mm1OZ1pHQmdZR0p3QVdJUVlHUkFBd0FIV0FCTEFBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmtBQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUN3QUFBQTJLaHVkYldob1pXRUFBQUk4QUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQWx3QUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ1pBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSnNBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb1FBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEVkFBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpbWxYcWtmSDhObDhabUZrWVFPQnhoSzRYTXMwU3luZ0hTSEV3TUlGNEFPOXZCL040Mm1OZ1pHQmcxdnBqeWNEQUVzclF4OURQbE13QUZFRUJUQUJTZ0FOQ0FBUlZBQUFDOGdDT0FBQUFBQUJVQUFCNDJtTmdaR0JnWUdJd1pRRFJERkFTQ1FBQUJjb0FPd0I0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQ1VsWVdCaVpXcEMyQ0RNc1JCZG9nVXFlckk3KzdoZXVnTnArZjl1QU5LZnNoNFRzWnIzTS9KS1VUOWNjRUxiNG1ub2hhSlN6NVlNaUhMWitMTTJTVE9KZmxLWFBET0pmRlUvTy9FSlo4OHRsMTd1L2ZXcTMxbnJIZm5Ob3pyZy9XaDZaeGE2U3JxblhYV0gzdHIxR2xVWm1qQ2NHMVZyU3RkczZXajVjYWRIb3RIc1JmSFJIYWNKUXVNckRsRUo5Qkk2cVMxUWxQOXkzZVN1OWc1eGs5R09pZEpsTkFnVjBIMlZkcUtPbDVxNmwvdjZUQkhBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVR3QUFvQUFBQUFCYndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjM4bU50WVhBQUFBRThBQUFBTWdBQUFEd0hGZjEyWjJ4NVpnQUFBWEFBQUFJZUFBQUNoQkxGdkVab1pXRmtBQUFEa0FBQUFDOEFBQUEyS0kyZGoyaG9aV0VBQUFQQUFBQUFJQUFBQUNRRm1RR2JhRzEwZUFBQUErQUFBQUFRQUFBQUVBbGlBS2RzYjJOaEFBQUQ4QUFBQUFvQUFBQUtBYWdBMUcxaGVIQUFBQVA4QUFBQUdBQUFBQ0FBQndCRmJtRnRaUUFBQkJRQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRTVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWltQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVc5bFp2Z1A1RE16TUlLRUdSRXEvZ09GQWZCNURlWUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5cVl6Yi8zL0g4aFBBOUgvWi8veEE2c0NBZ0NpSndtSkFBQjQya1hSUFcvVFFCd0djRDkzN2psdjl0bXhmVzZUMUhseGJJZlN4bW5jT2lpdDh0SldRbTBScFVLaUtrSWdoaTZka0JoQWZBZ0cxSUdWbFcvQTNoM3hIUmlSbUJoWVVzN3R3SjEwd3owMy9ILzNLRkNPYnhKeVNYNG9NMFVCNVdDYUFhMFR4Uk9rd2hOTUUwMU1NS1VCaXpJdm5XQWs3NGZDTXhCRWNaU05vZ1FHNFVnendXSjhHWnVxV1N2T04zdGpvT3RHRkx6Sk9lKzI2V3FmUC9LSnpVKzVhNGk5NE40dUVBaVptejduMWFwZkt0UmU1VEd1RnRkSDFtekwyYWRSNExkSWw4WGxJb0Y2N0g3K2MwWTdHczdPNjNFVWR2OUhXSWsyUHFxZEFoUzVpTEorczBGQ1hDdDlaVC9YU0FtN2xjaUpIYVo1SWhXWkJFd2xzbzg0RytYYmh5ZFY4Z0dkSW9zbGltbjVGd2h2bUQ4bDdUZkZ0KytUbDZxYzF4SXdxZzJyN2V3R0RhRjVvOFA1T2FGemJoMmU5N1oxV3F2cUxqNGxGSTY3VmR0dnVhYUZLUGIzR2hVTkh4Yno1RGtsN3ZwcTI3YkxmbW1Kb054WUdiUmVwQ3JPbmx3OHR2a0JSVmVZQXFhMStQdU5sOE5BUlc4N21zOU9SZ2hiWEwrMURXNSs0VGUrS3p1NWJXVEFZNTdzWm5objRIY2tLYms3TStGSm1DRkg2TXMyWllzUzZXVjViekdMeFpRa1lGL1RFTmhaYmFZbkQ2dHFRU2M5Yy9QeTJRWElneVlOaUhyMXVqSnNXMTNBRmFWZ3JKKytveVNNZGlydEFlaWtjYi9zTDRmTzhuTHlzejYxMStvbFF1cStCdFRqU3FUaWFEellxeUpzenA0Q3pHQ3VxZHRFYzByWVhPdllSZ0hRblVZWmFyZ2tVeFZFMHY0Qi8xQlVuQUFBZU5wallHUmdZQUJpbmxVOXB2SDhObDhabUZrWVFPQnhoSzRYZ3Y2dnkzU002U0tReThIQUJCSUZBUDVtQ1ZVQWVOcGpZR1JnWUdiNHo4REF3SFNNUWVmL0JhWXNCcUFJQ21BQkFHVWNCRGdDeGdBQUFqb0FTd0k2QUN3Q0tBQXdBQUFBQUFCbUFOUUJRZ0FBZU5wallHUmdZR0JoY0dGZ1lnQUJSZ1kwQUFBSGpnQk5lTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNQUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQ3dBQUFBMktWZWR6V2hvWldFQUFBSFlBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZmdBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQUFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJSUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpQUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM4QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPSmRrMjA2NC9sdHZqSXdzekNBd09NSVhTOWttbmtpa3cyUTRtQmdBdkVBL2w0SCszamFZMkJrWUdCVy9HTUVKQ2N5R0RMSU1wb3dBRVZRQUJNQVFSb0NiZ0FBQTVFQUFBRlJBREVBQUFBQUFDQUFBSGphWTJCa1lHQmdZdUJuQU5FTVVCSUpBQUFDRkFBVkFIamFUWXc5YjhJd0VJYWZpQVNKZE9oU2RlZ0FIcGl0b0ZSaVkyRmdZbVhxQXRpZ0RIR1FIU0pGcWpyeXUzdTRIbnJENlhrLzdvQ1NIektlay9FYTkzTnlDbEYvWFBEQ1crS3BxRVhpa2crV1RNanltVGh6Tm9selNiNFNGN3h6U1R3Vi96dHh5U2VQYmRmZTdyMzFhdDhaNjkyNURlUDZZSDFvT3FkV3VvcDZaNTMxeDk0YWRScVZHWm93WEZ0VjYwclhiT2xvdVhHbngrSlI3TVV4a1IxbnlRSWphdzdSQ1RTU09tbXQwRlQvOHAza0xuYU84Wk9SemtrU0pUVElWWkI5bGJhaWpwZWEraGZ6ZVRCUEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDMEFBQUEyS0pxZGttaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNG1OdnN0VGorVzIrTWpDek1JREE0d2hkTHdUOW41SHBNak9JeThIQUJLSUFHRzhKTWdBQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLTTJlYTJob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0dFlyd2x2aitXMitNakN6TUlEQTR3aGRMd1Q5L3k4ekc5TmRJSmVEZ1Fra0NnQWZTd29jQUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00Ni41NTA1MTgnIHk9Jy02MS42Nzg5OTcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTM5LjA3ODUxOScgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMi41MzEwNCwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ni41NTA1MTgsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDYuNTUwNTE4JyB5PSctNjEuNjc4OTk3Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00MS44ODM5MzQnIHk9Jy02NC42ODU1MTUnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzcuNzE4OTY1JyB5PSctNjEuNjc4OTk3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zNC42MDU2MjEnIHk9Jy02MS42Nzg5OTcnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTMwLjQ2ODY3MScgeT0nLTYxLjY3ODk5Nyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzguNDkzOTEnIHk9Jy02NS4yOTQzNjEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOS43MDgzMyAwSDQ2LjQwMzc4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjY1Mzc4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjQuMzI1ODIsNC43ODQwMSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Ni41NTA1MTgnIHk9Jy02MS42Nzg5OTcnPs61PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Mi43ODY0OTYnIHk9Jy02MC42ODI3MzMnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NC01Ni45MDU1SDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNS45NjQsLTY0LjU3ODQxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \DiagramSquare {
              sw = A,
              nw/style = pullback,
              se = B,
              nw = A',
              ne = B',
              south = f,
              east = g,
              west = f^{*}(g),
              north = \varepsilon _{g},
            }
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          Let <fr:tex
display="inline"><![CDATA[\alpha \colon g\to g']]></fr:tex> be a morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. By the construction of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>, we have the following commutative diagram.
          
    
      
      <fr:figure><fr:resource
hash="1ee8ae6f4500f08dd08da5314907b5d1"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5OC4yMjM2MjFwdCcgaGVpZ2h0PScxNzUuNDY3NzY2cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTMyLjE0OTA4MSAxMTYuOTc4NTExJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLUnVjWW1ob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0s1YTNmR3h2UGJmR1ZnWm1FQWdjY1J1bFlJK3I4T2N3ampVU0NYZzRFSkpBb0FIa01KbndCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDMEFBQUEyS0pxZGNtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNG1OdnN0TGorVzIrTWpDek1JREE0d2hkS3dUOW41SHBNak9JeThIQUJLSUFJRThKVWdBQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPc0FBb0FBQUFBQkJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUUwQUFBQmdxbU5pZTJOdFlYQUFBQUZFQUFBQU13QUFBRHllV21SYloyeDVaZ0FBQVhnQUFBRGdBQUFBN0QwTlFsdG9aV0ZrQUFBQ1dBQUFBQ3NBQUFBMktodWRyV2hvWldFQUFBS0VBQUFBSHdBQUFDUUY3Z0RhYUcxMGVBQUFBcVFBQUFBTUFBQUFEQWtLQU8xc2IyTmhBQUFDc0FBQUFBZ0FBQUFJQUZRQWRtMWhlSEFBQUFLNEFBQUFGd0FBQUNBQUJRQTJibUZ0WlFBQUF0QUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1abWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUE0TURqSjFTWEpiT3dLWWsvc0NBV2V1UEpRTURzeGJ6Y2FBd0kwTDEvLzhNREFEb3R3N2ZBQUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFabVJnVWhKL1lQRC9Qd01EaEw3N1N2NFNXQlVRQUFDbmlRbXlBSGphTFk1UFNzUXdIRWJ6cGNNdlZOUGFQMm5Tb2s3SERLYTdrU2wxQ2lMMUVvb2JzWWpRdld0dm9PQVJSbkRuR2J5R3l6bUxtTVdzSHQvN05vK0JmYkFsZjhhT2RZeWgzN1JhMFJHMDBTYUd1MEFORWl0ME54RFVXT2ZwR3RjTWFHczA3ckxiOU5vSXZIM0tTcVgwZlgrWGM2Z3EvSXFJMnpRbitYNU9VVkY2cnppS010cEt5bFBMRDNFOGhzckdmRGc5RTJXbVFFL1QxVHhBWnRiVGJRRmxrLzBSanRQNklNckE2MGVmeGtiVzRKVmZzOFNQZ0phK284OEg5SzAySlBEeVMxTG53V3diVlBQS0FUUHMvaDVTSWFJRVAvRUNpeE1wMlQ5dWZCL1FlTnBqWUdSZ1lBQmhuZGUxOGZ3Mlh4bVlXUmhBNEhHRXJoVXl6UkxLWkFPa09CaVlRRHdBNFFrSElnQjQybU5nWkdCZzF2cGp5Y0RBRXNvUXorREJsTXdBRkVFQnpBQklkUUxOQUFSVkFBQUM4Z0NPQWNNQVh3QUFBQUFBVkFCMmVOcGpZR1JnWUdCbU1HVUEwUXhRRWdrQUFBWGxBRHdBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLVmVkcldob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0pkazIxT3h2UGJmR1ZnWm1FQWdjY1J1bGJJTlBORUpoc2d4Y0hBQk9JQkFBWk5DQnNBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFXUUFBb0FBQUFBQnBnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0RW1OdFlYQUFBQUU4QUFBQU5RQUFBRVFEeGdTSFoyeDVaZ0FBQVhRQUFBSzRBQUFEVktVZ3EyUm9aV0ZrQUFBRUxBQUFBQzhBQUFBMktJMmRiMmhvWldFQUFBUmNBQUFBSUFBQUFDUUY0d0hPYUcxMGVBQUFCSHdBQUFBVUFBQUFGQXhhQU9ac2IyTmhBQUFFa0FBQUFBd0FBQUFNQWFJQ2ZtMWhlSEFBQUFTY0FBQUFHQUFBQUNBQUNBQkZibUZ0WlFBQUJMUUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZoQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1XOWxadmdQNURNek1JS0VHUkVxL2dPRkFmd1pEZ1lBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnTWdEUUhFSUxrMHBrM01tLzkveC9JU29Pdy9zLytFL1RISDZ3V0RBQUlEQXhOQUFBQWVOcE4wczFQMDJBY0IvQitmeTN0NkY3NnN2WXBiS05qNjlwT0JEWlc2QWpneHNDZ3ZBZ1NqV1RFK0pZZ0VTOG1Ka3E4K1E4WVF6aDQ5ZXJaaTNmdXh2L0JvNGtYUFhnQm40NkR0a2tQeis5Sit2MDgzMGVBc0huUm9DUDZKaXdMQWtRTnNwS0RVZzNDRGlMbU1GbGhaWFRRRlQwNWlKMm9nelpmYnpFbkJ5OElnN2dkTkpBakRWSE01QkFmRjNSSkx3ejNadW9MUU0wT1JHaGxUZE5xRlhGc1d0dHlLYS90YW5hT3JYaFhsZ0NQOGJudWFwcHB1bXFxOERBWjQvVDhiTU5ZbnJWV3hjQnp4NmttaCtsaGdyUnBmL2k5SjFZVjdQV0xZZURYL28wd0dreTlrNm9wQ1B3aFlmSmlpbnljQ2RQQ2FxTGhFbmtnNFlrdFdYRll4R0lPNkhMa05NSzRuYnd1SEs3aUc4UXU0cENqWkNVNUF1YTBrcTFVZVRIODhyanhRT0o1RFlhY1dUSXExcEpYWW9yVFh1LzFTZXhweG5xL1BwY1ZDMmJXeGtsRGhHWFBGbGJIYmQxQUVMb3JwWXlDTitlOXhyNUk5dVJZSlo5UHUrb1FJVjBhYlk3Zmp5VHMzVDdZem12WFJkU1l6cUFiNTMrK2FHbmZrMUNmQzNyTE8yMzQ0MXAyWU90ZS9LTFBBeHR2eW5mUjVwYlp5Qm5JdUpKYi96ZngycEw4WmJoSU91VXdQZzBTbVdQeFhtTnFTaXl0MWpLbUtpT2FHdTFZazhjMzl4K1J0R1pZdTRmYnp6SUVXaTBOS1NvZkY0YkxKeEtrb2VhMTRpMC81RCtPeXEvZTc5Y2xtS1UwU0RVaklpLzJJdERoK3BNZFMrZVcvYTEwcFhYM3FhNkN5RjR6MXAvM0cxNnJMOEtibW45Ym5MMEdxbkpQOCtJSGZ1S3JzSmgwMWVhNTVDUjA2eksvZGxrUmIrYnlHek9IbzNKSUdFcVYzMHBlbWhNbjl6Q1VROWFsQnVSUGtROHNqcFdqblJ1bWxNcFNYWjg1dW5jQW1pK0xIa21uanpPdGlsRURiS1o2QzluZDF5TDV3V0ttMG9UWUtWMU51eU8rTlRMUytGN3M1aWVLS2xIUlZZQmltQWtrYkN3MFYwejQ1ZVU3Z0p5VGJUMmJKOFZTTVROUnplZFNRTmJpeHlENVEzd3FnWGhWZndHKzNuS0FlTnBqWUdSZ1lBRGlGMUpURHNiejIzeGxZR1poQUlISEVicFdDUHEvTHRNeHBvdEFMZ2NERTBnVUFDS3hDaFVBZU5wallHUmdZR2I0ejhEQXdQU0RRZWYvQmFZdERFQVJGTUFLQUc5OUJMVUN4Z0FBQWpvQVN3STZBQ3dDK0FBL0FpZ0FNQUFBQUFBQVpnRFVBVHdCcW5qYVkyQmtZR0JnWlhCaFlHSUFBVVlHTkFBQUI2a0FUbmphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9DQ3hkV0ZnWW1YcUF0aEZHV3dqSjBSQ3FqcjJkL2RoUFBRTlYrZCsyRURORHdYM0s1Z2x2VjlKSmU3QkZWUG1tU2ZpM2pMWExIam5pYUo4bHVTVmo4eWxOSitaSzE3NHlqeVIvRHR6ellyZlRYQ1g2MkNqMmdWam96ODUxNjMzTnZaZDhHcXBtK1MzMXR0NEdLeFJ4NXN5WTllUFo2ZGEzZWlXRFFISGhTc0Rsb2hpSjRsSjdEbEo1K2hZczA5Skx4d2tWeXpSTlAvNnJmUStiUTdwSnlPYkl6ZFJ3eWlMWHZRc1cwV2JYbXJhUDh1aEwvY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLTTJlUzJob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0dFlyd2wvaitXMitNakN6TUlEQTR3aGRLd1Q5L3k4ekc5TmRJSmVEZ1Fra0NnQW5Ld284QUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNi4zMDU1NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIuMTU3ODU5JyB5PSctMjYuODgyMjY5Jz7ugLDugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC05LjYyOTg1OCwtMjMuMjY2OTA2KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy05LjYyOTg1OCcgeT0nLTIzLjI2NjkwNic+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQuOTYzMjc0JyB5PSctMjYuMjczNDIzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS43OTgzMDQnIHk9Jy0yMy4yNjY5MDYnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMi4zMTUwMzknIHk9Jy0yMy4yNjY5MDYnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNi40NTE5ODknIHk9Jy0yNi4yNzM0MjMnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc5LjE0Njc2MycgeT0nLTIzLjI2NjkwNic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MC4zMDY1NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTEuNTczMjUnIHk9Jy0yNi44ODIyNjknPu6AsO6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjg2MTEgMEg0NS4yNTEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDUuNTAxLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjIuOTczMzksNS42MjI5NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS44NjU4MzYnIHk9Jy0yMS40MzQ4NjMnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTIuMTk3Mjc5JyB5PSctMjIuOTAxNTkyJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNDkyOTA4JyB5PSctMjYuMjczNDIzJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00NS4zOTEwOCwzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIuMTU3ODU5JyB5PSctMjYuODgyMjY5Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC42OTUzNi01MC4yMjQ1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzc5NjUsLTAuNjI2MTYsMC42MjYxNiwwLjc3OTY1LC04LjUwMDQ2LC01MC4zODEwNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTU5LjU5MDE1LC0yMS4zMTQ0NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00Ljk2MzI3NCcgeT0nLTI2LjI3MzQyMyc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0uNzk4MzA0JyB5PSctMjMuMjY2OTA2Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzIuMzE1MDM5JyB5PSctMjMuMjY2OTA2Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzYuNDUxOTg5JyB5PSctMjMuMjY2OTA2Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tMzAuNTI5OTcgNDEuNTE0OTRDMy4wNzcyOSA0Ni4yMjg4OCAyOS4xNzQ1OSAzNS42NzUyNSA0OS43NTI5OCA5LjMyMTYyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNjE1NDMsLTAuNzg4MTYsMC43ODgxNiwwLjYxNTQzLDQ5LjkwNjgzLDkuMTI0NTkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE3Ljc5OTY1LDQxLjgwMzM0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPs6xzrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLS42ODY0OTQnIHk9Jy0yMi4yNzA2NDInPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00tMzMuODI4MDggMzMuODI4NTdMLTkuMjc3MTYgOS4yODEwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE0LC0wLjcwNzA1LDAuNzA3MDUsMC43MDcxNCwtOS4xMDAzNyw5LjEwNDMxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00tMzQuNTMyNTYgMTQuODc4MDdILTguMjE5MTFWMjcuOTcyMjJILTM0LjUzMjU2Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMxLjUzMjU2LDE5LjYyODA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQuOTYzMjc0JyB5PSctMjYuMjczNDIzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS43OTgzMDQnIHk9Jy0yMy4yNjY5MDYnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMi4zMTUwMzknIHk9Jy0yMy4yNjY5MDYnPs6xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzcuNDk0MzgnIHk9Jy0yMy4yNjY5MDYnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                nw = A'',
                nw/style = pullback,
                ne = B'',
                sw = A,
                se = B,
                north = \varepsilon _{g'},
                west = f^{*}(g'),
                west/node/style = {right},
                south = f,
                east = g',
              }
              \node  [above left of = nw] (a') {$A'$};
              \draw  [->,morphism,bend right] (a') to node[swap] {$f^{*}(g)$} (sw);
              \draw  [->,morphism,bend left] (a') to node {$\alpha \varepsilon _{g}$} (ne);
              \draw  [->,morphism,exists] (a') to node[desc] {$f^{*}(\alpha )$} (nw);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          Thus, <fr:tex
display="inline"><![CDATA[\varepsilon _{g'}\Sigma _{f}(f^{*}(\alpha )) = \varepsilon _{g'}f^{*}(\alpha ) = \alpha \varepsilon _{g}]]></fr:tex> as required.
        </html:td>

      </html:tr>

    </html:table>
<fr:p>By construction, <fr:tex
display="inline"><![CDATA[\varepsilon _{\Sigma _{f}}\eta  = \mathsf {id}_{\Sigma _{f}}]]></fr:tex>. Thus, it remains to verify the other triangle equality.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[g \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex> be an object. We need to show that <fr:tex
display="inline"><![CDATA[f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} = \mathsf {id}_{f^{*}(g)}]]></fr:tex>. Note that <fr:tex
display="inline"><![CDATA[f^{*}(g)f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} = f^{*}(g)]]></fr:tex> by the construction of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>. Moreover, we also have the following equation.</fr:p><fr:tex
display="block"><![CDATA[       \begin {align*}         \varepsilon _{g}f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} &= \varepsilon _{g}\varepsilon _{f \circ  f^{*}(g)}\eta _{f^{*}(g)} && \text {by the construction of } f^{*}\\                                                     &= \varepsilon _{g}\mathsf {id} && \text {by the construction of } \eta \\                                                     &= \varepsilon _{g}       \end {align*}     ]]></fr:tex><fr:p>Thus, <fr:tex
display="inline"><![CDATA[f^{*}(\varepsilon _{g})\eta _{f^{*}(g)}]]></fr:tex> corresponds to the same cone over <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> as <fr:tex
display="inline"><![CDATA[\mathsf {id}_{f^{*}(g)}]]></fr:tex>. Then uniqueness implies that they are equal.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1994</fr:anchor><fr:addr
type="user">fnd-0007</fr:addr><fr:route>fnd-0007.xml</fr:route><fr:title
text="Cartesian category">Cartesian category</fr:title><fr:taxon>Section</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="frankndrssn.xml"
addr="frankndrssn"
title="Frank Tsai">Frank Tsai</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1185</fr:anchor><fr:addr
type="user">ct-000H</fr:addr><fr:route>ct-000H.xml</fr:route><fr:title
text="Locally cartesian categories have pullbacks"><fr:link
type="local"
href="ct-000G.xml"
addr="ct-000G"
title="Locally cartesian category">Locally cartesian categories</fr:link> have pullbacks</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is locally cartesian iff it has pullbacks.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1186</fr:anchor><fr:addr
type="machine">#332</fr:addr><fr:route>unstable-332.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>If <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is locally cartesian, then <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> has products for any object <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>. But, products in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> are pullbacks over <fr:tex
display="inline"><![CDATA[A]]></fr:tex>. Thus, <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has pullbacks.</fr:p>
  <fr:p>Conversely, assume that <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has pullbacks. Then since the forgetful functor <fr:tex
display="inline"><![CDATA[\Sigma _{A}\colon {{\mathcal {C}}_{/{A}}}\to \mathcal {C}]]></fr:tex> creates connected limits for any object <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>, the slice <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> has pullbacks. Moreover, <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A}]]></fr:tex> is the terminal object in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>. Thus, <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> is cartesian.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1187</fr:anchor><fr:addr
type="user">ct-000J</fr:addr><fr:route>ct-000J.xml</fr:route><fr:title
text="Slice comparison functor of a locally cartesian category admits a right adjoint"><fr:link
type="local"
href="ct-000I.xml"
addr="ct-000I"
title="Slice comparison functor">Slice comparison functor</fr:link> of a <fr:link
type="local"
href="ct-000G.xml"
addr="ct-000G"
title="Locally cartesian category">locally cartesian category</fr:link> admits a right adjoint</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is locally cartesian iff for all morphisms <fr:tex
display="inline"><![CDATA[f]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the functor <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> constructed in <fr:ref
addr="ct-000I"
href="ct-000I.xml"
taxon="Lemma" /> admits a right adjoint <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>. Moreover, <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> is (isomorphic to) the pullback functor.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1188</fr:anchor><fr:addr
type="machine">#330</fr:addr><fr:route>unstable-330.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By <fr:ref
addr="ct-000H"
href="ct-000H.xml"
taxon="Lemma" />, locally cartesian categories are precisely those categories with pullbacks.</fr:p>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1189</fr:anchor><fr:addr
type="machine">#328</fr:addr><fr:route>unstable-328.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex> for any <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. We show that the following diagram</fr:p>
    
      
      <fr:figure><fr:resource
hash="3bdf29e3ca5a6afa1fb82198dbd9d32b"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNC43NjA3MDdwdCcgaGVpZ2h0PScxMTcuODQ5NjI0cHQnIHZpZXdCb3g9Jy03MiAtNzIgNzYuNTA3MTM4IDc4LjU2NjQxNic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9VQUFvQUFBQUFBL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFYR050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFEWUFBQUEyTlZxTFR0b1pXRmtBQUFDUEFBQUFDOEFBQUEyS1J1Y2dHaG9aV0VBQUFKc0FBQUFIZ0FBQUNRRjhRS2FhRzEwZUFBQUFvd0FBQUFJQUFBQUNBWWhBR1ZzYjJOaEFBQUNsQUFBQUFZQUFBQUdBR3dBQUcxaGVIQUFBQUtjQUFBQUZnQUFBQ0FBQlFCRmJtRnRaUUFBQXJRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGhBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTZRek0vd0g4cGtoMGtocS9nT0ZBYlFlRE04QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOUR5UCt6d0h3R0FGVzFCc01BQUFBQUFnQmwveXdDaWdIRkFDNEFRd0FBQVFNT0FTTUdMd0VtSno0Qk1oWVZGQVlIRmg4QkZqNENQd0VPQVFjdUFTYzJOelkzTmpjeUZoYzJOeDRCRlFjM05pOEJKaWNPQVFjT0FSVWVBVGMrQVRjK0FRS0ZiQlNQYXk4MUN6TUVBU1V5RmdvUUFpSXRGejlIR0FZWUVrd3lTMllDQTBVUkVsQmhJa0FaRVNJVEU1WXRBUlVFRnp3cFNCWWRIQUk1SUNoRkhRNEpBWFgrVEV0SUFna0REQzhkSlJvUENCd1BCUUlCQVFvd01CeGhFQ1VDQVZ4U1kwd1REMElER3lJbkFRRVZEdnU0Q2lNR0lnUUJNQ012ZFNFN0xBRUJKeDBQRHdCNDJtTmdaR0JnQU9LNWEzY3F4dlBiZkdWZ1ptRUFnY2NSdXA0SStyOE9jd2pqVVNDWGc0RUpKQW9BRnVFSmdRQjQybU5nWkdCZ1p2alBBQ1JER0ZJWm5KbTZHSUFpS0lBSkFFQVdBcElBQUFOVUFBQUN6UUJsQUFBQUFBQnNBQUI0Mm1OZ1pHQmdZR0p3QVdJUVlHUkFBd0FIV0FCTEFBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDArMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNWWjJ4NVpnQUFBV1FBQUFGTEFBQUJZRG1Tc1RKb1pXRmtBQUFDc0FBQUFDOEFBQUEyS00yZWFXaG9aV0VBQUFMZ0FBQUFIZ0FBQUNRR0xBSU9hRzEwZUFBQUF3QUFBQUFNQUFBQURBaCtBRTlzYjJOaEFBQUREQUFBQUFnQUFBQUlBRlFBc0cxaGVIQUFBQU1VQUFBQUZnQUFBQ0FBQndBNmJtRnRaUUFBQXl3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaVp2Z1A1RE5EcEpIVS9BY0tBd0R5S1ExSGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoTy8vOERTY2YvLy84ZkFQTVpBRktvQnA1NDJqV1BNVS9DUUFDRjc5M0JIV0RiUTF2YUdBRlRRWnBvRkVOSkt3d01LbWcwRXBURU1KQ1ltQ2liZzBGY0dSaDFNakZ4Y25IekI3ZzRPZmtuSEl5anZ3R3dOZkZOTDEvZThEMUNTWDQ2cFYvMGt4UkppUkFmbmw4eUxkMHdYYy9rUlFpbjRKUTl5L1Q4SW16QkRkUHlMQTBCRDdGYmcrK3lWNXh6UStXb21Xc3BLTkgrTUJhRk9xT1hXVnhNcGswMXJhc01hclRYVWFERWwycVBQL2FBbmlRUmwrT2hLVmxHZ0RIUW1CU0FZbDNVUjBZK0NTbzFIdUtFNU1oOTRKZ0VZV1IxT21hY3ZwRXNXU0diZ2FsZXpqazhjTE96U0drUVdWaGNnZ3ViLy9ucW9aeFhjSElGTHRoL1o4SEFmYjViY0RKU290TTlZOFAyUVJ0ME4zbDRQYmxQYTFvMSsvUncycWRZM3g0dDZ0SEwyKzZBMG8yOTkwWUUwRnEwTWt0WldvQWVWZmQ3TXRHc0hHeHB0VWo0QURycTdLcVIzNkdROCtNWGR0TmNickhKOXh4UGtGK3p2VHVEQUhqYVkyQmtZR0FBNHRZcndqdmorVzIrTWpDek1JREE0d2hkVHdUOS95OHpHOU5kSUplRGdRa2tDZ0FmeVFvZUFIamFZMkJrWUdCbStNOEFKRGtZVkJpWW1Oa1lnQ0lvZ0JrQUk4Y0JRZ0FBQW5ZQUFBTUFBQ1FEQ0FBckFBQUFBQUJVQUxCNDJtTmdaR0JnWUdhd0JHSVFZR1JBQXdBR2R3QkNBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1BQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDd0FBQUEyS1ZlZHkyaG9aV0VBQUFIWUFBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmZ0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNBQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlJQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlBQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzhBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9KZGsyMTY0L2x0dmpJd3N6Q0F3T01JWFU5a21ua2lrdzJRNG1CZ0F2RUEvdHdIL1hqYVkyQmtZR0JXL0dNRUpDY3lHRExJTXBvd0FFVlFBQk1BUVJvQ2JnQUFBNUVBQUFGUkFERUFBQUFBQUNBQUFIamFZMkJrWUdCZ1l1Qm5BTkVNVUJJSkFBQUNGQUFWQUhqYVRZdzliOEl3RUlhZmlBU0pkT2hTZGVnQUhwaXRvRlJpWTJGZ1ltWHFBdGlnREhHUUhTSkZxanJ5dTN1NEhuckQ2WGsvN29DU0h6S2VrL0VhOTNOeUNsRi9YUERDVytLcHFFWGlrZytXVE1qeW1UaHpOb2x6U2I0U0Y3eHpTVHdWL3p0eHlTZVBiZGZlN3IzMWF0OFo2OTI1RGVQNllIMW9PcWRXdW9wNlo1MzF4OTRhZFJxVkdab3dYRnRWNjByWGJPbG91WEdueCtKUjdNVXhrUjFueVFJamF3N1JDVFNTT21tdDBGVC84cDNrTG5hTzhaT1J6a2tTSlRUSVZaQjlsYmFpanBlYStoZnplVEJQQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUMwQUFBQTJLSnFka0dob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0bU52c3JUaitXMitNakN6TUlEQTR3aGRUd1Q5bjVIcE1qT0l5OEhBQktJQUdPMEpOQUFBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5rQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDd0FBQUEyS2h1ZGEyaG9aV0VBQUFJOEFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFsd0FBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNaQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUpzQUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9RQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFZBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaW1sWHFzZkg4Tmw4Wm1Ga1lRT0J4aEs0bk1zMFN5bmdIU0hFd01JRjRBTy90Qi9WNDJtTmdaR0JnMXZwanljREFFc3JReDlEUGxNd0FGRUVCVEFCU2dBTkNBQVJWQUFBQzhnQ09BQUFBQUFCVUFBQjQybU5nWkdCZ1lHSXdaUURSREZBU0NRQUFCY29BT3dCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUNVbFlXQmlaV3BDMkNETXNSQmRvZ1VxZXJJNys3aGV1Z05wK2Y5dUFOS2ZzaDRUc1pyM00vSktVVDljY0VMYjRtbm9oYUpTejVZTWlITForTE0yU1RPSmZsS1hQRE9KZkZVL08vRUpaODh0bDE3dS9mV3EzMW5ySGZuTm96cmcvV2g2WnhhNlNycW5YWFdIM3RyMUdsVVptakNjRzFWclN0ZHM2V2o1Y2FkSG90SHNSZkhSSGFjSlF1TXJEbEVKOUJJNnFTMVFsUDl5M2VTdTlnNXhrOUdPaWRKbE5BZ1YwSDJWZHFLT2w1cTZsL3Y2VEJIQUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUd0FBb0FBQUFBQmJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0YzOG1OdFlYQUFBQUU4QUFBQU1nQUFBRHdIRmYxMloyeDVaZ0FBQVhBQUFBSWVBQUFDaEJMRnZFWm9aV0ZrQUFBRGtBQUFBQzhBQUFBMktJMmRqV2hvWldFQUFBUEFBQUFBSUFBQUFDUUZtUUdiYUcxMGVBQUFBK0FBQUFBUUFBQUFFQWxpQUtkc2IyTmhBQUFEOEFBQUFBb0FBQUFLQWFnQTFHMWhlSEFBQUFQOEFBQUFHQUFBQUNBQUJ3QkZibUZ0WlFBQUJCUUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUU1QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1pbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1XOWxadmdQNURNek1JS0VHUkVxL2dPRkFmQjVEZVlBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZemIvMy9IOGhQQTlIL1ovL3hBNnNDQWdDaUp3bUpBQUI0MmtYUlBXL1RRQndHY0Q5MzdqbHY5dG14Zlc2VDFIbHhiSWZTeG1uY09paXQ4dEpXUW0wUnBVS2lLa0lnaGk2ZGtCaEFmQWdHMUlHVmxXL0EzaDN4SFJpUm1CaFlVczd0d0oxMHd6MDMvSC8zS0ZDT2J4SnlTWDRvTTBVQjVXQ2FBYTBUeFJPa3doTk1FMDFNTUtVQml6SXZuV0FrNzRmQ014QkVjWlNOb2dRRzRVZ3p3V0o4R1p1cVdTdk9OM3Rqb090R0ZMekpPZSsyNldxZlAvS0p6VSs1YTRpOTRONHVFQWlabXo3bjFhcGZLdFJlNVRHdUZ0ZEgxbXpMMmFkUjRMZElsOFhsSW9GNjdINytjMFk3R3M3TzYzRVVkdjlIV0lrMlBxcWRBaFM1aUxKK3MwRkNYQ3Q5WlQvWFNBbTdsY2lKSGFaNUloV1pCRXdsc284NEcrWGJoeWRWOGdHZElvc2xpbW41Rndodm1EOGw3VGZGdCsrVGw2cWMxeEl3cWcycjdld0dEYUY1bzhQNU9hRnpiaDJlOTdaMVdxdnFMajRsRkk2N1ZkdHZ1YWFGS1BiM0doVU5IeGJ6NURrbDd2cHEyN2JMZm1tSm9OeFlHYlJlcENyT25sdzh0dmtCUlZlWUFxYTErUHVObDhOQVJXODdtczlPUmdoYlhMKzFEVzUrNFRlK0t6dTViV1RBWTU3c1puaG40SGNrS2JrN00rRkptQ0ZINk1zMlpZc1M2V1Y1YnpHTHhaUWtZRi9URU5oWmJhWW5ENnRxUVNjOWMvUHkyUVhJZ3lZTmlIcjF1akpzVzEzQUZhVmdySisrb3lTTWRpcnRBZWlrY2Ivc0w0Zk84bkx5c3o2MTErb2xRdXErQnRUalNxVGlhRHpZcXlKc3pwNEN6R0N1cWR0RWMwcllYT3ZZUmdIUW5VWVphcmdrVXhWRTB2NEIvMUJVbkFBQWVOcGpZR1JnWUFCaW5sVTlsdkg4Tmw4Wm1Ga1lRT0J4aEs0bmd2NnZ5M1NNNlNLUXk4SEFCQklGQVA3a0NWY0FlTnBqWUdSZ1lHYjR6OERBd0hTTVFlZi9CYVlzQnFBSUNtQUJBR1VjQkRnQ3hnQUFBam9BU3dJNkFDd0NLQUF3QUFBQUFBQm1BTlFCUWdBQWVOcGpZR1JnWUdCaGNHRmdZZ0FCUmdZMEFBQUhqZ0JOZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU1LjEwNTAxMycgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTcuOTEwNDI4JyB5PSctNjQuNjg1NTE1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTUzLjc0NTQ1OScgeT0nLTYxLjY3ODk5Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTAuNjMyMTE2JyB5PSctNjEuNjc4OTk3Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ni40OTUxNjUnIHk9Jy02MS42Nzg5OTcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTEuNDU5MzIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU0LjUyMDQwNCcgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjg2MjEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuNjc4OTk3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINDYuNDAzNzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNjUzNzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4zMjU4Miw0Ljc4NDAxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjY3ODk5Nyc+zrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU4LjgxMjk5JyB5PSctNjAuNjgyNzMzJz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS42Nzg5OTcnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        
    \SpliceDiagramSquare {
      sw = A,
      se = B,
      nw = A',
      ne = B',
      south = f,
      east = g,
      west = f^{*}(g),
      west/node/style = {right},
      north = \varepsilon _{g},
    }
  
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>is a pullback, where <fr:tex
display="inline"><![CDATA[\varepsilon _{g}]]></fr:tex> is the counit of the adjunction. Note that since <fr:tex
display="inline"><![CDATA[f \circ  f^{*}(g) = \Sigma _{f}(f^{*}(g))]]></fr:tex> by construction, the component <fr:tex
display="inline"><![CDATA[\varepsilon _{g}]]></fr:tex> makes the diagram commute.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[h'\colon C\to A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h\colon C\to B']]></fr:tex> be morphisms such that <fr:tex
display="inline"><![CDATA[fh' = gh]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="2eb932eee263ecd4d313f468c72b28ee"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3Ni40MjcyMjhwdCcgaGVpZ2h0PScxNzQuNDQ0ODM3cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE3LjYxODE1MiAxMTYuMjk2NTU4Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzBBQUFBMktKcWRjbWhvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRtTnZzdExqK1cyK01qQ3pNSURBNHdoZEt3VDluNUhwTWpPSXk4SEFCS0lBSUU4SlVnQUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLUnVjWW1ob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0s1YTNmR3h2UGJmR1ZnWm1FQWdjY1J1bFlJK3I4T2N3ampVU0NYZzRFSkpBb0FIa01KbndCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSc0FBb0FBQUFBQlF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUZFQUFBQmdxR3ppWldOdFlYQUFBQUZJQUFBQU5BQUFBRVFpTEFDNloyeDVaZ0FBQVh3QUFBR05BQUFCek1VV0kxZG9aV0ZrQUFBRERBQUFBQzhBQUFBMktoeWRaMmhvWldFQUFBTThBQUFBSHdBQUFDUUY3Z0RiYUcxMGVBQUFBMXdBQUFBUUFBQUFFQXUwQVd4c2IyTmhBQUFEYkFBQUFBb0FBQUFLQVZZQXhHMWhlSEFBQUFONEFBQUFGd0FBQUNBQUJnQktibUZ0WlFBQUE1QUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUVZQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc3M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lBR0lCWmdZSENBY2hsU2lzdlNHZGdVRkI0WU1HdjlzV1JnWU5aaVBnNFVabVNBZy8vL0dSZ0FXVUVRVHdBQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUFMbEZCU1V4QjhZL1ArUFlOMS9lUGUxL0dXd1dqQUFBUHpGREFGNDJqV1F3VzdUUUJDRzk1KzFkK3ZFanAxNGJjZHRhamRyWXplcVNHaEliSVFxNThxQkk0aExSWVNxNWs3VkV4eTRVNGxIS0JJM2VBVmVvOGMrQzdCRmNKblJQL09QOVAzRHdENzkxdlNZN3RnTHhwQWpReVI4Q1BsUTJtcUJxbDQxR3pSckh3TVVjNnlhZHBuemFrSFZ1a1BTeE1sZjh3WWRubVpRUW1wemdrdnVPUmFFTFRtWGJrSjh6NUt3K3oyZXpzSzVtZ2JCTkJyUGp2ZkpsbjJiU2lGS2doMEkydisvVmZOd2hoOVplM3lpUDF5OXZFajJDQmdGbDgrdWI4ckZreFBmNHozUm84TFhKQnpIbXVURm1UNG9BNktnUEN6Tzg0bmxDSWUwWDVCeE1ST0pmV0VGWGVDZXJZeG9tMldzREhLY3hNa0FoalUzOUNiVkJsTFV1aks5cXF1Nnd6SkhYYTFOMkRpUitQelZUZFZRZkgvek9pU28xUG5tQ2RMRFVMZzNqNFFYamMxY0VhS3hkK3VLY0tpcGo0T3RvL1NBdXNPcEhJOFV4THZkODR4amxKenVYa1ZRT3ZpM2NMYTcwNTQzQXVWdkh6aTNyTVpIT21PQkVWd1VocU1OTzdSTDgyT0o5M2ZDalVOdTNmSTBTeXZBd3Yydjg2R1VYb0NmZ3lNY1RWeVgvUUdZQWpjc0FBQUFlTnBqWUdSZ1lBRGlweHd2QXVQNWJiNHlNTE13Z01EakNGMHJCUDFmaVNXVTZRcVF5OEhBQkJJRkFCUjRDVzBBZU5wallHUmdZTmI2WThuQXdCTEtFTS9nd1pUTUFCUkJBU3dBU0hZQ3pnQUVWUUFBQXFvQWZ3THlBSTRCd3dCZkFBQUFBQUJ3QU1RQTVnQUFlTnBqWUdSZ1lHQmg4R1FBMFF4UUVna0FBQWYwQUZFQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdzQUFvQUFBQUFCcWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjRBMk50WVhBQUFBRThBQUFBTWdBQUFEd0hGZjE0WjJ4NVpnQUFBWEFBQUFMV0FBQURiSHhIbEI5b1pXRmtBQUFFU0FBQUFDOEFBQUEyS0kyZGIyaG9aV0VBQUFSNEFBQUFJQUFBQUNRRnFnR2NhRzEwZUFBQUJKZ0FBQUFVQUFBQUZBd09BUFJzYjJOaEFBQUVyQUFBQUF3QUFBQU1BYTRDaW0xaGVIQUFBQVM0QUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQk5BQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRm9BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXltU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVc5bFp2Z1A1RE16TUlLRUdSRXEvZ09GQWZhbURmY0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5bVl3Yi8zL0g4aFBBOUgvWi8veEI2c0NBZ0NpU1FtTEFBQjQya1dTUFcvYlZoU0crUjVTcEVTS3ZQd1FMeDFMcGtSUkpKWFVFU1ZUcGxKYmxTekxTQkc3elVjTDFIQVFKT2lRSlZPQkRpMWFvRCtoQ0lJTVdiTVYvUWZaQTJRTThoOHlGdWpVQWwzc1hsWkQ3d0h1Y004ZHpuT2VWNEowZHBYVE0vb2dIVWtTWkFaVnM2RDEwMnlCZ2dkYzFYZ1hDeXpsV0UzTG9GaGdKdDczZUdBaFRyTzBuS1U1TEdJb1NxNW1lSDFnSy9aMll6VVpIZ0FEUDVYQnVveXhRU1R2ak5nWElYbnNBZk10Zmh4Zm53TXhGMzA3Wk14MVE3MisvYVJxNCtYbDIxUG5hTnBheTJrYzltaWdaa2FEb0p6NXIvNDZsL3NhemkvYVdab00vbS9oV25yelY2VmZoeVFPU2J0WE55bkJXMmtrclNzYVFhTCtSeUltYnFsYXdBdGVDb0NsZ0J3aEsyZFZoUWdFbGZnZ0wxRm1Ba3JWcWhYd1lLLzZTdEYzamU5L3pCOHJZbDZIdzNJN1R0U2F4eDJ1QmJNN3F3dVNWOHk1Y3pIY04rVnQxL1R4SXBmUjhxZmI2NTV2TzBpejhMalQxUERUNVNwL0tKTy91eE41bmhIcU5ZTFJ1VGJ1UFNvVW5OOS9ldGRqSnpJRzNPYXduY3QvM2pBamlSVU05OVBWMGIwWmtoNHpCUnVrTDYvK3BwL3BuWFJXa1ltUlE5TFVqUzVmcllZdGl5QVV2S0tFdmFtQXFmRFNyTm9CVTRTdkVmWm4zZ0pwdkpFN0s3bUcxZDNPVjUvZW5qWkJMZkthcGk1M3VuT1hIRjFGWURqeFluZ0xzbWx4VHNTSDgvdGJyT2IxR25VOWFMaE83YmxDYk5Dd0FVczcyVTFBdjEyK2l3clU4cWs1bXF1SDdTaHkrclQ4ekNVS3hnRWZLZm4xcHRFYkhLOG4vb1JvUGVURzZTOXBteG53VEU0bkp0TVZuZFUxUlc0S2grT3JQL0FuM2t1SGxjT1poVUFOUkFiM05xN1lScDNBMzl3bEY5QWlqV2syRXFrVmFSVXlnN0xLWjZabWZFazUxTitMQkRqYzZSYjNQbmVWdWtsRGUvTHNtNmVnVzEwNUp1WGx0ODI5eUJrQVB0ZmpBL1BCRHpJbDZXRXpHb3NkZHo0eHdxMmt0YldWZjJ3dnZSdHRuYWdkYWtBN2E2WUtUZy9HeHk2Uzd0SFhnR3Fwdm0xNnBMVjBURzcwUGFzT21LMk9BU1dwaWE0Q0Vnci9CWUcxY1NJQUFIamFZMkJrWUdBQVloTzVpL3J4L0RaZkdaaFpHRURnY1lTdUZZTCtyOHQwak9raWtNdkJ3QVFTQlFEMDlBa1FBSGphWTJCa1lHQm0rTS9Bd01CMGpFSG4vd1dtYWdhZ0NBcGdCUUJtWUFSS0FzWUFBQUk2QUVzQ09nQXNBcXdBVFFJb0FEQUFBQUFBQUdZQTFBRklBYlo0Mm1OZ1pHQmdZR1h3WVdCaUFBRkdCalFBQUFoeEFGWjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS1ZlZHJXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9KZGsyMU94dlBiZkdWZ1ptRUFnY2NSdWxiSU5QTkVKaHNneGNIQUJPSUJBQVpOQ0JzQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVMwQUFvQUFBQUFCVlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDAvbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNXWjJ4NVpnQUFBV1FBQUFIcUFBQUNIUFQvRXp0b1pXRmtBQUFEVUFBQUFDOEFBQUEyS05LZU4yaG9aV0VBQUFPQUFBQUFIZ0FBQUNRR01nSGRhRzEwZUFBQUE2QUFBQUFRQUFBQUVBdFpBSUpzYjJOaEFBQURzQUFBQUFvQUFBQUtBV0lBc0cxaGVIQUFBQU84QUFBQUdBQUFBQ0FBQ0FBNmJtRnRaUUFBQTlRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRXFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzWTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCbVp2Z1A1RE5EcEpIVS9BY0tBd0R6QUExS2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqTy8vOERTY2YvLy84ZkFQTVpBRks1QnA5NDJqWFF6Mm9UVVJRRzhQdmRrN25USkpPWjZLUXpsYVpUMHZ5WnRwS2tkSWFadG9zb2pZazF4YlEyVUlJRWdvSVdCQVUxUmhjdXNvZ0xRVmRDUVZ5NGNlY0R1SEhscWcvZzFvVzRFaDlCa25oSDZMbWJ3OGRkL0w3RE9Ddk1adnduLzhHcWJKT3hFRUc0YWRsbXh2SUNTMVNodWlYWEQyd3JDS3ZJcVNKajJZR3RRK1pSN05VUWV2UUY5MFFtSlZDenl2UFFsTUZvVGtFcWFmb1VWNmV6ZGlwcnBnZ3A1YVNyUVl1djFONy95UTM1Y1JweFl6S3lERnBTUVFRK1o2aUFadDl2akRPRk5MaWhpeWhPR0FMNU14d3hPY1F1enlZaytGZm1zSFcySmFXbW4zZUZ0T1Vjek90UUhkakNnRkJ6NHIvWGpIQkJ5YzJYaEVybk84a1AzcWUzaSs2U1lhRGJ1MHVqem40SC9IcjY1clBwdTZ5dTd6Z2ZUL3NEamtwOXZHd3FqOTcwaHB4djdIMXJ4Z0Q5a0c5ZjRKUlZ3Vy90dEU2TVJIdDdmMWV2eGFJR01OR2dKODNDTlE3ajB1UXpQVzhYRDJuNjY2SklNQWJtelg1VGtuK1B6Q0FkZVhuUksvQkxyalJIWU50QktNOGJDWmZoeUFJeXI4QU53dWhadG1XSHNnNGxycEpJeEJWd0hCODBYbTAwRjRXRjJNc2JxLzNBTDR0WVhGV28zRng3WEgveGdhamp0NTZPTzJ1cllrK0h4cyttZjNWcFZvM1M3UWRBZmF2YlgraVZoM2M0VnRZcnZZVWt3TFdIdTBVUGREcDZQV2o1UnhRckZQVURuUk5qL3dBZDBscitBQUI0Mm1OZ1pHQmdBR0oyUWMrLzhmdzJYeG1ZV1JoQTRIR0VyaFdDL3YrU21adnBMcERMd2NBRUVnVUE5K1lKS2dCNDJtTmdaR0JnWnZqUEFDUTVHRlQrWDJEbVpnQ0tvQUFXQUVyM0F4VUFBQUoyQUFBREFBQWtBd2dBS3dMYkFETUFBQUFBQUZRQXNBRU9BQUI0Mm1OZ1pHQmdZR0d3WkdCbUFBRkdCalFBQUFhU0FFTjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTEzLjk5Mzk5NycgeT0nLTI3LjU2NDIyMSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTYuNzk5NDEyJyB5PSctMjYuOTU1Mzc1Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTEyLjYzNDQ0MycgeT0nLTIzLjk0ODg1OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS41MjExJyB5PSctMjMuOTQ4ODU4Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01LjM4NDE0OScgeT0nLTIzLjk0ODg1OCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTMuNDA5Mzg4JyB5PSctMjcuNTY0MjIxJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg0Ni40MDM3OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni42NTM3OCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0LjMyNTgyLDQuNzg0MDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTcuNzAxOTc0JyB5PSctMjIuOTUyNTk0Jz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjQ2NTk5NiwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMS40NjU5OTYnIHk9Jy0yMy45NDg4NTgnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ0LjE2OTU0LDM3LjczODMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDEuMDgxMTggMzMuODI4NTdDLTQ2LjQ3NDQ5LTEuMTM0MzUtMzUuODg3Ni0yOC4zODUzLTguNjk1MzYtNTAuMjI0NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjc3OTY1LC0wLjYyNjE2LDAuNjI2MTYsMC43Nzk2NSwtOC41MDA0NiwtNTAuMzgxMDQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00Ny43MDk2MywtMjEuNzY1ODUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS40NjU5OTYsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjEuNDY1OTk2JyB5PSctMjMuOTQ4ODU4Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xNi44MDE3MzgnIHk9Jy0yNi45NTUzNzUnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTMxLjc1MTUxIDQxLjM1NDMxQzIuMzI5ODYgNDYuMzc0MjggMjguNjcyNDkgMzUuOTMyODUgNDkuNzUwMjcgOS4zMTk0OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjYyMDgyLC0wLjc4Mzg3LDAuNzgzODcsMC42MjA4Miw0OS45MDU0Nyw5LjEyMzUyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNy4xNzg0LDM5Ljk2MjE5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+aDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2UtZGFzaGFycmF5PSczLjAsMi4wJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KPHBhdGggZD0nTS0zMy44MjgwOCAzMy44Mjg1N0wtOS4yNzcxNiA5LjI4MTA3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTQsLTAuNzA3MDUsMC43MDcwNSwwLjcwNzE0LC05LjEwMDM3LDkuMTA0MzEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTS0yOC42MzMzOSAxNi42MjgwN0gtMTQuMTE4MjlWMjkuMTE4MDZILTI4LjYzMzM5Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTI1LjYzMzM5LDE5LjYyODA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNDY1OTk2LC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIxLjQ2NTk5NicgeT0nLTIzLjk0ODg1OCc+aDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTYuODAxNzM4JyB5PSctMjYuOTU1Mzc1Jz7igKA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        
    \SpliceDiagramSquare {
      sw = A,
      se = B,
      nw = A',
      ne = B',
      south = f,
      east = g,
      west = f^{*}(g),
      west/node/style = {right},
      north = \varepsilon _{g},
    }
  
        \node  [above left = of nw] (c) {$C$};
        \draw  [->,morphism,bend right] (c) to node[swap] {$h'$} (sw);
        \draw  [->,morphism,bend left] (c) to node {$h$} (ne);
        \draw  [->,morphism,exists] (c) to node[desc] {$h^{\dag }$} (nw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Note that <fr:tex
display="inline"><![CDATA[h]]></fr:tex> is a morphism <fr:tex
display="inline"><![CDATA[h\colon \Sigma _{f}(h')\to g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. Thus, it corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[h^{\dag }\colon h'\to f^{*}(g)]]></fr:tex> under the adjunction.</fr:p><fr:p>The transpose of <fr:tex
display="inline"><![CDATA[h^{\dag }]]></fr:tex> can be computed as <fr:tex
display="inline"><![CDATA[\varepsilon _{g} \circ  \Sigma _{f}(h^{\dag })]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> is the identity on morphisms, we have
      <fr:tex
display="block"><![CDATA[         (h^{\dag })^{\dag } = \varepsilon _{g} \circ  \Sigma _{f}(h^{\dag }) = \varepsilon _{g} \circ  h^{\dag } = h       ]]></fr:tex>
      Thus, the top triangle also commutes.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1190</fr:anchor><fr:addr
type="machine">#329</fr:addr><fr:route>unstable-329.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has pullbacks. Then we can take <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> to be the pullback functor. It remains to check that <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex>.</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
      
  <html:tr>
        
  <html:th>Unit</html:th>

        
  <html:th>Counit</html:th>

      </html:tr>

      
  <html:tr>
        
  <html:td>
          Let <fr:tex
display="inline"><![CDATA[h \in  {{\mathcal {C}}_{/{A}}}]]></fr:tex> be an object, we take <fr:tex
display="inline"><![CDATA[\eta _{h}\colon h\to f^{*}(\Sigma _{f}(h))]]></fr:tex> to be the unique morphism given by the following pullback:
          
    
      
      <fr:figure><fr:resource
hash="c09b8b07b92837716709f79f64e26dcc"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI0My4yNTI3NDdwdCcgaGVpZ2h0PScxODEuMzgwMTM0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTYyLjE2ODQ5OCAxMjAuOTIwMDknPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVA0QUFvQUFBQUFCR3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hjTjM4bU50WVhBQUFBRThBQUFBTWdBQUFEd0hMLzBNWjJ4NVpnQUFBWEFBQUFFcEFBQUJPTkNXS2VGb1pXRmtBQUFDbkFBQUFDMEFBQUEyS01HZGFHaG9aV0VBQUFMTUFBQUFIZ0FBQUNRR1F3S1JhRzEwZUFBQUF1d0FBQUFRQUFBQUVBbW9BUU5zYjJOaEFBQUMvQUFBQUFvQUFBQUtBTXdBWUcxaGVIQUFBQU1JQUFBQUZ3QUFBQ0FBQmdBaWJtRnRaUUFBQXlBQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRDdBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXltS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHBxTUM5bVp2Z1A1RE16TUlLRUdSRXEvZ09GQWUxM0RhZ0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5bW95TC83L0g4alhBTkgvYi81SkFLc0NBZ0NZbXdrNUFBQjQyaVhPdlU0Q1FSUUY0SHRtTmpQT3lzK0N1QnMxRVphVlJRdElGTmlORktLTldsQVNDNE9Ga2xpaENVYnRVT05QWStKRDBQb01sc1pIOEEwb2pJbTJhdUxxRUhKUGNhcnZYQUtkL2dGWG5HaVdDSTZka1NJSklZV3RheEorVVYvb054Q2dHNWR5b3k1WE9YWU9UUm0vcXlVbUM0eVZFZ0VuTUV0VXUxYnY1ZUY3VDFrTUIzMDMxKytjM0JTdU5VbmIybStOL1NtdE9yYk1DSm1BSDFZYldFTllSdEd2QldIN05oaUJTL25nZUE0ODJXcUQ5ellWQktleHRqdFkzKzh3a3h1cDV1ZmdlVmczaFdKRUkzK0xpUDJ3SjhvUktiajZWWjJ3SXQyOFh3c1YvTUJ4SGE4TTZlcHhpY2ZvQXl1bHhjcXlYYmE4N085OUxNVXdIYjBobG1ibldjKzY2RWZSME9CQU14cUNZOFphT1BzeXpBbk00eWl0OEg3Wk5LSlhvU1RSUDVMY08wUUFBQUI0Mm1OZ1pHQmdBT0s1T1cvYTQvbHR2akl3c3pDQXdPTUlYVk1FL1orUjZSY3ppTXZCd0FTaUFCOCtDV2dBQUFCNDJtTmdaR0JnWnZqUEFDU2RHZHdaUEpsK01RQkZVQUFMQUVTTEF0c0FBQUxUQUFBQnlRQjBBY2tBU0FOREFFY0FBQUFBQURBQVlBQ2NBQUI0Mm1OZ1pHQmdZR0ZRWkFEUkRGQVNDUUFBQkF3QUtRQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmtBQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUN3QUFBQTJLaHVkUTJob1pXRUFBQUk4QUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQWx3QUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ1pBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSnNBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb1FBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEVkFBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpbWxYcWErUDViYjR5TUxNd2dNRGpDRjFUWkpvbGxQRU9rT0pnWUFMeEFQbkZDQjE0Mm1OZ1pHQmcxdnBqeWNEQUVzclF4OURQbE13QUZFRUJUQUJTZ0FOQ0FBUlZBQUFDOGdDT0FBQUFBQUJVQUFCNDJtTmdaR0JnWUdJd1pRRFJERkFTQ1FBQUJjb0FPd0I0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQ1VsWVdCaVpXcEMyQ0RNc1JCZG9nVXFlckk3KzdoZXVnTnArZjl1QU5LZnNoNFRzWnIzTS9KS1VUOWNjRUxiNG1ub2hhSlN6NVlNaUhMWitMTTJTVE9KZmxLWFBET0pmRlUvTy9FSlo4OHRsMTd1L2ZXcTMxbnJIZm5Ob3pyZy9XaDZaeGE2U3JxblhYV0gzdHIxR2xVWm1qQ2NHMVZyU3RkczZXajVjYWRIb3RIc1JmSFJIYWNKUXVNckRsRUo5Qkk2cVMxUWxQOXkzZVN1OWc1eGs5R09pZEpsTkFnVjBIMlZkcUtPbDVxNmwvdjZUQkhBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdZQUFvQUFBQUFCcUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjRDMk50WVhBQUFBRThBQUFBT3dBQUFFd0VQUVNOWjJ4NVpnQUFBWGdBQUFLN0FBQURWT0xUM3pob1pXRmtBQUFFTkFBQUFDOEFBQUEyS0kyZFhXaG9aV0VBQUFSa0FBQUFJQUFBQUNRRnJnR2NhRzEwZUFBQUJJUUFBQUFVQUFBQUZBd3VBUGhzYjJOaEFBQUVtQUFBQUF3QUFBQU1BYTRDaEcxaGVIQUFBQVNrQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQkx3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRmpBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXltZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVc5blp2Z1A1RE16TUlLRUdSRXEvZ09GQWZrT0RmOEFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdzZ0RRWEF3ZFFqb2toalNHRGVTdno5di8vZ1dKdzl2L1ovMmY5OGZ2akM5WUJCUUI1YlE3SEFIamFSWkk5Yjl0V0ZJYjVIbEtYRXI4dUpaS1hpaVZUSHhSSjJVa3B5VkxJMkZJa3h3b1MxRzZiandJTjJpWElrQ1ZMbGhRWkF2UW5GQjB5ZE0wV2RPbWZDSklsUU5ILzBMRkFwM2EwZTJVRnlEM0FIYzY3bk9jOFI0RnlkakdpWi9TbmNxd29VRG1ZN2tEdnA5a1NVeEVLcG9zT2xsaXBNVXVMY0xwRUtmc0hJblFRcDFsYWxPa0lEbkZNQzhFeXZEbHlOWGVuZG1zeVBBSUdRYXFDZHpqbmc1NjZtL092SXZMNEF4NDQ0aVRlV3dDeGtMa2JjZDVvUkVaMTUvRW14dXZ6ZDZmMTQ1bS9WdE00NnRLQVpXYU5vSjBGdi83N1NPM3JlUFI5SzB1VHdlY0lWOUl2ZnRiNlZTanlRZm42NGo5NlJSK1VzdzJMSERZaW5XMlJBaFllRkdVeERTUG9USllrbkswZ08yV1JacEtZY1UweTViaGVla3VrOFhZQlpTRjAzUHFtL2ZEd3pzd0MrZVJadHFHMk80c0cxUTJHMEt6SHkrRU5xTFlqQkpFWUx1NDNlY1hyMXFwR1dHdlVLNzlveEFjMUYzRDAyOWNTME52ekQ3MHBLcU9ablMvWXZOWHIxZnUwdXRrZ0NzZWh5TFhSbm1WMkJ5ZnJTVEFoV2crRmVmcFQydUltUEZ2UWJac2Jtc0dydXFaYUNpbmppNy94RC81UTVzcGFVVW9ISVF1bHB3MWdHV0VEbkVQT1gyNy9Ra2hvYVN6TmNtbFdHZzJYQ0l1Tnc0eGxZa1Vqc04rbUNURGY3VXp2M1cxb1ZadUc3dVRaZDA5Qk56cHFUTnJySjlaQnJ6NEFBbUhFUi9hRGx5b2w2ZHpxamVXTzIxZk5xSm40emVib3I5YksyMjhaUksxSUIxcVpsV280UFJxZk5KQjBqcjhGbU1NQzEvWkk5dzFNOXZ1ZVV3VnN2MjFDU3lveTFVQmJoK09MaE83Z3ZYSno0M0I3aTlJSlhWcHl3TWxSMDJ5bEZ0ZG5uem9qNU5MamtpNnhJbm1NdEhoT3dZN2pRM3VocVNUMjV0S0tvZS82bFZyUTltRmN0VXpHdmFodlZuVERaQkRjeWc2L3JFNS82TjZWam9Id2ZHWEY1TllEZkxTYncwc1R3VTcwNDMyZk8zRHIrNytQODlBTjJzQng3cHNnY3RkdDBhWGtjRDZnamRpV1JQZ2ZGNlJvZ1FCNDJtTmdaR0JnQU9LY0FsM3BlSDZicnd6TUxBd2c4RGhDMXhSQi8xZGxPc1owRWNqbFlHQUNpUUlBN0lRSTBBQjQybU5nWkdCZ1p2alB3TURBZEl6QjRQOEZwbW9Hb0FnS1lBVUFacndFVGdMR0FBQUNPZ0JMQXF3QVRRSW9BREFDV2dBd0FBQUFBQUJtQU5vQlNBR3FlTnBqWUdSZ1lHQmw4R0ZnWWdBQlJnWTBBQUFJY1FCV2VOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUVFBQW9BQUFBQUJKUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaGNONFptTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SEwvME1aMng1WmdBQUFYQUFBQUZDQUFBQllCb1BpRkZvWldGa0FBQUN0QUFBQUMwQUFBQTJLVGlkWjJob1pXRUFBQUxrQUFBQUhnQUFBQ1FHMUFNOWFHMTBlQUFBQXdRQUFBQVFBQUFBRUF0N0FWNXNiMk5oQUFBREZBQUFBQW9BQUFBS0FPWUFhRzFoZUhBQUFBTWdBQUFBRndBQUFDQUFCZ0FxYm1GdFpRQUFBemdBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFFQkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdJTkdCaVNRVWx5V0RwVFVZRjdNelBBZnlHZG1ZQVFKTXlKVS9BY0tBd0FYcWc0Y0FIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXltb3lMLzcvSDhqWEFOSC9iLzVKQUtzQ0FnQ1ltd2s1QUFCNDJpMlBQVXZEVUJTRzc1dWIzSHphRDYySnJhUTBLU1JDdFlLbWFVRmk2V2hkUktIU1FnY3BpcVBGUlIwRjk4NytndjZJam9LTGcvZ0xCQWMzRjNFUU5mV2FlczV5M3VWOXprTkFicWNFOTVTUUlpRklRV2FXbVd5T3VYNFZ2dWVIOVczVXd3MXprZUZ1LzBhaXJxS3RYU2hnaFpiVExrV2lHSlhhVHF2QUlMeUdINVArNVpKMWRTeHFvaGJZdmVoc1BCNUdYVHZRUkpYd0FSbHcxb2l6bG5sZzhoL05XMGVRQU9ZOTMrT0hWWVJsWXZUZlNnWEpQL1JxT0RtWEtaMEJRV2Fka0JSRnRBZWRheFMrK3JvdUlRRnl4dEYwU29mQ2hLd1Fvc0l4bTBnRU5xbkR2SnBYVjFGRkxRZ3R4eXB6dXlyS3pvSXBtL2lNbjNCZ05QSmJsWHlVcnJnL2daRVRNbGlOSDJXYVRRc1Bic1ZvbE96VFp2ejhyWU5pTjM0RGZ5Mmo3SFc0RURNVUhWbDBtYXBrWkx6dmRGSnpSdnhpeUJKWC9nVnJPRUhWQUFCNDJtTmdaR0JnQUdLT0tkclI4ZncyWHhtWVdSaEE0SEdFcmltQy9zL0FYTWdNNG5Jd01JRW9BTnZyQjRVQUFBQjQybU5nWkdCZ1p2alBBQ1N2TWlReUpETVhNZ0JGVUFBTEFFMHVBeGtBQUFOU0FBQUNLZ0NhQWlvQVl3UFZBR0VBQUFBQUFEWUFhQUN3QUFCNDJtTmdaR0JnWUdIUVpBRFJERkFTQ1FBQUJOUUFNUUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS1ZlZG8yaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9KZGsyM3V4dlBiZkdWZ1ptRUFnY2NSdXFiSU5QTkVKaHNneGNIQUJPSUJBQWpEQ0NVQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUm9BQW9BQUFBQUJRd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMWJHTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWZBREJaMng1WmdBQUFXd0FBQUdpQUFBQjNQNTNiMFZvWldGa0FBQURFQUFBQUM0QUFBQTJLUnVkWjJob1pXRUFBQU5BQUFBQUhnQUFBQ1FHY1FKUGFHMTBlQUFBQTJBQUFBQU1BQUFBREFsZkFQcHNiMk5oQUFBRGJBQUFBQWdBQUFBSUFISUE3bTFoZUhBQUFBTjBBQUFBRndBQUFDQUFCUUJSYm1GdFpRQUFBNHdBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFFWEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtbG1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F3TS93SDhwa2gwa2hxL2dPRkFibVBETjRBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpGay9QOFA1SVBwLzdQL3p3S3JBZ0lBbVBJSk53QUFBSGphSGRCTlR0dEFGQWR3dnpmMmpCT1B4MTh6dG9sSVN1eklUbEpJaWhJYzBhWkpxeUNFUUh3dEVSSUhRT0lBVlJmZFZxcmFYb0ZiZEYrcDZnRjZDQTZBdWdYRzBiekZ6THkzZUwrL0FjYm41eDM4Zy8rTUk4TUE0Z0ZsQWhndHlnVk00a1JTRnIrQ0JjeXFKVlN6bkJaNzB5cVoxUGYxaVJNQmVWRVcxYXdZUThhb0I1TXFsb3d5ZU5oM0cwRXIvTGlUblJJWXFDR1J5aE5SdTJjRjRXYmdYTG1SOUc0RU5WUGJ6Uy83eDNva0hoTGdIZCtMV2ttVHAzZXV0SWtKMzU1K0xiTDVvRFZCeUVaWlJzcWcyMlNBV0tubDdmM3RXNkN1Yk1CRmQydnFCMk1UZXR2MUNDMkZqWkQ2eTU5QU54d0NobVlaWDU3LzR5UCtOYzVybytaMFFPbGw2MUkwMFcrTlRiUldiMDdaQ01xcEZ0YklhWkhyTUFSNHVIYk9JdjJwcFRxZGFwMUlyR0w0ZEJIZm5KeWRZR1RKcHNld1d5NkVhWFBlZ0RZUCtxdnhCeUErVjZoMFkzNjlKVVV6WTlhbW41dm1keFBCRnJrVElsSmkvZUFTOFA3cGQzdEZZRlVOMy9IOXRKUitUdkJnMjJzZ09uSlhocHI0WnNDZHN2T2V6a2RaSHc5M08vbnJyMm1rb0pmZ1hrZ3BCZFNSY0kzbVlMbm1DNCsxTy8wQUFIamFZMkJrWUdBQVltZGREZDU0ZnB1dkRNd3NEQ0R3T0VMWEZFSC8xMlVPWWJvTTVISXdNSUZFQWREN0Irb0FBSGphWTJCa1lHQm0rTThBSkVNWXF2OS9aL3JNQUJSQkFjd0Fib29FeFFBQUExUUFBQUs4QUhzRFR3Qi9BQUFBQUFCeUFPNTQybU5nWkdCZ1lHWUlZQURSREZBU0NRQUFDSWdBVndCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDArMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNWWjJ4NVpnQUFBV1FBQUFGTEFBQUJZRG1Tc1RKb1pXRmtBQUFDc0FBQUFDOEFBQUEyS00yZVFXaG9aV0VBQUFMZ0FBQUFIZ0FBQUNRR0xBSU9hRzEwZUFBQUF3QUFBQUFNQUFBQURBaCtBRTlzYjJOaEFBQUREQUFBQUFnQUFBQUlBRlFBc0cxaGVIQUFBQU1VQUFBQUZnQUFBQ0FBQndBNmJtRnRaUUFBQXl3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaVp2Z1A1RE5EcEpIVS9BY0tBd0R5S1ExSGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoTy8vOERTY2YvLy84ZkFQTVpBRktvQnA1NDJqV1BNVS9DUUFDRjc5M0JIV0RiUTF2YUdBRlRRWnBvRkVOSkt3d01LbWcwRXBURU1KQ1ltQ2liZzBGY0dSaDFNakZ4Y25IekI3ZzRPZmtuSEl5anZ3R3dOZkZOTDEvZThEMUNTWDQ2cFYvMGt4UkppUkFmbmw4eUxkMHdYYy9rUlFpbjRKUTl5L1Q4SW16QkRkUHlMQTBCRDdGYmcrK3lWNXh6UStXb21Xc3BLTkgrTUJhRk9xT1hXVnhNcGswMXJhc01hclRYVWFERWwycVBQL2FBbmlRUmwrT2hLVmxHZ0RIUW1CU0FZbDNVUjBZK0NTbzFIdUtFNU1oOTRKZ0VZV1IxT21hY3ZwRXNXU0diZ2FsZXpqazhjTE96U0drUVdWaGNnZ3ViLy9ucW9aeFhjSElGTHRoL1o4SEFmYjViY0RKU290TTlZOFAyUVJ0ME4zbDRQYmxQYTFvMSsvUncycWRZM3g0dDZ0SEwyKzZBMG8yOTkwWUUwRnEwTWt0WldvQWVWZmQ3TXRHc0hHeHB0VWo0QURycTdLcVIzNkdROCtNWGR0TmNickhKOXh4UGtGK3p2VHVEQUhqYVkyQmtZR0FBNHRZcklwengvRFpmR1poWkdFRGdjWVN1S1lMKy81ZVpqZWt1a012QndBUVNCUUQrdmdsSEFIamFZMkJrWUdCbStNOEFKRGtZVkJpWW1Oa1lnQ0lvZ0JrQUk4Y0JRZ0FBQW5ZQUFBTUFBQ1FEQ0FBckFBQUFBQUJVQUxCNDJtTmdaR0JnWUdhd0JHSVFZR1JBQXdBR2R3QkNBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTE0LjcyNDc0NycgeT0nLTIyLjk0MDY5MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTcuNTMwMTYxJyB5PSctMjIuMzMxODQ0Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTEzLjM2NTE5MicgeT0nLTE5LjMyNTMyNyc+KM6jPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00LjU2NDgxNCcgeT0nLTE4LjI2ODE4Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0uMDcxMjEzJyB5PSctMTkuMzI1MzI3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzMuMDQyMTMnIHk9Jy0xOS4zMjUzMjcnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nNy43MDYzODknIHk9Jy0xOS4zMjUzMjcnPikpPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDc5LjkxMjA4LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0xNC4xNDAxMzcnIHk9Jy0yMi45NDA2OTEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4MS4zMTQ4NywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg3NC44NTY1NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3NS4xMDY1NCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMwLjk2NTAxLDYuODcyOTEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMTguNDMyNzI0JyB5PSctMTcuOTkxNDMxJz7OozwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTMuNjU4ODc5JyB5PSctMTYuMjQ3OTY5Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy05LjE2NTI3OCcgeT0nLTE3Ljk5MTQzMSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNi40NjcwMjMnIHk9Jy0xNy45OTE0MzEnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTIuMzQ0Njk0JyB5PSctMTcuOTkxNDMxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004NS4zNTgyNi02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDg1LjM1ODI2LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODguNjIyMTUsLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+zqM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE2LjUwOTcxJyB5PSctMTguMjY4MTgnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTEyLjAxNjEwOScgeT0nLTE5LjMyNTMyNyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctOC45MDI3NjYnIHk9Jy0xOS4zMjUzMjcnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQuMjM4NTA4JyB5PSctMTkuMzI1MzI3Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0LTU2LjkwNTVINzYuMjU5MzInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzYuNTA5MzIsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQwLjE5MDM4LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ1LjY4NDQ4LDM3LjczODMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi4xOTY3NDYsLTE5LjMyNTMyNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjIuMTk2NzQ2JyB5PSctMTkuMzI1MzI3Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0xNC4xNDAxMzcnIHk9Jy0yMi45NDA2OTEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTQxLjA4MTE4IDMzLjgyODU3Qy00Ni40NzQ0OS0xLjEzNDM1LTM1Ljg4NzYtMjguMzg1My04LjY5NTM2LTUwLjIyNDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43Nzk2NSwtMC42MjYxNiwwLjYyNjE2LDAuNzc5NjUsLTguNTAwNDYsLTUwLjM4MTA0KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDUuMDA0NzMsLTIwLjgzMTM4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuMTk2NzQ2LC0xOS4zMjUzMjcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIyLjE5Njc0NicgeT0nLTE5LjMyNTMyNyc+aDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2Utd2lkdGg9JzEuNic+CjxwYXRoIGQ9J00tMzAuMjM2NTcgNDIuNDA1MjZDMTIuNjU3MTIgNTIuMDcyMiA0Ny40MzYzNyA0MS4yNDEwMSA3Ny4yNTUxNCA4LjkyNzU1JyBmaWxsPSdub25lJy8+CjxnIHN0cm9rZS13aWR0aD0nMC42Jz4KPGcgc3Ryb2tlPScjZmZmJz4KPHBhdGggZD0nTS0zMC4yMzY1NyA0Mi40MDUyNkMxMi42NTcxMiA1Mi4wNzIyIDQ3LjQzNjM3IDQxLjI0MTAxIDc3LjI1NTE0IDguOTI3NTUnIGZpbGw9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00tMzMuODI4MDggMzMuODI4NTdMLTkuMjc3MTYgOS4yODEwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE0LC0wLjcwNzA1LDAuNzA3MDUsMC43MDcxNCwtOS4xMDAzNyw5LjEwNDMxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00tMjguNzU0ODIgMTUuMjY2OThILTEzLjk5Njg1VjI1LjY0MTk1SC0yOC43NTQ4MlonIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yNS43NTQ4MiwxOS42MjgwNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjE5Njc0NiwtMTkuMzI1MzI3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi4xOTY3NDYnIHk9Jy0xOS4zMjUzMjcnPs63PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xOC4wOTE5NTgnIHk9Jy0xOC4yNjgxOCc+aDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                width = 3cm,
                sw = A,
                nw/style = pullback,
                se = B,
                nw = A',
                ne = B',
                south = f,
                east = \Sigma _{f}(h),
                west = f^{*}(\Sigma _{f}(h)),
                west/node/style = {right},
                north = \varepsilon _{\Sigma _{f}(h)},
              }
              \node  [above left of = nw] (c) {$B'$};
              \draw  [->,morphism,bend right] (c) to node[swap] {$h$} (sw);
              \draw  [double,morphism,bend left] (c) to (ne);
              \draw  [->,morphism,exists] (c) to node[desc] {$\eta _{h}$} (nw);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          <fr:p>where <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> is the counit defined on the right. Then naturality is a consequence of uniqueness.</fr:p>
        </html:td>

        
  <html:td>Let <fr:tex
display="inline"><![CDATA[g \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex> be an object. We take <fr:tex
display="inline"><![CDATA[\varepsilon _{g}\colon \Sigma _{f}(f^{*}(g))\to g]]></fr:tex> to be the following morphism.
          
    
      
      <fr:figure><fr:resource
hash="713a053a883955433c0f73df139f72b9"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzOC44MDA0NDNwdCcgaGVpZ2h0PScxMTcuODQ5NjI0cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTIuNTMzNjI5IDc4LjU2NjQxNic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9VQUFvQUFBQUFBL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFYR050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFEWUFBQUEyTlZxTFR0b1pXRmtBQUFDUEFBQUFDOEFBQUEyS1J1Y2dtaG9aV0VBQUFKc0FBQUFIZ0FBQUNRRjhRS2FhRzEwZUFBQUFvd0FBQUFJQUFBQUNBWWhBR1ZzYjJOaEFBQUNsQUFBQUFZQUFBQUdBR3dBQUcxaGVIQUFBQUtjQUFBQUZnQUFBQ0FBQlFCRmJtRnRaUUFBQXJRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGhBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTZRek0vd0g4cGtoMGtocS9nT0ZBYlFlRE04QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOUR5UCt6d0h3R0FGVzFCc01BQUFBQUFnQmwveXdDaWdIRkFDNEFRd0FBQVFNT0FTTUdMd0VtSno0Qk1oWVZGQVlIRmg4QkZqNENQd0VPQVFjdUFTYzJOelkzTmpjeUZoYzJOeDRCRlFjM05pOEJKaWNPQVFjT0FSVWVBVGMrQVRjK0FRS0ZiQlNQYXk4MUN6TUVBU1V5RmdvUUFpSXRGejlIR0FZWUVrd3lTMllDQTBVUkVsQmhJa0FaRVNJVEU1WXRBUlVFRnp3cFNCWWRIQUk1SUNoRkhRNEpBWFgrVEV0SUFna0REQzhkSlJvUENCd1BCUUlCQVFvd01CeGhFQ1VDQVZ4U1kwd1REMElER3lJbkFRRVZEdnU0Q2lNR0lnUUJNQ012ZFNFN0xBRUJKeDBQRHdCNDJtTmdaR0JnQU9LNWEzZkt4dlBiZkdWZ1ptRUFnY2NSdWw0SStyOE9jd2pqVVNDWGc0RUpKQW9BRm1NSmZ3QjQybU5nWkdCZ1p2alBBQ1JER0ZJWm5KbTZHSUFpS0lBSkFFQVdBcElBQUFOVUFBQUN6UUJsQUFBQUFBQnNBQUI0Mm1OZ1pHQmdZR0p3QVdJUVlHUkFBd0FIV0FCTEFBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmtBQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUN3QUFBQTJLaHVkYldob1pXRUFBQUk4QUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQWx3QUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ1pBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSnNBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb1FBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEVkFBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpbWxYcWtmSDhObDhabUZrWVFPQnhoSzRYTXMwU3luZ0hTSEV3TUlGNEFPOXZCL040Mm1OZ1pHQmcxdnBqeWNEQUVzclF4OURQbE13QUZFRUJUQUJTZ0FOQ0FBUlZBQUFDOGdDT0FBQUFBQUJVQUFCNDJtTmdaR0JnWUdJd1pRRFJERkFTQ1FBQUJjb0FPd0I0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQ1VsWVdCaVpXcEMyQ0RNc1JCZG9nVXFlckk3KzdoZXVnTnArZjl1QU5LZnNoNFRzWnIzTS9KS1VUOWNjRUxiNG1ub2hhSlN6NVlNaUhMWitMTTJTVE9KZmxLWFBET0pmRlUvTy9FSlo4OHRsMTd1L2ZXcTMxbnJIZm5Ob3pyZy9XaDZaeGE2U3JxblhYV0gzdHIxR2xVWm1qQ2NHMVZyU3RkczZXajVjYWRIb3RIc1JmSFJIYWNKUXVNckRsRUo5Qkk2cVMxUWxQOXkzZVN1OWc1eGs5R09pZEpsTkFnVjBIMlZkcUtPbDVxNmwvdjZUQkhBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVR3QUFvQUFBQUFCYndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjM4bU50WVhBQUFBRThBQUFBTWdBQUFEd0hGZjEyWjJ4NVpnQUFBWEFBQUFJZUFBQUNoQkxGdkVab1pXRmtBQUFEa0FBQUFDOEFBQUEyS0kyZGoyaG9aV0VBQUFQQUFBQUFJQUFBQUNRRm1RR2JhRzEwZUFBQUErQUFBQUFRQUFBQUVBbGlBS2RzYjJOaEFBQUQ4QUFBQUFvQUFBQUtBYWdBMUcxaGVIQUFBQVA4QUFBQUdBQUFBQ0FBQndCRmJtRnRaUUFBQkJRQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRTVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWltQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVc5bFp2Z1A1RE16TUlLRUdSRXEvZ09GQWZCNURlWUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5cVl6Yi8zL0g4aFBBOUgvWi8veEE2c0NBZ0NpSndtSkFBQjQya1hSUFcvVFFCd0djRDkzN2psdjl0bXhmVzZUMUhseGJJZlN4bW5jT2lpdDh0SldRbTBScFVLaUtrSWdoaTZka0JoQWZBZ0cxSUdWbFcvQTNoM3hIUmlSbUJoWVVzN3R3SjEwd3owMy9ILzNLRkNPYnhKeVNYNG9NMFVCNVdDYUFhMFR4Uk9rd2hOTUUwMU1NS1VCaXpJdm5XQWs3NGZDTXhCRWNaU05vZ1FHNFVnendXSjhHWnVxV1N2T04zdGpvT3RHRkx6Sk9lKzI2V3FmUC9LSnpVKzVhNGk5NE40dUVBaVptejduMWFwZkt0UmU1VEd1RnRkSDFtekwyYWRSNExkSWw4WGxJb0Y2N0g3K2MwWTdHczdPNjNFVWR2OUhXSWsyUHFxZEFoUzVpTEorczBGQ1hDdDlaVC9YU0FtN2xjaUpIYVo1SWhXWkJFd2xzbzg0RytYYmh5ZFY4Z0dkSW9zbGltbjVGd2h2bUQ4bDdUZkZ0KytUbDZxYzF4SXdxZzJyN2V3R0RhRjVvOFA1T2FGemJoMmU5N1oxV3F2cUxqNGxGSTY3VmR0dnVhYUZLUGIzR2hVTkh4Yno1RGtsN3ZwcTI3YkxmbW1Kb054WUdiUmVwQ3JPbmx3OHR2a0JSVmVZQXFhMStQdU5sOE5BUlc4N21zOU9SZ2hiWEwrMURXNSs0VGUrS3p1NWJXVEFZNTdzWm5objRIY2tLYms3TStGSm1DRkg2TXMyWllzUzZXVjViekdMeFpRa1lGL1RFTmhaYmFZbkQ2dHFRU2M5Yy9QeTJRWElneVlOaUhyMXVqSnNXMTNBRmFWZ3JKKytveVNNZGlydEFlaWtjYi9zTDRmTzhuTHlzejYxMStvbFF1cStCdFRqU3FUaWFEellxeUpzenA0Q3pHQ3VxZHRFYzByWVhPdllSZ0hRblVZWmFyZ2tVeFZFMHY0Qi8xQlVuQUFBZU5wallHUmdZQUJpbmxVOXB2SDhObDhabUZrWVFPQnhoSzRYZ3Y2dnkzU002U0tReThIQUJCSUZBUDVtQ1ZVQWVOcGpZR1JnWUdiNHo4REF3SFNNUWVmL0JhWXNCcUFJQ21BQkFHVWNCRGdDeGdBQUFqb0FTd0k2QUN3Q0tBQXdBQUFBQUFCbUFOUUJRZ0FBZU5wallHUmdZR0JoY0dGZ1lnQUJSZ1kwQUFBSGpnQk5lTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNQUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQ3dBQUFBMktWZWR6V2hvWldFQUFBSFlBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZmdBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQUFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJSUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpQUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM4QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPSmRrMjA2NC9sdHZqSXdzekNBd09NSVhTOWttbmtpa3cyUTRtQmdBdkVBL2w0SCszamFZMkJrWUdCVy9HTUVKQ2N5R0RMSU1wb3dBRVZRQUJNQVFSb0NiZ0FBQTVFQUFBRlJBREVBQUFBQUFDQUFBSGphWTJCa1lHQmdZdUJuQU5FTVVCSUpBQUFDRkFBVkFIamFUWXc5YjhJd0VJYWZpQVNKZE9oU2RlZ0FIcGl0b0ZSaVkyRmdZbVhxQXRpZ0RIR1FIU0pGcWpyeXUzdTRIbnJENlhrLzdvQ1NIektlay9FYTkzTnlDbEYvWFBEQ1crS3BxRVhpa2crV1RNanltVGh6Tm9selNiNFNGN3h6U1R3Vi96dHh5U2VQYmRmZTdyMzFhdDhaNjkyNURlUDZZSDFvT3FkV3VvcDZaNTMxeDk0YWRScVZHWm93WEZ0VjYwclhiT2xvdVhHbngrSlI3TVV4a1IxbnlRSWphdzdSQ1RTU09tbXQwRlQvOHAza0xuYU84Wk9SemtrU0pUVElWWkI5bGJhaWpwZWEraGZ6ZVRCUEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDMEFBQUEyS0pxZGttaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNG1OdnN0VGorVzIrTWpDek1JREE0d2hkTHdUOW41SHBNak9JeThIQUJLSUFHRzhKTWdBQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLTTJlYTJob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0dFlyd2x2aitXMitNakN6TUlEQTR3aGRMd1Q5L3k4ekc5TmRJSmVEZ1Fra0NnQWZTd29jQUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuMTUyNzksLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00Ni41NTA1MTgnIHk9Jy02MS42Nzg5OTcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTM5LjA3ODUxOScgeT0nLTY1LjI5NDM2MSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMi41MzEwNCwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00Ni41NTA1MTgsLTYxLjY3ODk5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDYuNTUwNTE4JyB5PSctNjEuNjc4OTk3Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00MS44ODM5MzQnIHk9Jy02NC42ODU1MTUnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzcuNzE4OTY1JyB5PSctNjEuNjc4OTk3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zNC42MDU2MjEnIHk9Jy02MS42Nzg5OTcnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTMwLjQ2ODY3MScgeT0nLTYxLjY3ODk5Nyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzguNDkzOTEnIHk9Jy02NS4yOTQzNjEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOS43MDgzMyAwSDQ2LjQwMzc4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ2LjY1Mzc4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjQuMzI1ODIsNC43ODQwMSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQ2LjU1MDUxOCwtNjEuNjc4OTk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Ni41NTA1MTgnIHk9Jy02MS42Nzg5OTcnPs61PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Mi43ODY0OTYnIHk9Jy02MC42ODI3MzMnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NC01Ni45MDU1SDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNS45NjQsLTY0LjU3ODQxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDYuNTUwNTE4LC02MS42Nzg5OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ2LjU1MDUxOCcgeT0nLTYxLjY3ODk5Nyc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \DiagramSquare {
              sw = A,
              nw/style = pullback,
              se = B,
              nw = A',
              ne = B',
              south = f,
              east = g,
              west = f^{*}(g),
              north = \varepsilon _{g},
            }
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          Let <fr:tex
display="inline"><![CDATA[\alpha \colon g\to g']]></fr:tex> be a morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. By the construction of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>, we have the following commutative diagram.
          
    
      
      <fr:figure><fr:resource
hash="1ee8ae6f4500f08dd08da5314907b5d1"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5OC4yMjM2MjFwdCcgaGVpZ2h0PScxNzUuNDY3NzY2cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTMyLjE0OTA4MSAxMTYuOTc4NTExJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLUnVjWW1ob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0s1YTNmR3h2UGJmR1ZnWm1FQWdjY1J1bFlJK3I4T2N3ampVU0NYZzRFSkpBb0FIa01KbndCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDMEFBQUEyS0pxZGNtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNG1OdnN0TGorVzIrTWpDek1JREE0d2hkS3dUOW41SHBNak9JeThIQUJLSUFJRThKVWdBQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPc0FBb0FBQUFBQkJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUUwQUFBQmdxbU5pZTJOdFlYQUFBQUZFQUFBQU13QUFBRHllV21SYloyeDVaZ0FBQVhnQUFBRGdBQUFBN0QwTlFsdG9aV0ZrQUFBQ1dBQUFBQ3NBQUFBMktodWRyV2hvWldFQUFBS0VBQUFBSHdBQUFDUUY3Z0RhYUcxMGVBQUFBcVFBQUFBTUFBQUFEQWtLQU8xc2IyTmhBQUFDc0FBQUFBZ0FBQUFJQUZRQWRtMWhlSEFBQUFLNEFBQUFGd0FBQUNBQUJRQTJibUZ0WlFBQUF0QUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1abWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUE0TURqSjFTWEpiT3dLWWsvc0NBV2V1UEpRTURzeGJ6Y2FBd0kwTDEvLzhNREFEb3R3N2ZBQUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFabVJnVWhKL1lQRC9Qd01EaEw3N1N2NFNXQlVRQUFDbmlRbXlBSGphTFk1UFNzUXdIRWJ6cGNNdlZOUGFQMm5Tb2s3SERLYTdrU2wxQ2lMMUVvb2JzWWpRdld0dm9PQVJSbkRuR2J5R3l6bUxtTVdzSHQvN05vK0JmYkFsZjhhT2RZeWgzN1JhMFJHMDBTYUd1MEFORWl0ME54RFVXT2ZwR3RjTWFHczA3ckxiOU5vSXZIM0tTcVgwZlgrWGM2Z3EvSXFJMnpRbitYNU9VVkY2cnppS010cEt5bFBMRDNFOGhzckdmRGc5RTJXbVFFL1QxVHhBWnRiVGJRRmxrLzBSanRQNklNckE2MGVmeGtiVzRKVmZzOFNQZ0phK284OEg5SzAySlBEeVMxTG53V3diVlBQS0FUUHMvaDVTSWFJRVAvRUNpeE1wMlQ5dWZCL1FlTnBqWUdSZ1lBQmhuZGUxOGZ3Mlh4bVlXUmhBNEhHRXJoVXl6UkxLWkFPa09CaVlRRHdBNFFrSElnQjQybU5nWkdCZzF2cGp5Y0RBRXNvUXorREJsTXdBRkVFQnpBQklkUUxOQUFSVkFBQUM4Z0NPQWNNQVh3QUFBQUFBVkFCMmVOcGpZR1JnWUdCbU1HVUEwUXhRRWdrQUFBWGxBRHdBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLVmVkcldob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0pkazIxT3h2UGJmR1ZnWm1FQWdjY1J1bGJJTlBORUpoc2d4Y0hBQk9JQkFBWk5DQnNBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFXUUFBb0FBQUFBQnBnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0RW1OdFlYQUFBQUU4QUFBQU5RQUFBRVFEeGdTSFoyeDVaZ0FBQVhRQUFBSzRBQUFEVktVZ3EyUm9aV0ZrQUFBRUxBQUFBQzhBQUFBMktJMmRiMmhvWldFQUFBUmNBQUFBSUFBQUFDUUY0d0hPYUcxMGVBQUFCSHdBQUFBVUFBQUFGQXhhQU9ac2IyTmhBQUFFa0FBQUFBd0FBQUFNQWFJQ2ZtMWhlSEFBQUFTY0FBQUFHQUFBQUNBQUNBQkZibUZ0WlFBQUJMUUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZoQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1XOWxadmdQNURNek1JS0VHUkVxL2dPRkFmd1pEZ1lBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnTWdEUUhFSUxrMHBrM01tLzkveC9JU29Pdy9zLytFL1RISDZ3V0RBQUlEQXhOQUFBQWVOcE4wczFQMDJBY0IvQitmeTN0NkY3NnN2WXBiS05qNjlwT0JEWlc2QWpneHNDZ3ZBZ1NqV1RFK0pZZ0VTOG1Ka3E4K1E4WVF6aDQ5ZXJaaTNmdXh2L0JvNGtYUFhnQm40NkR0a2tQeis5Sit2MDgzMGVBc0huUm9DUDZKaXdMQWtRTnNwS0RVZzNDRGlMbU1GbGhaWFRRRlQwNWlKMm9nelpmYnpFbkJ5OElnN2dkTkpBakRWSE01QkFmRjNSSkx3ejNadW9MUU0wT1JHaGxUZE5xRlhGc1d0dHlLYS90YW5hT3JYaFhsZ0NQOGJudWFwcHB1bXFxOERBWjQvVDhiTU5ZbnJWV3hjQnp4NmttaCtsaGdyUnBmL2k5SjFZVjdQV0xZZURYL28wd0dreTlrNm9wQ1B3aFlmSmlpbnljQ2RQQ2FxTGhFbmtnNFlrdFdYRll4R0lPNkhMa05NSzRuYnd1SEs3aUc4UXU0cENqWkNVNUF1YTBrcTFVZVRIODhyanhRT0o1RFlhY1dUSXExcEpYWW9yVFh1LzFTZXhweG5xL1BwY1ZDMmJXeGtsRGhHWFBGbGJIYmQxQUVMb3JwWXlDTitlOXhyNUk5dVJZSlo5UHUrb1FJVjBhYlk3Zmp5VHMzVDdZem12WFJkU1l6cUFiNTMrK2FHbmZrMUNmQzNyTE8yMzQ0MXAyWU90ZS9LTFBBeHR2eW5mUjVwYlp5Qm5JdUpKYi96ZngycEw4WmJoSU91VXdQZzBTbVdQeFhtTnFTaXl0MWpLbUtpT2FHdTFZazhjMzl4K1J0R1pZdTRmYnp6SUVXaTBOS1NvZkY0YkxKeEtrb2VhMTRpMC81RCtPeXEvZTc5Y2xtS1UwU0RVaklpLzJJdERoK3BNZFMrZVcvYTEwcFhYM3FhNkN5RjR6MXAvM0cxNnJMOEtibW45Ym5MMEdxbkpQOCtJSGZ1S3JzSmgwMWVhNTVDUjA2eksvZGxrUmIrYnlHek9IbzNKSUdFcVYzMHBlbWhNbjl6Q1VROWFsQnVSUGtROHNqcFdqblJ1bWxNcFNYWjg1dW5jQW1pK0xIa21uanpPdGlsRURiS1o2QzluZDF5TDV3V0ttMG9UWUtWMU51eU8rTlRMUytGN3M1aWVLS2xIUlZZQmltQWtrYkN3MFYwejQ1ZVU3Z0p5VGJUMmJKOFZTTVROUnplZFNRTmJpeHlENVEzd3FnWGhWZndHKzNuS0FlTnBqWUdSZ1lBRGlGMUpURHNiejIzeGxZR1poQUlISEVicFdDUHEvTHRNeHBvdEFMZ2NERTBnVUFDS3hDaFVBZU5wallHUmdZR2I0ejhEQXdQU0RRZWYvQmFZdERFQVJGTUFLQUc5OUJMVUN4Z0FBQWpvQVN3STZBQ3dDK0FBL0FpZ0FNQUFBQUFBQVpnRFVBVHdCcW5qYVkyQmtZR0JnWlhCaFlHSUFBVVlHTkFBQUI2a0FUbmphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9DQ3hkV0ZnWW1YcUF0aEZHV3dqSjBSQ3FqcjJkL2RoUFBRTlYrZCsyRURORHdYM0s1Z2x2VjlKSmU3QkZWUG1tU2ZpM2pMWExIam5pYUo4bHVTVmo4eWxOSitaSzE3NHlqeVIvRHR6ellyZlRYQ1g2MkNqMmdWam96ODUxNjMzTnZaZDhHcXBtK1MzMXR0NEdLeFJ4NXN5WTllUFo2ZGEzZWlXRFFISGhTc0Rsb2hpSjRsSjdEbEo1K2hZczA5Skx4d2tWeXpSTlAvNnJmUStiUTdwSnlPYkl6ZFJ3eWlMWHZRc1cwV2JYbXJhUDh1aEwvY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLTTJlUzJob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0dFlyd2wvaitXMitNakN6TUlEQTR3aGRLd1Q5L3k4ekc5TmRJSmVEZ1Fra0NnQW5Ld284QUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNi4zMDU1NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIuMTU3ODU5JyB5PSctMjYuODgyMjY5Jz7ugLDugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC05LjYyOTg1OCwtMjMuMjY2OTA2KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy05LjYyOTg1OCcgeT0nLTIzLjI2NjkwNic+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQuOTYzMjc0JyB5PSctMjYuMjczNDIzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS43OTgzMDQnIHk9Jy0yMy4yNjY5MDYnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMi4zMTUwMzknIHk9Jy0yMy4yNjY5MDYnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNi40NTE5ODknIHk9Jy0yNi4yNzM0MjMnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc5LjE0Njc2MycgeT0nLTIzLjI2NjkwNic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MC4zMDY1NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTEuNTczMjUnIHk9Jy0yNi44ODIyNjknPu6AsO6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjg2MTEgMEg0NS4yNTEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDUuNTAxLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjIuOTczMzksNS42MjI5NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNS44NjU4MzYnIHk9Jy0yMS40MzQ4NjMnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTIuMTk3Mjc5JyB5PSctMjIuOTAxNTkyJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNDkyOTA4JyB5PSctMjYuMjczNDIzJz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00NS4zOTEwOCwzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIuMTU3ODU5JyB5PSctMjYuODgyMjY5Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC42OTUzNi01MC4yMjQ1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzc5NjUsLTAuNjI2MTYsMC42MjYxNiwwLjc3OTY1LC04LjUwMDQ2LC01MC4zODEwNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTU5LjU5MDE1LC0yMS4zMTQ0NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTkuNjI5ODU4LC0yMy4yNjY5MDYpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuNjI5ODU4JyB5PSctMjMuMjY2OTA2Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00Ljk2MzI3NCcgeT0nLTI2LjI3MzQyMyc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0uNzk4MzA0JyB5PSctMjMuMjY2OTA2Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzIuMzE1MDM5JyB5PSctMjMuMjY2OTA2Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzYuNDUxOTg5JyB5PSctMjMuMjY2OTA2Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tMzAuNTI5OTcgNDEuNTE0OTRDMy4wNzcyOSA0Ni4yMjg4OCAyOS4xNzQ1OSAzNS42NzUyNSA0OS43NTI5OCA5LjMyMTYyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNjE1NDMsLTAuNzg4MTYsMC43ODgxNiwwLjYxNTQzLDQ5LjkwNjgzLDkuMTI0NTkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE3Ljc5OTY1LDQxLjgwMzM0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPs6xzrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLS42ODY0OTQnIHk9Jy0yMi4yNzA2NDInPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00tMzMuODI4MDggMzMuODI4NTdMLTkuMjc3MTYgOS4yODEwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE0LC0wLjcwNzA1LDAuNzA3MDUsMC43MDcxNCwtOS4xMDAzNyw5LjEwNDMxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00tMzQuNTMyNTYgMTQuODc4MDdILTguMjE5MTFWMjcuOTcyMjJILTM0LjUzMjU2Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMxLjUzMjU2LDE5LjYyODA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtOS42Mjk4NTgsLTIzLjI2NjkwNilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctOS42Mjk4NTgnIHk9Jy0yMy4yNjY5MDYnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQuOTYzMjc0JyB5PSctMjYuMjczNDIzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS43OTgzMDQnIHk9Jy0yMy4yNjY5MDYnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMi4zMTUwMzknIHk9Jy0yMy4yNjY5MDYnPs6xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzcuNDk0MzgnIHk9Jy0yMy4yNjY5MDYnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                nw = A'',
                nw/style = pullback,
                ne = B'',
                sw = A,
                se = B,
                north = \varepsilon _{g'},
                west = f^{*}(g'),
                west/node/style = {right},
                south = f,
                east = g',
              }
              \node  [above left of = nw] (a') {$A'$};
              \draw  [->,morphism,bend right] (a') to node[swap] {$f^{*}(g)$} (sw);
              \draw  [->,morphism,bend left] (a') to node {$\alpha \varepsilon _{g}$} (ne);
              \draw  [->,morphism,exists] (a') to node[desc] {$f^{*}(\alpha )$} (nw);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
          Thus, <fr:tex
display="inline"><![CDATA[\varepsilon _{g'}\Sigma _{f}(f^{*}(\alpha )) = \varepsilon _{g'}f^{*}(\alpha ) = \alpha \varepsilon _{g}]]></fr:tex> as required.
        </html:td>

      </html:tr>

    </html:table>
<fr:p>By construction, <fr:tex
display="inline"><![CDATA[\varepsilon _{\Sigma _{f}}\eta  = \mathsf {id}_{\Sigma _{f}}]]></fr:tex>. Thus, it remains to verify the other triangle equality.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[g \in  {{\mathcal {C}}_{/{B}}}]]></fr:tex> be an object. We need to show that <fr:tex
display="inline"><![CDATA[f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} = \mathsf {id}_{f^{*}(g)}]]></fr:tex>. Note that <fr:tex
display="inline"><![CDATA[f^{*}(g)f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} = f^{*}(g)]]></fr:tex> by the construction of <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex>. Moreover, we also have the following equation.</fr:p><fr:tex
display="block"><![CDATA[       \begin {align*}         \varepsilon _{g}f^{*}(\varepsilon _{g})\eta _{f^{*}(g)} &= \varepsilon _{g}\varepsilon _{f \circ  f^{*}(g)}\eta _{f^{*}(g)} && \text {by the construction of } f^{*}\\                                                     &= \varepsilon _{g}\mathsf {id} && \text {by the construction of } \eta \\                                                     &= \varepsilon _{g}       \end {align*}     ]]></fr:tex><fr:p>Thus, <fr:tex
display="inline"><![CDATA[f^{*}(\varepsilon _{g})\eta _{f^{*}(g)}]]></fr:tex> corresponds to the same cone over <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex> as <fr:tex
display="inline"><![CDATA[\mathsf {id}_{f^{*}(g)}]]></fr:tex>. Then uniqueness implies that they are equal.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Backlinks">Backlinks</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1996</fr:anchor><fr:addr
type="user">log-000R</fr:addr><fr:route>log-000R.xml</fr:route><fr:title
text="Comprehension schema via syntactic category"><fr:link
type="local"
href="log-000I.xml"
addr="log-000I"
title="Comprehension schema">Comprehension schema</fr:link> via syntactic category</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[T\colon \mathcal {C}^\mathrm {op}\to \mathsf {Lat}]]></fr:tex> be a <fr:link
type="local"
href="log-000C.xml"
addr="log-000C"
title="Doctrine">doctrine</fr:link> with those structures listed in <fr:ref
addr="log-000H"
href="log-000H.xml"
taxon="Lemma" />.
  Additionally, assume that <fr:tex
display="inline"><![CDATA[T]]></fr:tex> satisfies <fr:link
type="local"
href="log-000D.xml"
addr="log-000D"
title="Frobenius reciprocity">Frobenius reciprocity</fr:link>.
  Then there is a doctrine <fr:tex
display="inline"><![CDATA[T^{\flat }\colon \mathsf {Elts}(T)^\mathrm {op}\to \mathsf {Lat}]]></fr:tex> indexed by the syntactic category of <fr:tex
display="inline"><![CDATA[T]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[T^{\flat }]]></fr:tex> admits comprehension schema.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1297</fr:anchor><fr:addr
type="machine">#299</fr:addr><fr:route>unstable-299.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>This proof is adopted from Errol Yuksel's proof.
    Any error should be attributed to me.</fr:p>
  <fr:p>Let us define the action on objects by <fr:tex
display="inline"><![CDATA[T^{\flat }(\Gamma .\varphi ) = {{T(\Gamma )}_{/{\varphi }}}]]></fr:tex>.
    That is, <fr:tex
display="inline"><![CDATA[T^{\flat }]]></fr:tex> sends each formula-in-context <fr:tex
display="inline"><![CDATA[\Gamma .\varphi ]]></fr:tex> to its downward closure ordered by entailment.
    By assumption, each <fr:tex
display="inline"><![CDATA[T(\Gamma )]]></fr:tex> is cartesian.
    Thus, each slice <fr:tex
display="inline"><![CDATA[{{T(\Gamma )}_{/{\varphi }}}]]></fr:tex> is also cartesian by <fr:ref
addr="ct-000H"
href="ct-000H.xml"
taxon="Lemma" />.</fr:p>
  <fr:p>For each morphism <fr:tex
display="inline"><![CDATA[f\colon \Gamma .\varphi \to \Delta .\psi ]]></fr:tex>, we define <fr:tex
display="inline"><![CDATA[T^{\flat }(f)]]></fr:tex> to be the following composite:</fr:p>
  <fr:tex
display="block"><![CDATA[{{T(\Delta )}_{/{\psi }}} \xrightarrow {{{T(f)}_{/{\psi }}}} {{T(\Gamma )}_{/{T(f)(\psi )}}} \xrightarrow {\varphi  \wedge  \mathord {\hspace {1pt}\text {--}\hspace {1pt}}} {{T(\Gamma )}_{/{\varphi }}}]]></fr:tex>
  <fr:p>where <fr:tex
display="inline"><![CDATA[{{T(f)}_{/{\psi }}}]]></fr:tex> sends each <fr:tex
display="inline"><![CDATA[\chi  \vdash  \psi ]]></fr:tex> to <fr:tex
display="inline"><![CDATA[T(f)(\chi ) \vdash  T(f)(\psi )]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\varphi  \wedge  \mathord {\hspace {1pt}\text {--}\hspace {1pt}}]]></fr:tex> is the usual pullback functor along the morphism <fr:tex
display="inline"><![CDATA[\varphi  \vdash  T(f)(\psi )]]></fr:tex>.</fr:p>
  <fr:p>This composite admits a left adjoint <fr:tex
display="inline"><![CDATA[\exists ^{\flat }_{f}]]></fr:tex> defined as the composite of the top morphisms of the following diagram:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="4863ea188a85adfaccec22bd95b694a5"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMxNi4yNTY0NDNwdCcgaGVpZ2h0PSc1Mi43NDc5MnB0JyB2aWV3Qm94PSctNzIgLTcyIDIxMC44Mzc2MjkgMzUuMTY1MjgnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFWUUFBb0FBQUFBQmpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY3A1QVdOdFlYQUFBQUU4QUFBQU93QUFBRXdFbVFRcFoyeDVaZ0FBQVhnQUFBSnpBQUFDNUFoRHpjeG9aV0ZrQUFBRDdBQUFBQzBBQUFBMktTeWRoV2hvWldFQUFBUWNBQUFBSGdBQUFDUUd4UUsxYUcxMGVBQUFCRHdBQUFBVUFBQUFGQkJtQWNwc2IyTmhBQUFFVUFBQUFBd0FBQUFNQVRBQ0JHMWhlSEFBQUFSY0FBQUFHQUFBQUNBQUNBQlJibUZ0WlFBQUJIUUFBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUZSQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1kbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBycU0xOWxadmdQNURNek1JS0VHUkVxL2dPRkFlZWhEYjhBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1Jnc2dEUVhBd2RRam9sQm55R04rUVR6MWYvL2dXSnc5djlMLytmOHNmNmpEOVlCQlFCMjJRNi9BSGphSlpMUFR4TkJGTWZudmRudXIzYTczWFozdGhiYTB1M1NnY2EyeU5adGlyS0ZnSUJFcENpSmNwQ0RpVUdKSnBJUWcxR0pkNHdtSmw3MFltSk12R24wNE1FejhlVEpQOEovUXFtekpXOG1iK2FiTjIvbTg5NFFJSWNEZ3Z1VUVJTVFEV1NseG1zZENEdk1aYmg3c3FHNEJZb2FmRlpqajcvK3J1V1JGdENtMzRhZUVBTGt5YUNCeC9pYnJJZ05OVVdHTkNoeWpVY1FNTmVXRlZhR0NEcGhUK1NzeXJYejdkQU40dlhRbUp1R3FyZ3c3TlJhNENteUNVSEliRVZXNEUvWDBLeENkcjdoclZHWWRPclVkc3gwcnVnbnJPeW9sZHd5Y3JhNW5aYWx2R3BVTnlaV1JRaXJVMGlWTW1hdTRPcXAvQVBEVnFrRVJ5ZmZJKy9pWkNGQThKcWVSN2xWMFJWQURKM2U3dnZkR1pBTlc0TitaYXlkc1ZvUytHZmpFSm1uVllSOHB2Y0s1RE5KQ2tQR1c0TW12WU0veVhyTWVQcjRKbkF4WXJRaFpvek54YXp5R3U4SXBCaEtZTVhGT0JYYncxTWxjRzBodU1MblJJVmM1dUxyRDN0OXYzQUJZRFFwcHdDcXJqV0JqbG5xM25oWmJxQ1dTcW5RdUxhMExLSEZUWUNTMzdPb21qSlVLQ1V0dm5ndWdxeWZRZHljK3lnTlZmejA3NkVValpRdnoxYkdsWVJsc0hFQVBsMjhQUjRGSzJYNjFWQVI5Ui9vK3h1cGhlMngwUW1BK1haU0U1b1RaSzBwQ1FMTy9LMmUzZzBUK01ZVWVwSWcyUjlVNkJJY2t5a3lTMGpDaEdITGVsVEF0OE5PQkFMQmprWGhZNHRvekJqWFExWjRJTXJURk9HaXNRemVNazBxWmowSmxCRm41eG5XNjltTW80Z2YwK0lnemFUVGMxMjN1Yll6dTNnVDZKWmJ2UGRDZDk1OVFWeHRYVG9hMGFuK0tNd3g5TFI4ZjhXNjIrZFBweDJOb2s0bEszak1Gb3FhektRckIzdkxBTmRYNzIreTNCSzlLajFmbjI3QndlR01UTWgvZi9Wbm1nQjQybU5nWkdCZ0FHS3hQSC9OZUg2YnJ3ek1MQXdnOERoQzF3VkIvMmRnVG1VR2NUa1ltRUFVQU5laEIzRUFBQUI0Mm1OZ1pHQmdadmpQQUNSM01NVCsvODZjeWdBVVFRR3NBR3NvQklBQUFBTlVBQUFDOGdCK0Fyd0Fld080QUYwRHJBQjBBQUFBQUFBZ0FKSUJFQUZ5ZU5wallHUmdZR0JsQ0dCZ1lnQUJSZ1kwQUFBSTFRQmFlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ3dOcUZnWW1WcVF0Z0YyV3dqWndRQ2FucTJOL2RoL0hRTjF5ZCsyRUROVDhVM0s5Z2x2UitKWlc0QjFkTW1XZWVpSHZMWExQZ25TZUs4bG1TVno0eWw5SjhacTU0NFN2elJQTHZ6RFVyZmpmQlhhNkRqV29YakkzKzVGeTMzdHZZZDhHcnBXNlMzMXB2NDJHd1JoMXZ5b3hkUDU2ZGFuV2pXellFSEJldURGZ2lpcDBrSnJIbkpKMmpZODArSmIxd2tGeXhSTlA4NjdmUys3UTVwSitNYkk3Y1JBMmpMSHJSczJ3VmJYcXBhZjhBeUJFdjd3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOd0FBb0FBQUFBQTlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUUwQUFBQmdxbkZpd1dOdFlYQUFBQUZFQUFBQU13QUFBRHllckdSS1oyeDVaZ0FBQVhnQUFBQ2VBQUFBb0o1VWlnUm9aV0ZrQUFBQ0dBQUFBQzhBQUFBMktWaWVOMmhvWldFQUFBSklBQUFBSGdBQUFDUUdOd0FUYUcxMGVBQUFBbWdBQUFBTUFBQUFEQWw1QUoxc2IyTmhBQUFDZEFBQUFBZ0FBQUFJQUNvQVVHMWhlSEFBQUFKOEFBQUFGd0FBQUNBQUJRQVZibUZ0WlFBQUFwUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQURaQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0xbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUE0TURqSjFTWEpiT3dLYWsvaUNSV2ZHUEVRTURzeUx6T2FBd0kwTDEvLzhNREFEN3l3OHpBQUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFabVJnVWxKL2tQai9Qd01EaEw1N1MzNGhXQlVRQUFDdkJnbnpBSGphSFl4ZENvSkFIQWYzOTA4Mk56OW9NVGRYNmNFMTFwNGpsQTRSMUNrNlNVR242S21yNUJVNlJIU0FRa3VidDJGZ0dOanUrNlNHaml4aVRFQ05lV0ZzS2NCTmFXdFV0Y0lOeVlTYzJQUEczYnY3aUpWREF0cU5ablJvRzBuYUQybmF2aEpOa3JZeFJxd0hiTTlBWjdvUFQwakZqYTFsenUybW11ZlNWbXRGSjdoTEYxMFI2RVdJeHlCMGJTOStsZ1lvL2drbVNMTis5UVA2WFJwdEFBQjQybU5nWkdCZ0FHSmJoL2lEOGZ3Mlh4bVlXUmhBNEhHRXJndUMvditHZVNMVE1TQ1hnNEVKSkFvQUMyb0o3d0I0Mm1OZ1pHQmdWdnhqQkNRbk12Z3krREFkWndDS29BQm1BRkozQTA0QUFBT1JBQUFERXdCTkF0VUFVQUFBQUFBQUtnQlFlTnBqWUdSZ1lHQm1FR0VBMFF4UUVna0FBQUtzQUJzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnVkdKallXQmlaZW9DMktBTWNaQWRJa1dxT3ZLN2U3Z2Vlc1BwZVQvdWdKSWZNcDZUOFJyM2MzSUtVWDljOE1KYjRxbW9SZUtTRDVaTXlQS1pPSE0yaVhOSnZoSVh2SE5KUEJYL08zSEpKNDl0MTk3dXZmVnEzeG5yM2JrTjQvcGdmV2c2cDFhNmlucG5uZlhIM2hwMUdwVVptakJjVzFYclN0ZHM2V2k1Y2FmSDRsSHN4VEdSSFdmSkFpTnJEdEVKTkpJNmFhM1FWUC95bmVRdWRvN3hrNUhPU1JJbE5NaFZrSDJWdHFLT2w1cjZGL041TUU4QUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFRQUFvQUFBQUFCSlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWdBQUFCZ2hnT1dOR050WVhBQUFBRThBQUFBTlFBQUFFUURxQ0thWjJ4NVpnQUFBWFFBQUFFM0FBQUJVQWxXVTRkb1pXRmtBQUFDckFBQUFDMEFBQUEyS095ZGhXaG9aV0VBQUFMY0FBQUFIUUFBQUNRR1NRSmJhRzEwZUFBQUF2d0FBQUFVQUFBQUZBdERBTzVzYjJOaEFBQURFQUFBQUF3QUFBQU1BTElBL20xaGVIQUFBQU1jQUFBQUdBQUFBQ0FBQ0FBZmJtRnRaUUFBQXpRQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRUJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbThtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqRUR2QU9DbkZaZWxBU1EwbE5tYUcvMEErTXdNalNKZ1JvZncvVUJnQTN4TU5TWGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtOSmtuSzdIOS93OWthVUJZLzIvK0tiajdENndXREFEa3pBdGhBQUFBZU5vdDBMdE93Z0FZQmVELy9JV0NEUmZiUU50Z2tVdGpDekZDUUdtREJnZWp4aGlad01SRkd5NWlqRS9nQXhpZmc4bkVKMkEzVGo2QWs0T0xrNE9Ua3kwMjZIbUE3NXdjQW8zbmhMNUFwQkZGTTJYTHJzRzFISGNYelRSUzBFU2xBQlU5ZGRTb0dvQmhOU1lxRWhkSDRIMHZMWHhMUSsvc3NiTTNQUjFkSnBZSFAvZTNRVENXSXhRRzFBN2Q2cDhMVll5bFVHNkZxcjFsMVdHNVRsUFZWb0hLUXN3bXo0KzVkNklJUUhiUlEvL2kwTCtiZm5XVkNDOTZRck5NeEgyZVVUNDBOYk9HbUdtSm1peXFPOGphWnF5MTJYUnMyYkhXMFdJM240c2YzRnliTW9UQ1lhbjMwTlhiT2VaY1crZlp4OVVBVUhUL2ZVVXRDa0l4WTdCdVpBdmhacWI2UEJEVytJMGtTaEl0UWJWTG9vdndpaGhLZUlZSDNkL1dBUzhxNlJ2QkoxZjR4ZTlJekJJL1NmR0oveG9TdjRkT1B3MEFlTnBqWUdSZ1lBQmk1clI3MHZIOE5sOFptRmtZUU9CeGhLNExndjdQd0t6S0RPSnlNRENCS0FEbHlRZVhBQUFBZU5wallHUmdZR2I0endBa1F4bVVnS1FxQTFBRUJiQUNBQzFEQWF3QUFBQUNnQUFBQVkwQVpBR05BRGtDVkFBaUExVUFMd0FBQUFBQUxBQldBSVlBcUhqYVkyQmtZR0JnWlpCallHSUFBVVlHTkFBQUEvTUFLSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCSlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWtBQUFCZ2hjUVVXMk50WVhBQUFBRkFBQUFBTlFBQUFFUUR1Q0NuWjJ4NVpnQUFBWGdBQUFFOUFBQUJWQWFtVHJ4b1pXRmtBQUFDdUFBQUFDMEFBQUEyS01HZGhtaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR0JBSlRhRzEwZUFBQUF3Z0FBQUFVQUFBQUZBdnZBUXRzYjJOaEFBQURIQUFBQUF3QUFBQU1BTXdCQ20xaGVIQUFBQU1vQUFBQUZ3QUFBQ0FBQndBaWJtRnRaUUFBQTBBQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVNtYWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhRRUFEQTBNakF4SklLUzVMQjBwcUtBZ3pNL3dIOHBrWkdFSENqQWdWLzRIQ0FQa0NEYTRBQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWURJQTBCeENDNURTWkZ5c0kvLzhQWkdsQVdQOXYva200L3hHc0Znd0E2TkVMZkFBQUFIamFKYys5VGdKUkVBWGdPZmR1N21WWGZoYkVKV29VRm1UUkFoS0YzWTBraURacVFVa3NqQlpLWW9VbUdMVkRqVCtOaVE5QjZ6TllHaHQ3MzREQ21HaXJKcXhlSkhPS3FiNHpRNkNUWCtDU0UwMFJJV1VscFloQlNHR3BOUWFub01aMzZ2RFFqa2k1VnBYTEhGc0hob3pjdXRHeFBHUEZxTWNKekJTVnR0bDV2di9lMVUyRy9hNmQ2YmFPci9OWGlxUk41VGRIL3JoU1U1Wk1DaG1GNDFmcVdJRmZRc0Z4UFgvbnhodUNDMW52YUJvODF0d0I3NnpyRUp4RzJuWnZkYS9GREs3Rkc1KzlwMzdWRURvakd2b2JST3lIUFZLR1NJZXRUbFh4eTlMT09xNnZ3L0ZTZGlwWGdyUlZ1Y1JEOElHbDRueDUwU3FadWZUZ0xoeG5tQWplRUU2d3MzVE9QTzhHUVYvalFDUG9nMlBTbkR2OTBvd1FabkdZMFBGKzBkQ0NWNkhMLzk0UUdLc2hUZW8xMks3TmFvTVg1b0xOMEI4dVNENklBQUFBZU5wallHUmdZQUJpRTAyRjlIaCttNjhNekN3TUlQQTRRdGNGUWY5blpQckZET0p5TURDQktBRGF6QWZ1QUFBQWVOcGpZR1JnWUdiNHp3QWtuUms0R0xpWWZqRUFSVkFBS3dBNXVBSmVBQUFDMHdBQUFja0FkQUhKQUVnRFF3QkhBa2NBQ0FBQUFBQUFNQUJnQUp3QXFuamFZMkJrWUdCZ1pWQmtBTkVNVUJJSkFBQUVKd0FxQUhqYVBZd3hxOEl3RklXL1loWHRHeHdFaHpkSThBZUVTaCs0dURrNHVUcTh6Wm9nSFpwS1dvc3U0ay8zTmdSdjRQRGRjODROa1BFaVlaaUVlZEJoVW5uenlHTitXRVNlaUwrS25QSExtaEZKT2hObnhTNXl5cFQveUdPV2xKRW40ajhpWi96eDNqZjE3ZDVacjQ2TnNkNWRhcjg5V2Q5V2pWTWJuUS9yd1Rycno1MDFxbndxMDFkdGY2MVZvWE5kc0tlaDVzYWREb3RIY1JUSEJIWmNKUE5zT1lXOXBaTE1TV2VESnYrbUIwbGRhSnpETDBZYUpVOVJReTgzcmVoVnVvb2kzR21LRDFpc0xrc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFYd0FBb0FBQUFBQnZ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVjQUFBQmdoY3A0WjJOdFlYQUFBQUU4QUFBQVFBQUFBRlFFT2dUc1oyeDVaZ0FBQVh3QUFBTUdBQUFEb0wrSnNEQm9aV0ZrQUFBRWhBQUFBQzBBQUFBMktQQ2RoV2hvWldFQUFBUzBBQUFBSGdBQUFDUUdXQUdWYUcxMGVBQUFCTlFBQUFBWUFBQUFHQkFQQVR4c2IyTmhBQUFFN0FBQUFBNEFBQUFPQXR3QjhtMWhlSEFBQUFUOEFBQUFHQUFBQUNBQUNRQlBibUZ0WlFBQUJSUUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUY1QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1Xc3M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lOR0JpU1FVbHlXRHBUVVo3N0t6UEFmeUdkbVlBUUpNeUpVL0FjS0F3QU1ZQTRrQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnY2dEUVBBd2RRam9WQm55R0VJWTM1QlBQVi8vK0Jva2k4LzVmK3Ivcy85NC9OSHdPd1BqZ0FBUFowRVNONDJrV1N6MjhiVlJESDMzZmVlcC8zaDNmWFAvYUg3ZFR4cnAxZHUwNWlOekc3U1pTdTI2U3lXMHJhUWxVcXBDQUVBYUZXNWNvRkNVb3ZjRUNjRU9MQWhRc2N1TUFGd1QwU1hCRi9BRGYrQUNSdXRPYXRWUW5OWWViTnpIdWF6NXN2QTd1MVpLUnh4a3pHTktnaVN1SU1PWHlQOE95SkVqUVVDSHhZR2lsRWYveTc4SG1MTy95WHdqSEd3RGFYU3o2a245bVJQSEFicXJlT0hjKzFNQ2F4alJmaTFQZlNySjdHSThSQ2xXWkJabWZGNjJIcWk0YWFaT2tNYVp6RVk4Z2EvdjZVQTVYbW9WK0hJMTQ5L2NFUWNGc25BLzRaREc5ME5ySE1RVjhwdTJycHFtTFc2UDBPMXZvZ0ZVQzFXdy9lYXpvR1BYcjZsNlZyWlNKRnJ3cHdLTkM1RE9DdTBVUnczaEJHOU1EU1piTDJreTJnMU00RDJFWlNiYTlkTklwM1lCWk1ONWRqZWtpL3N5dlBtZVJrSW9xVEhMdWU3NmxDSXVhWThaNHE2WFp6WkRLLzQva1dlaElqelNTSlJUWjJVMDlOOE0yQm96Z3Q3ZXFsd1FIUWQyTU9lOTIyN1g3SUwyemJMM1dvYnI5c3U1WjMxQnNlQWoxUDFwMk9iZGRxSGIzY2VxTW80NHRuNXk5V3Iwd2J4enp1ZGJyVVZ4TkRJeWczM2EvK3VjOGpnZnV2dFpONG8vOS9DYzE0NjNNbEtvT3Q5ak5aYnRHZjlDczdLVmpTckxCdEpBVk1saFpEcjNhU0NIV01PSmtoTGx4Y05FMUZKUGZWazUzVDFTVkpXSFQ2bmwrWHZOTFIxcmNQRmtsN0IyaFhkQVZSb3pUaThNMExtNjg4N201U1hWTlJDZmR5YjY5RTFZMGFtdXVIZFZUbEgvdG10WmNQOWdCcm8wcjAwWGRjTldVcmZmLzAzVkllSnRmM3dxR2hCRzRJYXUzSGI3ZVBSeWNoL3pFZ0l1M2dDWnFWN20zaitQV0wzUTNNY2tmbXJJbnZicGNtZzJaNE90ZmVzZWpyaWc3U0pUZXh4VEtpMzNET0ppeG5yQ1FzTHJsbWhmaW1hVlpvMi9lRUtsZnJkK0JMQWE0UVphaXVSSnI0aFNpenFieFNpUEphVURhRFdoUFFKMmRudzVGbE9sSXEyb0hEYmFLMzd0VUNaK0IxMHJ1SE44RHZCTzAzUDNERHgzZnRFOHJTTzR0ZVIvdGswek5RY1huMHBmOXczdnQ0M3hGeWJrVmI1UHBsWmYrR3VYLzkwaUlPTDVkd2UvN29YdE9kOHptVW1YbDBheWoxY2pvK2t5ai9BWVJHZTg0QUFIamFZMkJrWUdBQTR1VjI3WTd4L0RaZkdaaFpHRURnY1lTdUM0TCt6OENzeVF6aWNqQXdnU2dBODlzSDVnQUFBSGphWTJCa1lHQm0rTThBSkZrWmRQNTNNbXN5QUVWUUFCc0FSODBDOHdBQUFzWUFBQUpYQUU0Q3NnQXNBam9BU3dNRkFEQURBUUJIQUFBQUFBQWVBSWdBN2dGcUFkQUFBSGphWTJCa1lHQmdZL0JqWUdJQUFVWUdOQUFBQ0w0QVdYamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b0NDeGRXRmdZbVhxQXRoRkdXd2pKMFJDcWpyMmQvZGhQUFFOVitkKzJFRE5Ed1gzSzVnbHZWOUpKZTdCRlZQbW1TZmkzakxYTEhqbmlhSjhsdVNWajh5bE5KK1pLMTc0eWp5Ui9EdHp6WXJmVFhDWDYyQ2oyZ1Zqb3o4NTE2MzNOdlpkOEdxcG0rUzMxdHQ0R0t4Ung1c3lZOWVQWjZkYTNlaVdEUUhIaFNzRGxvaGlKNGxKN0RsSjUraFlzMDlKTHh3a1Z5elJOUC82cmZRK2JRN3BKeU9iSXpkUnd5aUxYdlFzVzBXYlhtcmFQOHVoTC9jQUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPQUFBb0FBQUFBQSt3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVzkwbjJOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDbloyeDVaZ0FBQVdRQUFBREFBQUFBd0owRlNhZG9aV0ZrQUFBQ0pBQUFBQzhBQUFBMktKaWVQR2hvWldFQUFBSlVBQUFBSUFBQUFDUUY3UUQrYUcxMGVBQUFBblFBQUFBSUFBQUFDQVRNQUJsc2IyTmhBQUFDZkFBQUFBWUFBQUFHQUdBQUFHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJBQStibUZ0WlFBQUFwd0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQURjQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1TbU9jd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBxR01JUXdNL3dIOHBraDBraHEvZ09GQWM2S0RQNEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2Z2gvLzlEeVA5cndYd0dBRlFtQnJBQUFBQUFBUUFaLy84QzBRSzRBRHdBQUFFREJ4UVdId0UyQnhRR0x3RUhKeVluSmpZWE1qWTNFelkzTmlZckFTWUhCZ2NHQndZbUp6OEJQZ0VYSVRZWEJ3WW1Qd00wSmdjakJ3NEJBYldJQkJBV1FTWUREZ2l1cXd3RkFRRVNHazhvQTRrREFRRUpGQ2hpTEF3S0pDSUZGd0VHUFFRTUVRSTRHd0VlQVJzQkF3WUNTVTBsR3drS0FtNzk0QllNQ0FJQ0F3OE9Cd0VEQXdJQkNROEdBUlVjQWlNSURRWUhBeGtIQ1NWbkZnSUtFN1FPQndFRERzUVhBZ3NVTFNVNUhRSURBZzk0Mm1OZ1pHQmdBT0xqVEcrMnh2UGJmR1ZnWm1FQWdjY1J1aTRJK3Y5L3BvdE1PNEJjRGdZbWtDZ0FNejBMQUFCNDJtTmdaR0JnWnZqUHdNREFWTVlnK2IrVjZTSURVQVFGTUFFQVhSTUQ3d0oyQUFBQ1ZnQVpBQUFBQUFCZ0FBQjQybU5nWkdCZ1lHS3daUURSREZBU0NRQUFCcElBUXdCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUxLjAzMTE1MiwtNTQuNTA4Njk3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE2Ljc0MTk0LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS4wMzExNTIsLTU0LjUwODY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuMDMxMTUyJyB5PSctNTQuNTA4Njk3Jz5UPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00My44MjU1MDknIHk9Jy01NC41MDg2OTcnPijiiIYpPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yNy43NzQ1NTMnIHk9Jy01MS41MTk5Mic+L8+IPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU4LjE2NjA5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS4wMzExNTIsLTU0LjUwODY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuMDMxMTUyJyB5PSctNTQuNTA4Njk3Jz5UPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00My44MjU1MDknIHk9Jy01NC41MDg2OTcnPijOkyk8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTI5Ljg1MDExMycgeT0nLTUxLjUxOTkyJz4vVDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMTkuOTkwMTgnIHk9Jy01MS41MTk5Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTYuODc2ODM3JyB5PSctNTEuNTE5OTInPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTEyLjIxMDI1MycgeT0nLTUxLjUxOTkyJz4pKDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNS45ODM1NjcnIHk9Jy01MS41MTk5Mic+z4g8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLS40NjE0MTInIHk9Jy01MS41MTk5Mic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNTUuMTU3OCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuMDMxMTUyLC01NC41MDg2OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUxLjAzMTE1MicgeT0nLTU0LjUwODY5Nyc+VDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDMuODI1NTA5JyB5PSctNTQuNTA4Njk3Jz4ozpMpPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yOS44NTAxMTMnIHk9Jy01MS41MTk5Mic+L8+VPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00yMS4yOTc0OS0zLjYxNjYySDUzLjExMDU1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUzLjM2MDU1LC0zLjYxNjYyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC41ODA3MiwtMTEuNjc4NDQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS4wMzExNTIsLTU0LjUwODY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTEuMDMxMTUyJyB5PSctNTQuNTA4Njk3Jz5UPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00NS4yNTMxNTUnIHk9Jy01NC41MDg2OTcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQyLjEzOTgxMicgeT0nLTU0LjUwODY5Nyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzcuNDczMjI4JyB5PSctNTQuNTA4Njk3Jz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zNC4zNTk5MDUnIHk9Jy01Mi4yNjcxMDMnPi/PiDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTE3LjEwNTk3LTMuNjE2NjJIMTUwLjEwMjI2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE1MC4zNTIyNiwtMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTIzLjcxNTc0LC0xMC4zMTczNCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjAzMTE1MiwtNTQuNTA4Njk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01MS4wMzExNTInIHk9Jy01NC41MDg2OTcnPs+VPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy00My45NzY4NjknIHk9Jy01NC41MDg2OTcnPuKIpzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzUuNzk3NjQyJyB5PSctNTQuNTA4Njk3Jz7igJM8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTE1MC42MDIyNiAzLjYxNjYySDExNy42MDU5NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMTcuMzU1OTcsMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTI4LjQ1NDc5LDguNDAwNjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS4wMzExNTIsLTU0LjUwODY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNTEuMDMxMTUyJyB5PSctNTQuNTA4Njk3Jz7OozwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDUuMzQ0MTE3JyB5PSctNTMuNTEyNDMzJz7PlTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTMuNjEwNTUgMy42MTY2MkgyMS43OTc0OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwyMS41NDc0OSwzLjYxNjYyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNy44MzgyMSwxMC4yMTE3NiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjAzMTE1MiwtNTQuNTA4Njk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01MS4wMzExNTInIHk9Jy01NC41MDg2OTcnPs6jPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00NS4zNDQxMTcnIHk9Jy01My40NTE1NDknPmY8dHNwYW4geD0nLTQwLjg1MDUxOCcgeT0nLTUxLjk4NDgzNic+L8+IPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwzNS43MDQwMywyLjQ3OTE3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuMDMxMTUyLC01NC41MDg2OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjAzMTE1MicgeT0nLTU0LjUwODY5Nyc+7oGhPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMTMyLjEwNDEzLDIuNDc5MTcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS4wMzExNTIsLTU0LjUwODY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTEuMDMxMTUyJyB5PSctNTQuNTA4Njk3Jz7ugaE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram,node distance=3cm]
      \node  (1) {${{T(\Delta )}_{/{\psi }}}$};
      \node  [right = of 1] (2) {${{T(\Gamma )}_{/{T(f)(\psi )}}}$};
      \node  [right = of 2] (3) {${{T(\Gamma )}_{/{\varphi }}}$};
      \draw  [->,morphism,offset=1.5] (1) to node[swap] (r1) {${{T(f)}_{/{\psi }}}$} (2);
      \draw  [->,morphism,offset=1.5] (2) to node[swap] (r2) {$\varphi  \wedge  \mathord {\hspace {1pt}\text {--}\hspace {1pt}}$} (3);
      \draw  [->,morphism,offset=1.5] (3) to node[swap] (l2) {$\Sigma _{\varphi }$} (2);
      \draw  [->,morphism,offset=1.5] (2) to node[swap] (l1) {${{\Sigma _{f}}_{/{\psi }}}$} (1);
      \draw  [adjoint] (l1) to (r1);
      \draw  [adjoint] (l2) to (r2);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>where <fr:tex
display="inline"><![CDATA[\Sigma _{\varphi }]]></fr:tex> is the left adjoint in <fr:ref
addr="ct-000J"
href="ct-000J.xml"
taxon="Lemma" /> and <fr:tex
display="inline"><![CDATA[{{\Sigma _{f}}_{/{\psi }}}]]></fr:tex> is the functor given by the action on morphisms of the left adjoint <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  T(f)]]></fr:tex>.</fr:p>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[\Gamma |\chi  \vdash  \varphi ]]></fr:tex>.
    And assume the following pullback square.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="c544bcd7073229ee2ed975db85021a4f"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI3OC4xMzcxMjFwdCcgaGVpZ2h0PScxMTQuOTAyMzMxcHQnIHZpZXdCb3g9Jy03MiAtNzIgMTg1LjQyNDc0NyA3Ni42MDE1NTQnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTWNBQW9BQUFBQUE0QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW5LVU1tTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSjZaMng1WmdBQUFXd0FBQUJVQUFBQVZBc29hMzlvWldGa0FBQUJ3QUFBQUM4QUFBQTJLT09keG1ob1pXRUFBQUh3QUFBQUhnQUFBQ1FGeHY5K2FHMTBlQUFBQWhBQUFBQUlBQUFBQ0FYR0FEZHNiMk5oQUFBQ0dBQUFBQVlBQUFBR0FDb0FBRzFoZUhBQUFBSWdBQUFBRndBQUFDQUFCQUFXYm1GdFpRQUFBamdBQUFEVEFBQUJQcTgzZGVGd2IzTjBBQUFEREFBQUFCQUFBQUFnQUFNQUFYamFZMkJtZXN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1cEk2czlRZlRRWUdaaW5tNjBCaFJvVFMvLzhaR0FBZDd3N1hBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJxLy85RHlMdTN3UElNQUZOaEJxVUFBQUFCQURmLzVRSjBBbVlBRkFBQUFSTVdJd1lIQmlZbkN3RUdKeVluSmpjVE5qTTJBVzMvQ0FJQ0V3TU5CL0h4REFzVEFnRUkvd2NRREFKUC9iOFFFZ01CQ0E4Q0gvM2hHZ1FERWdRUUFqMFZBZ0FBQUhqYVkyQmtZR0FBNHFJWnVvbngvRFpmR1poWkdFRGdjWVN1UFlMKy81UlpoaWtOeU9WZ1lBS0pBZ0FBVUFrRUFIamFZMkJrWUdDVytxTUpKR1VZekJuTW1Fb1lnQ0lvZ0FrQU96b0NTUUFBQXh3QUFBS3FBRGNBQUFBQUFDb0FBSGphWTJCa1lHQmdZaEJsQU5FTVVCSUpBQUFDcWdBYkFIamFUWTZ4YXNNd0VJWS9VOGRRSjVDcEhUb1VUUm1GamZNQWhReVpzbVlzSkpFSURsZ09rbVB3VXZJQWZlaGVGQTA5d2ZIcHYrK0VnSklmTWg2VnNZejlVVG1GM0o0OFk4NWI0a0tPU2x6eXdZb1hzdnhWa2srK0V1Y3MrRTQ4NDUxTDRrTHllK0tTTmIrYnZydmVCdXZWcmpmV3UxTVhwcnJhV3gvYTNxbGFWODlnYTUzMWg4RWFkWnlVR2Rzd25qdlY2RW8zYk9qcHVISmp3T0xsWnp0SlRHVEhTV2FCaVpxS2Zjd0NyY3lkZURWYTB2L0dWZ3dYclVOOHpZaDFsSmtTR21VdlNEK0xyMmppcnFiNUF3bFJNUk1BZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFhQUFBb0FBQUFBQi9nQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY2wzOFdOdFlYQUFBQUU4QUFBQVJBQUFBRndFN2dTNFoyeDVaZ0FBQVlBQUFBT0pBQUFFaUhabG5tcG9aV0ZrQUFBRkRBQUFBQzhBQUFBMktKaWRaR2hvWldFQUFBVThBQUFBSUFBQUFDUUY3UUVyYUcxMGVBQUFCVndBQUFBY0FBQUFIQStEQVRGc2IyTmhBQUFGZUFBQUFCQUFBQUFRQXRRRUdHMWhlSEFBQUFXSUFBQUFHQUFBQUNBQUNnQlNibUZ0WlFBQUJhQUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUdkQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1NbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBycU1WOWxadmdQNURNek1JS0VHUkVxL2dPRkFlRlVEYTBBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnOGdEUWZBd2RRam8xQmp5R0VJWU1obS9rRTg5WC8vNEhpS1B6L2wvK3Yrei83Lzh3L3RuOE13YnFSQUFDUEtST2dlTnB0azArUDIwUVl4djIrWTN0c3gzSGl4UGJrcjVPTk4zWTJiWnh0SE1aSkd6YmRsbDF0Rm1naXRRZ1FvcUJxRVJVdFNEMXdnQXRDUWdnNFZ1TEFCWWtEQjZEYUUwaEl2WGFGT1BJTitBUmNnR01KNC9UQWdXcEdvNWw1NS9EODN1Y1pDYVJYSlpET3BMdVNKa21wQloxd3pFZmVHYlFHTFRHNWw2MHRTUkp2cXVzMS9vWS9Tek54SU5UeFdzQ3BvdzZCUm1FVWNqYmlhWm1uUER3SElWV3pFVVp6MkFPMnhabll6OGs0cEFHMUFINzZUQzU2K3lHeHROTWZUQVdnVkZ2MnlPY0VRSGQ2dDg2YnhuWkhZYUErSzVzMlR1cmdReDJJaW9zWHUzWGR3UGNlLys2WkdpSXBXQlFJUWRBTEtyZ05ETFM4U2ttVjZ0MjNQVFRLUDJaVjZ4SERuRFBvVHB0SXNDRDBwK3UvY1lpL1NBZVpmcDc2NEtvRkZEclRQUkF6WVo2ejBSMUROTTZFQzVTT0tnUVhpRW83Z2pBdGk1dEFEWG1TOHNSakVLNG1iMDVuNkNpQmpWRHJKemxab1ZRcDVVcnR0QnVEckxzN0NKWDlDM2F0Ujh4ZTJXaG9Mb0R5SllIaWRnVXNkYjdqNm9nUC8zbjR2QXlYUnZHVi9Fa25Db0NzenBzVTBCNVdhN0VNY2RjeS9kR25nMmJmdGRpZUhuOXpyWUk1VzdYeG1xTVpwRUdwRFBLRzZ5L1VCTmNxNDlxd01NRm1RWXc4SFlJRmdvSDZ3RnpCNW1WWUxmQ3l2Um9KMHBSbjVrVWI4S2RDM3ZHbjlYVGhkUUxvOUV2QU9qazNQT3FXQnRXck4wQVJTaS8zTFRRMVJkZkxuZUhPR0dTaHFIL09qeXpaWkUvblhlV2ZhYzYyRUtLcTN3YTMybE0xQW1uZjZWdmFhSlF2TmZ4RVBwaTZDS2dGN2UwVWdNZmJlVzFVS3NIWFU5MkIvOEZ2Y3VtdkIvZ0YvaW90TTM2UFozWUtNaEhqbEh0TXNHY21Dc0lDcUZFV1NUNkhyQ3lxNGhrTnMyb2dXcEZtRjFrbXhKazVUUFFoNFF6KytLNSs2MnJ6b2pEWXNIeW4wQVR3ZEd0Mi9JRWZvcUxLaW82R21TUDZDeWNJaFVESXRtazk5VVJlaExnc0NKTm9nSHF2aE85L3J4Q2FRM3p3K0EzUzNQZmZTYnA5elFoYUFLMSs5NFJkT0Y1dWthL012QzArZzVxTXVzV2UvTnpDT0xpWmRDc0d3T1RJVkFHTHU3WEtVSWJkb09YY1BqYmZzdkRiRWtFcjQwY3BXYmZ4UXppVFlta3VTU3hqNXhzWWozcUN4WFU4eHYrRDJ4Z2RQZW1KTUR4OVVocUhrUWc2cXNrcHYvNDZvSjh6MjY2RmFNVFJTOWZEM2FLVDNwek95TUpydm5MUE0yc1U5WW9pM0xoL2IyVWFSeVFlSDk2dGlrOVpPSDNnM0Y1Y1BxeXpTd1ExTUM5K1hKMHM3VS9lRFJxdnliRGN1L055a3kwSTNvK0liWUJaL0pQczY4YmhqV2lPK05ISmxZSDhMMEw0bUhRQUFBQjQybU5nWkdCZ0FPTDNHZHpjOGZ3Mlh4bVlXUmhBNEhHRXJqMkMvcS9BZEpIcEpKREx3Y0FFRWdVQSs5WUpLd0I0Mm1OZ1pHQmdadmpQd01EQU5JOUI4bjhyMDBVR29BZ0tZQWNBWVFBRUhBSjJBQUFCSEFCWkFsWUFHUUpPQURjQ0ZBQTNBcHNBSGdLZUFETUFBQUFBQUJRQWRBRGdBV0FCNEFKRWVOcGpZR1JnWUdCbkNHUmdZZ0FCUmdZMEFBQUpKQUJkZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS1ZlZHQyaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9KZGsyMjJ4dlBiZkdWZ1ptRUFnY2NSdXZiSU5QTkVKaHNneGNIQUJPSUJBQVBYQ0JFQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV1VBQW9BQUFBQUJ0Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMHgyTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWdnRENaMng1WmdBQUFXd0FBQUxDQUFBRG5QS3JaMlJvWldGa0FBQUVNQUFBQUM4QUFBQTJLSTJkZVdob1pXRUFBQVJnQUFBQUlBQUFBQ1FGcWdHY2FHMTBlQUFBQklBQUFBQVVBQUFBRkF4VUFSRnNiMk5oQUFBRWxBQUFBQXdBQUFBTUFhNENvbTFoZUhBQUFBU2dBQUFBR0FBQUFDQUFDQUJZYm1GdFpRQUFCTGdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGaUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtS21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F6TS93SDhwa2gwa2hxL2dPRkFkbUFEVGdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLWmpCay8vOFA1S2VCNlArei84OEVxd0lDQUptTkNUNEFBSGphYmROTGI5TkFFQWR3ejZ3ZnNSTjc0OWU2VFZJM2laMTFxcVpKMjZST1cwTGFOQVdwN3hZSlNoR0NFeUJ4UXVLQ1FPSVRJSVFRQjY3YytBcmNLL1hNaHdHSlM4dWE4amhRNzIxbkQvT2IvMWdDYWVlaWcwL3hxN1F1U1VBb3FKb0ZXcDBuUStpeWdLa2FtNFlockpGSTVXblFIVUpmM0MreXdJS0lKenp0OHc1WVNLR2JNaldCVDZ0RnVWalNSd3ZOVllEWTV3VG9OS1UwcnBHcE50ME4wYVZIMUxmWVJqUXpBSWlZcUJkRFNoMG5OSEtsaDFrWlBweWZidHZyUFc5TWVCUldNVmFUdkk0ZzcvZ2Z2eDJUdWdiSEorV0VOK0ovSlpqa2MyL2xlZzRrOGFIVXVwakRCcHhLYldtY2FZUkUvU1VSSFh1cUZyQXVTd1ZnVFNEYmtLVDk3SVFRQ0pWNFFOWWdUUVJLMWJJUnNHQXhlNHExWi9yekY1MEhzdWpYWm1BNUZidm1EYUlLMDRMKzF1Z0V5WWphV3lmTkpaT1VITk9IOXgwQ250OHJqYXQrMFFhZWhCdVZnZ1l2ejBlZGV3VDkxbFROZGZPaG9TRGtLNVB6MWZ0ZEdZNFBIKzI3ZEpOQXpJb01pdmI1ank4MDM0aGthQzd4MGZwQkh4cFZhZ29iU0hzWDMvRVZua2s3bVV5MEhLS21Yc2JscTFtemFUY0loVmNja1Y1UFlESWVUN0laVUZuazFZYWx2anNFSGwyRzIwK1pCcVA5eXEyVm03MENvSWR1d1RSSVpYcmdvRzJvRU9UdGFOaGNCbUphakNHeTV1QndnaXB1VmM4WmdlN1l5anNaYWF3WEFTeHRzOVVBL0h4K1Z1dUMwdW1aN1lGNnJWeXIyWFZjdSs0Z0J2TUJhOHVkbVVLK0dtK01GL3dGeEhHVDViZGY4ekxOZzJzeTNEU3BJUnMwcDhtazhOdDVRemp2Wk00c2cwWG0vMTAzb2MzTVlqUEY4U2p4V0hDNWs5bkZIenp2cDRuSWw0SUZkWDRGK3ZIMDNlVG9OaGNqRnlzWVZDMXY5aURod1VTMVIrbThqRVFCNnZGWmcyaUdyZ0lVRGEreWtvd1JGQUt3dlJ4Uk9lQlg4WjlZdTQybGxvQmpiTVU1QzJDVjF6elJncUt6RlVNM3k2NzRrZVM5bUJxSWh0SXVWOXB5TjdVY1MyMG15cHRWWitLL1FValNUd3l3ZFJJQUFIamFZMkJrWUdBQTRwRFBHcVh4L0RaZkdaaFpHRURnY1lTdVBZTCtyOHQwak9raWtNdkJ3QVFTQlFBUDBBbXNBSGphWTJCa1lHQm0rTS9Bd01CMGpFSG4vd1dtYWdhZ0NBcGdCUUJtWUFSS0FzWUFBQUk2QUVzQ09nQXNBcXdBVFFKdUFFMEFBQUFBQUdZQTFBRklBYzU0Mm1OZ1pHQmdZR1VJWjJCaUFBRkdCalFBQUFtRUFHRjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFRQUFvQUFBQUFCSlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWdBQUFCZ2hnT1dOR050WVhBQUFBRThBQUFBTlFBQUFFUURxQ0thWjJ4NVpnQUFBWFFBQUFFM0FBQUJVQWxXVTRkb1pXRmtBQUFDckFBQUFDMEFBQUEyS095ZGUyaG9aV0VBQUFMY0FBQUFIUUFBQUNRR1NRSmJhRzEwZUFBQUF2d0FBQUFVQUFBQUZBdERBTzVzYjJOaEFBQURFQUFBQUF3QUFBQU1BTElBL20xaGVIQUFBQU1jQUFBQUdBQUFBQ0FBQ0FBZmJtRnRaUUFBQXpRQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRUJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbThtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqRUR2QU9DbkZaZWxBU1EwbE5tYUcvMEErTXdNalNKZ1JvZncvVUJnQTN4TU5TWGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtOSmtuSzdIOS93OWthVUJZLzIvK0tiajdENndXREFEa3pBdGhBQUFBZU5vdDBMdE93Z0FZQmVELy9JV0NEUmZiUU50Z2tVdGpDekZDUUdtREJnZWp4aGlad01SRkd5NWlqRS9nQXhpZmc4bkVKMkEzVGo2QWs0T0xrNE9Ua3kwMjZIbUE3NXdjQW8zbmhMNUFwQkZGTTJYTHJzRzFISGNYelRSUzBFU2xBQlU5ZGRTb0dvQmhOU1lxRWhkSDRIMHZMWHhMUSsvc3NiTTNQUjFkSnBZSFAvZTNRVENXSXhRRzFBN2Q2cDhMVll5bFVHNkZxcjFsMVdHNVRsUFZWb0hLUXN3bXo0KzVkNklJUUhiUlEvL2kwTCtiZm5XVkNDOTZRck5NeEgyZVVUNDBOYk9HbUdtSm1peXFPOGphWnF5MTJYUnMyYkhXMFdJM240c2YzRnliTW9UQ1lhbjMwTlhiT2VaY1crZlp4OVVBVUhUL2ZVVXRDa0l4WTdCdVpBdmhacWI2UEJEVytJMGtTaEl0UWJWTG9vdndpaGhLZUlZSDNkL1dBUzhxNlJ2QkoxZjR4ZTlJekJJL1NmR0oveG9TdjRkT1B3MEFlTnBqWUdSZ1lBQmk1clI3K3ZIOE5sOFptRmtZUU9CeGhLNDlndjdQd0t6S0RPSnlNRENCS0FEb1B3ZWhBQUFBZU5wallHUmdZR2I0endBa1F4bVVnS1FxQTFBRUJiQUNBQzFEQWF3QUFBQUNnQUFBQVkwQVpBR05BRGtDVkFBaUExVUFMd0FBQUFBQUxBQldBSVlBcUhqYVkyQmtZR0JnWlpCallHSUFBVVlHTkFBQUEvTUFLSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5MTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE2LjAwMzkzNSwtNjEuODAzNTMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTEuOTAwNTEsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE2LjAwMzkzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE2LjAwMzkzNScgeT0nLTYxLjgwMzUzJz7OkzwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctOS43NzcyNjYnIHk9Jy02NS40MTg4OTQnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNi45ODIxOScgeT0nLTYxLjgwMzUzJz4uPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00LjIxNDc4MicgeT0nLTYxLjgwMzUzJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0uMzQwNDA4JyB5PSctNjEuODAzNTMnPlQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNi44NjUyMzUnIHk9Jy02MS44MDM1Myc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScxMC43Mzk2MDknIHk9Jy02MS44MDM1Myc+azwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxNi4yMzk4MjgnIHk9Jy02MS44MDM1Myc+KSg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMjMuOTg4NTc2JyB5PSctNjEuODAzNTMnPs+VPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzMwLjUwNTgwOCcgeT0nLTYxLjgwMzUzJz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzM2LjU5NDA0OCcgeT0nLTYxLjgwMzUzJz7iiKc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNDUuNDQ5Njk2JyB5PSctNjEuODAzNTMnPlQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNTIuNjU1MzM5JyB5PSctNjEuODAzNTMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNTYuNTI5NzEzJyB5PSctNjEuODAzNTMnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNjIuMjY5NzgyJyB5PSctNjEuODAzNTMnPikoPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzcwLjAxODUzJyB5PSctNjEuODAzNTMnPs+IPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc2Ljg2NTU1MycgeT0nLTY1LjQxODg5NCc+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jzc5LjY2MDYyOScgeT0nLTYxLjgwMzUzJz4pKTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNy43ODQ3MywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE2LjAwMzkzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE2LjAwMzkzNScgeT0nLTYxLjgwMzUzJz7OkzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS43NzcyNjYnIHk9Jy02MS44MDM1Myc+Ls+VPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTguOTA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTcuNjg0MDUsLTMwLjUzNjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTYuMDAzOTM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTYuMDAzOTM1JyB5PSctNjEuODAzNTMnPms8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTAyLjAxMzU1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNi4wMDM5MzUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xNi4wMDM5MzUnIHk9Jy02MS44MDM1Myc+4oiGPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy03LjcwMTcwOScgeT0nLTY1LjQxODg5NCc+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00LjkwNjYzNCcgeT0nLTYxLjgwMzUzJz4uz4g8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNC43MDc3OTgnIHk9Jy02NS40MTg4OTQnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDQuODE5MSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE2LjAwMzkzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE2LjAwMzkzNScgeT0nLTYxLjgwMzUzJz7iiIY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTcuNzAxNzA5JyB5PSctNjEuODAzNTMnPi7PiDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuNDU2MDUgMEg5Ni45NTgwMScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5Ny4yMDgwMSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDc0LjYxNjE3LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNi4wMDM5MzUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xNi4wMDM5MzUnIHk9Jy02MS44MDM1Myc+aDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTEzLjgxMTAyLTguMzU0MTZWLTQ4LjA1MTMzJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMTEzLjgxMTAyLC00OC4zMDEzMyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTE3LjA3NDksLTMwLjIwMjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTYuMDAzOTM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTYuMDAzOTM1JyB5PSctNjEuODAzNTMnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEyLjM0MDI3LTU2LjkwNTVIOTkuNzYzNTcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTAwLjAxMzU3LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1NC4yMjU3LC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTYuMDAzOTM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTYuMDAzOTM1JyB5PSctNjEuODAzNTMnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      width = 4cm,
      nw = \Gamma '.(T(k)(\varphi ) \wedge  T(h)(\psi ')),
      nw/style = {pullback},
      ne = \Delta '.\psi ',
      sw = \Gamma .\varphi ,
      se = \Delta .\psi ,
      north = h,
      south = g,
      west = k,
      east = f,
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>We wish to show that <fr:tex
display="inline"><![CDATA[T^{\flat }(f)\exists ^{\flat }_{g}(\chi ) \cong  \exists ^{\flat }_{h}T^{\flat }(k)(\chi )]]></fr:tex>.
    The left-hand side computes to <fr:tex
display="inline"><![CDATA[\psi ' \wedge  T(f){{\Sigma _{g}}_{/{\psi }}}(\chi )]]></fr:tex>, while the right-hand side computes to <fr:tex
display="inline"><![CDATA[{{\Sigma _{h}}_{/{g}}}(T(k)(\varphi ) \wedge  T(h)(\psi ') \wedge  T(k)(\chi ))]]></fr:tex>.
    This is isomorphic to <fr:tex
display="inline"><![CDATA[\psi ' \wedge  {{\Sigma _{h}}_{/{\psi '}}}(T(k)(\varphi ) \wedge  T(k)(\chi ))]]></fr:tex> by Frobenius reciprocity.
    <fr:tex
display="inline"><![CDATA[T(k)]]></fr:tex>, as a right adjoint, commutes with pullbacks.
    Thus, the right-hand side is isomorphic to <fr:tex
display="inline"><![CDATA[\psi ' \wedge  {{\Sigma _{h}}_{/{\psi '}}}T(k)(\varphi  \wedge  \chi )]]></fr:tex>.
    Further, since <fr:tex
display="inline"><![CDATA[\chi  \vdash  \psi ]]></fr:tex>, this is isomorphic to <fr:tex
display="inline"><![CDATA[\psi ' \wedge  {{\Sigma _{h}}_{/{\psi '}}}T(k)(\chi )]]></fr:tex>.
    Then, <fr:tex
display="inline"><![CDATA[\exists ^{\flat }_{f}]]></fr:tex> inherits the <fr:link
type="local"
href="log-000E.xml"
addr="log-000E"
title="Beck-Chevalley condition">Beck-Chevalley</fr:link> condition from <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex>.</fr:p>
  <fr:p>Since <fr:tex
display="inline"><![CDATA[T^{\flat }]]></fr:tex> has all the structures listed in <fr:ref
addr="log-000H"
href="log-000H.xml"
taxon="Lemma" />, it admits a naming functor.
    Let us define <fr:tex
display="inline"><![CDATA[{\mathopen {}\{\Gamma .\varphi \colon \mathord {\hspace {1pt}\text {--}\hspace {1pt}}\}\mathclose {}}\colon T^{\flat }(\Gamma .\varphi )\to {{\mathsf {Elts}(T)}_{/{\Gamma .\varphi }}}]]></fr:tex> by</fr:p>
  <fr:tex
display="block"><![CDATA[     {\mathopen {}\{\Gamma .\varphi \colon \chi  \vdash  \varphi \}\mathclose {}} := (\mathsf {id}_{\Gamma }, \chi  \vdash  \varphi )   ]]></fr:tex>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[\gamma \colon \Delta .\chi \to \Gamma .\varphi ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\psi  \in  T(\Gamma )]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\psi  \vdash  \varphi ]]></fr:tex>.
    Then <fr:tex
display="inline"><![CDATA[{\mathopen {}[\gamma ]\mathclose {}}_{\Gamma .\varphi } \leq  \psi ]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[\exists _{\gamma }(\chi ) \leq  \psi ]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[\chi  \leq  T^{\flat }(\gamma )(\psi )]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[\chi  \leq  T(\gamma )(\psi )]]></fr:tex>.
    But there is a morphism <fr:tex
display="inline"><![CDATA[\gamma  \to  {\mathopen {}\{\Gamma .\varphi \colon \psi  \vdash  \varphi \}\mathclose {}}]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[\chi  \leq  T(\gamma )(\psi )]]></fr:tex>.
    Thus,</fr:p>
  <fr:tex
display="block"><![CDATA[     {\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{\Gamma .\varphi } \dashv  {\mathopen {}\{\Gamma .\varphi \colon \mathord {\hspace {1pt}\text {--}\hspace {1pt}}\}\mathclose {}}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1997</fr:anchor><fr:addr
type="user">ct-001G</fr:addr><fr:route>ct-001G.xml</fr:route><fr:title
text="Exponentiable objects and right adjoints"><fr:link
type="local"
href="ct-001E.xml"
addr="ct-001E"
title="Exponentiable object">Exponentiable</fr:link> objects and right adjoints</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a cartesian category.
  Then an object <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is exponentiable iff <fr:tex
display="inline"><![CDATA[B^{*}\colon \mathcal {C}\to {{\mathcal {C}}_{/{B}}}]]></fr:tex> admits a right adjoint <fr:tex
display="inline"><![CDATA[\Pi _{B}]]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1303</fr:anchor><fr:addr
type="machine">#305</fr:addr><fr:route>unstable-305.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Note that pullbacks over the terminal object <fr:tex
display="inline"><![CDATA[1]]></fr:tex> are products.
    Thus, we may assume that <fr:tex
display="inline"><![CDATA[B^{*}]]></fr:tex> sends each object <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex> to the first projection <fr:tex
display="inline"><![CDATA[B \times  A \to  B]]></fr:tex>.</fr:p>
  <fr:p>Suppose that <fr:tex
display="inline"><![CDATA[B^{*}]]></fr:tex> admits a right adjoint <fr:tex
display="inline"><![CDATA[\Pi _{B}]]></fr:tex>.
    <fr:tex
display="inline"><![CDATA[B \times  (\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]]></fr:tex> can be expressed as <fr:tex
display="inline"><![CDATA[\Sigma _{B}B^{*}]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\Sigma _{B}]]></fr:tex> is constructed in <fr:ref
addr="ct-000I"
href="ct-000I.xml"
taxon="Lemma" />.
    By <fr:ref
addr="ct-000J"
href="ct-000J.xml"
taxon="Lemma" />, <fr:tex
display="inline"><![CDATA[\Sigma _{B}]]></fr:tex> is left adjoint to <fr:tex
display="inline"><![CDATA[B^{*}]]></fr:tex>.
    Thus, we may define <fr:tex
display="inline"><![CDATA[(\mathord {\hspace {1pt}\text {--}\hspace {1pt}})^{B} := \Pi _{B}B^{*}]]></fr:tex>.</fr:p>
  <fr:p>Conversely, suppose that <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is exponentiable.
    Let us use the notation <fr:tex
display="inline"><![CDATA[(\mathord {\hspace {1pt}\text {--}\hspace {1pt}})^{\dag }]]></fr:tex> to denote the exponential transpose.
    Then given any object <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>, let <fr:tex
display="inline"><![CDATA[\Pi _{B}f]]></fr:tex> be given by the following pullback, where <fr:tex
display="inline"><![CDATA[\pi _{1}\colon B \times  1\to B]]></fr:tex> is the product projection.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="74c63fca3521e6cf67a210bca0649385"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzMS45MDg4MTJwdCcgaGVpZ2h0PScxMjMuODg3NjcxcHQnIHZpZXdCb3g9Jy03MiAtNzIgODcuOTM5MjA4IDgyLjU5MTc4MSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdVQUFvQUFBQUFCbndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hkMTRZMk50WVhBQUFBRThBQUFBT3dBQUFFd0VjZ1E0WjJ4NVpnQUFBWGdBQUFLNEFBQURNRTd3YnJ4b1pXRmtBQUFFTUFBQUFDOEFBQUEyS1NDZGRtaG9aV0VBQUFSZ0FBQUFIZ0FBQUNRR2lnSkthRzEwZUFBQUJJQUFBQUFVQUFBQUZBMjNBUFZzYjJOaEFBQUVsQUFBQUF3QUFBQU1BWjRDWG0xaGVIQUFBQVNnQUFBQUdBQUFBQ0FBQ1FCTWJtRnRaUUFBQkxnQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRmlBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbTJzYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFIwWWo3QXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBU2VRNHpBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdzZ0RRWEF3ZFFqb25CaVNHTmVSUHpnZi8vZ1dKdzl2LzkvK2Y4Q2Z6akF0WUJCUUJ5NXc2bkFIamFSWkxQVHhOQkZNZm56U3l6Yk5udWJyZmRYVXJiN1k4dHUxU2t4Wlp1S2VBdVB3cVNGZ1RrVURFbXFGRVRsVVRqajVzYU1ESGhwQWM5ZU9BZ0J4T3VYbzAzdVhpVW0zOEZGN2xwNjJ3VDQwenlNdk8rNy9BKzcvc1FRYzN1YjdLRnY2SXNHa04xaEdyUm1tdVh3S0syYTJSTk1DVGdXYVF5VUQ0YjVIUTNXdkdBMVRpV1RYbnk3MDJvL20yZkEwR0pTMmxRSlhoMit5R1F2ZTByMXdHdnFwdlBPMCtTT0JLdXA0Nk83cjBBWEYwOVNDdDlqejV0N3hId2xuKzJRRnpIR1oyblFMZ2NEM2h6cG5GWERXMU10dVlrajNBV0Q2QkNnK3pNWnk5eElPbC9QdU9kdFZJVGQwNTRnaENnVnJlRTcrTWZhSlo5U05BbTZ6aG5PeDVVZEVPbnZKNEdEM3pTNHdtYVpmbXl6cWdzMjdIZEdpT1ZzQXdWVjZjT0hFNHBuRElrekYwWW1RTElhellCT1MzTGNqNUxVa1Y1eGNSUmVVUFdKSDNlS3N3QVdEclRGVk9XVmRVTTlROXRCeks4N3h3M0k3TVRzUVZpVzJZRzU2a3pJR0RnV3RxSHN6WmhhTzJ0aEdNUDUvOUxFTGZIM25DNWZrRHNFRlR1VHVKOWZJS1N5RUZOeHRNYnZrYjU0QmJCSWRSMm9tNHR1R1dkdHdOWWhsZjJvY2o4NmhVUnFwa1FZRTdZRG1YTVZROE1odXNCM2lmTkVhZkFYVmJVcTNlOGxyTElwZUF3VW9zYWM5ZVdibnlQSnd4Rm9ISkNEeDNBWkhHOUxrdmxTSU5BYytibUxoNGNMRlpHenVONjhsd2hQRDZLRzM3YlNHd1dIeXdvWWgyZ090dzVGYkNJWHkrdHhMVUZyblZLQVRESHNYQmNHdWRtRlhXNTBUbVZsSXNOOHZaeGJrcVJRRlFUWWVqdlM5MUNnWGZGN2hsK0IxK1F5ejU4NEVuVloyN1ZnczJpSlFoTVpINFpXVmMzbU9wWWJBdlpMdXFCdzJ3U1BSazhQMkthZVJJYmJBejU2bHFoVHdwUndLTjZ0bXJDS3puSk5zcUk3NFl3QmswUkFGSnFXQk1IMk5SRmVQcHJrYzFBZHNZL3RyRlJFUUdESUV6SE1ocUFvTW1DaW12cGtyK1ZFa094T0VCME9EUHR2eXl4bHY4Q3R6VjZFWGphWTJCa1lHQUE0ajVuM3MveC9EWmZHWmhaR0VEZ2NZU3VEWUwrcjg4Y3lYUUp5T1ZnWUFLSkFnQUY5Z2txQUhqYVkyQmtZR0JtK004QUpFc1k5UDVmWUk1a0FJcWdBRllBWERRRDJnQUFBc1lBQUFOMEFFb0NPZ0JMQXBjQU1nS3NBQzRBQUFBQUFHQUF4Z0UrQVpoNDJtTmdaR0JnWUdYd1ptQm1BQUZHQmpRQUFBaHZBRlo0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1JQUFvQUFBQUFBM1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hUeDBGV050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUIwWjJ4NVpnQUFBV1FBQUFCVUFBQUFWSjVQNzUxb1pXRmtBQUFCdUFBQUFDd0FBQUEyS0ptZVVHaG9aV0VBQUFIa0FBQUFJQUFBQUNRRVRBSkJhRzEwZUFBQUFnUUFBQUFJQUFBQUNBUWVBR3BzYjJOaEFBQUNEQUFBQUFZQUFBQUdBQ29BQUcxaGVIQUFBQUlVQUFBQUZnQUFBQ0FBQlFBWGJtRnRaUUFBQWl3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBQytBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTRtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9xTWlneU0vd0g4cGtoMGtocS9nT0ZBYUw3REVFQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpSy8vOUR5UDhQd0h3R0FFLzNCbjBBQUFBQUFnQnFBQUFBNEFMYkFBc0FGUUFBRXdNT0FTSW1Kd00rQVRJV0V3NENMZ0UyTng0QjRDZ0JDQk1KQVNnQ0lpMGtBUUVoTVNFQ0lCd1lJUUtqL2pzUENRa1FBY1FhSGgzOWZSa2hBU0F6SWdFQklRQjQybU5nWkdCZ0FHTEY1MW41OGZ3Mlh4bVlXUmhBNEhHRXJnMHl6WFNaNlRhUTRtQmdBdkVBL01zSWpuamFZMkJrWUdCbStNL0F3TUIwbVNHTEladmhBUU5RQkFVd0FRQldXQU9SQXRNQUFBRkxBR29BQUFBQUFDb0FBSGphWTJCa1lHQmdZaEFEWWhCZ1pFQURBQUxhQUIwQUFIamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU2grNHVEazR1VHE4elpvZ0hacEtXb3N1NGsvM05nUnY0UERkYzg0TmtQRWlZWmlFZWRCaFVubnp5R04rV0VTZWlMK0tuUEhMbWhGSk9oTm54UzV5eXBUL3lHT1dsSkVuNGo4aVovengzamYxN2Q1WnI0Nk5zZDVkYXI4OVdkOVdqVk1iblEvcndUcnJ6NTAxcW53cTAxZHRmNjFWb1hOZHNLZWg1c2FkRG90SGNSVEhCSFpjSlBOc09ZVzlwWkxNU1dlREp2K21CMGxkYUp6REwwWWFKVTlSUXk4M3JlaFZ1b29pM0dtS0QxaXNMa3NBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTVlBQW9BQUFBQUE0UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MUcyTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUJrQUFBQVpERnVBckpvWldGa0FBQUJ5QUFBQUN3QUFBQTJLUmllSUdob1pXRUFBQUgwQUFBQUhnQUFBQ1FGeXdMV2FHMTBlQUFBQWhRQUFBQUlBQUFBQ0FZS0FKSnNiMk5oQUFBQ0hBQUFBQVlBQUFBR0FESUFBRzFoZUhBQUFBSWtBQUFBRndBQUFDQUFCQUFnYm1GdFpRQUFBandBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEQ0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd5TS93SDhwa2gwa2hxL2dPRkFhTjNERmdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy85RHlQOFh3SHdHQUZGSEJvMEFBQUFBQVFDU0FBQUNOd0tyQUI0QUFBRVJCaFk3QVJVbUp5TUdCelV6TWpZbkVRNEJKeU0xTXhZL0FUWTNOaFlCbUFRaVRqTXNPdEU2TEROT0lRTXVWQk1TRWhJK0J6ODVHQTRDaS8zTkZ4UXRBd0VCQXkwVUZ3SUFFZ3dCTFFJS0Fnb3VBUWtBZU5wallHUmdZQURpNzJzZFN1UDViYjR5TUxNd2dNRGpDRjBiWkpvNWlHazFrT0pnWUFMeEFBcFhDRlo0Mm1OZ1pHQmdadmpQQUNTREdDWXhOREtaTXdCRlVBQVRBRUxjQXFnQUFBTlNBQUFDdUFDU0FBQUFBQUF5QUFCNDJtTmdaR0JnWUdLUVp3RFJERkFTQ1FBQUE2UUFKUUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUzhBQW9BQUFBQUJXd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MDUyTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QW5RQjdaMng1WmdBQUFXd0FBQUhxQUFBQ0xMbEdXV2hvWldGa0FBQURXQUFBQUM4QUFBQTJLTTJkZ0dob1pXRUFBQU9JQUFBQUhnQUFBQ1FHTFFITmFHMTBlQUFBQTZnQUFBQVFBQUFBRUFwekFJVnNiMk5oQUFBRHVBQUFBQW9BQUFBS0FXb0FzRzFoZUhBQUFBUEVBQUFBR0FBQUFDQUFDQUJDYm1GdFpRQUFBOXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFc0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtbXNNNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaRWhqWnZnUDVETkRwSkhVL0FjS0F3RGg1UTB6ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pHay9mOFA1RHVDNlA4SC9zOEZxd0lDQUpSZkNSSUFBSGphTmRFeGI5TkFGQWZ3KzkvRjV5VFlQaFBIZHF2RVNSeW5OaW9pS1hXdzJ3b01hbWhBclJJVktsQ0hTa2hJMEEwaDFCYllNblNFQ1lFRUN3c2JINEFCSmlZK0FDc0RZdVF6Sk9GY2ladnUvdThOdjNlUFVOS1p6K2x2K292MHlDb2hLWkowMVhHdHFoTW5EdTlCamNLb243aE9rdmJncTd6cXVJbHJRT1o1SEdkSVkvWUZqM2hWNThpY1N6WTA1V2hTVktDZnMvcXNwTTdtWTcxdTZReTZjcml2UVN1MXMvZC8vUk42MzBSSlRDZU9ZSjRLeGtDTFFnVTA5L0hXYWJWamdncUQ1M0ZaY0FRL2NKZkl3OGpGK1pSeCtvMDB5REpaazFLckgwUmMydndHYkFOcUF5NFg0S3JQejd4V2prdkNLQWk1eXY3Zm1XeUlQNzJ1Ulo0UTJEOTR5Q1o3TzN1Z3Q4elI4ZXhOM1RBMkdoL2ZQVGlpNkE1T201Ynk1TlhCQ2FVcnQ3OFBDNEN4UzlmUFUxWlhRZTlzYkIrSzhuaDlaOVBJQ3ZrRXNMREZuZzA3TnluRTR2UXplejVlMm1XelB4VmVKZ1FrbVhmcEZmcVQzSkNQSEtCS2JEdU1Nc1R5b3gwdTRhbmtXVUh1anE4amd5dHpBNEhzQ1pPMEM1V3JYTkI4SFJGZVpJWWlYT1BxY2lzQkFsdllvRzVnZW9VbzFFWUR6eFREaGZMaXVPWW5GRzFiT01CQ1N6UUx2bENLbW4ydkJsUGd3K3pyd0xwMnVibEpPNEhYcWxUMHNDQlh4NTZPOEpaNUhDOHZiSy9Rb0hOV1dWTHlTbE1QMTQ3enNRbjVCeGtuVklJQUFIamFZMkJrWUdBQTRucURmZHZqK1cyK01qQ3pNSURBNHdoZEd3VDlYNCtaamVrdWtNdkJ3QVFTQlFBUWVBazBBSGphWTJCa1lHQm0rTThBSkRrWVZQNGZZR1pqQUlxZ0FCWUFTVWdEQUFBQUFuWUFBQU1BQUNRRENBQXJBZlVBTmdBQUFBQUFWQUN3QVJZQUFIamFZMkJrWUdCZ1lYQmtZR1lBQVVZR05BQUFCMW9BUzNqYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9ZQUFvQUFBQUFCQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FDd1M1Mk50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0J6WjJ4NVpnQUFBV3dBQUFEUkFBQUE0SWdJNFB4b1pXRmtBQUFDUUFBQUFDOEFBQUEyS2h5ZGEyaG9aV0VBQUFKd0FBQUFId0FBQUNRRjJBRU9hRzEwZUFBQUFwQUFBQUFJQUFBQUNBYi9BSDlzYjJOaEFBQUNtQUFBQUFZQUFBQUdBSEFBQUcxaGVIQUFBQUtnQUFBQUZ3QUFBQ0FBQkFCS2JtRnRaUUFBQXJnQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRGlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXJtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhRRUFEQXlwSUtTNUxaMkJUQUFKbXJUK1dEQXpNV3N6SGdjS01DQlgvL3pNd0FBQUtlUTdDQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1FvSy8vOUR5UHNQd2ZJTUFGS2lCcHdBQUhqYU5Zc3hUc013R0ViOS9ZNS8xeW5GRmswSmxKS290aFVhVlNRSTJvUUJ0U3NEUjJCRHZRQmlZdUVBM0tUbjRUNVFrRmplOHQ0VEVCL2ZucTdwU3p3S2dSSUZKbXpCK2hkOTFhSzZXblZiZEd1TFk0UUdxNjYvTFdYVlVyWGVJTzlPODc5NGl3M3VDbVNzL1dIQlRvNU1BbFphU24yVWt4d2tHbXFZeXZONjNHUno1K2FUczNveEphV0hpaUp6SkNqSE5QMjNXVE91c1MvNnhkSy92ejY5NUFNQ1R0enUvdTB6dGpkTE81SXBweFNzSnpZbW1aWGh3VjlFUitUaVpYZ3VaNGxoUTk0R09sUkMvQUNmYkJkZEFBQUFlTnBqWUdSZ1lBRGk5VjdYVjhmejIzeGxZR1poQUlISEVibzJDUHEvRWtzbzB4VWdsNE9CQ1NRS0FDTHNDY1lBZU5wallHUmdZTmI2WThuQXdCTEtVTTlReTZUTEFCUkJBVXdBUzZzQzZ3QUVWUUFBQXFvQWZ3QUFBQUFBY0FBQWVOcGpZR1JnWUdCaThHUUEwUXhRRWdrQUFBZStBRThBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9FQUFvQUFBQUFBL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWMTE1R050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNWWjJ4NVpnQUFBV1FBQUFERkFBQUF6SFVYTGMxb1pXRmtBQUFDTEFBQUFDOEFBQUEyS1orZU1HaG9aV0VBQUFKY0FBQUFId0FBQUNRSFZnTjNhRzEwZUFBQUFud0FBQUFJQUFBQUNBZDZBSHhzYjJOaEFBQUNoQUFBQUFZQUFBQUdBR1lBQUcxaGVIQUFBQUtNQUFBQUdBQUFBQ0FBQmdCQmJtRnRaUUFBQXFRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGRBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTNzczRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWW5CaVp2Z1A1RE5EcEpIVS9BY0tBd0RxU3cweWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoTy8vOUR5UC83d1h3R0FGS3NCcDRBQUFCNDJtTmdacWo1LzUvNUJ0TWVCZzBHRXdaN0JnWnpZWE5UTlgxR05qVlRFek54UlRsR2NUWjJFSlJqWkljd0ZDRXlSbWJDeG5hTTVpWnE2c3BxYk96TU1EWXorNzgyWmtFUkdXRmhFUUhHeGRrdFRDek92QUtlbmhrSmpNeEJQUHpSemYrYytVVEVSTTFsTnh6SzdXUHk5Tmt0TDhpU2N6UmxJb3VmM3k4MzVsQW1TUjVlRmtaR1JqWmVFVTVHeG1CSE4xMHVUZzFPL2pCRGJ6c3VUaXRtUmpZZVVVNUdBVVo3NWlSSExUc21SaDZ4djRlWUVuMk1QSm4rdlJSbVlBQUFtdVFtYXdBQUFIamFZMkJrWUdBQTRnamxUZUh4L0RaZkdaaFpHRURnY1lTdURZTCsvNS81QnRNZUlKZURnUWtrQ2dBS2V3b1dBSGphWTJCa1lHQm0rTS9Bd01DaXhsREQ0TWQ4Z3dFb2dnS1lBRVNJQXRZQUExUUFBQVFtQUh3QUFBQUFBR1lBQUhqYVkyQmtZR0JnWW5CZ1lHWUFBVVlHTkFBQUJ3c0FTSGphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9NRGFoWUdKbGFrTFlCZGxzSTJjRUFtcDZ0amYzWWZ4MERkY25mdGhBelUvRk55dllKYjBmaVdWdUFkWFRKbG5ub2g3eTF5ejRKMG5pdkpaa2xjK01wZlNmR2F1ZU9FcjgwVHk3OHcxSzM0M3dWMnVnNDFxRjR5Ti91UmN0OTdiMkhmQnE2VnVrdDlhYitOaHNFWWRiOHFNWFQrZW5XcDFvMXMyQkJ3WHJneFlJb3FkSkNheDV5U2RvMlBOUGlXOWNKQmNzVVRUL091MzB2dTBPYVNmakd5TzNFUU5veXg2MGJOc0ZXMTZxV24vQU1nUkwrOEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTndBQW9BQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGN4NEJXTnRZWEFBQUFFOEFBQUFNUUFBQUR3SElQMGZaMng1WmdBQUFYQUFBQUNzQUFBQTBGNldrLzFvWldGa0FBQUNIQUFBQUN3QUFBQTJLS09lTFdob1pXRUFBQUpJQUFBQUhRQUFBQ1FHQVFJbmFHMTBlQUFBQW1nQUFBQU1BQUFBREFlQUFIMXNiMk5oQUFBQ2RBQUFBQWdBQUFBSUFDb0FhRzFoZUhBQUFBSjhBQUFBRndBQUFDQUFCUUFyYm1GdFpRQUFBcFFBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFEWkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtYW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwb2FNaTlnWnZnUDVETXpNSUtFR1JFcS9nT0ZBZlkxRGNRQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlob3lML2ovSDhnSDAvOHYvRWtDcXdJQ0FKazVDVDBBQUFCNDJtTmdaSWhtWUdCY3k3U2FRUUpJQzdLSldUT0txaXV6bXhvYm1ha0w4akdxbTRxWm1adUpNZW95S3pncEJxNEtWSFNXWjliMEVaVEpNUlprWityL2UwaEdWSUdaV1VGVWhrbEltSU5SbmtsVW41RUxhQXlERWdNRDAxMm1IUXlhbUdZcW92SE4xTFFaVFJWRmxaWFltRXFZcEN3bHZHZDZTVnBJTS8wN3l5UnRJUW5rU0ZoS01ZSEVtWGFEV0JsL1g4aUlnS3dVa1dIeS9Mc2R6cGFRRVpXWEYyVmdBQUM3UnlGc2VOcGpZR1JnWUFEaUdJVlhndkg4Tmw4Wm1Ga1lRT0J4aEs0Tk1zMTBsMmtIa09KZ1lBTHhBT21oQ0F0NDJtTmdaR0JnWnZqUEFDSVpsQmlVbWU0eUFFVlFBRE1BTldjQ0x3QUFBQUtBQUFBQ0FBQmJBd0FBSWdBQUFBQUFLZ0JvZU5wallHUmdZR0JtMEdJQTBReFFFZ2tBQUFUU0FERUFlTnBGakRGdndqQVFoYitJQklsMDZGSjFZQUFQekZhaU1IZGhZR0psWWdGc29neHhrQk1pSWFHTy9kMDlqQ1Z1ZVBydXZYY0g1UHlTOEp5RXo2RFBTY2xrZTNIR0IxK1JwN0l0SStmTVdURWhTV2ZpTFBpSm5FcHlpSnp4elNYeVZQeEg1SncxZjV1dXZkNEc2OVd1TTlhN2MrdkxZbTk5MzNST2xib0krOVk2NjQrRE5lcDBWMlpzK3JGdVZhVUxYYkdobytYS2pRR0xSN0VUeHdSMm5DWHpsQlRzZzlQVFNPcWtWYUxGZmVkYnlWM29ITU1uSTUwVGQxSERLRmU5YUMxdFJSVXVOZFUvWXowdkR3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTU3LjU3MDk0NCwtNjAuNDQ3NTAxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEwLjE3NzYzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ny41NzA5NDQsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTcuNTcwOTQ0JyB5PSctNjAuNDQ3NTAxJz7OoDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTAuMDk4OTQ1JyB5PSctNTguOTUzMTInPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQzLjI0MTY2NCcgeT0nLTYwLjQ0NzUwMSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMi41LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTcuNTcwOTQ0LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTU3LjU3MDk0NCcgeT0nLTYwLjQ0NzUwMSc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC04LjM1NDE3Vi00OC41NTEzNScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguODAxMzUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjUyNzc3LC0zMC40NTI3NiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU3LjU3MDk0NCwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01Ny41NzA5NDQnIHk9Jy02MC40NDc1MDEnPiE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDkuNzE0LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ny41NzA5NDQsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTcuNTcwOTQ0JyB5PSctNjAuNDQ3NTAxJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01MC4wOTg5NDUnIHk9Jy02NC4wNjI4NjUnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDkuNDIwNjEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ny41NzA5NDQsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTcuNTcwOTQ0JyB5PSctNjAuNDQ3NTAxJz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00OS41MTQzMzUnIHk9Jy02NC4wNjI4NjUnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTE0LjczMzE3IDBINDQuNjU4NDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDQuOTA4NDYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNy40OTg3NSw0LjE3MjkxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTcuNTcwOTQ0LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU3LjU3MDk0NCcgeT0nLTYwLjQ0NzUwMSc+zrI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDYuNTgzNTEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00Ni44MzM1MSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI4LjQ5NjYxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTcuNTcwOTQ0LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU3LjU3MDk0NCcgeT0nLTYwLjQ0NzUwMSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTIuOTA0MzU5JyB5PSctNjMuNDU0MDE4Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J003LjA1NTU0LTU2LjkwNTVINDQuMzY1MDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDQuNjE1MDcsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIxLjU3OTg4LC02Ni41NzI4NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU3LjU3MDk0NCwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01Ny41NzA5NDQnIHk9Jy02MC40NDc1MDEnPs+APC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01Mi42NjE4NzgnIHk9Jy02My44MTgxNzcnPuKAoDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTIuOTEyMDk5JyB5PSctNTguMjg0NTc2Jz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = {\Pi _{B}f},
      nw/style = {pullback},
      ne = {A^{B}},
      sw = 1,
      se = {B^{B}},
      north = \beta ,
      east = {f^{B}},
      south = {\pi _{1}^{\dag }},
      west = {\mathsf {!}},
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Now let <fr:tex
display="inline"><![CDATA[\alpha \colon f\to g]]></fr:tex> be a morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>, we extend the above assignment to morphisms as follows:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="4fa034167f7dca1a305bb0805ae1fd71"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5MS4yNDYyNzFwdCcgaGVpZ2h0PScxODEuNTE4NzU1cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTI3LjQ5NzUxNCAxMjEuMDEyNTAzJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQS9nQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoYng0QkdOdFlYQUFBQUU4QUFBQU1RQUFBRHdITVB6L1oyeDVaZ0FBQVhBQUFBQzJBQUFBekFxNjNZdG9aV0ZrQUFBQ0tBQUFBQ3dBQUFBMktPdWVRbWhvWldFQUFBSlVBQUFBSGdBQUFDUUdZQUtkYUcxMGVBQUFBblFBQUFBTUFBQUFEQWQ5QUtOc2IyTmhBQUFDZ0FBQUFBZ0FBQUFJQUNvQVptMWhlSEFBQUFLSUFBQUFHQUFBQUNBQUJnQXBibUZ0WlFBQUFxQUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQURiQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBvcU1pOWdadmdQNURNek1JS0VHUkVxL2dPRkFmUG9EYk1BQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeWlveUwvai9IOGdIMC84Zi9Fa0Nxd0lDQUpkSkNTMEFBQUI0MmxYSlN3N0JZQlNHNGUrY05xV1JsS2FYOUVMVHYvU1NDQW1paUlUTkdObURoV0JvWmdNR1JoSzdNTEVBaVJWVWxJSEU3SG56Z3JFR2NPY2JhckFBUTlJb1NsSnBRVVBiMExoUCtTU2dlMFpWUTZXTW8xNkhTQXdFaDAxSDhPRTFyNnRxZzY1ZTBDbzJycUJ3RkpVYklNd0FLZVlUMGpKMHhaNlRsVmJHbzJHZTZ1SS84NlJMWTJHMUk0WFA3RS9kL2RhWmVmdzZmcjF6cHo1L3hJK1BWc1hUTjJKWmprMlBsOFhsWjcxVWJBSnZEemNoRmdBQWVOcGpZR1JnWUFCaVBldjIxbmgrbTY4TXpDd01JUEE0UXRjVW1XWldaYm9OcERnWW1FQThBTitKQjJkNDJtTmdaR0JnWnZqUEFDVGpHU3dackpoVkdZQWlLSUFaQURVT0FnVUFBQUxUQUFBQlN3QnFBMThBT1FBQUFBQUFLZ0JtZU5wallHUmdZR0JtMEdCZ1lnQUJSZ1kwQUFBRXR3QXdlTm85akRHcndqQVVoYjlpRmUwYkhBU0hOMGp3QjRSS0g3aTRPVGk1T3J6Tm1pQWRta3BhaXk3aVQvYzJCRy9nOE4xenpnMlE4U0pobUlSNTBHRlNlZlBJWTM1WVJKNkl2NHFjOGN1YUVVazZFMmZGTG5MS2xQL0lZNWFVa1NmaVB5Sm4vUEhlTi9YdDNsbXZqbzJ4M2wxcXZ6MVozMWFOVXh1ZEQrdkJPdXZQblRXcWZDclRWMjEvclZXaGMxMndwNkhteHAwT2kwZHhGTWNFZGx3azgydzVoYjJsa3N4Slo0TW0vNllIU1Yxb25NTXZSaG9sVDFGREx6ZXQ2Rlc2aWlMY2FZb1BXS3d1U3dBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNY0FBb0FBQUFBQTRRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVXgxRzJOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDRVoyeDVaZ0FBQVdRQUFBQmtBQUFBWkRGdUFySm9aV0ZrQUFBQnlBQUFBQzBBQUFBMktSaWVFbWhvWldFQUFBSDRBQUFBSGdBQUFDUUZ5d0xXYUcxMGVBQUFBaGdBQUFBSUFBQUFDQVlLQUpKc2IyTmhBQUFDSUFBQUFBWUFBQUFHQURJQUFHMWhlSEFBQUFJb0FBQUFGd0FBQUNBQUJBQWdibUZ0WlFBQUFrQUFBQURLQUFBQk11c0lrZVp3YjNOMEFBQUREQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1abVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvYU1oZ3lNL3dIOHBraDBraHEvZ09GQWFOM0RGZ0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aUcvLzlEeVA4WHdId0dBRkZIQm8wQUFBQUFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FlTnBqWUdSZ1lBRGk3MnNkSnNiejIzeGxZR1poQUlISEVicW15RFJ6RU5OcUlNWEJ3QVRpQVFBTnlRaGtBQUFBZU5wallHUmdZR2I0endBa2d4Z21NVFF5bVRNQVJWQUFFd0JDM0FLb0FBQURVZ0FBQXJnQWtnQUFBQUFBTWdBQWVOcGpZR1JnWUdCaWtHY0EwUXhRRWdrQUFBT2tBQ1VBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktuNXViZzVPcnc5dXNDZEtocWFTMTZDTCtkRzlEOEFZTzN6M24zQUFaTHhLR1NaZ0hIU2FWTjQ4ODVvZEY1SW40cThnWnY2d1prYVF6Y1Zic0lxZE0rWTg4WmtrWmVTTCtJM0xHSCs5OVU5L3VuZlhxMkJqcjNhWDIyNVAxYmRVNHRkSDVzQjZzcy83Y1dhUEtweko5MWZiWFdoVTYxd1Y3R21wdTNPbXdlQlJIY1V4Z3gwVXl6NVpUMkZzcXlaeDBObWp5YjNxUTFJWEdPZnhpcEZIeUZEWDBjdE9LWHFXcktNS2RwdmdBVlRJdVF3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT0VBQW9BQUFBQUEvQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFYxMTVHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQURGQUFBQXpIVVhMYzFvWldGa0FBQUNMQUFBQUM4QUFBQTJLWitlSW1ob1pXRUFBQUpjQUFBQUh3QUFBQ1FIVmdOM2FHMTBlQUFBQW53QUFBQUlBQUFBQ0FkNkFIeHNiMk5oQUFBQ2hBQUFBQVlBQUFBR0FHWUFBRzFoZUhBQUFBS01BQUFBR0FBQUFDQUFCZ0JCYm1GdFpRQUFBcVFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEZEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtM3NzNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBZbkJpWnZnUDVETkRwSkhVL0FjS0F3RHFTdzB5ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy85RHlQLzd3WHdHQUZLc0JwNEFBQUI0Mm1OZ1pxajUvNS81QnRNZUJnMEdFd1o3QmdaellYTlROWDFHTmpWVEV6TnhSVGxHY1RaMkVKUmpaSWN3RkNFeVJtYkN4bmFNNWlacTZzcHFiT3pNTURZeis3ODJaa0VSR1dGaEVRSEd4ZGt0VEN6T3ZBS2VuaGtKak14QlBQelJ6ZitjK1VURVJNMWxOeHpLN1dQeTlOa3RMOGlTY3pSbElvdWYzeTgzNWxBbVNSNWVGa1pHUmpaZUVVNUd4bUJITjEwdVRnMU8vakJEYnpzdVRpdG1SalllVVU1R0FVWjc1aVJITFRzbVJoNnh2NGVZRW4yTVBKbit2UlJtWUFBQW11UW1hd0FBQUhqYVkyQmtZR0FBNGdqbFRjWHgvRFpmR1poWkdFRGdjWVN1S1lMKy81LzVCdE1lSUplRGdRa2tDZ0FON1Fva0FIamFZMkJrWUdCbStNL0F3TUNpeGxERDRNZDhnd0VvZ2dLWUFFU0lBdFlBQTFRQUFBUW1BSHdBQUFBQUFHWUFBSGphWTJCa1lHQmdZbkJnWUdZQUFVWUdOQUFBQndzQVNIamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b01EYWhZR0psYWtMWUJkbHNJMmNFQW1wNnRqZjNZZngwRGRjbmZ0aEF6VS9GTnl2WUpiMGZpV1Z1QWRYVEpsbm5vaDd5MXl6NEowbml2SlprbGMrTXBmU2ZHYXVlT0VyODBUeTc4dzFLMzQzd1YydWc0MXFGNHlOL3VSY3Q5N2IySGZCcTZWdWt0OWFiK05oc0VZZGI4cU1YVCtlbldwMW8xczJCQndYcmd4WUlvcWRKQ2F4NXlTZG8yUE5QaVc5Y0pCY3NVVFQvT3UzMHZ1ME9hU2ZqR3lPM0VRTm95eDYwYk5zRlcxNnFXbi9BTWdSTCs4QUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOd0FBb0FBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY3g0QldOdFlYQUFBQUU4QUFBQU1RQUFBRHdISVAwZloyeDVaZ0FBQVhBQUFBQ3NBQUFBMEY2V2svMW9aV0ZrQUFBQ0hBQUFBQ3dBQUFBMktLT2VIMmhvWldFQUFBSklBQUFBSFFBQUFDUUdBUUluYUcxMGVBQUFBbWdBQUFBTUFBQUFEQWVBQUgxc2IyTmhBQUFDZEFBQUFBZ0FBQUFJQUNvQWFHMWhlSEFBQUFKOEFBQUFGd0FBQUNBQUJRQXJibUZ0WlFBQUFwUUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURaQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1hbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBvYU1pOWdadmdQNURNek1JS0VHUkVxL2dPRkFmWTFEY1FBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeWhveUwvai9IOGdIMC84di9Fa0Nxd0lDQUprNUNUMEFBQUI0Mm1OZ1pJaG1ZR0JjeTdTYVFRSklDN0tKV1RPS3FpdXpteG9ibWFrTDhqR3FtNHFabVp1Sk1lb3lLemdwQnE0S1ZIU1daOWIwRVpUSk1SWmtaK3IvZTBoR1ZJR1pXVUZVaGtsSW1JTlJua2xVbjVFTGFBeURFZ01EMDEybUhReWFtR1lxb3ZITjFMUVpUUlZGbFpYWW1FcVlwQ3dsdkdkNlNWcElNLzA3eXlSdElRbmtTRmhLTVlIRW1YYURXQmwvWDhpSWdLd1VrV0h5L0xzZHpwYVFFWldYRjJWZ0FBQzdSeUZzZU5wallHUmdZQURpR0lWWHV2SDhObDhabUZrWVFPQnhoSzRwTXMxMGwya0hrT0pnWUFMeEFPMFRDQmw0Mm1OZ1pHQmdadmpQQUNJWmxCaVVtZTR5QUVWUUFETUFOV2NDTHdBQUFBS0FBQUFDQUFCYkF3QUFJZ0FBQUFBQUtnQm9lTnBqWUdSZ1lHQm0wR0lBMFF4UUVna0FBQVRTQURFQWVOcEZqREZ2d2pBUWhiK0lCSWwwNkZKMVlBQVB6RmFpTUhkaFlHSmxZZ0Zzb2d4eGtCTWlJYUdPL2QwOWpDVnVlUHJ1dlhjSDVQeVM4SnlFejZEUFNjbGtlM0hHQjErUnA3SXRJK2ZNV1RFaFNXZmlMUGlKbkVweWlKenh6U1h5VlB4SDVKdzFmNXV1dmQ0RzY5V3VNOWE3Yyt2TFltOTkzM1JPbGJvSSs5WTY2NCtETmVwMFYyWnMrckZ1VmFVTFhiR2hvK1hLalFHTFI3RVR4d1IybkNYemxCVHNnOVBUU09xa1ZhTEZmZWRieVYzb0hNTW5JNTBUZDFIREtGZTlhQzF0UlJVdU5kVS9ZejB2RHdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFWNEFBb0FBQUFBQmxRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVjEwdldOdFlYQUFBQUU0QUFBQU5RQUFBRHdBblFCOVoyeDVaZ0FBQVhBQUFBS2dBQUFERUNSYkhycG9aV0ZrQUFBRUVBQUFBQzhBQUFBMktOS2RhV2hvWldFQUFBUkFBQUFBSGdBQUFDUUdIQUhPYUcxMGVBQUFCR0FBQUFBVUFBQUFGQXcxQUtKc2IyTmhBQUFFZEFBQUFBd0FBQUFNQVh3Q1FtMWhlSEFBQUFTQUFBQUFHQUFBQUNBQUNRQkNibUZ0WlFBQUJKZ0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZiQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvNk1hUXpNL3dIOHBraDBraHEvZ09GQWRLQ0RRb0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPak9rLy84UDVEc3hwUDMvLzMvLy83bGdWVUFBQUpTVkNSUUFBQUI0MmsyU1QwOFRVUkRBZDk3YnZpMmw3RnRhZHJkazJXN2JiWGNMMlBKbjZ5NEZLWDlxVnlncFZLc0dUUlBVeEppWVlFUUJNZkZBRENhWTZNbklRUTlldlBrUjlHUmk0bDAvZ2NhREp6K0FvZld0eE1UTU83ek16T0gzbXhrT2M2UGRZMHpRQnk3SmpYQlRIT2ZGUzZaTlNxNmFUb0lzZ3BBRWxWQWdRanJJS1c3Y3FZRG5XclpwRVFILysyUFc0THg5cnRrNnBiRGV2b0gzV3lzdFFPZWt4azdueFpBb1RpZmZIRzFzSXloV0Q0eDQ2TTZ6OWk1QzQwc2ZmUjVBYktKeVA4SkRBcUR6MC9WYk5MSmFYbGtVS3p6V0JZQTQxUEE5UDNzV0FSMDhmb2Nmck9hYXVQTTlSaUljQjV6VC9ZbDcwZGVBR2JBSXBtM1pjMUN5Yk1ZY0FLdEo4QlRYQ3dnTlNESUJsaStDN1hwQktLcWlla3dIUitZeGlmU0VBTUhsdGRxVGNWOGpDdkNQbHZNYmJxbEErQjRoaEF2KzhGWjE3elhHclZMOS9rRnJPRStXUklpaXo1M2ZJbU1XcUhYMU5rQjFhbjBqMFM3c1hrZVFHU20yRTcwQUtMcTVtSE1BSCswLzNhNlhMbUErbXhQWFJJUzVnTjN0RnRGcHhqNGZzTk1UdUl4bFY4Q1paR2lFRFQwQWo1dkJ6SjA1cUlESzhzeVI5Vml1VjJTR3pCRTVya0pzMkt1SUlhcUtaMFpTTG9BcFV4bVFha282YjF2UlJsV1hxSitJREs1cWFaZWh5VlFCU0tTb3dhZHBLQnlWTDJrZ1VYalZlVitOejA0WWl5aHI2cWxZck0vaSt3amd1dzE0aVhVQ0QvUDFjV1JtLzFaeW9hQmk5RmxUTzhIS21Bdml4RzRSZnNBbmRqMXpKNXRnSmhVMjhRRWlLQWE0YzhIN2YvYk1oUGtvS3ZiY01UaFpWeEFzaStIYlZuVHoydklDeXRyeEFVVlJMRDhqRGFKTXowS3gzRUI0UnBKcVRXT1M4a01SRFIyV1FBejFqNlZtWmFVL0JwQzAxRlBzWUI5M3loTlhzRkhSUWRHTU1Oc1BiOGZzeUdGdkFjUEZ4czJtTFBrNHEydXNYK3Y4K2hMT2hETThPUFpvemMrblp4REllbzc3QTJPdGVQNTQybU5nWkdCZ0FPS2x4WnEvNC9sdHZqSXdzekNBd09NSVhWTUUvVitQbVp2cENwREx3Y0FFRWdVQUUzOEpPZ0I0Mm1OZ1pHQmdadmpQQUNRNUdQaitIMkRtWmdDS29BQldBRWV1QXZBQUFBSjJBQUFEQ0FBckF0c0FNd0gxQURZQjV3QU9BQUFBQUFCY0FMb0JJQUdJZU5wallHUmdZR0JsY0dSZ1pnQUJSZ1kwQUFBSGRRQk1lTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWlVBQW9BQUFBQUIyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaGQxNGJHTnRZWEFBQUFFOEFBQUFQZ0FBQUV3RWRRUTNaMng1WmdBQUFYd0FBQU5xQUFBRUVNWXdHeGhvWldGa0FBQUU2QUFBQUM4QUFBQTJLU0NkWm1ob1pXRUFBQVVZQUFBQUhnQUFBQ1FHaHdLS2FHMTBlQUFBQlRnQUFBQVlBQUFBR0JDdkFSVnNiMk5oQUFBRlVBQUFBQTRBQUFBT0E1NENmRzFoZUhBQUFBVmdBQUFBR0FBQUFDQUFDZ0JNYm1GdFpRQUFCWGdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFHU0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtT3M0NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdJTkdCaVNRVWx5V0RwUjBZajdBelBBZnlHZG1ZQVFKTXlKVS9BY0tBd0FWdmc0OEFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ3NnRFFYQXdkUWpvbkJpU0dkZVJQemdmLy9nV0lnOWtZUSsvLysvN1AvQlAxeEJldUFBZ0J6R3c2cEFBQjQyazJUeTI4YlZSVEc3emwzUE1PTXgvUHlQT0o0L0poTVBPUFF4R041WWp1aGlSM1hia2ljNWxHQ0ZHeFZ0RlMwVmRWS1ZCUlFoUUExU0VqWmdjcTJDMWdnZFl2RUJzU09idGgyeDErUlRWa2dnYzBkVjBqb1NsZDM1aHpwZnIvN2ZZZFFNcHorVFVmNEsvSElDbGtucEoxdHQ0SUlmRDVvT1Y0UkhBVUV0dk1xOElLWC9MTmIyYmdEckNmMEExNmcvNTBwYi85MnhvR281WlFTR0FwOC9QNEhRRSt2djNVTmNOODQvbXp5MEVVOXMxNTQ5dXp1NTRETi9hY2xMZlhnaCt1bkZEbzdmK3lCZklSbFcrQ0JjZ3NDNFBIRzRMWWhYVjNiNnlrZHl2a0NnQUVEZXYrUzl5WUhpdjNQajNqL01Ccmk1SVZBQ1VHeVBGM0JDanduTmRJbkJDalR5d2RoQitLRzdaaTg0Tml4M1dwM29NdjAxeUJzdFpQRmdKaHMxa0M3MEFxRGtJSHdnZ0syMDBoYTBYc2dQbndVdmN1QmIrczJLSWFyZSthRzc5cUMwOTd0alpEMlZIMTNWRzFtNkx5UnNlQkpSTUcwVnVmN1pVdlRJUWlMbDF4WmdFOG52V2hNMFZvdWVObHN1aWlsRU5KdXJsNitGbk53Y25UcklLc09LQ3phbWcyYVB2bnJaelZkOFRtb05vUGUxbUViS21VMVF4SzI3dlFsL2pSajJ5S2tVb1EyWTFtTm5Sa1pvMlNzLzJleVM1RG9MMEVSRXJzWUdLc0dDWmxqMnN3NHJITjJXbHFVRFltSGVDWFhNWmNmN1l4dklMZXRtMWZ2SE55VkViRHZwZ1NKbGVmRjBoTU91RlI5TTc5ZkNkbkZjZW1UYjhaVkRndzNEU2daTWFMZjhtUEFPN3MzRDAyTnNZeXZwTDNHMjdjMUNSQ3RiWDMzM2lqeUd5TUsvc3JhYVg1MUUzQ0JVTktZcnVFWnZpQXVDY21RdVRVTGw1Vzgvc3dkeXBpeXIzQWF0aEFrRUl5cDBZVWF5K09zaWZKV0VaTE1yUVloenpMYTdJRERmR1NtbmRGaE5WemlEalRqblZ1ZFBlMHlWNER2OVhiVzZZMjNiL3lleXp1YXlLdDVXM29LYTdXamRWVnA2RXp6Y09POXh6ZzNWNHVyeTdqdXZyNlVxVi9BUWZmRXlSL1g3dlUxZVIyZ1dabWNpeWpqVjl0WGNsYWYyenZuQVpEajJQWThxbk5ibXJFem1Kd3IydWFBZnYzaHdodWFBcktSejhCcnFjSk41aCtRMnZSUC9CWitJUzMyd1d6d2cyWVhtUGhrY3ZnSWtwZ3l2eHl2WlR1c0d2cHN5aEliaFZjWm5wV2gwOVdMeFVWcXpnM211OGJoVWtwaDd1QUYyMnNXNFV2VlpSUGo1QjVMaUdCcElrQ0JCVkpPQStSaytPamxaZllHYWxqLzdnU2RXQVlFVWJ4b2xpMEEwVkpGQTl1bHFEc3F5SktaQThoV3loZTdYMFJNOHI5YzVKeTBBQUI0Mm1OZ1pHQmdBT0twRjlmcXh2UGJmR1ZnWm1FQWdjY1J1cVlJK3I4dWN5VFRKU0NYZzRFSkpBb0FHUXdKaVFCNDJtTmdaR0JnWnZqUEFDUkxHSFFZK0prakdZQWlLSUFOQURaSUFoa0FBQUxHQUFBRGRBQktBam9BTEFMNEFEOENsd0F5QXF3QUxnQUFBQUFBWUFET0FUWUJyZ0lJQUFCNDJtTmdaR0JnWUdQd1ptQm1BQUZHQmpRQUFBaUtBRmQ0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPWUFBb0FBQUFBQkFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxQ3dTNTJOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENCeloyeDVaZ0FBQVd3QUFBRFJBQUFBNElnSTRQeG9aV0ZrQUFBQ1FBQUFBQzhBQUFBMktoeWRYV2hvWldFQUFBSndBQUFBSHdBQUFDUUYyQUVPYUcxMGVBQUFBcEFBQUFBSUFBQUFDQWIvQUg5c2IyTmhBQUFDbUFBQUFBWUFBQUFHQUhBQUFHMWhlSEFBQUFLZ0FBQUFGd0FBQUNBQUJBQktibUZ0WlFBQUFyZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURpQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1ybWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4UUVBREF5cElLUzVMWjJCVEFBSm1yVCtXREF6TVdzekhnY0tNQ0JYLy96TXdBQUFLZVE3Q0FBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytRb0svLzlEeVBzUHdmSU1BRktpQnB3QUFIamFOWXN4VHNNd0dFYjkvWTUvMXluRkZrMEpsSktvdGhVYVZTUUkyb1FCdFNzRFIyQkR2UUJpWXVFQTNLVG40VDVRa0ZqZTh0NFRFQi9mbnE3cFN6d0tnUklGSm16QitoZDkxYUs2V25WYmRHdUxZNFFHcTY2L0xXWFZVclhlSU85Tzg3OTRpdzN1Q21Tcy9XSEJUbzVNQWxaYVNuMlVreHdrR21xWXl2TjYzR1J6NSthVHMzb3hKYVdIaWlKekpDakhOUDIzV1RPdXNTLzZ4ZEsvdno2OTVBTUNUdHp1L3UwenRqZExPNUlwcHhTc0p6WW1tWlhod1Y5RVIrVGlaWGd1WjRsaFE5NEdPbFJDL0FDZmJCZGRBQUFBZU5wallHUmdZQURpOVY3WGo4ZnoyM3hsWUdaaEFJSEhFYnFtQ1BxL0Vrc28weFVnbDRPQkNTUUtBQ1plQ2RRQWVOcGpZR1JnWU5iNlk4bkF3QkxLVU05UXk2VExBQlJCQVV3QVM2c0M2d0FFVlFBQUFxb0Fmd0FBQUFBQWNBQUFlTnBqWUdSZ1lHQmk4R1FBMFF4UUVna0FBQWUrQUU4QWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE3LjQ4Mjk3NywtMjIuMDI2Nzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOS43NTU3NCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTcuNDgyOTc3LC0yMi4wMjY3OSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTcuNDgyOTc3JyB5PSctMjIuMDI2NzknPs6gPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xMC4wMTA5NzgnIHk9Jy0yMC41MzI0MDknPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTMuMTUzNjk3JyB5PSctMjIuMDI2NzknPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIuNSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE3LjQ4Mjk3NywtMjIuMDI2Nzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE3LjQ4Mjk3NycgeT0nLTIyLjAyNjc5Jz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTguMzU0MTZWLTQ4LjU1MTM1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC44MDEzNSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuMjYzODksLTMwLjQ1Mjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTcuNDgyOTc3LC0yMi4wMjY3OSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ5LjUzMjc2LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNy40ODI5NzcsLTIyLjAyNjc5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xNy40ODI5NzcnIHk9Jy0yMi4wMjY3OSc+QzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS42NDk4NjMnIHk9Jy0yNS42NDIxNTQnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDkuNDIwNjEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNy40ODI5NzcsLTIyLjAyNjc5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xNy40ODI5NzcnIHk9Jy0yMi4wMjY3OSc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctOS40MjYzNjknIHk9Jy0yNS42NDIxNTQnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTE0LjMxMTI4IDBINDQuNDc3MjInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDQuNzI3MjIsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyOS42NDQyNCwyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTcuNDgyOTc3LC0yMi4wMjY3OSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ2LjU4MzUxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDYuODMzNTEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOC40OTY2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE3LjQ4Mjk3NywtMjIuMDI2Nzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTE3LjQ4Mjk3NycgeT0nLTIyLjAyNjc5Jz5nPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xMy4zNDYwMjcnIHk9Jy0yNS4wMzMzMDcnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTcuMDU1NTQtNTYuOTA1NUg0NC4zNjUwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0NC42MTUwNywtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjEuNTc5ODgsLTY2LjU3Mjg1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTcuNDgyOTc3LC0yMi4wMjY3OSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTcuNDgyOTc3JyB5PSctMjIuMDI2NzknPs+APC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0xMi41NzM5MTEnIHk9Jy0yNS4zOTc0NjYnPuKAoDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMTIuODI0MTMyJyB5PSctMTkuODYzODY1Jz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01MC40MTU5MiwzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTcuNDgyOTc3LC0yMi4wMjY3OSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTcuNDgyOTc3JyB5PSctMjIuMDI2NzknPs6gPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xMC4wMTA5NzgnIHk9Jy0yMC41MzI0MDknPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTMuMTUzNjk3JyB5PSctMjIuMDI2NzknPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00MS4zMzY4NyAzMS44ODQxMkMtNDYuMDMwOC0zLjA2MDAzLTM0Ljk3MTA0LTI5Ljk1ODc0LTcuNDUxNC01MS4xOTA1NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjc5MTcyLC0wLjYxMDgxLDAuNjEwODEsMC43OTE3MiwtNy4yNTM0OCwtNTEuMzQzMjgpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00MS45NTI0OCwtMjIuNTA2NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE3LjQ4Mjk3NywtMjIuMDI2Nzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTE3LjQ4Mjk3NycgeT0nLTIyLjAyNjc5Jz4hPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzMuMCwyLjAnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNLTMxLjg4NDUyIDMxLjg4NDEyTC04LjU5Mjk2IDguNTk2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNSwtMC43MDcwMywwLjcwNzAzLDAuNzA3MTUsLTguNDE2MTcsOC40MTk4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00tMzEuNTcxOTYgMTQuMzA4MDFILTguNTUxOTRWMjYuMDk2OTJILTMxLjU3MTk2Wicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTI4LjU3MTk2LDE4LjMxMzU4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTcuNDgyOTc3LC0yMi4wMjY3OSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMTcuNDgyOTc3JyB5PSctMjIuMDI2NzknPs6gPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xMS42MDIyMTEnIHk9Jy0yMS4wMjQ5NzcnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTUuNzA1ODY2JyB5PSctMjIuMDI2NzknPs6xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTI1LjUwNTEzIDQyLjE3NTdDNi4yMTQwMiA0NS44NjM4MiAzMC4zMjEyNiAzNS40NDc0OCA0OS4wNzY1OCAxMC4yMjMyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNTk2NjUsLTAuODAyNDMsMC44MDI0MywwLjU5NjY1LDQ5LjIyNTc0LDEwLjAyMjYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE5Ljk0ODMzLDQxLjE2NDM0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTcuNDgyOTc3LC0yMi4wMjY3OSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTcuNDgyOTc3JyB5PSctMjIuMDI2NzknPs6xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xMi4zMDM2MzYnIHk9Jy0yNS4wMzMzMDcnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYuNDA3MjknIHk9Jy0yMi4wMjY3OSc+zrI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw = {\Pi _{B}g},
        nw/style = {pullback},
        ne = {C^{B}},
        sw = 1,
        se = {B^{B}},
        east = {g^{B}},
        south = {\pi _{1}^{\dag }}
      }
      \node  [above left = of nw] (pif) {$\Pi _{B}f$};
      \draw  [->,morphism,bend right] (pif) to node[swap] {$\mathsf {!}$} (sw);
      \draw  [->,morphism,exists] (pif) to node[desc] {$\Pi _{B}\alpha $} (nw);
      \draw  [->,morphism,bend left] (pif) to node {$\alpha ^{B}\beta $} (ne);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Note that</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       g^{B}\alpha ^{B}\beta  &= (g\alpha )^{B}\beta  && \text {functoriality of $(\mathord {\hspace {1pt}\text {--}\hspace {1pt}})^{B}$}\\                   &= f^{B}\beta \\                   &= \pi _{1}^{\dag }\mathsf {!}     \end {align*}   ]]></fr:tex>
  <fr:p>Let any morphism <fr:tex
display="inline"><![CDATA[\alpha \colon B^{*}(A')\to f]]></fr:tex> be given.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="46ff9a61cbcb1b3d9e4c6fdf32196ba6"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEyNi4zODY4MDlwdCcgaGVpZ2h0PSc4NS45NTIyNzlwdCcgdmlld0JveD0nLTcyIC03MiA4NC4yNTc4NzMgNTcuMzAxNTE5Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzBBQUFBMktKcWRsR2hvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRtTnZzcFRqK1cyK01qQ3pNSURBNHdoZGJ3VDluNUhwTWpPSXk4SEFCS0lBRi9FSk1BQUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU04QUFvQUFBQUFBNlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ2lPUnpHMk50WVhBQUFBRkFBQUFBS1FBQUFEUUFEQUVxWjJ4NVpnQUFBV3dBQUFCNEFBQUFlSk1TUEpGb1pXRmtBQUFCNUFBQUFDd0FBQUEyS09LZGkyaG9aV0VBQUFJUUFBQUFIZ0FBQUNRR05mL2RhRzEwZUFBQUFqQUFBQUFHQUFBQUJnT3dBQUJzYjJOaEFBQUNPQUFBQUFZQUFBQUdBRHdBQUcxaGVIQUFBQUpBQUFBQUZ3QUFBQ0FBQkFBa2JtRnRaUUFBQWxnQUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRExBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWxtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVUQXhKSUtTNUxCMHBlWjdqT0xQVkhrNEdCV1lyNU9sQ1lFYUhpLzM4R0JnRHJuUTd2QUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeENDK05mLy80ZVEvN1hBZkFZQVh1VUhNd0FBQUFBQkFKUUFDUUtHQWZnQUlnQUFBVGMyRnhZWEJnOENId0VXQndZSEppOEJCdzRCSXlZbkpqOEJKeVkzTmpjeUZ3R095dzRLRXdFQ0F4cTdwVElFQVFFVEN3WFV5d2tJQmhFREF4RE56UkFEQXhFR0JBRWR5aEVCQWhNS0F4cTdwVElJQXhNQ0FnVFV5d29GQWhNSERjN09EUWNUQWdJQUFIamFZMkJrWUdBQTRwVzhmTi9qK1cyK01qQ3pNSURBNHdoZGIyU2FXWWJ4QjVEaVlHQUM4UUR3bVFmc2VOcGpZR1JnWUpiNm93a2taUmltTUV4amFtTUFpcUFBUmdCTXlnTVhBQUFESEFBQUFKUUFBQUFBQUFBQVBBQUFlTnBqWUdSZ1lHQmlVR1lBMFF4UUVna0FBQVFJQUNrQWVOcE5qckZxd3pBUWhqOVR4MUFua0trZE9oUk5HWVdOOHdDRkRKbXlaaXdra1FnT1dBNlNZL0JTOGdCOTZGNFVEVDNCOGVtLzc0U0FraDh5SHBXeGpQMVJPWVhjbmp4anpsdmlRbzVLWFBMQmloZXkvRldTVDc0UzV5ejRUanpqblV2aVF2Sjc0cEkxdjV1K3U5NEc2OVd1TjlhN1V4ZW11dHBiSDlyZXFWcFh6MkJybmZXSHdScDFuSlFaMnpDZU85WG9TamRzNk9tNGNtUEE0dVZuTzBsTVpNZEpab0dKbW9wOXpBS3R6SjE0TlZyUy84WldEQmV0UTN6TmlIV1VtUklhWlM5SVA0dXZhT0t1cHZrRENWRXhFd0I0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUFBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUN3QUFBQTJLVmVkejJob1pXRUFBQUhZQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZnQUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0FBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSUlBQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaUFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0pkazIxYTQvbHR2akl3c3pDQXdPTUlYVzlrbW5raWt3MlE0bUJnQXZFQS9lQUgrWGphWTJCa1lHQlcvR01FSkNjeUdETElNcG93QUVWUUFCTUFRUm9DYmdBQUE1RUFBQUZSQURFQUFBQUFBQ0FBQUhqYVkyQmtZR0JnWXVCbkFORU1VQklKQUFBQ0ZBQVZBSGphVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9GUmlZMkZnWW1YcUF0aWdESEdRSFNKRnFqcnl1M3U0SG5yRDZYay83b0NTSHpLZWsvRWE5M055Q2xGL1hQRENXK0twcUVYaWtnK1dUTWp5bVRoek5vbHpTYjRTRjd4elNUd1YvenR4eVNlUGJkZmU3cjMxYXQ4WjY5MjVEZVA2WUgxb09xZFd1b3A2WjUzMXg5NGFkUnFWR1pvd1hGdFY2MHJYYk9sb3VYR254K0pSN01VeGtSMW55UUlqYXc3UkNUU1NPbW10MEZULzhwM2tMbmFPOFpPUnpra1NKVFRJVlpCOWxiYWlqcGVhK2hmemVUQlBBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDArMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNWWjJ4NVpnQUFBV1FBQUFGTEFBQUJZRG1Tc1RKb1pXRmtBQUFDc0FBQUFDOEFBQUEyS00yZWJXaG9aV0VBQUFMZ0FBQUFIZ0FBQUNRR0xBSU9hRzEwZUFBQUF3QUFBQUFNQUFBQURBaCtBRTlzYjJOaEFBQUREQUFBQUFnQUFBQUlBRlFBc0cxaGVIQUFBQU1VQUFBQUZnQUFBQ0FBQndBNmJtRnRaUUFBQXl3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaVp2Z1A1RE5EcEpIVS9BY0tBd0R5S1ExSGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoTy8vOERTY2YvLy84ZkFQTVpBRktvQnA1NDJqV1BNVS9DUUFDRjc5M0JIV0RiUTF2YUdBRlRRWnBvRkVOSkt3d01LbWcwRXBURU1KQ1ltQ2liZzBGY0dSaDFNakZ4Y25IekI3ZzRPZmtuSEl5anZ3R3dOZkZOTDEvZThEMUNTWDQ2cFYvMGt4UkppUkFmbmw4eUxkMHdYYy9rUlFpbjRKUTl5L1Q4SW16QkRkUHlMQTBCRDdGYmcrK3lWNXh6UStXb21Xc3BLTkgrTUJhRk9xT1hXVnhNcGswMXJhc01hclRYVWFERWwycVBQL2FBbmlRUmwrT2hLVmxHZ0RIUW1CU0FZbDNVUjBZK0NTbzFIdUtFNU1oOTRKZ0VZV1IxT21hY3ZwRXNXU0diZ2FsZXpqazhjTE96U0drUVdWaGNnZ3ViLy9ucW9aeFhjSElGTHRoL1o4SEFmYjViY0RKU290TTlZOFAyUVJ0ME4zbDRQYmxQYTFvMSsvUncycWRZM3g0dDZ0SEwyKzZBMG8yOTkwWUUwRnEwTWt0WldvQWVWZmQ3TXRHc0hHeHB0VWo0QURycTdLcVIzNkdROCtNWGR0TmNickhKOXh4UGtGK3p2VHVEQUhqYVkyQmtZR0FBNHRZcndodmorVzIrTWpDek1JREE0d2hkYndUOS95OHpHOU5kSUplRGdRa2tDZ0FlelFvYUFIamFZMkJrWUdCbStNOEFKRGtZVkJpWW1Oa1lnQ0lvZ0JrQUk4Y0JRZ0FBQW5ZQUFBTUFBQ1FEQ0FBckFBQUFBQUJVQUxCNDJtTmdaR0JnWUdhd0JHSVFZR1JBQXdBR2R3QkNBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVY0QUFvQUFBQUFCbEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hkeDRqbU50WVhBQUFBRThBQUFBTlFBQUFFUUFld1JlWjJ4NVpnQUFBWFFBQUFLZEFBQURES2hMTVRWb1pXRmtBQUFFRkFBQUFDOEFBQUEyS1NDZG5HaG9aV0VBQUFSRUFBQUFIZ0FBQUNRR2xnSkthRzEwZUFBQUJHUUFBQUFVQUFBQUZBN2NBUTVzYjJOaEFBQUVlQUFBQUF3QUFBQU1BWFlDUG0xaGVIQUFBQVNFQUFBQUdBQUFBQ0FBQ1FCQ2JtRnRaUUFBQkp3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRmJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbStzRTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFIwWk43SXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBbHVRNWRBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtuQmpTbURmKy93OWtPVUpZL3cvOG4vc25HS3dXREFEMWx3dldBQUFBZU5wRmtzOVBFMEVVeCtlOTJlNjJ1M1YzdTkxTzB3SmJ0bHQyVVNuRkx1eENoZkl6Q0JSRXdBVGJtR0NNZ2FBa21oZ05pUnBENGtFdnhoZ1BIcnh3TUNIZVREeHkwMzlBUFduOE0vUW1yYk1teHBsa011OTlEL1A5Zk9jUkpMVk9oMDdnZCtLVGdKQVFnckRLc21tVCtWV1dNYVVLU0lNd1VvZHNIVUxQMWtETVdPQm5XVllGcm9oZUhYd3UyUFFyN01zNU5ZNHRkamFwbTdXSko3SUllbUlnRDduMmozVlpSQ2V1aUFCYWJQZEtrb0lXSHpoL0NOTFFBMXhna0V5ZFBFdXJncElCQ2dMSU5DVUJwT0x2SGh0S3dsU1FKbmd0Q0tCckVqMXpES3VFVUxMVStVMmJlRXhzVWlaajNIRTZETndLT0tJYlpHMEx1RE9KbnlLM0t0bFJqd1hweUdQZ2VvNHJTdlRmbllyczQxTUJFbnBPTFlDaHdyMGJ0NEVlYksxZkJWd3hOaDYyNzNaajZ0Ull6OUhSN2lQQWtaVTNCVDEyNSszV0FZWDZ3cmNHSkM5aEw1TkVvRUpSQXR3WW45czI1TFhSeHJSYXA0TERDUXlZbzNzejlnVUJWSGJ5SHZkV0swdlkvaUpSUW9BME9oVzhpWi9KRkM5b1pKTTdMcnBSbEN6TFJJa1ZvQTZUOUM5UFpKYjNxMUhlanV1NVFjaEpWZFRBRDVqb3dXRk5GL1I4WXZwY2Z3MmdsSEY1dEFWTjAwbzI3Um5VbGkxTWEydGFSbVV6enVseEFJZHhYYmMwelRBc09aN2ZpbVI0MWY2MGxKb2FObWVwNjFpOVdCSTlKWUVnTkRLdmYyMVNqcmJaN1BMY3Z0Si9DWEp1K2JsUWpBUGhDOGxrNXlkK2dFOWtNS0xwc3lCa1FUZ2N6WWNwU3FMcnFkSDBlRUVZYmY0cEhDM2dQQVd3SU9MMlhJK3JiaFJBMXVUc0FRNEpUSkZMU1lOUGoxL08xYzJCL1lYV05SVG1VK2JhenNYZEpBTE9kc2NrbWN2NVJPR2xBRUpzYUtKcnBjL2pEL3VGK3k5YS9RSVkzUXFnYlBpSVR1RDRnRHVMMTFkTmZZNUNhMW14cTVlM2RSa1FNL09weFZ2TmlsTnRVbkRLb3dkZHd4T0F4VDk1b0hRSEFBQUFlTnBqWUdSZ1lBRGloOW1kYytQNWJiNHlNTE13Z01EakNGMXZCUDFmbnptUzZSYVF5OEhBQkJJRkFDWFFDZkVBZU5wallHUmdZR2I0endBa1N4aXMvbDlnam1RQWlxQUFWZ0JkU0FQbUFBQUN4Z0FBQTNBQU9nTjBBRW9DT2dCTEF2Z0FQd0FBQUFBQVdBQzRBUjRCaG5qYVkyQmtZR0JnWlhCa1lHWUFBVVlHTkFBQUIzVUFUSGphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9DQ3hkV0ZnWW1YcUF0aEZHV3dqSjBSQ3FqcjJkL2RoUFBRTlYrZCsyRURORHdYM0s1Z2x2VjlKSmU3QkZWUG1tU2ZpM2pMWExIam5pYUo4bHVTVmo4eWxOSitaSzE3NHlqeVIvRHR6ellyZlRYQ1g2MkNqMmdWam96ODUxNjMzTnZaZDhHcXBtK1MzMXR0NEdLeFJ4NXN5WTllUFo2ZGEzZWlXRFFISGhTc0Rsb2hpSjRsSjdEbEo1K2hZczA5Skx4d2tWeXpSTlAvNnJmUStiUTdwSnlPYkl6ZFJ3eWlMWHZRc1cwV2JYbXJhUDh1aEwvY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPc0FBb0FBQUFBQkJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUUwQUFBQmdxbU5pZTJOdFlYQUFBQUZFQUFBQU13QUFBRHllV21SYloyeDVaZ0FBQVhnQUFBRGdBQUFBN0QwTlFsdG9aV0ZrQUFBQ1dBQUFBQ3NBQUFBMktodWR6MmhvWldFQUFBS0VBQUFBSHdBQUFDUUY3Z0RhYUcxMGVBQUFBcVFBQUFBTUFBQUFEQWtLQU8xc2IyTmhBQUFDc0FBQUFBZ0FBQUFJQUZRQWRtMWhlSEFBQUFLNEFBQUFGd0FBQUNBQUJRQTJibUZ0WlFBQUF0QUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1abWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUE0TURqSjFTWEpiT3dLWWsvc0NBV2V1UEpRTURzeGJ6Y2FBd0kwTDEvLzhNREFEb3R3N2ZBQUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFabVJnVWhKL1lQRC9Qd01EaEw3N1N2NFNXQlVRQUFDbmlRbXlBSGphTFk1UFNzUXdIRWJ6cGNNdlZOUGFQMm5Tb2s3SERLYTdrU2wxQ2lMMUVvb2JzWWpRdld0dm9PQVJSbkRuR2J5R3l6bUxtTVdzSHQvN05vK0JmYkFsZjhhT2RZeWgzN1JhMFJHMDBTYUd1MEFORWl0ME54RFVXT2ZwR3RjTWFHczA3ckxiOU5vSXZIM0tTcVgwZlgrWGM2Z3EvSXFJMnpRbitYNU9VVkY2cnppS010cEt5bFBMRDNFOGhzckdmRGc5RTJXbVFFL1QxVHhBWnRiVGJRRmxrLzBSanRQNklNckE2MGVmeGtiVzRKVmZzOFNQZ0phK284OEg5SzAySlBEeVMxTG53V3diVlBQS0FUUHMvaDVTSWFJRVAvRUNpeE1wMlQ5dWZCL1FlTnBqWUdSZ1lBQmhuZGVXOGZ3Mlh4bVlXUmhBNEhHRXJqY3l6UkxLWkFPa09CaVlRRHdBMktzSEFBQjQybU5nWkdCZzF2cGp5Y0RBRXNvUXorREJsTXdBRkVFQnpBQklkUUxOQUFSVkFBQUM4Z0NPQWNNQVh3QUFBQUFBVkFCMmVOcGpZR1JnWUdCbU1HVUEwUXhRRWdrQUFBWGxBRHdBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01Mi40NjA0ODQsLTYzLjM1NDg3MilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNS4zMDcyNSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNDYwNDg0LC02My4zNTQ4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUyLjQ2MDQ4NCcgeT0nLTYzLjM1NDg3Mic+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNDIuMTkwMDEnIHk9Jy02My4zNTQ4NzInPsOXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zMi4yMjczOTcnIHk9Jy02My4zNTQ4NzInPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTI0Ljc1NTM5OCcgeT0nLTY2Ljk3MDIzNic+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUzLjE1NTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUyLjQ2MDQ4NCwtNjMuMzU0ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01Mi40NjA0ODQnIHk9Jy02My4zNTQ4NzInPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjguNDUyNzQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUyLjQ2MDQ4NCwtNjMuMzU0ODcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjQuNDA5MzUsLTQ1LjE3OTEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNDYwNDg0LC02My4zNTQ4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUyLjQ2MDQ4NCcgeT0nLTYzLjM1NDg3Mic+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNC44Mjg3Mi03LjI0MzA0TDIyLjY4MjEzLTM0LjAyMDEnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC41NTQ3MiwtMC44MzE5NywwLjgzMTk3LDAuNTU0NzIsMjIuODIwODIsLTM0LjIyODA5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTQuOTAyMTksLTI5LjQ0NjkzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNDYwNDg0LC02My4zNTQ4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUyLjQ2MDQ4NCcgeT0nLTYzLjM1NDg3Mic+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDYuMTAxMzIyJyB5PSctNjYuMzYxMzknPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDEuOTM2MzUzJyB5PSctNjMuMzU0ODcyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0zOC44MjMwMScgeT0nLTYzLjM1NDg3Mic+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMzIuODMxNTQ5JyB5PSctNjYuMzYxMzknPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzAuMTM2Nzc0JyB5PSctNjMuMzU0ODcyJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xOS44NjI4IDBINDguMDk5OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMzQ5OTYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzMS42MzE5OSwyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNDYwNDg0LC02My4zNTQ4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUyLjQ2MDQ4NCcgeT0nLTYzLjM1NDg3Mic+zrE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTUyLjYzMjMyLTYuNDA5NzNMMzQuMjIzMzYtMzQuMDIwMScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC41NTQ3MiwtMC44MzE5NywwLjgzMTk3LC0wLjU1NDcyLDM0LjA4NDY3LC0zNC4yMjgwOSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNTUzMDUsLTI4LjA5NTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNDYwNDg0LC02My4zNTQ4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUyLjQ2MDQ4NCcgeT0nLTYzLjM1NDg3Mic+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$B \times  A'$};
      \node  [right = of 1] (2) {$A$};
      \node  [between = 1 and 2] (ref) {};
      \node  [below = 1.5cm of ref] (3) {$B$};
      \draw  [->,morphism] (1) to node[swap] {$B^{*}(A')$} (3);
      \draw  [->,morphism] (1) to node {$\alpha $} (2);
      \draw  [->,morphism] (2) to node {$f$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Then this morphism corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[A' \to  \Pi _{B}f]]></fr:tex> as follows:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="685275cf6ed15cd0e2f68b59fa35d7dc"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE4NC41MzE2NjZwdCcgaGVpZ2h0PScxODAuMTczNzUzcHQnIHZpZXdCb3g9Jy03MiAtNzIgMTIzLjAyMTExMSAxMjAuMTE1ODM2Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLVmVkcldob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0pkazIxT3h2UGJmR1ZnWm1FQWdjY1J1bGJJTlBORUpoc2d4Y0hBQk9JQkFBWk5DQnNBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1JQUFvQUFBQUFBM1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hUeDBGV050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUIwWjJ4NVpnQUFBV1FBQUFCVUFBQUFWSjVQNzUxb1pXRmtBQUFCdUFBQUFDd0FBQUEyS0ptZVRHaG9aV0VBQUFIa0FBQUFJQUFBQUNRRVRBSkJhRzEwZUFBQUFnUUFBQUFJQUFBQUNBUWVBR3BzYjJOaEFBQUNEQUFBQUFZQUFBQUdBQ29BQUcxaGVIQUFBQUlVQUFBQUZnQUFBQ0FBQlFBWGJtRnRaUUFBQWl3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBQytBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTRtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9xTWlneU0vd0g4cGtoMGtocS9nT0ZBYUw3REVFQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpSy8vOUR5UDhQd0h3R0FFLzNCbjBBQUFBQUFnQnFBQUFBNEFMYkFBc0FGUUFBRXdNT0FTSW1Kd00rQVRJV0V3NENMZ0UyTng0QjRDZ0JDQk1KQVNnQ0lpMGtBUUVoTVNFQ0lCd1lJUUtqL2pzUENRa1FBY1FhSGgzOWZSa2hBU0F6SWdFQklRQjQybU5nWkdCZ0FHTEY1MW5sOGZ3Mlh4bVlXUmhBNEhHRXJoVXl6WFNaNlRhUTRtQmdBdkVBL2NjSWtuamFZMkJrWUdCbStNL0F3TUIwbVNHTEladmhBUU5RQkFVd0FRQldXQU9SQXRNQUFBRkxBR29BQUFBQUFDb0FBSGphWTJCa1lHQmdZaEFEWWhCZ1pFQURBQUxhQUIwQUFIamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU2grNHVEazR1VHE4elpvZ0hacEtXb3N1NGsvM05nUnY0UERkYzg0TmtQRWlZWmlFZWRCaFVubnp5R04rV0VTZWlMK0tuUEhMbWhGSk9oTm54UzV5eXBUL3lHT1dsSkVuNGo4aVovengzamYxN2Q1WnI0Nk5zZDVkYXI4OVdkOVdqVk1iblEvcndUcnJ6NTAxcW53cTAxZHRmNjFWb1hOZHNLZWg1c2FkRG90SGNSVEhCSFpjSlBOc09ZVzlwWkxNU1dlREp2K21CMGxkYUp6REwwWWFKVTlSUXk4M3JlaFZ1b29pM0dtS0QxaXNMa3NBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTVlBQW9BQUFBQUE0UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MUcyTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUJrQUFBQVpERnVBckpvWldGa0FBQUJ5QUFBQUN3QUFBQTJLUmllSEdob1pXRUFBQUgwQUFBQUhnQUFBQ1FGeXdMV2FHMTBlQUFBQWhRQUFBQUlBQUFBQ0FZS0FKSnNiMk5oQUFBQ0hBQUFBQVlBQUFBR0FESUFBRzFoZUhBQUFBSWtBQUFBRndBQUFDQUFCQUFnYm1GdFpRQUFBandBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEQ0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd5TS93SDhwa2gwa2hxL2dPRkFhTjNERmdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy85RHlQOFh3SHdHQUZGSEJvMEFBQUFBQVFDU0FBQUNOd0tyQUI0QUFBRVJCaFk3QVJVbUp5TUdCelV6TWpZbkVRNEJKeU0xTXhZL0FUWTNOaFlCbUFRaVRqTXNPdEU2TEROT0lRTXVWQk1TRWhJK0J6ODVHQTRDaS8zTkZ4UXRBd0VCQXkwVUZ3SUFFZ3dCTFFJS0Fnb3VBUWtBZU5wallHUmdZQURpNzJzZGF1UDViYjR5TUxNd2dNRGpDRjByWkpvNWlHazFrT0pnWUFMeEFBdFRDRnA0Mm1OZ1pHQmdadmpQQUNTREdDWXhOREtaTXdCRlVBQVRBRUxjQXFnQUFBTlNBQUFDdUFDU0FBQUFBQUF5QUFCNDJtTmdaR0JnWUdLUVp3RFJERkFTQ1FBQUE2UUFKUUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOd0FBb0FBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY3g0QldOdFlYQUFBQUU4QUFBQU1RQUFBRHdISVAwZloyeDVaZ0FBQVhBQUFBQ3NBQUFBMEY2V2svMW9aV0ZrQUFBQ0hBQUFBQ3dBQUFBMktLT2VLV2hvWldFQUFBSklBQUFBSFFBQUFDUUdBUUluYUcxMGVBQUFBbWdBQUFBTUFBQUFEQWVBQUgxc2IyTmhBQUFDZEFBQUFBZ0FBQUFJQUNvQWFHMWhlSEFBQUFKOEFBQUFGd0FBQUNBQUJRQXJibUZ0WlFBQUFwUUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURaQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1hbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBvYU1pOWdadmdQNURNek1JS0VHUkVxL2dPRkFmWTFEY1FBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeWhveUwvai9IOGdIMC84di9Fa0Nxd0lDQUprNUNUMEFBQUI0Mm1OZ1pJaG1ZR0JjeTdTYVFRSklDN0tKV1RPS3FpdXpteG9ibWFrTDhqR3FtNHFabVp1Sk1lb3lLemdwQnE0S1ZIU1daOWIwRVpUSk1SWmtaK3IvZTBoR1ZJR1pXVUZVaGtsSW1JTlJua2xVbjVFTGFBeURFZ01EMDEybUhReWFtR1lxb3ZITjFMUVpUUlZGbFpYWW1FcVlwQ3dsdkdkNlNWcElNLzA3eXlSdElRbmtTRmhLTVlIRW1YYURXQmwvWDhpSWdLd1VrV0h5L0xzZHpwYVFFWldYRjJWZ0FBQzdSeUZzZU5wallHUmdZQURpR0lWWGt2SDhObDhabUZrWVFPQnhoSzRWTXMxMGwya0hrT0pnWUFMeEFPcWRDQTk0Mm1OZ1pHQmdadmpQQUNJWmxCaVVtZTR5QUVWUUFETUFOV2NDTHdBQUFBS0FBQUFDQUFCYkF3QUFJZ0FBQUFBQUtnQm9lTnBqWUdSZ1lHQm0wR0lBMFF4UUVna0FBQVRTQURFQWVOcEZqREZ2d2pBUWhiK0lCSWwwNkZKMVlBQVB6RmFpTUhkaFlHSmxZZ0Zzb2d4eGtCTWlJYUdPL2QwOWpDVnVlUHJ1dlhjSDVQeVM4SnlFejZEUFNjbGtlM0hHQjErUnA3SXRJK2ZNV1RFaFNXZmlMUGlKbkVweWlKenh6U1h5VlB4SDVKdzFmNXV1dmQ0RzY5V3VNOWE3Yyt2TFltOTkzM1JPbGJvSSs5WTY2NCtETmVwMFYyWnMrckZ1VmFVTFhiR2hvK1hLalFHTFI3RVR4d1IybkNYemxCVHNnOVBUU09xa1ZhTEZmZWRieVYzb0hNTW5JNTBUZDFIREtGZTlhQzF0UlJVdU5kVS9ZejB2RHdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVpJQUFvQUFBQUFCMVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hkMTRiR050WVhBQUFBRThBQUFBUGdBQUFFd0Vjd1E0WjJ4NVpnQUFBWHdBQUFOZ0FBQUVBT0ZMWGRwb1pXRmtBQUFFM0FBQUFDOEFBQUEyS1NDZGNtaG9aV0VBQUFVTUFBQUFIZ0FBQUNRR2lnSkxhRzEwZUFBQUJTd0FBQUFZQUFBQUdCQ3ZBVFJzYjJOaEFBQUZSQUFBQUE0QUFBQU9BNDRDYkcxaGVIQUFBQVZVQUFBQUdBQUFBQ0FBQ2dCTWJtRnRaUUFBQld3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBR1BBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbU9zNDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFIwWWo3QXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBVnZnNDhBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdzZ0RRWEF3ZFFqb25CaVNHTmVSUHpnZi8vZ1dJZzlrWVErLy8rLzNQK0JQMXhCZXVBQWdCeTZnNm9BQUI0MmtXVHoyL2JaQmpIMytkNUhidDJYTnR4WXJ0cEVxZUpFN3RsYXhMaXhtbTZObW5YckhSSnU2NFVxYVJDNnBoZzA5Z2tFTC9FQWRDS2hOUVRJT0RBWVFkMm1MUXJFaWZFalY0NHNodC9SUy9iRFJJZUZ5SDhTcS84dnQ5WGVwL1A4LzIrakxQQjVDOCt3bDlaaVMyeURtUHRkRHZ5NitDSmZ1U1VYSEEwa0dnV2RSQ2xVcnhuUittd0MzUW04SHhSNHYvOWM5SCs3VlFBMmNocVJUQTErT2l0ZDRHZkhMLzZCdUN1ZWZEcCtJTThwcVk3aGFkUDczMEcyTnA5VkRRUzd6MDVQdUhRM2Y1ekNPcE5uTE1sRWJoUWxnQVBWdnQzVEdWL2ViaWhkYm5nU1FBbTlQbURxNlZYQk5Ec3YzL0NCM3YxQVk2ZlNad3hZTU5KSGQvQlA5ZzZMWGhjSmxWYzlvTXVoTFpqaTVKZGhDNzArQVZQWEN6dE4yMmk4dnpBajlwRXFxRU9ZV1NMQVR4ZU1RUmpWdDU0ZVg0Rm9HTDVIUFNpcnV1VkVpL1U5QjBYMC9xK2JtbjJWVzloRmNDelNUZGNYVGROVjVtYVBZNWwrSDU4TmtpdEwyVTJ1ZSs1YzFnUmc2U01JQXl0SDE0Y2NrSTdIT1VDdjFyNVg0S3N2L2lWVUo0Q1JoK3kzdVE1L2d4bnJCYlRWRjFvMjFGN0tYUnNKeU5Lb2g4UVdRMkNxQjBQTW9YUUl1SXBnZ3N4ZCtBSHBQcHhBNXdNc1VmWUVPeWtVbEZOUllSd01kdk5YUDVrKytnV0NsdXB6UDdkRy9kVUJOek1KeVNGNUZtNStLMEFRcUt4bHR1dEJuUnhXUHo0bTZONUFjeDhFbEF4UTBRdjhrTEF1OWR2NzJXTVBvZWpuV1NwK2RvZFF3RkVheXQxL2Y2bzdqVkhITHpGNVpQYzBocGdtWEhXbkN6aktUNWplUmF3QWZsekVTYUxXR2hRclp5WTB2L2lORzNKanlHSXFkbURHdVh2NGhBWExSZGkyNWI4UUNRUFcxMXd5TDR1NENrZnpBY0x3ZzNEZlAzdDd0QzRKaFRnY2FxZGRqYU90bTc5bnMwNWhpenFPVnQ1Qk11MW14MWRhNmFvNXNIcW13OXhacVlXemwvR1R2NmxoZW5HSmV6M0RwM2NRZTMrcHFGMkFGclY4Ym1NS242NXRaTzFOb1hodVFpQWdrRFRXYjBockJ2bWRuOThyaGxyZmY3MSsrVVZRd1BWekUzRFZLSndtOFZackUxZTRIZndDNHRvSWNVWmEvVW9mZTM0cFloMWlFTkpmam1seUhaSURUeDZWYkdOY1dLcEV4Y3lkSHNwMTYzd3pFeC90bWZ1TFNRMGNnY3YyYVdXQzEvb2VYb2hUdmFoZ2dpV0lRTVV6R2xMVFZLS1ZQancrVFhxZ1I0MGZqeEVKMVFCUVphdlpPWXNBTm5TWlJQYnhYcHZWRkNWVEJZZ1haMjcwdnU4VGlYL0F6Q0lsL1Y0Mm1OZ1pHQmdBT0w0blJyNThmdzJYeG1ZV1JoQTRIR0VyaFdDL3EvUEhNbDBDY2psWUdBQ2lRSUFBRjRKQkFCNDJtTmdaR0JnWnZqUEFDUkxHUFQrWDJDT1pBQ0tvQUEyQUZ3MUE5c0FBQUxHQUFBRGRBQktBam9BU3dMNEFEOENsd0F5QXF3QUxnQUFBQUFBWUFER0FTNEJwZ0lBQUFCNDJtTmdaR0JnWUdQd1ptQm1BQUZHQmpRQUFBaUtBRmQ0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPWUFBb0FBQUFBQkFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxQ3dTNTJOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENCeloyeDVaZ0FBQVd3QUFBRFJBQUFBNElnSTRQeG9aV0ZrQUFBQ1FBQUFBQzhBQUFBMktoeWRaMmhvWldFQUFBSndBQUFBSHdBQUFDUUYyQUVPYUcxMGVBQUFBcEFBQUFBSUFBQUFDQWIvQUg5c2IyTmhBQUFDbUFBQUFBWUFBQUFHQUhBQUFHMWhlSEFBQUFLZ0FBQUFGd0FBQUNBQUJBQktibUZ0WlFBQUFyZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURpQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1ybWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4UUVBREF5cElLUzVMWjJCVEFBSm1yVCtXREF6TVdzekhnY0tNQ0JYLy96TXdBQUFLZVE3Q0FBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytRb0svLzlEeVBzUHdmSU1BRktpQnB3QUFIamFOWXN4VHNNd0dFYjkvWTUvMXluRkZrMEpsSktvdGhVYVZTUUkyb1FCdFNzRFIyQkR2UUJpWXVFQTNLVG40VDVRa0ZqZTh0NFRFQi9mbnE3cFN6d0tnUklGSm16QitoZDkxYUs2V25WYmRHdUxZNFFHcTY2L0xXWFZVclhlSU85Tzg3OTRpdzN1Q21Tcy9XSEJUbzVNQWxaYVNuMlVreHdrR21xWXl2TjYzR1J6NSthVHMzb3hKYVdIaWlKekpDakhOUDIzV1RPdXNTLzZ4ZEsvdno2OTVBTUNUdHp1L3UwenRqZExPNUlwcHhTc0p6WW1tWlhod1Y5RVIrVGlaWGd1WjRsaFE5NEdPbFJDL0FDZmJCZGRBQUFBZU5wallHUmdZQURpOVY3WE44ZnoyM3hsWUdaaEFJSEhFYnBXQ1BxL0Vrc28weFVnbDRPQkNTUUtBQ1BvQ2NvQWVOcGpZR1JnWU5iNlk4bkF3QkxLVU05UXk2VExBQlJCQVV3QVM2c0M2d0FFVlFBQUFxb0Fmd0FBQUFBQWNBQUFlTnBqWUdSZ1lHQmk4R1FBMFF4UUVna0FBQWUrQUU4QWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPRUFBb0FBQUFBQS9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVjExNUdOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBREZBQUFBekhVWExjMW9aV0ZrQUFBQ0xBQUFBQzhBQUFBMktaK2VMR2hvWldFQUFBSmNBQUFBSHdBQUFDUUhWZ04zYUcxMGVBQUFBbndBQUFBSUFBQUFDQWQ2QUh4c2IyTmhBQUFDaEFBQUFBWUFBQUFHQUdZQUFHMWhlSEFBQUFLTUFBQUFHQUFBQUNBQUJnQkJibUZ0WlFBQUFxUUFBQUROQUFBQk9QTmJLcDl3YjNOMEFBQURkQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm0zc3M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFluQmladmdQNURORHBKSFUvQWNLQXdEcVN3MHllTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzlEeVAvN3dYd0dBRktzQnA0QUFBQjQybU5nWnFqNS81LzVCdE1lQmcwR0V3WjdCZ1p6WVhOVE5YMUdOalZURXpOeFJUbEdjVFoyRUpSalpJY3dGQ0V5Um1iQ3huYU01aVpxNnNwcWJPek1NRFl6Kzc4MlprRVJHV0ZoRVFIR3hka3RUQ3pPdkFLZW5oa0pqTXhCUFB6UnpmK2MrVVRFUk0xbE54eks3V1B5OU5rdEw4aVNjelJsSW91ZjN5ODM1bEFtU1I1ZUZrWkdSalplRVU1R3htQkhOMTB1VGcxTy9qQkRienN1VGl0bVJqWWVVVTVHQVVaNzVpUkhMVHNtUmg2eHY0ZVlFbjJNUEpuK3ZSUm1ZQUFBbXVRbWF3QUFBSGphWTJCa1lHQUE0Z2psVGZIeC9EWmZHWmhaR0VEZ2NZU3VGWUwrLzUvNUJ0TWVJSmVEZ1Fra0NnQUxkd29hQUhqYVkyQmtZR0JtK00vQXdNQ2l4bERENE1kOGd3RW9nZ0tZQUVTSUF0WUFBMVFBQUFRbUFId0FBQUFBQUdZQUFIamFZMkJrWUdCZ1luQmdZR1lBQVVZR05BQUFCd3NBU0hqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvTURhaFlHSmxha0xZQmRsc0kyY0VBbXA2dGpmM1lmeDBEZGNuZnRoQXpVL0ZOeXZZSmIwZmlXVnVBZFhUSmxubm9oN3kxeXo0SjBuaXZKWmtsYytNcGZTZkdhdWVPRXI4MFR5Nzh3MUszNDN3VjJ1ZzQxcUY0eU4vdVJjdDk3YjJIZkJxNlZ1a3Q5YWIrTmhzRVlkYjhxTVhUK2VuV3AxbzFzMkJCd1hyZ3hZSW9xZEpDYXg1eVNkbzJQTlBpVzljSkJjc1VUVC9PdTMwdnUwT2FTZmpHeU8zRVFOb3l4NjBiTnNGVzE2cVduL0FNZ1JMKzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTOEFBb0FBQUFBQld3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwNTJOdFlYQUFBQUU0QUFBQU1nQUFBRHdBblFCN1oyeDVaZ0FBQVd3QUFBSHFBQUFDTExsR1dXaG9aV0ZrQUFBRFdBQUFBQzhBQUFBMktNMmRmR2hvWldFQUFBT0lBQUFBSGdBQUFDUUdMUUhOYUcxMGVBQUFBNmdBQUFBUUFBQUFFQXB6QUlWc2IyTmhBQUFEdUFBQUFBb0FBQUFLQVdvQXNHMWhlSEFBQUFQRUFBQUFHQUFBQUNBQUNBQkNibUZ0WlFBQUE5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVzQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1tc000Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpFaGpadmdQNURORHBKSFUvQWNLQXdEaDVRMHplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPakdrL2Y4UDVEdUM2UDhIL3M4RnF3SUNBSlJmQ1JJQUFIamFOZEV4YjlOQUZBZncrOS9GNXlUWVBoUEhkcXZFU1J5bk5pb2lLWFd3MndvTWFtaEFyUklWS2xDSFNraEkwQTBoMUJiWU1uU0VDWUVFQ3dzYkg0QUJKaVkrQUNzRFl1UXpKT0ZjaVp2dS91OE52M2VQVU5LWnorbHYrb3YweUNvaEtaSjAxWEd0cWhNbkR1OUJqY0tvbjdoT2t2YmdxN3pxdUlsclFPWjVIR2RJWS9ZRmozaFY1OGljU3pZMDVXaFNWS0Nmcy9xc3BNN21ZNzF1NlF5NmNyaXZRU3Uxcy9kLy9STjYzMFJKVENlT1lKNEt4a0NMUWdVMDkvSFdhYlZqZ2dxRDUzRlpjQVEvY0pmSXc4akYrWlJ4K28wMHlESlprMUtySDBSYzJ2d0diQU5xQXk0WDRLclB6N3hXamt2Q0tBaTV5djdmbVd5SVA3MnVSWjRRMkQ5NHlDWjdPM3VndDh6UjhleE4zVEEyR2gvZlBUaWk2QTVPbTVieTVOWEJDYVVydDc4UEM0Q3hTOWZQVTFaWFFlOXNiQitLOG5oOVo5UElDdmtFc0xERm5nMDdOeW5FNHZRemV6NWUybVd6UHhWZUpnUWttWGZwRmZxVDNKQ1BIS0JLYkR1TU1zVHlveDB1NGFua1dVSHVqcThqZ3l0ekE0SHNDWk8wQzVXclhOQjhIUkZlWklZaVhPUHFjaXNCQWx2WW9HNWdlb1VvMUVZRHp4VERoZkxpdU9ZbkZHMWJPTUJDU3pRTHZsQ0ttbjJ2QmxQZ3crenJ3THAydWJsSk80SFhxbFQwc0NCWHg1Nk84Slo1SEM4dmJLL1FvSE5XV1ZMeVNsTVAxNDd6c1FuNUJ4a25WSUlBQUhqYVkyQmtZR0FBNG5xRGZmdmorVzIrTWpDek1JREE0d2hkS3dUOVg0K1pqZWt1a012QndBUVNCUUFSZEFrNEFIamFZMkJrWUdCbStNOEFKRGtZVlA0ZllHWmpBSXFnQUJZQVNVZ0RBQUFBQW5ZQUFBTUFBQ1FEQ0FBckFmVUFOZ0FBQUFBQVZBQ3dBUllBQUhqYVkyQmtZR0JnWVhCa1lHWUFBVVlHTkFBQUIxb0FTM2phVFk2eGFzTXdFSVkvVThkUXA5Q3BIVG9VVFJtRmpmc0FnUXlac21Zc0pKRUlEa2dLc21QSUV2b0FmZWhlRkEwOXdmSGRkNytFZ0pvYkJmY3FlRTM5WGlXVlRBK2VNZWN0Y3lWSFphNzVZTUVUUmZrczVwTmw1cElYdmpQUGVPZVV1UkwvazdubWk5OVZjT2ZMYUtQYUJHT2pQempYdDgzV3hxRVBYclc2ZVlpMTlUYnVSbXZVL3FyTTFBL1QwYWxPTjdwalJjQng1c0tJSmNyUE5tSk1ZczlCZG82ZWxvWnRjb05NUVRaS25CYjdQN0dXaEUrcFhYck5TR3JQVmJwaGtzd2cvU2hwUlpmdWFyby8zL1F3dXdBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNyB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjIuNDg5MDQ2LC0yMi45MjM0NTIpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTAuMTc3NjMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjQ4OTA0NiwtMjIuOTIzNDUyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0yMi40ODkwNDYnIHk9Jy0yMi45MjM0NTInPs6gPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xNS4wMTcwNDcnIHk9Jy0yMS40MjkwNzEnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTguMTU5NzY2JyB5PSctMjIuOTIzNDUyJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yLjUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi40ODkwNDYsLTIyLjkyMzQ1MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMjIuNDg5MDQ2JyB5PSctMjIuOTIzNDUyJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTguMzU0MTdWLTQ4LjU1MTM1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC44MDEzNSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuMjYzODksLTMwLjQ1Mjc2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuNDg5MDQ2LC0yMi45MjM0NTIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OS43MTQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjQ4OTA0NiwtMjIuOTIzNDUyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMi40ODkwNDYnIHk9Jy0yMi45MjM0NTInPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTE1LjAxNzA0NycgeT0nLTI2LjUzODgxNic+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OS40MjA2MSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjQ4OTA0NiwtMjIuOTIzNDUyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMi40ODkwNDYnIHk9Jy0yMi45MjM0NTInPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTE0LjQzMjQzNycgeT0nLTI2LjUzODgxNic+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTQuNzMzMTcgMEg0NC42NTg0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0NC45MDg0NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI3LjQ5ODc1LDQuMTcyOTEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi40ODkwNDYsLTIyLjkyMzQ1MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjIuNDg5MDQ2JyB5PSctMjIuOTIzNDUyJz7OsjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS02LjQwOTczVi00Ni41ODM1MScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ2LjgzMzUxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMjguNDk2NjEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi40ODkwNDYsLTIyLjkyMzQ1MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjIuNDg5MDQ2JyB5PSctMjIuOTIzNDUyJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xNy44MjI0NjEnIHk9Jy0yNS45Mjk5NjknPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTcuMDU1NTQtNTYuOTA1NUg0NC4zNjUwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0NC42MTUwNywtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjEuNTc5ODgsLTY2LjU3Mjg1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuNDg5MDQ2LC0yMi45MjM0NTIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIyLjQ4OTA0NicgeT0nLTIyLjkyMzQ1Mic+z4A8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE3LjU3OTk4JyB5PSctMjYuMjk0MTI4Jz7igKA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTE3LjgzMDIwMScgeT0nLTIwLjc2MDUyNyc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDUuMzkxMDgsMzcuNzM4MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjQ4OTA0NiwtMjIuOTIzNDUyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMi40ODkwNDYnIHk9Jy0yMi45MjM0NTInPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTE1LjAxNzA0NycgeT0nLTI2LjUzODgxNic+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDEuMDgxMTggMzMuODI4NTdDLTQ2LjI0MjY4LTEuNzI3MS0zNS4yNjY4NS0yOS4yNDgwOC03LjQ0ODEyLTUxLjE4NjM5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzg1MTcsLTAuNjE5MTksMC42MTkxOSwwLjc4NTE3LC03LjI1MTgzLC01MS4zNDExNyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQyLjExMDkzLC0yMS40OTcwMSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjQ4OTA0NiwtMjIuOTIzNDUyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yMi40ODkwNDYnIHk9Jy0yMi45MjM0NTInPiE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00tMzMuODI5MjUgMzMuODI4NTdMLTguNzA0MDQgOC43MDc2OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE1LC0wLjcwNzAzLDAuNzA3MDMsMC43MDcxNSwtOC41MjcyNSw4LjUzMDkzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tMzAuNTI5OTcgNDEuNTE0OTRDMi43NTg1IDQ2LjQwOTkzIDI4LjQ5MTQxIDM2LjIwMzEgNDkuMDY0NTkgMTAuMjE0JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNjIwNjQsLTAuNzg0MDMsMC43ODQwMywwLjYyMDY0LDQ5LjIxOTc2LDEwLjAxOCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTcuMzM4Miw0MC4yMDg3OSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjQ4OTA0NiwtMjIuOTIzNDUyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi40ODkwNDYnIHk9Jy0yMi45MjM0NTInPs6xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0xNy4zMDk3MDQnIHk9Jy0yNS45Mjk5NjknPuKAoDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw = {\Pi _{B}f},
        nw/style = {pullback},
        ne = {A^{B}},
        sw = 1,
        se = {B^{B}},
        east = {f^{B}},
        south = {\pi _{1}^{\dag }},
        north = \beta ,
      }
      \node  [above left = of nw] (pif) {$A'$};
      \draw  [->,morphism,bend right] (pif) to node[swap] {$\mathsf {!}$} (sw);
      \draw  [->,morphism,exists] (pif) to (nw);
      \draw  [->,morphism,bend left] (pif) to node {$\alpha ^{\dag }$} (ne);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>The unit and counit of the adjunction can be extracted from the square above.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1998</fr:anchor><fr:addr
type="user">ct-000L</fr:addr><fr:route>ct-000L.xml</fr:route><fr:title
text="Equivalent condition for the existence of images">Equivalent condition for the existence of <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">images</fr:link></fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with pullbacks. Then <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has images iff for each morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex>, the pullback functor <fr:tex
display="inline"><![CDATA[f^{*}\colon \mathsf {Sub}(B)\to \mathsf {Sub}(A)]]></fr:tex> admits a left adjoint <fr:tex
display="inline"><![CDATA[\exists _{f}\colon \mathsf {Sub}(A)\to \mathsf {Sub}(B)]]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1196</fr:anchor><fr:addr
type="machine">#327</fr:addr><fr:route>unstable-327.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By <fr:ref
addr="ct-000J"
href="ct-000J.xml"
taxon="Lemma" />, the pullback functor <fr:tex
display="inline"><![CDATA[f^{*}\colon {{\mathcal {C}}_{/{B}}}\to {{\mathcal {C}}_{/{A}}}]]></fr:tex> admits <fr:tex
display="inline"><![CDATA[\Sigma _{f}\colon {{\mathcal {C}}_{/{A}}}\to {{\mathcal {C}}_{/{B}}}]]></fr:tex> as a left adjoint.</fr:p>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1197</fr:anchor><fr:addr
type="machine">#325</fr:addr><fr:route>unstable-325.xml</fr:route><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[g\colon B'\rightarrowtail B]]></fr:tex> be an arbitrary object in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. We need to construct a functor <fr:tex
display="inline"><![CDATA[\mathsf {Img}\colon {{\mathcal {C}}_{/{B}}}\to \mathsf {Sub}(B)]]></fr:tex> so that each morphism <fr:tex
display="inline"><![CDATA[f \to  g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f) \to  g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>.</fr:p><fr:p>Let <fr:tex
display="inline"><![CDATA[f \to  g]]></fr:tex> be an arbitrary morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. Then this corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A} \to  f^{*}(g)]]></fr:tex> as follows:</fr:p>
    
      
      <fr:figure><fr:resource
hash="42bf1abc475a99195f5c5cbd701c9668"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3Mi43OTYzMzlwdCcgaGVpZ2h0PScxNzQuNDQ0ODM3cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE1LjE5NzU1OSAxMTYuMjk2NTU4Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVHdBQW9BQUFBQUJid0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGMzhtTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SEZmMTJaMng1WmdBQUFYQUFBQUllQUFBQ2hCTEZ2RVpvWldGa0FBQURrQUFBQUM4QUFBQTJLSTJkZzJob1pXRUFBQVBBQUFBQUlBQUFBQ1FGbVFHYmFHMTBlQUFBQStBQUFBQVFBQUFBRUFsaUFLZHNiMk5oQUFBRDhBQUFBQW9BQUFBS0FhZ0ExRzFoZUhBQUFBUDhBQUFBR0FBQUFDQUFCd0JGYm1GdFpRQUFCQlFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFNUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtaW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZkI1RGVZQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlxWXpiLzMvSDhoUEE5SC9aLy94QTZzQ0FnQ2lKd21KQUFCNDJrWFJQVy9UUUJ3R2NEOTM3amx2OXRteGZXNlQxSGx4YklmU3htbmNPaWl0OHRKV1FtMFJwVUtpS2tJZ2hpNmRrQmhBZkFnRzFJR1ZsVy9BM2gzeEhSaVJtQmhZVXM3dHdKMTB3ejAzL0gvM0tGQ09ieEp5U1g0b00wVUI1V0NhQWEwVHhST2t3aE5NRTAxTU1LVUJpekl2bldBazc0ZkNNeEJFY1pTTm9nUUc0VWd6d1dKOEdadXFXU3ZPTjN0am9PdEdGTHpKT2UrMjZXcWZQL0tKelUrNWE0aTk0TjR1RUFpWm16N24xYXBmS3RSZTVUR3VGdGRIMW16TDJhZFI0TGRJbDhYbElvRjY3SDcrYzBZN0dzN082M0VVZHY5SFdJazJQcXFkQWhTNWlMSitzMEZDWEN0OVpUL1hTQW03bGNpSkhhWjVJaFdaQkV3bHNvODRHK1hiaHlkVjhnR2RJb3NsaW1uNUZ3aHZtRDhsN1RmRnQrK1RsNnFjMXhJd3FnMnI3ZXdHRGFGNW84UDVPYUZ6YmgyZTk3WjFXcXZxTGo0bEZJNjdWZHR2dWFhRktQYjNHaFVOSHhiejVEa2w3dnBxMjdiTGZtbUpvTnhZR2JSZXBDck9ubHc4dHZrQlJWZVlBcWExK1B1Tmw4TkFSVzg3bXM5T1JnaGJYTCsxRFc1KzRUZStLenU1YldUQVk1N3NabmhuNEhja0tiazdNK0ZKbUNGSDZNczJaWXNTNldWNWJ6R0x4WlFrWUYvVEVOaFpiYVluRDZ0cVFTYzljL1B5MlFYSWd5WU5pSHIxdWpKc1cxM0FGYVZnckorK295U01kaXJ0QWVpa2NiL3NMNGZPOG5MeXN6NjExK29sUXVxK0J0VGpTcVRpYUR6WXF5SnN6cDRDekdDdXFkdEVjMHJZWE92WVJnSFFuVVlaYXJna1V4VkUwdjRCLzFCVW5BQUFlTnBqWUdSZ1lBQmlubFU5dnZIOE5sOFptRmtZUU9CeGhLNExndjZ2eTNTTTZTS1F5OEhBQkJJRkFBRnBDV0VBZU5wallHUmdZR2I0ejhEQXdIU01RZWYvQmFZc0JxQUlDbUFCQUdVY0JEZ0N4Z0FBQWpvQVN3STZBQ3dDS0FBd0FBQUFBQUJtQU5RQlFnQUFlTnBqWUdSZ1lHQmhjR0ZnWWdBQlJnWTBBQUFIamdCTmVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS1ZlZHdXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9KZGsyMFd4dlBiZkdWZ1ptRUFnY2NSdWk3SU5QTkVKaHNneGNIQUJPSUJBQUZoQ0FjQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzBBQUFBMktKcWRobWhvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRtTnZzdXpqK1cyK01qQ3pNSURBNHdoZEZ3VDluNUhwTWpPSXk4SEFCS0lBRzJNSlBnQUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1VBQW9BQUFBQUEvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlKMVhHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzZaMng1WmdBQUFXUUFBQURZQUFBQTJOVnFMVHRvWldGa0FBQUNQQUFBQUM4QUFBQTJLUnVjZG1ob1pXRUFBQUpzQUFBQUhnQUFBQ1FGOFFLYWFHMTBlQUFBQW93QUFBQUlBQUFBQ0FZaEFHVnNiMk5oQUFBQ2xBQUFBQVlBQUFBR0FHd0FBRzFoZUhBQUFBS2NBQUFBRmdBQUFDQUFCUUJGYm1GdFpRQUFBclFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEaEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtRm1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NNlF6TS93SDhwa2gwa2hxL2dPRkFiUWVETThBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmpwLy85RHlQK3p3SHdHQUZXMUJzTUFBQUFBQWdCbC95d0NpZ0hGQUM0QVF3QUFBUU1PQVNNR0x3RW1KejRCTWhZVkZBWUhGaDhCRmo0Q1B3RU9BUWN1QVNjMk56WTNOamN5RmhjMk54NEJGUWMzTmk4QkppY09BUWNPQVJVZUFUYytBVGMrQVFLRmJCU1BheTgxQ3pNRUFTVXlGZ29RQWlJdEZ6OUhHQVlZRWt3eVMyWUNBMFVSRWxCaElrQVpFU0lURTVZdEFSVUVGendwU0JZZEhBSTVJQ2hGSFE0SkFYWCtURXRJQWdrRERDOGRKUm9QQ0J3UEJRSUJBUW93TUJ4aEVDVUNBVnhTWTB3VEQwSURHeUluQVFFVkR2dTRDaU1HSWdRQk1DTXZkU0U3TEFFQkp4MFBEd0I0Mm1OZ1pHQmdBT0s1YTNlYXh2UGJmR1ZnWm1FQWdjY1J1aTRJK3I4T2N3ampVU0NYZzRFSkpBb0FHVmNKaXdCNDJtTmdaR0JnWnZqUEFDUkRHRklabkptNkdJQWlLSUFKQUVBV0FwSUFBQU5VQUFBQ3pRQmxBQUFBQUFCc0FBQjQybU5nWkdCZ1lHSndBV0lRWUdSQUF3QUhXQUJMQUFCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOa0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQ3dBQUFBMktodWRZV2hvWldFQUFBSThBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbHdBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDWkFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKc0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvUUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURWQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGltbFhxaGZIOE5sOFptRmtZUU9CeGhLNExNczBTeW5nSFNIRXdNSUY0QVBKakIvOTQybU5nWkdCZzF2cGp5Y0RBRXNyUXg5RFBsTXdBRkVFQlRBQlNnQU5DQUFSVkFBQUM4Z0NPQUFBQUFBQlVBQUI0Mm1OZ1pHQmdZR0l3WlFEUkRGQVNDUUFBQmNvQU93QjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFDVWxZV0JpWldwQzJDRE1zUkJkb2dVcWVySTcrN2hldWdOcCtmOXVBTktmc2g0VHNacjNNL0pLVVQ5Y2NFTGI0bW5vaGFKU3o1WU1pSExaK0xNMlNUT0pmbEtYUERPSmZGVS9PL0VKWjg4dGwxN3UvZldxMzFuckhmbk5venJnL1doNlp4YTZTcnFuWFhXSDN0cjFHbFVabWpDY0cxVnJTdGRzNldqNWNhZEhvdEhzUmZIUkhhY0pRdU1yRGxFSjlCSTZxUzFRbFA5eTNlU3U5ZzV4azlHT2lkSmxOQWdWMEgyVmRxS09sNXE2bC92NlRCSEFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDArMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNWWjJ4NVpnQUFBV1FBQUFGTEFBQUJZRG1Tc1RKb1pXRmtBQUFDc0FBQUFDOEFBQUEyS00yZVgyaG9aV0VBQUFMZ0FBQUFIZ0FBQUNRR0xBSU9hRzEwZUFBQUF3QUFBQUFNQUFBQURBaCtBRTlzYjJOaEFBQUREQUFBQUFnQUFBQUlBRlFBc0cxaGVIQUFBQU1VQUFBQUZnQUFBQ0FBQndBNmJtRnRaUUFBQXl3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaVp2Z1A1RE5EcEpIVS9BY0tBd0R5S1ExSGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoTy8vOERTY2YvLy84ZkFQTVpBRktvQnA1NDJqV1BNVS9DUUFDRjc5M0JIV0RiUTF2YUdBRlRRWnBvRkVOSkt3d01LbWcwRXBURU1KQ1ltQ2liZzBGY0dSaDFNakZ4Y25IekI3ZzRPZmtuSEl5anZ3R3dOZkZOTDEvZThEMUNTWDQ2cFYvMGt4UkppUkFmbmw4eUxkMHdYYy9rUlFpbjRKUTl5L1Q4SW16QkRkUHlMQTBCRDdGYmcrK3lWNXh6UStXb21Xc3BLTkgrTUJhRk9xT1hXVnhNcGswMXJhc01hclRYVWFERWwycVBQL2FBbmlRUmwrT2hLVmxHZ0RIUW1CU0FZbDNVUjBZK0NTbzFIdUtFNU1oOTRKZ0VZV1IxT21hY3ZwRXNXU0diZ2FsZXpqazhjTE96U0drUVdWaGNnZ3ViLy9ucW9aeFhjSElGTHRoL1o4SEFmYjViY0RKU290TTlZOFAyUVJ0ME4zbDRQYmxQYTFvMSsvUncycWRZM3g0dDZ0SEwyKzZBMG8yOTkwWUUwRnEwTWt0WldvQWVWZmQ3TXRHc0hHeHB0VWo0QURycTdLcVIzNkdROCtNWGR0TmNickhKOXh4UGtGK3p2VHVEQUhqYVkyQmtZR0FBNHRZcndtZmorVzIrTWpDek1JREE0d2hkRndUOS95OHpHOU5kSUplRGdRa2tDZ0FpUHdvb0FIamFZMkJrWUdCbStNOEFKRGtZVkJpWW1Oa1lnQ0lvZ0JrQUk4Y0JRZ0FBQW5ZQUFBTUFBQ1FEQ0FBckFBQUFBQUJVQUxCNDJtTmdaR0JnWUdhd0JHSVFZR1JBQXdBR2R3QkNBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01LjE1Mjc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0xNi40MTQ1OTInIHk9Jy0yNy41NjQyMjEnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOC42MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwwLjAsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIyLjUzMTA0LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE5LjIyMDAwNycgeT0nLTI2Ljk1NTM3NSc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xNS4wNTUwMzgnIHk9Jy0yMy45NDg4NTgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTExLjk0MTY5NScgeT0nLTIzLjk0ODg1OCc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNy44MDQ3NDQnIHk9Jy0yMy45NDg4NTgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTEuNDU5MzIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTE1LjgyOTk4MycgeT0nLTI3LjU2NDIyMSc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjg2MjEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy44ODY1OTEsLTIzLjk0ODg1OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjMuODg2NTkxJyB5PSctMjMuOTQ4ODU4Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005LjcwODMzIDBINDYuNDAzNzgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNjUzNzgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4zMjU4Miw0Ljc4NDAxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjMuODg2NTkxLC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIzLjg4NjU5MScgeT0nLTIzLjk0ODg1OCc+zrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTIwLjEyMjU2OScgeT0nLTIyLjk1MjU5NCc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS04LjYwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LC02NC41Nzg0MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQzLjk4ODMsMzcuNzM4MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMy44ODY1OTEnIHk9Jy0yMy45NDg4NTgnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS0zMS45MzI3NSA0MS4zMzA0N0MyLjA3NjExIDQ2LjM3NDUzIDI4LjY4NzkgMzUuODU4MDIgNDkuNzQ5ODggOS4zMTkxOCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjYyMTYxLC0wLjc4MzI2LDAuNzgzMjYsMC42MjE2MSw0OS45MDUyNyw5LjEyMzM3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNy4wNjYzNiwzOS45MzEyMyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLXdpZHRoPScxLjYnPgo8cGF0aCBkPSdNLTQxLjA4MTE4IDMzLjgyODU3Qy00Ni40NzQ0OS0xLjEzNDM1LTM1Ljg4NzYtMjguMzg1My04LjMwNTU0LTUwLjUzNzU4JyBmaWxsPSdub25lJy8+CjxnIHN0cm9rZS13aWR0aD0nMC42Jz4KPGcgc3Ryb2tlPScjZmZmJz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNDc0NDktMS4xMzQzNS0zNS44ODc2LTI4LjM4NTMtOC4zMDU1NC01MC41Mzc1OCcgZmlsbD0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzMuNzk1MjMsLTEwLjM0NjY2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjMuODg2NTkxLC0yMy45NDg4NTgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2UtZGFzaGFycmF5PSczLjAsMi4wJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KPHBhdGggZD0nTS0zMy44MjgwOCAzMy44Mjg1N0wtOS4yNzcxNiA5LjI4MTA3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTQsLTAuNzA3MDUsMC43MDcwNSwwLjcwNzE0LC05LjEwMDM3LDkuMTA0MzEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xOC4xMTE5NSwyNC4xODk4OCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjg4NjU5MSwtMjMuOTQ4ODU4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \SpliceDiagramSquare {
          ne = B',
          se = B,
          nw = A',
          nw/style = pullback,
          sw = A,
          east = g,
          east/style = {>->},
          west = f^{*}(g),
          west/style = {>->},
          south = f,
          north = \varepsilon _{g},
        }
        \node  [above left of = nw] (a) {$A$};
        \draw  [->,morphism,bend left] (a) to node {} (ne);
        \draw  [double,morphism,bend right] (a) to node {} (sw);
        \draw  [->,morphism,exists] (a) to node {} (nw);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>This then corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\exists _{f}(\mathsf {id}_{A}) \to  g]]></fr:tex> under the adjunction <fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex>. Thus, we define <fr:tex
display="inline"><![CDATA[\mathsf {Img}]]></fr:tex> by the assignment <fr:tex
display="inline"><![CDATA[f \mapsto  \exists _{f}(\mathsf {id}_{A})]]></fr:tex>. This assignment can be trivially extended to a functor: since the category <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex> is a preorder, every morphism <fr:tex
display="inline"><![CDATA[f \to  f']]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex> has to be mapped to the unique morphism <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f) \to  \mathsf {Img}(f')]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. This morphism must exist. Indeed, it is the lifting of <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)]]></fr:tex> against <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f')}]]></fr:tex> depicted in the following diagram.</fr:p>
    
      
      <fr:figure><fr:resource
hash="447c19ca1a6fbe2ea6dcb411e3c0becc"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0Ni41NjI4NTlwdCcgaGVpZ2h0PScxMjAuNjgwNzU3cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTcuNzA4NTczIDgwLjQ1MzgzOCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUMwQUFBQTJLSnFkY21ob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0bU52c3RMaitXMitNakN6TUlEQTR3aGRLd1Q5bjVIcE1qT0l5OEhBQktJQUlFOEpVZ0FBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEeGloR050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCRUFBQUFSQjVhakhkb1pXRmtBQUFCc0FBQUFDd0FBQUEyS2h1ZHJXaG9aV0VBQUFIY0FBQUFId0FBQUNRRkJnRFphRzEwZUFBQUFmd0FBQUFJQUFBQUNBWVlBRjlzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0lBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBU2JtRnRaUUFBQWlRQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpxMC9sZ3dNekZyTXg0SENqQWdWLy84ek1BQUErd01QZndCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFGOEFKd0Y3QWp3QUVBQUFBUU1HSXljbUp6Y1RQZ0UzTWhZWEJnY0JjZFFHREJZVEF3U2VBeGtlR1NZQkFRUUIzUDVjRVFjSERSQUJ1dzRnQVNBY0RBd0FlTnBqWUdSZ1lBQml0cWxwRitQNWJiNHlNTE13Z01EakNGMHJaSm9sbE1rR1NIRXdNSUY0QU92U0IyQjQybU5nWkdCZzF2cGp5Y0RBRXNvUXorREJXTTBBRkVFQlRBQktLQUxqQUFSVkFBQUJ3d0JmQUFBQUFBQWlBQUI0Mm1OZ1pHQmdZR0lRWkFEUkRGQVNDUUFBQWtZQUZ3QjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFDVWxZV0JpWldwQzJDRE1zUkJkb2dVcWVySTcrN2hldWdOcCtmOXVBTktmc2g0VHNacjNNL0pLVVQ5Y2NFTGI0bW5vaGFKU3o1WU1pSExaK0xNMlNUT0pmbEtYUERPSmZGVS9PL0VKWjg4dGwxN3UvZldxMzFuckhmbk5venJnL1doNlp4YTZTcnFuWFhXSDN0cjFHbFVabWpDY0cxVnJTdGRzNldqNWNhZEhvdEhzUmZIUkhhY0pRdU1yRGxFSjlCSTZxUzFRbFA5eTNlU3U5ZzV4azlHT2lkSmxOQWdWMEgyVmRxS09sNXE2bC92NlRCSEFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT2dBQW9BQUFBQUJBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMVUyTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQzVaMng1WmdBQUFXUUFBQURpQUFBQTVJdktRZ1JvWldGa0FBQUNTQUFBQUM4QUFBQTJLUnVkY1dob1pXRUFBQUo0QUFBQUhnQUFBQ1FHUXdKT2FHMTBlQUFBQXBnQUFBQUlBQUFBQ0FZUUFIdHNiMk5oQUFBQ29BQUFBQVlBQUFBR0FISUFBRzFoZUhBQUFBS29BQUFBRndBQUFDQUFCQUJLYm1GdFpRQUFBc0FBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFEa0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtNW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NYVF4TS93SDhwa2gwa2hxL2dPRkFiRDZETVVBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhwLy85RHlQK3p3WHdHQUZXZ0JzSUFBQUI0MmgzS3lVM0RRQmlHNGZsbXpEL080aGs3SGk5WWJCbEhOb2tJT1RpTUJVSzJ1Q0VrSkRoeW9ZQklWRUFKSEdpQkxxaUFDaWlDTGxpQzNzdDdlQmpZODgrU2YvQlBkczBZaEFaSkJVbFYzYUZKTTBNeVBVU0gxdlZ3YlVuVjJkcGx6ZmIvU3pPRnNxb3IxMVlyV0VrYWpVdU5KSW12ODJBUUZaT3JwYjBWbUNjTFlSS3Q0djNaVGpUWmkwWVBRV3owb3lJdjk0UHkvdmptajZRTGdmRkJxT01pRzQ3enA4RDR3c1BMOTN0bkwrZEZ3MkZQclJWMU5CMUtjTzZTZnZPMnVRQUZab0M3NmRFNmpGWWVaaWRiUXJYeU9mS3dmd1h0amdRWSt3WFVlUjJIQUFCNDJtTmdaR0JnQUdLRDVON0Q4ZncyWHhtWVdSaEE0SEdFcmhXQy9xL0xITUowR2NqbFlHQUNpUUlBQi9JSk1nQjQybU5nWkdCZ1p2alBBQ1JER0tyL2YyYzZ5Z0FVUVFGTUFHc2ZCSllBQUFOVUFBQUN2QUI3QUFBQUFBQnlBQUI0Mm1OZ1pHQmdZR0x3WkFEUkRGQVNDUUFBQjc0QVR3QjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLVmVkcldob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0pkazIxT3h2UGJmR1ZnWm1FQWdjY1J1bGJJTlBORUpoc2d4Y0hBQk9JQkFBWk5DQnNBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBL1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBtbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDOEFBQUEwRThPekgxb1pXRmtBQUFDSUFBQUFDMEFBQUEyS1JtZGNXaG9aV0VBQUFKUUFBQUFIZ0FBQUNRRkxBSzRhRzEwZUFBQUFuQUFBQUFLQUFBQUNnWGZBSnBzYjJOaEFBQUNmQUFBQUFnQUFBQUlBRFlBYUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBZ2JtRnRaUUFBQXB3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBZElsRE0wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaSmoxbjRIeE9ETURneHdEQXlNZkl6dWJ1QmdZaXJBcHFlc3hxcXVwbTVuYk1acWJHWW1Kc2pFZUNXcGxaVmJpNE5LdDRHQmtrM0pVOUZLd1pXR3hWZkJTZEpSaVkyUjZidloxVDJ5bGhIaFZLZ3NYQzVlSmJKUnR3WW9WaGJhUnNpWmNMSndNUU1ESWtBeTBhd0xRTG1rZ2g0MGRaSnVhUHFNSjJBSWhOWFUxSUVOY2psRmNqSEVDMUZSbUpsYjFjRFZUeHJSaWRtWm1pSVdNREJBekdWazVPRmhrazhPYUdLVit4M0p6c3pLQ0xRUUFFYU1qajNqYVkyQmtZR0FBNG4yc3E4M2orVzIrTWpDek1JREE0d2hkS3dUOW40RTVpQm5FNVdCZ0FsRUE4c01IOHdBQUFIamFZMkJrWUdCbStNOEFKSU1Za2htU0dZOHpBRVZRQUJNQVJza0M2Z0FBQTFJQUFBSXFBSm9BWXdBQUFBQUFBQUEyQUdoNDJtTmdaR0JnWUdhUVp3RFJERkFTQ1FBQUE3OEFKZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktOT2RaMmhvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaUkrMERmK1A1YmI0eU1MTXdnTURqQ0YwckJQMWZuNW1INlRpUXk4SEFCQklGQUF6cUNSY0FlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUkFBQW9BQUFBQUJOZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGMy9HTnRZWEFBQUFFOEFBQUFNUUFBQUR3SEZmMTBaMng1WmdBQUFYQUFBQUYzQUFBQnFKVjJCMnRvWldGa0FBQUM2QUFBQUM4QUFBQTJLSTJkY1dob1pXRUFBQU1ZQUFBQUlBQUFBQ1FGblFHYWFHMTBlQUFBQXpnQUFBQU1BQUFBREFjb0FIdHNiMk5oQUFBRFJBQUFBQWdBQUFBSUFHWUExRzFoZUhBQUFBTk1BQUFBR0FBQUFDQUFCZ0JGYm1GdFpRQUFBMlFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFTkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtU21LY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVzlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZlFiRGZBQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlxWXhiLzMvSDhnSDAvOW4vL0VGcXdJQ0FLSUZDWWNBQUFCNDJrWFB1MDdjUUJURzhmbG16SGpaaThkNzhYakJZR2ZYOWd3WFpXOUdOdHBGM29VdGtDQlNoQ0tCcUtJVU5Qc0N2QVVWQlczYVBBYzk0aDFTUnFKS0d6S3JGRG5GS2M2L09UOENjdmsrcEN2NlNoYUVnQWx3MjRIZFY3cEVKbjNKYlJtaHhKekZYT1YrVnFJdzk0bjBIY1JLcTd4UVF6aFVJTXNsMS9nK2RTMTNlL04wdkRjRkVrOHhpRWdJa2ZUWTdrQjhDbWxiWEFuUGtXZngvZ2tRUzlQZFVJaFdLNnhXdHIrdU14Ny9QRjgwRjBlZEpWTngrSUVtWE5jMktheEw3K24zRGV2YnVMa050RXFUL3dsYjZ1T0QxYStBbUtGazlQNExiM2doTTdJa3BIRGdjOS84UDhtTHZBaXh0ZzFnWU1XL25Vcy9oSkVvUFRCaUkvVkwrUG5hcHJtV2N6b0UvNUdsd0d3M3lqNmZ0NnhLZys2NTQ5WDFIZWh4eEdKcVBYNnJUM3JOQlBCa05aNDJydTRaVGRXczNodUJsVHVIdGJDYmRycmQ0YzlnM2o0SXFwUUdvUTBFdXE0c1hFeEhaeTJrMGVJTHdCM3V1WTAydFR0VmpBLzZiYWNDTkRvN05WanBocWtXcUtIOUJZNnROVmdBZU5wallHUmdZQUJpUHV1L3hmSDhObDhabUZrWVFPQnhoSzRWZ3Y2dnozU002U0tReThIQUJCSUZBQVppQ1hrQWVOcGpZR1JnWUdiNHo4REF3SFNNd2VEL0JhWXNCcUFJQ21BR0FHVjNCRHNDeGdBQUFqb0FTd0lvQURBQUFBQUFBR1lBMUhqYVkyQmtZR0JnWm5CaFlHSUFBVVlHTkFBQUIzTUFUSGphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9DQ3hkV0ZnWW1YcUF0aEZHV3dqSjBSQ3FqcjJkL2RoUFBRTlYrZCsyRURORHdYM0s1Z2x2VjlKSmU3QkZWUG1tU2ZpM2pMWExIam5pYUo4bHVTVmo4eWxOSitaSzE3NHlqeVIvRHR6ellyZlRYQ1g2MkNqMmdWam96ODUxNjMzTnZaZDhHcXBtK1MzMXR0NEdLeFJ4NXN5WTllUFo2ZGEzZWlXRFFISGhTc0Rsb2hpSjRsSjdEbEo1K2hZczA5Skx4d2tWeXpSTlAvNnJmUStiUTdwSnlPYkl6ZFJ3eWlMWHZRc1cwV2JYbXJhUDh1aEwvY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLTTJlUzJob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0dFlyd2wvaitXMitNakN6TUlEQTR3aGRLd1Q5L3k4ekc5TmRJSmVEZ1Fra0NnQW5Ld284QUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjcge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjgge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4xNTI3OSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MC41NjY0NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctNjAuNTY2NDcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU1LjEwNTAxMycgeT0nLTY0LjE4MTgzNCc+7oCwPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MC41NjY0NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctNjAuNTY2NDcnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy4yNjM4OSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYwLjU2NjQ3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTEuNDU5MzIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01NC41MjA0MDQnIHk9Jy02NC4xODE4MzQnPu6AsDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MC41NjY0NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctNjAuNTY2NDcnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg0Ni40MDM3OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni42NTM3OCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE1Ljg4ODY3LDUuOTAwNzEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYwLjU2NjQ3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy02Mi41NzcwMTInIHk9Jy02MC41NjY0Nyc+zrU8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU4LjgxMjk5JyB5PSctNTguNzM0NDI3Jz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nLTUwLjQxOTkwNCcgeT0nLTU4LjczNDQyNyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNDcuNzIxNjQ5JyB5PSctNTguNzM0NDI3Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00My43MjYxNzknIHk9Jy02MC4yMDExNTYnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y4JyB4PSctNDEuMDMxNDA0JyB5PSctNTguNzM0NDI3Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTguNjA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwtOC44NTk3MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MC41NjY0NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjIuNTc3MDEyJyB5PSctNjAuNTY2NDcnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNTAuODI2NjczJyB5PSctNjAuNTY2NDcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQ3LjcxMzMzJyB5PSctNjAuNTY2NDcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQzLjA0Njc0NicgeT0nLTYzLjU3Mjk4Nyc+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy00MC4zNTE5NzEnIHk9Jy02MC41NjY0Nyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTAuNTA1NTQtNTYuOTA1NUg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMC43NTU1NCwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMDU2NTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE2Ljk0MTc5LC02NC45NjczMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjAuNTY2NDcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYyLjU3NzAxMicgeT0nLTYwLjU2NjQ3Jz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTUwLjgyNjY3MycgeT0nLTYwLjU2NjQ3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny43MTMzMycgeT0nLTYwLjU2NjQ3Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy00My4wNDY3NDYnIHk9Jy02MC41NjY0Nyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2UtZGFzaGFycmF5PSczLjAsMi4wJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KPHBhdGggZD0nTTguMjM4MTMtNDguNjYyNDZMNTAuMTQ1OTItNi43NjMyMycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE3LDAuNzA3MDIsLTAuNzA3MDIsMC43MDcxNyw1MC4zMjI3MSwtNi41ODY0OSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \SpliceDiagramSquare {
          nw = A',
          nw/style = pullback,
          sw = A,
          ne = B',
          se = B,
          north = \varepsilon _{\mathsf {Img}(f')},
          east = \mathsf {Img}(f'),
          east/style = {>->},
          south = \mathsf {Img}(f),
          south/style = {>->},
        }
        \draw  [->,morphism,exists] (sw) to (ne);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>We can now extract the components of the unit and the counit from this correspondence.</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
      
  <html:tr>
        
  <html:th>Unit (<fr:tex
display="inline"><![CDATA[\vartheta ]]></fr:tex>)</html:th>

        
  <html:th>Counit (<fr:tex
display="inline"><![CDATA[\zeta ]]></fr:tex>)</html:th>

      </html:tr>

      
  <html:tr>
        
  <html:td>
          <fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be an object in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>. The identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}\colon \mathsf {Img}(f)\to \mathsf {Img}(f)]]></fr:tex> is, by definition, the identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}\colon \exists _{f}(\mathsf {id}_{A})\to \mathsf {Img}(f)]]></fr:tex>, which corresponds to the unit <fr:tex
display="inline"><![CDATA[\eta _{\mathsf {id}_{A}}\colon \mathsf {id}_{A}\to f^{*}(\mathsf {Img}(f))]]></fr:tex> of the adjunction <html:span
style="white-space: nowrap"><fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex></html:span>.</fr:p>
          <fr:p>Then since <fr:tex
display="inline"><![CDATA[\mathsf {Img}(f)]]></fr:tex> is monic, <fr:tex
display="inline"><![CDATA[\eta _{\mathsf {id}_{A}}]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f)}\eta _{\mathsf {id}_{A}}\colon f\to \mathsf {Img}(f)]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> is the counit of the adjunction <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex>. This defines the component of <fr:tex
display="inline"><![CDATA[\vartheta ]]></fr:tex> at <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. This is precisely the lifting of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> against <fr:tex
display="inline"><![CDATA[\varepsilon _{\mathsf {Img}(f)}]]></fr:tex>.</fr:p>
          
    
      
      <fr:figure><fr:resource
hash="9412b64af3fb67acab4f1f858195b591"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0Mi41MjA3MjdwdCcgaGVpZ2h0PScxMTguNzcxMjE4cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTUuMDEzODE4IDc5LjE4MDgxMic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9nQUFvQUFBQUFCQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjFVMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM1WjJ4NVpnQUFBV1FBQUFEaUFBQUE1SXZLUWdSb1pXRmtBQUFDU0FBQUFDOEFBQUEyS1J1ZGhXaG9aV0VBQUFKNEFBQUFIZ0FBQUNRR1F3Sk9hRzEwZUFBQUFwZ0FBQUFJQUFBQUNBWVFBSHRzYjJOaEFBQUNvQUFBQUFZQUFBQUdBSElBQUcxaGVIQUFBQUtvQUFBQUZ3QUFBQ0FBQkFCS2JtRnRaUUFBQXNBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTWFReE0vd0g4cGtoMGtocS9nT0ZBYkQ2RE1VQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZocC8vOUR5UCt6d1h3R0FGV2dCc0lBQUFCNDJoM0t5VTNEUUJpRzRmbG16RC9PNGhrN0hpOVliQmxITm9rSU9UaU1CVUsydUNFa0pEaHlvWUJJVkVBSkhHaUJMcWlBQ2lpQ0xsaUMzc3Q3ZUJqWTg4K1NmL0JQZHMwWWhBWkpCVWxWM2FGSk0wTXlQVVNIMXZWd2JVblYyZHBsemZiL1N6T0ZzcW9yMTFZcldFa2FqVXVOSkltdjgyQVFGWk9ycGIwVm1DY0xZUkt0NHYzWlRqVFppMFlQUVd6MG95SXY5NFB5L3ZqbWo2UUxnZkZCcU9NaUc0N3pwOEQ0d3NQTDkzdG5MK2RGdzJGUHJSVjFOQjFLY082U2Z2TzJ1UUFGWm9DNzZkRTZqRlllWmlkYlFyWHlPZkt3ZndYdGpnUVkrd1hVZVIySEFBQjQybU5nWkdCZ0FHS0Q1TjdaOGZ3Mlh4bVlXUmhBNEhHRXJndUMvcS9MSE1KMEdjamxZR0FDaVFJQUF3WUpIZ0I0Mm1OZ1pHQmdadmpQQUNSREdLci9mMmM2eWdBVVFRRk1BR3NmQkpZQUFBTlVBQUFDdkFCN0FBQUFBQUJ5QUFCNDJtTmdaR0JnWUdMd1pBRFJERkFTQ1FBQUI3NEFUd0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXOTBuR050WVhBQUFBRTRBQUFBTXdBQUFFUUFld0VnWjJ4NVpnQUFBV3dBQUFGTUFBQUJqUE53SkpOb1pXRmtBQUFDdUFBQUFDOEFBQUEyS05PZGUyaG9aV0VBQUFMb0FBQUFIZ0FBQUNRR053SjFhRzEwZUFBQUF3Z0FBQUFRQUFBQUVBajlBTlpzYjJOaEFBQURHQUFBQUFvQUFBQUtBTlFBaUcxaGVIQUFBQU1rQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQXp3QUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHA2TXVReWMvOEg4cG01R2RIVS9BY0tBd0REN3d6N2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VROEdkSVpjdi8vUjdEKzcvZy8rLzgwc0Zvd0FBRHNod3VWQUhqYVZWRExUc0pRRUoyWlcxb2dXQVNsRmR0VWFXTUxpQkI1dE1CVkVoY1NJeXBxNGtJa1NHVGpqeGcrRFJNU0VxSWY0dGFGNE1XTm1rbE96bU5tY1FZUVJnQXdwUWt3Z0kyRWs1ZyswK1NySVRRSXgxcVdLSTd2VUFJT0hRRFVQVWRXZEMybG9pSjdzbUpoVVBGMVRZeUt0dXU1ZmxCRXp3L2NXZ3NEWDI4aDAxYU80NjQyZFhFcDZ4YVdSZTZKSVJhcmNsT1NUSHk2MkcrRUdCWGlqOFpSM3ExS05KNk5HUm81SllGUzJxSGhaYkZ4L0xDME9XRXQ3d2owZTZQbW1zcG84RElncVJCZkwrSzhMU0VMNXc1UGgwUzd0T01taUNKaHpicmkzUzdmNU5zUnoyb2FCM1dSTWx1TExqNnd5Q3ZWSDNobHBxbGtzdGxNVmcyUkxDb0R3cDBvSHNNMzJCTkMvTU12b2V1cHFLZiswVXJLRjExRXhjQkNGcjFucXBRODQyWDhKYmZ0M25sVFR0NmM5RG1XRm5QTXB1MlF6VmkvOXZtWHpqclh4T3BiaGs5c0NOL3JyRDNyZU5wallHUmdZQUJpSSswRFYrUDViYjR5TUxNd2dNRGpDRjBYQlAxZm41bUg2VGlReThIQUJCSUZBQWYrQ1FNQWVOcGpZR1JnWU9iK3p3QWs0eG5rR0FTWmVSaUFJaWlBQlFBdXZ3RzBBQUFDVUFBQUFTNEFZd0lnQUI0RFh3QlZBQUFBQUFBT0FJZ0F4Z0FBZU5wallHUmdZR0JoOEdGZ1pnQUJSZ1kwQUFBSWJRQldlTnBOakQxdndqQVFocCtvQ1ZMRHdJSTZNTFFlT2x0QllXQmlZV0JpWldJQjdLSU1jWkFkSWlGVkhmbmRQWXdIenRMcGVUL09RTWtmR1kvSm1NVDltSnhDMUpNTHhrd1RqMFI5SlM2WjhjMGJXZjR1emllcnhMa2srOFFGSC93a0hvbi9tN2hrd1gzZHRaZHJiNzNhZHNaNmQycERXTzZzRDAzbjFGeFhVVytzcy83UVc2T09OMldHSmd6blZ0VzYwalZyT2xvdVhPbXhlQlJiY1V4a3gwbXlJRy9KTGpxQlJsSW5yVG1hNmlYZlNPNWk1eEIvTXRJNWNwTnRHT1FxeUQ1TFcxSEhTMDM5RCtwdE1Ec0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLTTJlWDJob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0dFlyd21maitXMitNakN6TUlEQTR3aGRGd1Q5L3k4ekc5TmRJSmVEZ1Fra0NnQWlQd29vQUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQS9RQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wbW1OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzhBQUFBMEU4T3pIMW9aV0ZrQUFBQ0lBQUFBQzBBQUFBMktSbWRoV2hvWldFQUFBSlFBQUFBSGdBQUFDUUZMQUs0YUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1hmQUpwc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURZQWFHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWdibUZ0WlFBQUFwd0FBQURLQUFBQk11c0lrZVp3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm02bUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWRJbERNMEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkpqMW40SHhPRE1EZ3h3REF5TWZJenVidUJnWWlyQXBxZXN4cXF1cG01bmJNWnFiR1ltSnNqRWVDV3BsWlZiaTROS3Q0R0JrazNKVTlGS3daV0d4VmZCU2RKUmlZMlI2YnZaMVQyeWxoSGhWS2dzWEM1ZUpiSlJ0d1lvVmhiYVJzaVpjTEp3TVFNRElrQXkwYXdMUUxta2doNDBkWkp1YVBxTUoyQUloTlhVMUlFTmNqbEZjakhFQzFGUm1KbGIxY0RWVHhyUmlkbVptaUlXTURCQXpHVms1T0Zoa2s4T2FHS1YreDNKenN6S0NMUVFBRWFNamozamFZMkJrWUdBQTRuMnNxL25qK1cyK01qQ3pNSURBNHdoZEZ3VDluNEU1aUJuRTVXQmdBbEVBN2RjSDN3QUFBSGphWTJCa1lHQm0rTThBSklNWWtobVNHWTh6QUVWUUFCTUFSc2tDNmdBQUExSUFBQUlxQUpvQVl3QUFBQUFBQUFBMkFHaDQybU5nWkdCZ1lHYVFad0RSREZBU0NRQUFBNzhBSmdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRXFmbTV1RGs2dkQyNndKMHFHcHBMWG9JdjUwYjBQd0JnN2ZQZWZjQUJrdkVvWkptQWNkSnBVM2p6em1oMFhraWZpcnlCbS9yQm1ScEROeFZ1d2lwMHo1anp4bVNSbDVJdjRqY3NZZjczMVQzKzZkOWVyWUdPdmRwZmJiay9WdDFUaTEwZm13SHF5ei90eFpvOHFuTW4zVjl0ZGFGVHJYQlhzYWFtN2M2YkI0RkVkeFRHREhSVExQbGxQWVd5ckpuSFEyYVBKdmVwRFVoY1k1L0dLa1VmSVVOZlJ5MDRwZXBhc293cDJtK0FCVk1pNURBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVWNBQW9BQUFBQUJmZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGNE1HTnRZWEFBQUFFOEFBQUFNd0FBQUVRRHlRU2haMng1WmdBQUFYQUFBQUpKQUFBQ3VITnlHb1pvWldGa0FBQUR2QUFBQUM4QUFBQTJLSTJkaFdob1pXRUFBQVBzQUFBQUlBQUFBQ1FGd2dHYmFHMTBlQUFBQkF3QUFBQVFBQUFBRUFucUFLdHNiMk5oQUFBRUhBQUFBQW9BQUFBS0FjSUExRzFoZUhBQUFBUW9BQUFBR0FBQUFDQUFCd0JZYm1GdFpRQUFCRUFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGRUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1LY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVjlrWnZnUDVETXpNSUtFR1JFcS9nT0ZBUUFPRGlRQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUlMazBwaTNNbC84L3gvQitqLzdqKzhmSTdCYU1BQUFESHNNYWdCNDJrV1JQMi9UUUJqRy9aeWRjK0lrUGplMnoybWNPazBjMjZXVXBIRlNHeVhCU1ZNQi9RTXRGU2dWUW1wVnBDNGRFQXZpVzhEU2daV1Z6OEdPK0E2TVNFeGRLWmNpeEoxMHcvdm9wUGYzL0NSSUJ6ZGRja20rUzFOSmdzeEFWUjFxSzR3eTlMbkRxY29ieURDUmZSb21UajlES3VZeGQzVDRZUlFtYWRpRlRoajZDYWNSUGc4TnhhZ1Z0bnRyUTZCdGh6SllnekhXYnNvckhmYkVJeVk3WnJiT1ovNmRNZUJ6a1JzZVk1V0twK1ZyWjRzWVY3Ky83aTlOQjlhT0hQcmVLbW5UcUZnZ1VBN3NUOWNuY2t2RnlVczNDb1AyL3dqTDRiMFBTaXNQU1J3aWJkNzh4Qzk4azBiU2ppU2xPaHpxaVAzakpFMVNEd3UyRGdSWSt2ZE51T05Ca0lSUlJ4QUxVaWVEa3l6WUlocnhDZW1DZnVrSHdHaWwwVDk2WEZIeVpiSm05QzduRnlEM0c3SlBsS3Z6VXR4Y2FnTTIxL3hoK2ZpOVRJSndWR3B1UXM3cWQ0dGVOYkNxMWU0UGQyS3V1eG9ocnFjQ2JsUUtGZXdQTjJjVkJJM3BjNERxMURiS0psRXREYjMxbHFubmdiSlZMMElKY2lKVlFQNnhYWk9Qd3RPZU5CZW1IRzZwRVZWdmJ4Z2xFem5aR29TUlVLZWppdzRTNFVrZ094YVRxVTI1RTk4T2hLMkYyRlNJZGJncTVJcGliaitKa2ppWnQ1eHkzeDFXM1lmejhSbUJaaktWTU5OckZYT3FWcVRnckJSNUd4TW9USFZ5WkRYeEh6VHI3Vkkyemc5ejVQWHNrYWZtdUZqM3RDckREZUtuUk9uVkJuaXJrcXFTdnpnUHZHY0tCcnUrZnpSYUtlaDJIWmgyckNJSU1YYnFmQlVZYkdoTDI4dW5OYk8yUmJKUi9HNWdCSFR0Y08rTnJJeEwrbXhjMkExZXZJb1BpWHc2M200YU5WSEhINkxPV0VZQUFBQjQybU5nWkdCZ0FPS0EwSDBQNC9sdHZqSXdzekNBd09NSVhSY0UvVitmNlJqVFJTQ1hnNEVKSkFvQUlFSUtHQUI0Mm1OZ1pHQmdadmpQd01EQWRJekI0UDhGcG40R29BZ0tZQUVBYURjRVlRTEdBQUFDT2dCTEFpZ0FNQUxDQURBQUFBQUFBR1lBMUFGY0FBQjQybU5nWkdCZ1lHRUlaMkJpQUFGR0JqUUFBQWxwQUdCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzBBQUFBMktKcWRobWhvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTRtTnZzdXpqK1cyK01qQ3pNSURBNHdoZEZ3VDluNUhwTWpPSXk4SEFCS0lBRzJNSlBnQUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLVmVkd1dob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0pkazIwV3h2UGJmR1ZnWm1FQWdjY1J1aTdJTlBORUpoc2d4Y0hBQk9JQkFBRmhDQWNBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNyB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4xNTI3OSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjA2NDYwMic+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTUuMTA1MDEzJyB5PSctNjQuNjc5OTY2Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjIuNTc3MDEyJyB5PSctNjEuMDY0NjAyJz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuMjYzODksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1MS40NTkzMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjIuNTc3MDEyLC02MS4wNjQ2MDIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYyLjU3NzAxMicgeT0nLTYxLjA2NDYwMic+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTQuNTIwNDA0JyB5PSctNjQuNjc5OTY2Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkuNzA4MzMgMEg0Ni40MDM3OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni42NTM3OCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE3LjI0MTEyLDUuNDAwNzEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctNjEuMDY0NjAyJz7OtTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTguODEyOTknIHk9Jy01OS43MzA3MDcnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctNTAuNDE5OTA0JyB5PSctNTkuNzMwNzA3Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny43MjE2NDknIHk9Jy01OS43MzA3MDcnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTQzLjcyNjE3OScgeT0nLTU5LjczMDcwNyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS04LjYwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTAuODI2NjczJyB5PSctNjEuMDY0NjAyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ny43MTMzMycgeT0nLTYxLjA2NDYwMic+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNDMuMDQ2NzQ2JyB5PSctNjEuMDY0NjAyJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0LTU2LjkwNTVINDcuODA2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMDU2NTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1Ljk2NCwtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Mi41NzcwMTIsLTYxLjA2NDYwMilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjIuNTc3MDEyJyB5PSctNjEuMDY0NjAyJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzMuMCwyLjAnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNOC4yMzgxMy00OC42NjI0Nkw1MC4xNDU5Mi02Ljc2MzIzJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTcsMC43MDcwMiwtMC43MDcwMiwwLjcwNzE3LDUwLjMyMjcxLC02LjU4NjQ5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyBmaWxsPScjZmZmJz4KPGcgZmlsbD0nI2ZmZic+CjxwYXRoIGQ9J00yMS42OTkxLTM0LjMxOTQzSDM3LjAzODUyVi0yMS40MjUwMkgyMS42OTkxWicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjQuNjk5MSwtMjkuMjg2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYyLjU3NzAxMiwtNjEuMDY0NjAyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy02Mi41NzcwMTInIHk9Jy02MS4wNjQ2MDInPs+RPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01Ny43NjYwNzEnIHk9Jy02MC4wMDc0NTUnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \begin {tikzpicture}[diagram]
              \SpliceDiagramSquare {
                nw = A',
                nw/style = pullback,
                sw = A,
                ne = B',
                se = B,
                north = \varepsilon _{\mathsf {Img}(f)},
                east = \mathsf {Img}(f),
                east/style = {>->},
                south = f,
              }
              \draw  [->,morphism,exists] (sw) to node[desc] {$\vartheta _{f}$} (ne);
            \end {tikzpicture}
          ]]></fr:resource-source></fr:resource></fr:figure>
    
  
        </html:td>

        
  <html:td>
          <fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon A\rightarrowtail B]]></fr:tex> be an object in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>. Then the identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}_{f}\colon f\to f]]></fr:tex> corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[s\colon \mathsf {id}_{A}\to f^{*}(f)]]></fr:tex> by the universal property of pullbacks.</fr:p>
          <fr:p>This morphism corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[\exists _{f}(\mathsf {id}_{A}) \to  f]]></fr:tex> under the adjunction <fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex>, which we take as the component of <fr:tex
display="inline"><![CDATA[\zeta ]]></fr:tex> at <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p>
        </html:td>

      </html:tr>

    </html:table>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1198</fr:anchor><fr:addr
type="machine">#326</fr:addr><fr:route>unstable-326.xml</fr:route><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has images, then we may define <fr:tex
display="inline"><![CDATA[\exists _{f}\colon \mathsf {Sub}(A)\to \mathsf {Sub}(B)]]></fr:tex> as the following composite:</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Sub}(A) \hookrightarrow  {{\mathcal {C}}_{/{A}}} \xrightarrow {\Sigma _{f}} {{\mathcal {C}}_{/{B}}} \xrightarrow {\mathsf {Img}} \mathsf {Sub}(B)     ]]></fr:tex><fr:p>Let <fr:tex
display="inline"><![CDATA[i_{A}\colon \mathsf {Sub}(A)\hookrightarrow {{\mathcal {C}}_{/{A}}}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[i_{B}\colon \mathsf {Sub}(B)\hookrightarrow {{\mathcal {C}}_{/{B}}}]]></fr:tex> be the inclusion functors. Note that</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Img}\Sigma _{f} \dashv  f^{*}i_{B}     ]]></fr:tex><fr:p>Since <fr:tex
display="inline"><![CDATA[f^{*}i_{B} \cong  i_{A}f^{*}]]></fr:tex> by construction, we have</fr:p><fr:tex
display="block"><![CDATA[       \mathsf {Img}\Sigma _{f} \dashv  i_{A}f^{*}     ]]></fr:tex><fr:p>Let <fr:tex
display="inline"><![CDATA[\eta ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> be the unit and counit of this adjunction respectively. Since <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> is a full subcategory of <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>, there is a natural isomorphism <fr:tex
display="inline"><![CDATA[\iota \colon \mathsf {id}_{{{\mathcal {C}}_{/{A}}}}\stackrel {\sim }{\smash {\longrightarrow }\rule {0pt}{0.4ex}}i_{A}]]></fr:tex>. Then we can define <fr:tex
display="inline"><![CDATA[\eta ']]></fr:tex> as follows:</fr:p><fr:tex
display="block"><![CDATA[       \eta ' := \mathsf {id}_{{{\mathcal {C}}_{/{A}}}} \xrightarrow {\eta } i_{A}f^{*}\mathsf {Img}\Sigma _{f}       \xrightarrow {\iota _{f^{*}\mathsf {Img}\Sigma _{f}}} f^{*}\mathsf {Img}\Sigma _{f}       \xrightarrow {f^{*}\mathsf {Img}\Sigma _{f}(\iota )} f^{*}\mathsf {Img}\Sigma _{f}i_{A}     ]]></fr:tex><fr:p>Then <fr:tex
display="inline"><![CDATA[\eta ']]></fr:tex> and <fr:tex
display="inline"><![CDATA[\varepsilon ]]></fr:tex> form the unit and counit of the adjunction <fr:tex
display="inline"><![CDATA[\mathsf {Img}\Sigma _{f}i_{A} \dashv  f^{*}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Related">Related</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1999</fr:anchor><fr:addr
type="user">ct-000H</fr:addr><fr:route>ct-000H.xml</fr:route><fr:title
text="Locally cartesian categories have pullbacks"><fr:link
type="local"
href="ct-000G.xml"
addr="ct-000G"
title="Locally cartesian category">Locally cartesian categories</fr:link> have pullbacks</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is locally cartesian iff it has pullbacks.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1186</fr:anchor><fr:addr
type="machine">#332</fr:addr><fr:route>unstable-332.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>If <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is locally cartesian, then <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> has products for any object <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>. But, products in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> are pullbacks over <fr:tex
display="inline"><![CDATA[A]]></fr:tex>. Thus, <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has pullbacks.</fr:p>
  <fr:p>Conversely, assume that <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has pullbacks. Then since the forgetful functor <fr:tex
display="inline"><![CDATA[\Sigma _{A}\colon {{\mathcal {C}}_{/{A}}}\to \mathcal {C}]]></fr:tex> creates connected limits for any object <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>, the slice <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> has pullbacks. Moreover, <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A}]]></fr:tex> is the terminal object in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>. Thus, <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> is cartesian.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2000</fr:anchor><fr:addr
type="user">ct-000G</fr:addr><fr:route>ct-000G.xml</fr:route><fr:title
text="Locally cartesian category">Locally cartesian category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is said to be <fr:em><fr:strong>locally cartesian</fr:strong></fr:em> if for any object <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex>, the slice <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex> is cartesian.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2001</fr:anchor><fr:addr
type="user">ct-000I</fr:addr><fr:route>ct-000I.xml</fr:route><fr:title
text="Slice comparison functor">Slice comparison functor</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be an arbitrary category and <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> be a morphism. There is a faithful functor <fr:tex
display="inline"><![CDATA[\Sigma _{f}\colon {{\mathcal {C}}_{/{A}}}\to {{\mathcal {C}}_{/{B}}}]]></fr:tex> whose action on objects is the assignment <fr:tex
display="inline"><![CDATA[g \mapsto  fg]]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1348</fr:anchor><fr:addr
type="machine">#331</fr:addr><fr:route>unstable-331.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Note that the category <fr:tex
display="inline"><![CDATA[{{({{\mathcal {C}}_{/{B}}})}_{/{f}}}]]></fr:tex> consists of the following data:</fr:p>
  
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
    
  <html:tr>
      
  <html:th>Objects</html:th>

      
  <html:th>Morphisms</html:th>

    </html:tr>

    
  <html:tr>
      
  <html:td>An object is a morphism <fr:tex
display="inline"><![CDATA[g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex> with codomain <html:span
style="white-space: nowrap"><fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</html:span>
        
    
      
      <fr:figure><fr:resource
hash="c2043888c305dac3969f4e22c65af81c"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExMy4xMDI4MzlwdCcgaGVpZ2h0PScxMTEuNTczMTkxcHQnIHZpZXdCb3g9Jy03MiAtNzIgNzUuNDAxODkzIDc0LjM4MjEyNyc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVE0QUFvQUFBQUFCTkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjB0R050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUM2WjJ4NVpnQUFBV1FBQUFGMUFBQUJxQlc2ckhob1pXRmtBQUFDM0FBQUFDOEFBQUEyS0kyZGpXaG9aV0VBQUFNTUFBQUFJQUFBQUNRRm1RR1phRzEwZUFBQUF5d0FBQUFLQUFBQUNnVXNBRXRzYjJOaEFBQURPQUFBQUFnQUFBQUlBR1lBMUcxaGVIQUFBQU5BQUFBQUdBQUFBQ0FBQmdCRmJtRnRaUUFBQTFnQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRUtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXltQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTWFRek0vd0g4cGtoMGtocS9nT0ZBZE9aRFNVQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqcC8vOER5YlQvLy8vUEJ2TVpBRld4QnNONDJrV1FQVS9DVUJTRzczdHZiVVdrdHdWNkd4RXIwSEtMQ1ZDMTJpYkdBQlVYUCtMSFJEQkdKeGNuRXhmamozQXdEcTcrREhmL2dEL0d3UVc5ZGZHYzdUenY4RDZIZ0J6OVJQU1dmcElSSVdBY3VtSENhTWx3Z0ZpNFFqZkVLZ1lZTWwrWGlSc1BrS3I3cG5CTitES1VTU29qbUpRalRvUWU0bTNIMHF4YUlkdm83QUNCSXhuNEt1YzhhTEtWUGovMmFJV2ZjOGNVZS83YUx1QUx4UzJQODNMWlc1aXZYZWNZTDdPUFEzdTBWUjB6NlhzTkd1aGhzVUNoSFRtdlh4UFdNakNaTG9leUhmd2pMTW5lazlhYUIxRkRTZmVuUjl2NElIMHl6bTJVaWY1bm9ocFhkY01Wc1VpVXdGQko5aEVtYWI0ZVhHV2xBbXlJSkZSU3VwRy9RTGliZVpRMjd3cjNEOUdWcHZyYUFtYTViamVydTM1ZEdHNTZrRTBweTdoOU1PMXNsMWl0WEhMd0hERlVuYTNhdU9GWU5tVG83ZFVYRFR6T3N1aUNVYWU3MHF4VWl0N0NIRVd4dnJUZXVJdzFUTTV1VGlwOG55RVFsb0Jsejc3ZmViSHRhK2hzeTJ4MG1xTGQ0Q1ZDZmdFRk9EbktBQUFBZU5wallHUmdZQUJpaFdPYno4ZnoyM3hsWUdaaEFJSEhFYnFlQ1BxL0x0TXhwb3RBTGdjREUwZ1VBQ2RkQ2tRQWVOcGpZR1JnWUdiNHo4REF3SFNNUWVmL0JhWXNCcUFJQ21BQ0FHVWFCRFlDeGdBQUFqb0FTd0FzQUFBQUFBQUFBR1lBMUhqYVkyQmtZR0JnWm5CaFlHSUFBVVlHTkFBQUIzTUFUSGphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9DQ3hkV0ZnWW1YcUF0aEZHV3dqSjBSQ3FqcjJkL2RoUFBRTlYrZCsyRURORHdYM0s1Z2x2VjlKSmU3QkZWUG1tU2ZpM2pMWExIam5pYUo4bHVTVmo4eWxOSitaSzE3NHlqeVIvRHR6ellyZlRYQ1g2MkNqMmdWam96ODUxNjMzTnZaZDhHcXBtK1MzMXR0NEdLeFJ4NXN5WTllUFo2ZGEzZWlXRFFISGhTc0Rsb2hpSjRsSjdEbEo1K2hZczA5Skx4d2tWeXpSTlAvNnJmUStiUTdwSnlPYkl6ZFJ3eWlMWHZRc1cwV2JYbXJhUDh1aEwvY0FBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVMwQUFvQUFBQUFCVlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDAvbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNXWjJ4NVpnQUFBV1FBQUFIcUFBQUNIUFQvRXp0b1pXRmtBQUFEVUFBQUFDOEFBQUEyS05LZVZXaG9aV0VBQUFPQUFBQUFIZ0FBQUNRR01nSGRhRzEwZUFBQUE2QUFBQUFRQUFBQUVBdFpBSUpzYjJOaEFBQURzQUFBQUFvQUFBQUtBV0lBc0cxaGVIQUFBQU84QUFBQUdBQUFBQ0FBQ0FBNmJtRnRaUUFBQTlRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRXFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzWTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCbVp2Z1A1RE5EcEpIVS9BY0tBd0R6QUExS2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZqTy8vOERTY2YvLy84ZkFQTVpBRks1QnA5NDJqWFF6Mm9UVVJRRzhQdmRrN25USkpPWjZLUXpsYVpUMHZ5WnRwS2tkSWFadG9zb2pZazF4YlEyVUlJRWdvSVdCQVUxUmhjdXNvZ0xRVmRDUVZ5NGNlY0R1SEhscWcvZzFvVzRFaDlCa25oSDZMbWJ3OGRkL0w3RE9Ddk1adnduLzhHcWJKT3hFRUc0YWRsbXh2SUNTMVNodWlYWEQyd3JDS3ZJcVNKajJZR3RRK1pSN05VUWV2UUY5MFFtSlZDenl2UFFsTUZvVGtFcWFmb1VWNmV6ZGlwcnBnZ3A1YVNyUVl1djFONy95UTM1Y1JweFl6S3lERnBTUVFRK1o2aUFadDl2akRPRk5MaWhpeWhPR0FMNU14d3hPY1F1enlZaytGZm1zSFcySmFXbW4zZUZ0T1Vjek90UUhkakNnRkJ6NHIvWGpIQkJ5YzJYaEVybk84a1AzcWUzaSs2U1lhRGJ1MHVqem40SC9IcjY1clBwdTZ5dTd6Z2ZUL3NEamtwOXZHd3FqOTcwaHB4djdIMXJ4Z0Q5a0c5ZjRKUlZ3Vy90dEU2TVJIdDdmMWV2eGFJR01OR2dKODNDTlE3ajB1UXpQVzhYRDJuNjY2SklNQWJtelg1VGtuK1B6Q0FkZVhuUksvQkxyalJIWU50QktNOGJDWmZoeUFJeXI4QU53dWhadG1XSHNnNGxycEpJeEJWd0hCODBYbTAwRjRXRjJNc2JxLzNBTDR0WVhGV28zRng3WEgveGdhamp0NTZPTzJ1cllrK0h4cyttZjNWcFZvM1M3UWRBZmF2YlgraVZoM2M0VnRZcnZZVWt3TFdIdTBVUGREcDZQV2o1UnhRckZQVURuUk5qL3dBZDBscitBQUI0Mm1OZ1pHQmdBR0oyUWMrRDhmdzJYeG1ZV1JoQTRIR0VyaWVDL3YrU21adnBMcERMd2NBRUVnVUE4SVFKREFCNDJtTmdaR0JnWnZqUEFDUTVHRlQrWDJEbVpnQ0tvQUFXQUVyM0F4VUFBQUoyQUFBREFBQWtBd2dBS3dMYkFETUFBQUFBQUZRQXNBRU9BQUI0Mm1OZ1pHQmdZR0d3WkdCbUFBRkdCalFBQUFhU0FFTjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjEuNjA4NzY1LC02MC40NDc1MDEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNjA4NzY1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTYxLjYwODc2NScgeT0nLTYwLjQ0NzUwMSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS42MDg3NjUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNjEuNjA4NzY1JyB5PSctNjAuNDQ3NTAxJz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjkzMTI0LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNjA4NzY1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTYxLjYwODc2NScgeT0nLTYwLjQ0NzUwMSc+QzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NCAwSDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY0LDQuMTcyOTEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS42MDg3NjUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuNjA4NzY1JyB5PSctNjAuNDQ3NTAxJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTQ4LjY2MjQ2Vi02LjkwOTczJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsMC4wLC02LjY1OTczKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNy40MTYzMiwtMjkuMjg2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjYwODc2NSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02MS42MDg3NjUnIHk9Jy02MC40NDc1MDEnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMjM4MTMtNDguNjYyNDZMNTAuMTQ1OTItNi43NjMyMycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE3LDAuNzA3MDIsLTAuNzA3MDIsMC43MDcxNyw1MC4zMjI3MSwtNi41ODY0OSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzIuNjMyNjksLTM1LjIwOTAxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNjA4NzY1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjYwODc2NScgeT0nLTYwLjQ0NzUwMSc+Zjx0c3BhbiB4PSctNTYuOTQyMTgxJz5nPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
          \begin {tikzpicture}[diagram]
            \node  (1) {$A$};
            \node  [right = of 1] (2) {$B$};
            \node  [below = of 1] (3) {$C$};
            \draw  [->,morphism] (1) to node {$f$} (2);
            \draw  [->,morphism] (3) to node {$g$} (1);
            \draw  [->,morphism] (3) to node[swap] {$fg$} (2);
          \end {tikzpicture}
        ]]></fr:resource-source></fr:resource></fr:figure>
    
  
        This is precisely an object in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>.
      </html:td>

      
  <html:td>A morphism <fr:tex
display="inline"><![CDATA[\alpha \colon g\to h]]></fr:tex> is a morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex> such that the following square commutes.
        Here, we identify the objects <fr:tex
display="inline"><![CDATA[g]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h]]></fr:tex> with objects in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>.
        
    
      
      <fr:figure><fr:resource
hash="7200d099b00612494c58c83b31926e3f"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExMy40NTQxMjdwdCcgaGVpZ2h0PScxMDYuNzc4NjlwdCcgdmlld0JveD0nLTcyIC03MiA3NS42MzYwODUgNzEuMTg1NzkzJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVUFBQW9BQUFBQUJjd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaGdKNFAyTnRZWEFBQUFFOEFBQUFNZ0FBQUR3SERQMThaMng1WmdBQUFYQUFBQUl2QUFBQ2xIa3NlOUpvWldGa0FBQURvQUFBQUM4QUFBQTJLSTJkWTJob1pXRUFBQVBRQUFBQUlBQUFBQ1FGNGdJU2FHMTBlQUFBQS9BQUFBQVFBQUFBRUFxa0FMaHNiMk5oQUFBRUFBQUFBQW9BQUFBS0FiZ0E0bTFoZUhBQUFBUU1BQUFBR0FBQUFDQUFCd0JOYm1GdFpRQUFCQ1FBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFOUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtV3NrNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdJTkdCaVNRVWx5V0RwUk1aOTdJelBBZnlHZG1ZQVFKTXlKVS9BY0tBd0FOb0E0MEFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXltWXdiL3ovSDhoUEI5SC9aLzBKQXFzQ0FnQ2gwZ21HQUFCNDJrMlJYV3ZUWUJUSG4zUHlORm56MGpSdnorUGFtRFpObTFUbzI1b3VtZGkxNnpyR3F1NUZFYVJGUkFRZDRvMGd5RkFRL0Faam44SVA0STMzd3I2UUNONXNKcjJTYzNrT25QL3YveU5JT3JkZGJNRXYwaU56UWtBb2dTU0cwUVRpSWVPMktIRVdzeVNkd0JSRXFRZFJrdWJqQVo5QW1oMElVMGlpTUFwRlNaUkt3UGd3UDBYL1EvSGpSZjhsaFlBWkRFcW1hL2oyT0hDWnhOUEZiSW5DVERjV3kvYTJKbFJNellHcnZnQzJNNnJNNjA3WmdERHk5bDFWZ3M4M3MvNUtRS2R6MTdjc3haTUxDSXE3T2FpL2lDazhQM3R6WXVrSEFqUlptVUhadVBuN1UxZGFBWVgyZGpqYk8wMmhWZGMxa3NHUTQ5cy8rQVd2eWFPY0xJdnNvU1Rxa0dkMXhEeHNFbk12NDgybUVVYWpEQ2JIQzZPOEE1MldJT2pCZG1wTklBd2E2MHJTaEVrd08zR2YzajhjcVlBMldxb21DMjV0YktJaGk4QVZJNWkwZDBEUVNvd2hzdmI0N0k1ZXNPckZEWmtYVGFOd1NWRnZGc3NBSmVtZzB3TDhmblB0eDFEb2o3VGVXSHhROVgyamdkTmRFNUVQT092Ui9qMVZxVGYzNTF2T0Z1Szh6WlNIWDhPcXJvQ2xNVHpRZEpuSytvWkVCWlVnbWQ3K3hoOXJoM3VFdER4SU0yZWptSzhOaW11ZS85MnhHdVNlYXVCQlhrWW1NTnVHZVN2Y1pwd2xPS0JNa1p1cW1USEYzYzJKM2JrNFdyMUNlbWpZVDg1UDNxa0lPSGNMa3B5dEs4WGFGUVZhR094V2oxdFI5aml1ZmJwY3RTbVlyZ0lvbXpGaWtBUXg0UG5pOWFsZHpweXRIaXYrOE5uYnNneUl6cUd4ZUwvc0I4T2xBRUYzNTF0MXRBdlkrQWRuMVZtdkFIamFZMkJrWUdBQVlwdnQzTUx4L0RaZkdaaFpHRURnY1lTdUpZTCtyOHQwak9rNGtNdkJ3QVFTQlFEcDhRakRBSGphWTJCa1lHQm0rTS9Bd01EMGcwR0hRWlJwQ3dOUUJBV3dBQUJLT3dMNkFzWUFBQUk2QUN3Q3JBQk5BdmdBUHdBQUFBQUFiZ0RpQVVvQUFIamFZMkJrWUdCZ1lmQmhZR0lBQVVZR05BQUFDRllBVlhqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVNrQUFvQUFBQUFCVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDFFV050WVhBQUFBRTRBQUFBTXdBQUFEd0FXQUNjWjJ4NVpnQUFBV3dBQUFIVEFBQUNBQmc4em54b1pXRmtBQUFEUUFBQUFDOEFBQUEyS1A2ZU5XaG9aV0VBQUFOd0FBQUFIZ0FBQUNRR1hnSWthRzEwZUFBQUE1QUFBQUFRQUFBQUVBdWdBSUJzYjJOaEFBQURvQUFBQUFvQUFBQUtBVlFBc20xaGVIQUFBQU9zQUFBQUdBQUFBQ0FBQndBNmJtRnRaUUFBQThRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRW1BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzRTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaFp2Z1A1RE5EcEpIVS9BY0tBd0Q1cHcxZGVOb2Rpb0VKQUNBUUF1OHJtcUFoV3VPcHZXc3prd1E5UklFQ1ZIczQ0N014elc2RzEyUkw3c21TZEhYK3kzcVFYUWp1QUhqYUhaQTliOU5RR0lYdnVXOThiejRjTzZxRGJ5U0lvelJwM0ZSeWdtckxEcFZJRVZFcjZOQ1VGcFdvVkZRTUJWR0pMN1dxT25USVVJUkFNTEFnSVVabVpoWitRQ2NtVmdiWUVEOEJKZUdHOTB6dk16M25NTTdxa3duL3lYK3dObHRrTEVHY0xMcktLYnBoN0lvMnBOL3dvMWk1Y2RKR1ZZcWlxMkpsUWZNcERydElRdnFDZlZITUMzVGQ0QUpNNDJpWU5wRFBPUkZsNUhpeW5yL2s1QWw1NCtIQWhKbVo3WDc0VXozbTJ3Vms3TkhRdGFrc1FRU2V0aVZncWdjclo4VjZBZHkyeEJSbmJZSGFPVGFaUHJCdzhwdHkvRHZyNkljczFMVFpNcUtHYjBFS0cwSjVTTFNtVm9vcjhDQ2s1aTM0Y1RLTnExeVY2QnFVdlVZaW16SEFzZDFmZVhGNTlhSndrVHE5T2I4WFI0RklaYVJCd1dyemVlL2tJOUZXdEhaNHR0V2NGemNzbVB4OC9OZVM0Tkp1N0J3QXZjNWdyN1FiSE4vbm1GMW83Wlp5QURjZlg1OExRZStIcjQ3V29rMUsxZWVzdnNWSnUzUFduSXdvNFY5WmlRVjZZeWYyaFI2MTZrRUpPVTFWL04vWUlkMGpWTk1LeTRqOUZtU3RJVDY5UmM4cjJCZ2Nub0w2QzUyRDRmaHoyYmFXdkY5dlVvRDErdDZKV2lxbFo4QWZyVCtwT0J2OFNvR29yT2Q3OS9UbHM2dkJiU0pQQUE3dmpiN05pQ3hTRzVWYmQ2dDMvUDBkd05acS93QzZ6MVZnQUhqYVkyQmtZR0FBNG4xM0w0Zkg4OXQ4WldCbVlRQ0J4eEc2bGdqNi8wdG1jNmE3UUM0SEF4TklGQUE2bHdxN0FIamFZMkJrWUdCbStNOEFKUDBaVlA1ZllEWm5BSXFnQUJZQVZTb0RpQUFBQW5ZQUFBTUFBQ1FDMndBekEwOEFLUUFBQUFBQVZBQ3lBUUFBQUhqYVkyQmtZR0JnWWJCa1lHSUFBVVlHTkFBQUJuc0FRbmphVFk2eGFzTXdFSVkvVThkUXA5Q3BIVG9VVFJtRmpmc0FnUXlac21Zc0pKRUlEa2dLc21QSUV2b0FmZWhlRkEwOXdmSGRkNytFZ0pvYkJmY3FlRTM5WGlXVlRBK2VNZWN0Y3lWSFphNzVZTUVUUmZrczVwTmw1cElYdmpQUGVPZVV1UkwvazdubWk5OVZjT2ZMYUtQYUJHT2pQempYdDgzV3hxRVBYclc2ZVlpMTlUYnVSbXZVL3FyTTFBL1QwYWxPTjdwalJjQng1c0tJSmNyUE5tSk1ZczlCZG82ZWxvWnRjb05NUVRaS25CYjdQN0dXaEUrcFhYck5TR3JQVmJwaGtzd2cvU2hwUlpmdWFyby8zL1F3dXdBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjEuNjA4NzY1LC02My42NDM4Mjgpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy45MzEyNCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNjA4NzY1LC02My42NDM4Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTYxLjYwODc2NScgeT0nLTYzLjY0MzgyOCc+QzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjYwODc2NSwtNjMuNjQzODI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02MS42MDg3NjUnIHk9Jy02My42NDM4MjgnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuNjI3MDMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjYwODc2NSwtNjMuNjQzODI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02MS42MDg3NjUnIHk9Jy02My42NDM4MjgnPkQ8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguNDg2NzkgMEg0Ny41NzE0OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ny44MjE0OSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1LjY3OTc1LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS42MDg3NjUsLTYzLjY0MzgyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuNjA4NzY1JyB5PSctNjMuNjQzODI4Jz7OsTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03LjQxNjMyLC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjYwODc2NSwtNjMuNjQzODI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02MS42MDg3NjUnIHk9Jy02My42NDM4MjgnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTUwLjQ5ODcyLTYuNDA5NzNMOC41OTE4My00OC4zMDg5NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC43MDcxNSwtMC43MDcwMywwLjcwNzAzLC0wLjcwNzE1LDguNDE1MDQsLTQ4LjQ4NTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMyLjYzMjM3LC0zNS4yMDg5OCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjYwODc2NSwtNjMuNjQzODI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02MS42MDg3NjUnIHk9Jy02My42NDM4MjgnPmg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
          \begin {tikzpicture}[diagram]
            \node  (1) {$C$};
            \node  [below = of 1] (2) {$A$};
            \node  [right = of 1] (3) {$D$};
            \draw  [->,morphism] (1) to node {$\alpha $} (3);
            \draw  [->,morphism] (1) to node[swap] {$g$} (2);
            \draw  [->,morphism] (3) to node {$h$} (2);
          \end {tikzpicture}
        ]]></fr:resource-source></fr:resource></fr:figure>
    
  
        This is precisely a morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{A}}}]]></fr:tex>.
      </html:td>

    </html:tr>

  </html:table>

  <fr:p>Thus, we may take <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> to be the forgetful functor <fr:tex
display="inline"><![CDATA[{{({{\mathcal {C}}_{/{B}}})}_{/{f}}} \to  {{\mathcal {C}}_{/{A}}}]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>