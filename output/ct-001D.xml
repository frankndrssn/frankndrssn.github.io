<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1228</fr:anchor><fr:addr
type="user">ct-001D</fr:addr><fr:route>ct-001D.xml</fr:route><fr:title
text="Heyting categories admit Heyting implications"><fr:link
type="local"
href="ct-0019.xml"
addr="ct-0019"
title="Heyting category">Heyting categories</fr:link> admit <fr:link
type="local"
href="ct-001C.xml"
addr="ct-001C"
title="Heyting implication">Heyting implications</fr:link></fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex> be two subobjects of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in a Heyting category.
  Then the Heyting implication <fr:tex
display="inline"><![CDATA[A_{1} \Rightarrow  A_{2}]]></fr:tex> exists.
  Moreover, for any morphism <fr:tex
display="inline"><![CDATA[f\colon B\to A]]></fr:tex>, <fr:tex
display="inline"><![CDATA[f^{*}(A_{1} \Rightarrow  A_{2}) \cong  f^{*}(A_{1}) \Rightarrow  f^{*}(A_{2})]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>769</fr:anchor><fr:addr
type="machine">#275</fr:addr><fr:route>unstable-275.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Fix a subobject <fr:tex
display="inline"><![CDATA[m\colon A_{1}\rightarrowtail A]]></fr:tex>.
    Recall from <fr:ref
addr="ct-0011"
href="ct-0011.xml"
taxon="Lemma" /> that <fr:tex
display="inline"><![CDATA[A_{1} \cap  (\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]]></fr:tex> may be described as <fr:tex
display="inline"><![CDATA[\exists _{m}m^{*}]]></fr:tex>.
    Then take <fr:tex
display="inline"><![CDATA[A_{1} \Rightarrow  (\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]]></fr:tex> to be the right adjoint of <fr:tex
display="inline"><![CDATA[A_{1} \cap  (\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]]></fr:tex> given as follows:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="d485e6138ca3770ee9491aeaeea909f8"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMxNC41NjE4NzNwdCcgaGVpZ2h0PSc0NC4zODc1NTJwdCcgdmlld0JveD0nLTcyIC03MiAyMDkuNzA3OTE1IDI5LjU5MTcwMSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBJQUFvQUFBQUFCRlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRTBBQUFCZ3FrcGlmV050WVhBQUFBRkVBQUFBTkFBQUFFUWlHQUxMWjJ4NVpnQUFBWGdBQUFEdUFBQUJGTjBFMjZKb1pXRmtBQUFDYUFBQUFDOEFBQUEyS016REcyaG9aV0VBQUFLWUFBQUFIZ0FBQUNRRnV2L1dhRzEwZUFBQUFyZ0FBQUFRQUFBQUVBdVNBTEJzYjJOaEFBQUN5QUFBQUFvQUFBQUtBTG9BWkcxaGVIQUFBQUxVQUFBQUdBQUFBQ0FBQndBZmJtRnRaUUFBQXV3QUFBRE9BQUFCT0JOL0tydHdiM04wQUFBRHZBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUFCQmdZSEdEdWx1Q3lkZ1UySjRVRWlzK0lmSXdZR1prWG1jMEJoUm9UcS8vOFpHQUE3RHcvSEFBQUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUUF1V1VHSlNZSHlUKy80OWczV084KzE5K0VWZ3RHQUFBN1JJTEFYamFYWSt4U3NOUUdJWC84eXMzRFNScFFzMU43NDFGMGtqaVZoQkpObGNkQlRlUlRyNUEzOEJGVVZjUlFRUVg4VkZhSDhGQkhBWEIxYkYvYkZOd2NEcDh3emtmaDVqQzVwdXZlRVk5MGtRdUhPVVVKY3FxMWx2STZuMGtHaW40WEw0VXg3R1NUNGY3RzJxTTQ3R3pzODR5dXJ2bGgvbkVDOWM0NXZ0ZW4xbS9mOFN3a0I5NXhpa1I2S2hwK0pCZmFiQ0FTS3N5VThWZWxXVFJ2NncwSHlBeWNoSlkwOFdqVER5ekdlQkd6bHArTVJFL3phOXRGK2hzZHdDemlnUnU3Z0poNnlId0pVOFhQMXJQc0tqL0ZFVzFxL21pclVqdW0wR0F0eVVzRjczVStzaFhhMFBmcGtUMEM2QnJNem9BQUhqYVkyQmtZR0FBNG0wQ1JvSHgvRFpmR1poWkdFRGdzWkQ5VmdUOS93M3pSS1lUUUM0SEF4TklGQUFJUkFvWEFIamFZMkJrWUdCVy9HTUVKQ2N5Q0REd01YVXdBRVZRQUFzQVF6b0NsUUFBQTVFQUFBS1dBQkFDbGdCUUF0VUFVQUFBQUFBQU1BQmtBSW9BQUhqYVkyQmtZR0JnWVpCallHSUFBVVlHTkFBQUE5Z0FKM2phVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9GUmlZMkZnWW1YcUF0aWdESEdRSFNKRnFqcnl1M3U0SG5yRDZYay83b0NTSHpLZWsvRWE5M055Q2xGL1hQRENXK0twcUVYaWtnK1dUTWp5bVRoek5vbHpTYjRTRjd4elNUd1YvenR4eVNlUGJkZmU3cjMxYXQ4WjY5MjVEZVA2WUgxb09xZFd1b3A2WjUzMXg5NGFkUnFWR1pvd1hGdFY2MHJYYk9sb3VYR254K0pSN01VeGtSMW55UUlqYXc3UkNUU1NPbW10MEZULzhwM2tMbmFPOFpPUnpra1NKVFRJVlpCOWxiYWlqcGVhK2hmemVUQlBBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFQZ0FBb0FBQUFBQkd3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWWgxdTJOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFEQVoyeDVaZ0FBQVdRQUFBRWtBQUFCU05SOVhyOW9aV0ZrQUFBQ2lBQUFBQzhBQUFBMktSZkNJMmhvWldFQUFBSzRBQUFBSHdBQUFDUUhEZ05CYUcxMGVBQUFBdGdBQUFBSUFBQUFDQWJUQURCc2IyTmhBQUFDNEFBQUFBWUFBQUFHQUtRQUFHMWhlSEFBQUFMb0FBQUFGd0FBQUNBQUJBQnZibUZ0WlFBQUF3QUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUQwQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm16bVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBybU11UXlNL3dIOHBraDBraHEvZ09GQWRYYkRUUUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aTUvLzlEeVA5VHdId0dBRll6QnNrQUFBQjQyaldNd1U3Q1FCaUU5Ly9YdHRLRmx0TGRMa3BwS0FnRm1oU1EwZ1lwTGFZYUR4NDBldEFuOE9iUnR6THhCVHo3RkQ2SFYyMVFNOGtrTTVQNUNKRDU5eGY5aEEveVRNaXdnQnhHZ1VGTk5PZ29LR2l5aXFzSW1nRXppQ0JKYzNSa0RtbXlkMGQ2b0trbXFOVXNWSG1hcE1seVgxWHFqNEs0d0tyNXUvOEM0eFRlUTVNaUQ5ZlhvYUYxdVZJVExnYzlyRFBWdEwwK1V6U2RxY0N0V2xCZWFQSmhON25UMjQrWFYyMlhBWEswbWFIVGJ1K3NoYTJhQ2s3ZEdtekhhNkNOb1VBVWsrem15R0NhSzVSRHB5TkF1WC9ON01HU1lwYjczWmRiYmhyUXRLWnY4MGcyaFF1d2kzaUZSUFBjczA5d3V2STNpTlBkb0VSRnR1TkdsS21ianU5YmZTeTJMVVE1bDA1ME1KdlVXZStwWElnRllqa1d4OTQvVkxFSklUOUFnaWRTZU5wallHUmdZQURpMmZtc252SDhObDhabUZrWVFPQ3hrUDFXQlAzL0cvTWR4bU5BTGdjREUwZ1VBQTlNQ25nQWVOcGpZR1JnWUdiNHo4REF3TUxMWU1CZ3lIeUhBU2lDQXBnQU9TNENXQUFDeGdBQUJBMEFNQUFBQUFBQXBBQUFlTnBqWUdSZ1lHQml5R01BMFF4UUVna0FBQXRiQUhRQWVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE5UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MDRXTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ1VaMng1WmdBQUFXUUFBQUNvQUFBQXFML3NEZVZvWldGa0FBQUNEQUFBQUM4QUFBQTJLQnpEUTJob1pXRUFBQUk4QUFBQUhRQUFBQ1FHQndJaWFHMTBlQUFBQWx3QUFBQUlBQUFBQ0FWMkFDUnNiMk5oQUFBQ1pBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSnNBQUFBRmdBQUFDQUFCUUEwYm1GdFpRQUFBb1FBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtMnMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJrWnZnUDVETkRwSkhVL0FjS0F3RG85dzB0ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlPLy85RHlQOEh3SHdHQUZLWEJwMEFBQUFBQWdBay8vOEM0UUxkQUM4QU1nQUFOd0UyTnpJV0Z4TVVGak0yRmdZdkFRY25KaWMwTmhjV05qY3ZBU0VIQmhRV0Z6WVhEZ0V2QVFjbUp6UTJNejRCTnpNRHR3RmxCaFFOQmdFK0ZpMFZBUXdGZElBSUJRRU5DeE0wQXdrSC92OU9EUndURFFNQkRRVm5XQXdCREFraVBwbnJJWFlDVmhBQkNRLzlnQllQQXgwSEFRTURBUUlJRHdjQkFRd1haa1dFRkNRUUFRSVBEZ1lCQXdNQkNnOEdBU1BJQVZJQUFBQjQybU5nWkdCZ0FPS0doeExPOGZ3Mlh4bVlXUmhBNExHUS9WWUUvZjgvMDBPbXUwQXVCd01UU0JRQUlvRUxBUUI0Mm1OZ1pHQmdadmpQQUNJWlZCamttUjR5QUVWUUFCTUFOWXdDTUFBQUFBSjJBQUFEQUFBa0FBQUFBQUJVQUFCNDJtTmdaR0JnWUdJd0JtSVFZR1JBQXdBRnJ3QTZBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQzBBQUFBMktZL0NRMmhvWldFQUFBSkFBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbUFBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDYUFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKd0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGkyb04zMThiejIzeGxZR1poQUlISFF2WmJrV21XVU1ZN1FJcURnUW5FQXdBcUNRbURBQUFBZU5wallHUmdZTmI2WThuQXdCTEswTWZRejVUTUFCUkJBVXdBVW9BRFFnQUVWUUFBQXZJQWpnQUFBQUFBVkFBQWVOcGpZR1JnWUdCaU1HVUEwUXhRRWdrQUFBWEtBRHNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5nQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTno3R050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDZ0FBQUFyS0FDSGFSb1pXRmtBQUFDQkFBQUFDNEFBQUEySjd2Q1oyaG9aV0VBQUFJMEFBQUFId0FBQUNRRWp3RzhhRzEwZUFBQUFsUUFBQUFLQUFBQUNnUkdBR1JzYjJOaEFBQUNZQUFBQUFnQUFBQUlBQ3dBVm0xaGVIQUFBQUpvQUFBQUZ3QUFBQ0FBQlFBWmJtRnRaUUFBQW9BQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRFVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXZNYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWU5Ca1p2Z1A1RE5EcEpIVS9BY0tBd0R2a1EwZWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaRWo1ejhBWXdzekFJTTdBd0NxaXBLYXV4Mml1Wm1adXgyakV6OGpIS000bUpNOG94aGdzbG15b0tjUElLS05tbUNiR3lCUG53Y2prRXMvUC9JMHJLVDVpbGEzVHd0RGtWQjZCeEQvdGxmLytwUWl5TUFBQkk0TWwwRnhOaUxtTVltenNmSXhLcGtCVDFVM1U5Qm5Wek0yTXhNVGxHQmsxd0NhSzhzWjZNUVg3Q0RFek1vcUM3V0dBbXBqMHQzWGhCMThoRmlhd1BRQVZKQ0ZNZU5wallHUmdZQURpenlzbjFjZnoyM3hsWUdaaEFJSEhRdlpiRWZSL0JxWUdaaENYZzRFSlJBRUFMdzRKdGdBQWVOcGpZR1JnWUdiNHo4REF3TlRBWU1sZ3lSakNBQlJCQVV3QU8yd0NVQUFDZ0FBQUFZMEFaQUE1QUFBQUFBQUFBQ3dBVm5qYVkyQmtZR0JnWnBCZ0FORU1VQklKQUFBREVBQWZBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUDBBQW9BQUFBQUJId0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFloMmNHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBREFaMng1WmdBQUFXUUFBQUUxQUFBQldDd3hFcWRvWldGa0FBQUNuQUFBQUM4QUFBQTJLY2pDSTJob1pXRUFBQUxNQUFBQUh3QUFBQ1FINndSSWFHMTBlQUFBQXV3QUFBQUlBQUFBQ0FnOUFGeHNiMk5oQUFBQzlBQUFBQVlBQUFBR0FLd0FBRzFoZUhBQUFBTDhBQUFBRndBQUFDQUFCQUIxYm1GdFpRQUFBeFFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFENUFBQUFCQUFBQUFnQUFNQUFYamFZMkJta1dPY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcm1NdVF5TS93SDhwa2gwa2hxL2dPRkFicjZET29BZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1Fndmk1Ly85RHlQOVR3SHdHQUZZekJza0FBQUI0MmkyTVQwN0NVQmpFKzMwdHIrM2p0YVdsZlVYYUFLWFFCeWdVQkVwWVNQMUQxS2d4Y1dOaW9qdmpCYnlBU3pkdVBJRnJMK0tKWENzbFpDYVp6R1R5azBCNi9QdFZQdUJIZXBXa2JnN1pmSmJFSnFnbVdMSUo3VVRrU2piUEVyR2RZcEdJWkpFVmFnTDNWN0JMNUI2eG9MQkhpblVGVTUvN3JrbzJHb0hJRnNWVEZJM3NxTE1GOW5xTXRNUTBaOGtFNjY2dWh3RUhFbE9ERXJEcnJZU2h6Z3dOd0tiVnhwSVBXRjhObnE2anNUV2l6ZWZQVytTS2IxSVpvMjV1S1RwakdvUkdwYjlPY3dEZEhTSmUzUnpXN0s1R0Job05RZzlLRDEvVHdHNzNVTERPSFhtNWIxWXR4Mm04RDhkRGJ0Z2R3SXNSMVJGcEtRM0RWRUdidUVldE14a3JtbmUrdjhhVDVjRnhlUldGNVVvc3cybHFiWjVsZCtJNnFRTGovcDZUdnFXWHFFeDRiZWI2MzF1d1dwWCtBWGo5S1BrQUFBQjQybU5nWkdCZ0FPSm4vRE5WNC9sdHZqSXdzekNBd0dNaCs2MEkrdjlYbGw3RzQwQXVCd01UU0JRQUcxRUtoUUI0Mm1OZ1pHQmdadmpQd01EQThwSWhoaUdHcFpjQktJSUNtQUJRWEFNOUFBTlVBQUFFNlFCY0FBQUFBQUNzQUFCNDJtTmdaR0JnWUdJb1lRRFJERkFTQ1FBQUMvRUFlZ0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTVFBQW9BQUFBQUEzZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MG8yTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUJZQUFBQVdPYStkQlZvWldGa0FBQUJ2QUFBQUMwQUFBQTJLQTNERUdob1pXRUFBQUhzQUFBQUlBQUFBQ1FGVmdJNWFHMTBlQUFBQWd3QUFBQUlBQUFBQ0FVYUFIQnNiMk5oQUFBQ0ZBQUFBQVlBQUFBR0FDd0FBRzFoZUhBQUFBSWNBQUFBRndBQUFDQUFCQUFiYm1GdFpRQUFBalFBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEQUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd5TS93SDhwa2gwa2hxL2dPRkFkU0JETjhBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy85RHlQOFh3SHdHQUZGSEJvMEFBQUFBQVFCd0FBQUI1QUtwQUJrQUFBRVJCaFk3QVJVdkFROEJOVE15TmljUkRnRW5OUlkyTnpZV0FWY0RJRWtuWjFCd1JpZEpJQU1zVkJRaGRETVZDd0tML2NrYUZTVURBUUlDSlJVYUFnb1VDUUVrQWhZdUFRb0FlTnBqWUdSZ1lBRGkzaTlpOCtQNWJiNHlNTE13Z01CaklmdXR5RFRUWmFhVlFJcURnUW5FQXdBVmR3azdBQUFBZU5wallHUmdZR2I0ejhEQXdIU1pvWUFobWZFSkExQUVCVEFCQUZhYUE1UUMwd0FBQWtjQWNBQUFBQUFBTEFBQWVOcGpZR1JnWUdCaWtHSUEwUXhRRWdrQUFBTW5BQ0FBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktIN2k0T1RpNU9yek5taUFkbWtwYWl5N2lUL2MyQkcvZzhOMXp6ZzJROFNKaG1JUjUwR0ZTZWZQSVkzNVlSSjZJdjRxYzhjdWFFVWs2RTJmRkxuTEtsUC9JWTVhVWtTZmlQeUpuL1BIZU4vWHQzbG12am8yeDNsMXF2ejFaMzFhTlV4dWREK3ZCT3V2UG5UV3FmQ3JUVjIxL3JWV2hjMTJ3cDZIbXhwME9pMGR4Rk1jRWRsd2s4Mnc1aGIybGtzeEpaNE1tLzZZSFNWMW9uTU12UmhvbFQxRkRMemV0NkZXNmlpTGNhWW9QV0t3dVN3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hYZDBnMk50WVhBQUFBRTRBQUFBTXdBQUFFUUFkZ0V5WjJ4NVpnQUFBV3dBQUFFNkFBQUJVQ2lDYjJkb1pXRmtBQUFDcUFBQUFDOEFBQUEySjJYRExHaG9aV0VBQUFMWUFBQUFId0FBQUNRRk53RmdhRzEwZUFBQUF2Z0FBQUFPQUFBQURnYkVBSUZzYjJOaEFBQURDQUFBQUFvQUFBQUtBUG9BaG0xaGVIQUFBQU1VQUFBQUdBQUFBQ0FBQndBeWJtRnRaUUFBQXl3QUFBRFRBQUFCUHFrcmRkdHdiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9HTTVReWMvNEg4cGs1R2RIVS9BY0tBd0M2YWd6cWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VTQ0daSVlTdi8vUjdEK3IvdS80SDhmV0MwWUFBRHVoZ3VpQUhqYVBZNnhUc0pRQUVYZmZWVWFIUXF2RFRVSUZndENvUVlxSmZDQ0dnaXhFVEVHR2pUQjZLSTRxSW5PYXRUTndkRmZjRFh4RTVnNytnTzZPRG00dW9MUEdFM3VjdTRkN2lFZ2hmRUh4dlNOTEJFQ3VRaExnV3hnNWo4Q1ExbUxHK0IxY0RIL0p2dERybzdYY0tMWGFIVkE0N0p1TDNxYktUVU5lblBzWG5qaHRTdHp2UVBNUnRSQ283Q1JYSkZ3ZmNiMzZGTXZsZ050T3lsN1VvdE1NeU9qdGR6ZDJ3a2s4OXVWZVVyOWlsbFNWQmFlTXN4bXMzc3B4UWdobE95TXYvQkpBeEloQ1VJMFZ2OHpFeWJSTk5PaU90ZXJRazVXOE9qMGsrMTlLcDEzeTU3cSs5YXFleUJKL1pMTmFUQjZXWWhCdWo4NnZhT3dWRWNVRCs4ZWhUOFlDTTJjK0FIcGlaOGhBcUlLWU9tS2duUVJuSlZaU0hlcm5HRzRaUjNhZFFjK25UdHBBY0dvVmpMamFOYlFIejJuTW53WitXK25kRUJTQUFCNDJtTmdaR0JnQU9MZUdYNzE4ZncyWHhtWVdSaEE0TEdRL1ZZRS9mOEZreGJUWFNDWGc0RUpKQW9BSUxvS2FRQjQybU5nWkdCZzV2elB3TURBWk1HZ3k2REMrSjhCS0lJQ21BRS9ZQUtjQUFJcUFBQUNPQUF0QWhBQVZBQlNBQUFBQUFBQUFGSUFoZ0NvQUFCNDJtTmdaR0JnWUdFd1pHQmlBQUZHQmpRQUFBV3pBRHA0MmsyT3NXckRNQkNHUDFQYlVMZlFxUjA2RkUwWmhZMzdBSVVNbWJKbUxDU1JNQzVZRHBKajhGTDZBSG5vWEJRTnZZT2ZULy85ZHdpbytDWGpWaGt2VVcrVlU4cnJ6Z1ZQdkNZdXBWWGlpbmRXUEpEbGorSjg4SlU0NTVudnhBVnYvQ1F1eGY5TFhQSEpaVDBPcC9Oa3ZkcU94bnAzSEVKbzZwMzFvUitkYW5SOU56YldXYitmckZHSFJabTVEM00zcUZiWHVtWE55TUNKTXhNV0x6L2JpbU1pTzQ0eUM5SU5OYnZvQlhxWk84azFhSEgvSnphU2NERzFqOWVNcEE0c29vWlo5b0pvSjNsRkczYzE3UlgrQ0REN0FIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3MxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTIuMTg1NDA4LC01Ny4yMDQxNTUpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTUuNTgzMzYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUyLjE4NTQwOCwtNTcuMjA0MTU1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01Mi4xODU0MDgnIHk9Jy01Ny4yMDQxNTUnPlN1YjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzYuMzU1ODUzJyB5PSctNTcuMjA0MTU1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zMi40ODE0NzknIHk9Jy01Ny4yMDQxNTUnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTI1LjAwOTQ4JyB5PSctNTcuMjA0MTU1Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDY3LjUzMTgzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Mi4xODU0MDgsLTU3LjIwNDE1NSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTIuMTg1NDA4JyB5PSctNTcuMjA0MTU1Jz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM2LjM1NTg1MycgeT0nLTU3LjIwNDE1NSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzIuNDgxNDc5JyB5PSctNTcuMjA0MTU1Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0yNS4wMDk0OCcgeT0nLTU1LjcwOTc3NCc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjAuNTQwMTExJyB5PSctNTcuMjA0MTU1Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE1NS4xMzMxNiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuMTg1NDA4LC01Ny4yMDQxNTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUyLjE4NTQwOCcgeT0nLTU3LjIwNDE1NSc+U3ViPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zNi4zNTU4NTMnIHk9Jy01Ny4yMDQxNTUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMyLjQ4MTQ3OScgeT0nLTU3LjIwNDE1NSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjUuMDA5NDgnIHk9Jy01Ny4yMDQxNTUnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTIwLjEzODktMy42MTY2Mkg2Mi40NzYyOScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2Mi43MjYyOSwtMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzUuOTE5MjQsLTExLjc3MjU4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuMTg1NDA4LC01Ny4yMDQxNTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUyLjE4NTQwOCcgeT0nLTU3LjIwNDE1NSc+bTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDUuMTE1ODAyJyB5PSctNjAuMjEwNjcyJz7iiJc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwNy43NDAyMy0zLjYxNjYySDE1MC4wNzc2MicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNTAuMzI3NjIsLTMuNjE2NjIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEyMy41NzQ5NywtMTEuMjg5NTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Mi4xODU0MDgsLTU3LjIwNDE1NSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTIuMTg1NDA4JyB5PSctNTcuMjA0MTU1Jz7iiIA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQ3LjY3NDUyMycgeT0nLTU2LjIwNzg5MSc+bTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNjIuOTc2MjkgMy42MTY2MkgyMC42Mzg5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDIwLjM4ODksMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzUuOTczNjUsNy40Mjg0NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUyLjE4NTQwOCwtNTcuMjA0MTU1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01Mi4xODU0MDgnIHk9Jy01Ny4yMDQxNTUnPuKIgzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuNjc0NTIzJyB5PSctNTYuMjA3ODkxJz5tPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xNTAuNTc3NjIgMy42MTY2MkgxMDguMjQwMjMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTA3Ljk5MDIzLDMuNjE2NjIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEyMy41MjA1OCw2LjQyODQ0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuMTg1NDA4LC01Ny4yMDQxNTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUyLjE4NTQwOCcgeT0nLTU3LjIwNDE1NSc+bTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDUuMTE1ODAyJyB5PSctNjAuMjEwNjcyJz7iiJc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwzOS44MDc2LDIuNDc5MTcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Mi4xODU0MDgsLTU3LjIwNDE1NSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTIuMTg1NDA4JyB5PSctNTcuMjA0MTU1Jz7ugaE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwxMjcuNDA4OTQsMi40NzkxNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUyLjE4NTQwOCwtNTcuMjA0MTU1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01Mi4xODU0MDgnIHk9Jy01Ny4yMDQxNTUnPu6BoTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram,node distance=3cm]
      \node  (1) {$\mathsf {Sub}(A)$};
      \node  [right = of 1] (2) {$\mathsf {Sub}(A_{1})$};
      \node  [right = of 2] (3) {$\mathsf {Sub}(A)$};
      \draw  [->,morphism,offset=1.5] (1) to node[swap] (r1) {$m^{*}$} (2);
      \draw  [->,morphism,offset=1.5] (2) to node[swap] (r2) {$\forall _{m}$} (3);
      \draw  [->,morphism,offset=1.5] (2) to node[swap] (l1) {$\exists _{m}$} (1);
      \draw  [->,morphism,offset=1.5] (3) to node[swap] (l2) {$m^{*}$} (2);
      \draw  [adjoint] (l1) to (r1);
      \draw  [adjoint] (l2) to (r2);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Then for any subobject <fr:tex
display="inline"><![CDATA[A_{2} \in  \mathsf {Sub}(A)]]></fr:tex> the counit of the adjunction <fr:tex
display="inline"><![CDATA[\varepsilon _{A_{2}}\colon A_{1} \cap  (A_{1} \Rightarrow  A_{2})\to A_{2}]]></fr:tex> says precisely that <fr:tex
display="inline"><![CDATA[A_{1} \cap  (A_{1} \Rightarrow  A_{2})]]></fr:tex> is contained in <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex>.
    And <fr:tex
display="inline"><![CDATA[A_{1} \Rightarrow  A_{2}]]></fr:tex> is the largest such subobject by the universal property of right adjoint.</fr:p>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon B\to A]]></fr:tex> be a morphism.
    Form the following pullback.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="df2f19104d0877879b80bdbc2d53a81b"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzNC4xMjQ0NzhwdCcgaGVpZ2h0PScxMTYuOTM2MzY5cHQnIHZpZXdCb3g9Jy03MiAtNzIgODkuNDE2MzE5IDc3Ljk1NzU3OSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTVFBQW9BQUFBQUEzZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MG8yTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUJZQUFBQVdPYStkQlZvWldGa0FBQUJ2QUFBQUMwQUFBQTJLQTNDK21ob1pXRUFBQUhzQUFBQUlBQUFBQ1FGVmdJNWFHMTBlQUFBQWd3QUFBQUlBQUFBQ0FVYUFIQnNiMk5oQUFBQ0ZBQUFBQVlBQUFBR0FDd0FBRzFoZUhBQUFBSWNBQUFBRndBQUFDQUFCQUFiYm1GdFpRQUFBalFBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEQUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd5TS93SDhwa2gwa2hxL2dPRkFkU0JETjhBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy85RHlQOFh3SHdHQUZGSEJvMEFBQUFBQVFCd0FBQUI1QUtwQUJrQUFBRVJCaFk3QVJVdkFROEJOVE15TmljUkRnRW5OUlkyTnpZV0FWY0RJRWtuWjFCd1JpZEpJQU1zVkJRaGRETVZDd0tML2NrYUZTVURBUUlDSlJVYUFnb1VDUUVrQWhZdUFRb0FlTnBqWUdSZ1lBRGkzaTlpcCtQNWJiNHlNTE13Z01CaklmdFZ5RFRUWmFhVlFJcURnUW5FQXdBYTRRbFJBQUFBZU5wallHUmdZR2I0ejhEQXdIU1pvWUFobWZFSkExQUVCVEFCQUZhYUE1UUMwd0FBQWtjQWNBQUFBQUFBTEFBQWVOcGpZR1JnWUdCaWtHSUEwUXhRRWdrQUFBTW5BQ0FBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktIN2k0T1RpNU9yek5taUFkbWtwYWl5N2lUL2MyQkcvZzhOMXp6ZzJROFNKaG1JUjUwR0ZTZWZQSVkzNVlSSjZJdjRxYzhjdWFFVWs2RTJmRkxuTEtsUC9JWTVhVWtTZmlQeUpuL1BIZU4vWHQzbG12am8yeDNsMXF2ejFaMzFhTlV4dWREK3ZCT3V2UG5UV3FmQ3JUVjIxL3JWV2hjMTJ3cDZIbXhwME9pMGR4Rk1jRWRsd2s4Mnc1aGIybGtzeEpaNE1tLzZZSFNWMW9uTU12UmhvbFQxRkRMemV0NkZXNmlpTGNhWW9QV0t3dVN3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmdBQW9BQUFBQUE5UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFVOejdHTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUNnQUFBQXJLQUNIYVJvWldGa0FBQUNCQUFBQUM0QUFBQTJKN3ZDVVdob1pXRUFBQUkwQUFBQUh3QUFBQ1FFandHOGFHMTBlQUFBQWxRQUFBQUtBQUFBQ2dSR0FHUnNiMk5oQUFBQ1lBQUFBQWdBQUFBSUFDd0FWbTFoZUhBQUFBSm9BQUFBRndBQUFDQUFCUUFaYm1GdFpRQUFBb0FBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFEVUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtdk1jNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwVFVZTkJrWnZnUDVETkRwSkhVL0FjS0F3RHZrUTBlZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pFajV6OEFZd3N6QUlNN0F3Q3FpcEthdXgyaXVabVp1eDJqRXo4akhLTTRtSk04b3hoZ3NsbXlvS2NQSUtLTm1tQ2JHeUJQbndjamtFcy9QL0kwcktUNWlsYTNUd3REa1ZCNkJ4RC90bGYvK3BRaXlNQUFCSTRNbDBGeE5pTG1NWW16c2ZJeEtwa0JUMVUzVTlCblZ6TTJNeE1UbEdCazF3Q2FLOHNaNk1RWDdDREV6TW9xQzdXR0FtcGowdDNYaEIxOGhGaWF3UFFBVkpDRk1lTnBqWUdSZ1lBRGl6eXNuclk3bnQvbkt3TXpDQUFLUGhleFhJZWovREV3TnpDQXVCd01UaUFJQU5IZ0p6QUFBZU5wallHUmdZR2I0ejhEQXdOVEFZTWxneVJqQ0FCUkJBVXdBTzJ3Q1VBQUNnQUFBQVkwQVpBQTVBQUFBQUFBQUFDd0FWbmphWTJCa1lHQmdacEJnQU5FTVVCSUpBQUFERUFBZkFIamFSWXd4YjhJd0VJVy9pQVNKZE9oU2RXQUFEOHhXb2pCM1lXQmlaV0lCYktJTWNaQVRJaUdoanYzZFBZd2xibmo2N3IxM0IrVDhrdkNjaE0rZ3owbkpaSHR4eGdkZmthZXlMU1BuekZreElVbG40aXo0aVp4S2NvaWM4YzBsOGxUOFIrU2NOWCticnIzZUJ1dlZyalBXdTNQcnkySnZmZDkwVHBXNkNQdldPdXVQZ3pYcWRGZG1iUHF4YmxXbEMxMnhvYVBseW8wQmkwZXhFOGNFZHB3bDg1UVU3SVBUMDBqcXBGV2l4WDNuVzhsZDZCekRKeU9kRTNkUnd5aFh2V2d0YlVVVkxqWFZQMk05THc4QUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOa0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUNVUTJOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2RBQUFBcVA1ZC95Vm9aV0ZrQUFBQ0RBQUFBQzBBQUFBMktNdkNMV2hvWldFQUFBSThBQUFBSGdBQUFDUUZlUUFpYUcxMGVBQUFBbHdBQUFBSUFBQUFDQVhvQUZ0c2IyTmhBQUFDWkFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKc0FBQUFGd0FBQUNBQUJBQTNibUZ0WlFBQUFvUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQURWQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm0rc0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzK0lmSXdZR1prWG1jMEJoUm9UUy8vOFpHQUFoNGc3V0FBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFOY2s5Q3NJd0dBYmc3MDF0MnNhUUdHaXNnNlNnYURjTDFiYURZSEYyY3BaTzNzQnI2Q1lpT0hzc2IrS2c0TS82UEFUYTBSaFBQS2drbWlRT2xnYzhSd3FGMFRTck5adG1pNnBCTmtOWjFVV0tuSzB3ZDlCb1dEK0plWUROTFZUTWNYNlJQbXhzWVU0eWNrenA4OGVGUFBxQ3dZcEVzTjV2WG11dnE1Mkh6djVRR0tYTXZRM2hPU1Y1ODQyb1hXNEhSbUdvci8raE54V0lGWEFBQUFCNDJtTmdaR0JnQU9MRFgvMTE0L2x0dmpJd3N6Q0F3R01oKzFYSU5QTkV4anRBaW9PQkNjUURBQkxkQ1JRQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWtRenhERCtaZ0NLb0FBbUFGalFBNTRBQUFPUkFBQUNWd0JiQUFBQUFBQlVBQUI0Mm1OZ1pHQmdZR0l3WXdEUkRGQVNDUUFBQmVNQVBBQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV01BQW9BQUFBQUJ4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFlGMUpXTnRZWEFBQUFFNEFBQUFOUUFBQUR3QWh3QytaMng1WmdBQUFYQUFBQUsxQUFBRDRQcGJlTHRvWldGa0FBQUVLQUFBQUM4QUFBQTJLUmZDVDJob1pXRUFBQVJZQUFBQUlBQUFBQ1FIQ3dMamFHMTBlQUFBQkhnQUFBQVVBQUFBRkE0YUFOZHNiMk5oQUFBRWpBQUFBQXdBQUFBTUFkNEN4RzFoZUhBQUFBU1lBQUFBR0FBQUFDQUFDQUJ2Ym1GdFpRQUFCTEFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGZ0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNRNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUk1ZOGhqWnZnUDVETkRwSkhVL0FjS0F3RDY1ZzJXZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpQay9mOFA1S2N4NVA3Ly8zLzIvMmxnVlVBQUFKbThDVDhBQUFCNDJuMlN6V3NUUVJUQTU3MUpkcHRzc3BQOW1tM1R6VGJKSnJ0SjAyNlNKdG5ZTnMxSFU1RmFzVlhCV0JFOTZVRVFCQkZFOEYvd0lCNjg2bG53TEhnczNyMzdieWg0YVoya2xvTFE3c0RDdkRmemVML2ZHd0prNzZTT1QvRUhHUklDbElFa3F5QVgvYUFQTFc1elNlWkwwSWNCOVNRL3NsdDk2SXI0R3JkVjhQekFqN3ArSFZSazBJcTRGTURIalV3c2swMk1tcFVOZ0pMbFUyQkxqTEZTZ2VaQ2RzTkZnOTFpbHNxM3ZXb1B3T01pbjNFWjAzVTNPWmQ5TkUzRCsrT2o2OXF3Ylk2cDc3bDVMRW1Ca2tDSTdWa2ZmazFvVVliSjRXTGdsMHZuS1Zqd1Y5L0dpbk5BeElkazVXUVZ5M0JFUWpLZTBnZ1NhVVlpT2pZbDJlWXRIZ21BZ1lBTUlZaTYwK1dDTGFqRUFUcUFLQkJRa2p4VndPMjE2VkVzUEUrOGVGVi9HQlA5YWh4VTNkRUtaczl6dUd4M2QwZUhTRWRNMnoyc2ROSTBxNmN0ZUZlbllGcnQ3RGh2WlRUd0EzZmJTY253K25oVXYwL1JXc2tWREVOeGszRUV4VmxvNUIrMFlqQTVlSHpUWURzVVNqekRJYU1kLy9uS2xMSVhnMHJISHczM3UxRE9zN1JnQTlJNCtVMS93bmZ5akpEeVFNekVEMVRLVUtWK01LQlJweTIySVBxdVF3aWljZVJUcW1qMjU3WXJQSnhPMXBLbVhGRnJGaEpMRExvOVFCSDVkLzIwWUxzTDMycU1vbGxiMzZ1cGNzNk1KeXpIaEdRdHBVak1jSXRLWEU0cUVwaGFJaGp2eVBaa1dMMmRuTDkzOWRxOG93Q2FhQ2hxa3VieUd6cnFDUWw0U3ZPMkt1dEEwMlVMMGFyMjloZFVSWGFzK0J4ZnRDQis1M1BQOEZvVWUvMUM3dVdCeVZRaFlmbExJN1F6bGdNd0RFMVJFdG5JTlVxNDNDbHNJaTRQdlRIRzdmbDJPdXhKbTR1RmdsYkV3WmFPYURkc0hzYnExWlNTZnpKdVdrM0VjY1hLdW1kRjR3WTU4NGlmaE1kOVFpNFRkNWt3bUQyZDh3Rzh1VkRNeWwwNkZaSktKNm1UMzlSUlMwcGdLNXJYcjF3Qm1tS2M0LytTUjVleGg3c1hNNWUyeDAzOVA1SGtMOE9HZmlzQUFBQjQybU5nWkdCZ0FHTGJZOXQyeC9QYmZHVmdabUVBZ2NkQzlxc1E5SDlkNWp0TUY0RmNEZ1lta0NnQU1na0t3UUI0Mm1OZ1pHQmdadmpQd01EQXdzdWc4LzhDOHgwR29BZ0tZQVVBVzhvRDlRTEdBQUFDT2dCTEFqb0FMQVFOQURBQzB3QXdBQUFBQUFCbUFOUUJlQUh3ZU5wallHUmdZR0JseUdOZ1lnQUJSZ1kwQUFBTHd3QjRlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUzhBQW9BQUFBQUJXd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MDUyTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QW5RQjdaMng1WmdBQUFXd0FBQUhxQUFBQ0xMbEdXV2hvWldGa0FBQURXQUFBQUM4QUFBQTJLRUhDWEdob1pXRUFBQU9JQUFBQUhnQUFBQ1FHTFFITmFHMTBlQUFBQTZnQUFBQVFBQUFBRUFwekFJVnNiMk5oQUFBRHVBQUFBQW9BQUFBS0FXb0FzRzFoZUhBQUFBUEVBQUFBR0FBQUFDQUFDQUJDYm1GdFpRQUFBOXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFc0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtbXNNNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaRWhqWnZnUDVETkRwSkhVL0FjS0F3RGg1UTB6ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pHay9mOFA1RHVDNlA4SC9zOEZxd0lDQUpSZkNSSUFBSGphTmRFeGI5TkFGQWZ3KzkvRjV5VFlQaFBIZHF2RVNSeW5OaW9pS1hXdzJ3b01hbWhBclJJVktsQ0hTa2hJMEEwaDFCYllNblNFQ1lFRUN3c2JINEFCSmlZK0FDc0RZdVF6Sk9GY2ladnUvdThOdjNlUFVOS1p6K2x2K292MHlDb2hLWkowMVhHdHFoTW5EdTlCamNLb243aE9rdmJncTd6cXVJbHJRT1o1SEdkSVkvWUZqM2hWNThpY1N6WTA1V2hTVktDZnMvcXNwTTdtWTcxdTZReTZjcml2UVN1MXMvZC8vUk42MzBSSlRDZU9ZSjRLeGtDTFFnVTA5L0hXYWJWamdncUQ1M0ZaY0FRL2NKZkl3OGpGK1pSeCtvMDB5REpaazFLckgwUmMydndHYkFOcUF5NFg0S3JQejd4V2prdkNLQWk1eXY3Zm1XeUlQNzJ1Ulo0UTJEOTR5Q1o3TzN1Z3Q4elI4ZXhOM1RBMkdoL2ZQVGlpNkE1T201Ynk1TlhCQ2FVcnQ3OFBDNEN4UzlmUFUxWlhRZTlzYkIrSzhuaDlaOVBJQ3ZrRXNMREZuZzA3TnluRTR2UXplejVlMm1XelB4VmVKZ1FrbVhmcEZmcVQzSkNQSEtCS2JEdU1Nc1R5b3gwdTRhbmtXVUh1anE4amd5dHpBNEhzQ1pPMEM1V3JYTkI4SFJGZVpJWWlYT1BxY2lzQkFsdllvRzVnZW9VbzFFWUR6eFREaGZMaXVPWW5GRzFiT01CQ1N6UUx2bENLbW4ydkJsUGd3K3pyd0xwMnVibEpPNEhYcWxUMHNDQlh4NTZPOEpaNUhDOHZiSy9Rb0hOV1dWTHlTbE1QMTQ3enNRbjVCeGtuVklJQUFIamFZMkJrWUdBQTRnYVBrdi94L0RaZkdaaFpHRURnc1pEOUtnVDlYNCtaamVrdWtNdkJ3QVFTQlFBZHRnbS9BSGphWTJCa1lHQm0rTThBSkRrWVZQNGZZR1pqQUlxZ0FCWUFTVWdEQUFBQUFuWUFBQU1BQUNRRENBQXJBZlVBTmdBQUFBQUFWQUN3QVJZQUFIamFZMkJrWUdCZ1lYQmtZR1lBQVVZR05BQUFCMW9BUzNqYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01Mi42MDA0OTMsLTYyLjI4NzgyOSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNS4xNjY3MiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNjAwNDkzLC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUyLjYwMDQ5MycgeT0nLTYyLjI4NzgyOSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNDYuNjUwNTQ2JyB5PSctNjUuOTAzMTkzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQyLjA3MDQ5MicgeT0nLTYyLjI4NzgyOSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMzguMTk2MTE4JyB5PSctNjIuMjg3ODI5Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0zMC43MjQxMTknIHk9Jy02MC43OTM0NDgnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTI2LjI1NDc0OScgeT0nLTYyLjI4NzgyOSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNC4wNDM0LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNjAwNDkzLC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUyLjYwMDQ5MycgeT0nLTYyLjI4NzgyOSc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC0xMS4xMDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwwLjAsLTExLjM1OTczKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04LjIwNzIxLC0zMC41MzYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUyLjYwMDQ5MywtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01Mi42MDA0OTMnIHk9Jy02Mi4yODc4MjknPm48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTAuOTEyNDMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUyLjYwMDQ5MywtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01Mi42MDA0OTMnIHk9Jy02Mi4yODc4MjknPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ1LjEyODQ5NCcgeT0nLTYwLjc5MzQ0OCc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1My4xNTU1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNjAwNDkzLC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUyLjYwMDQ5MycgeT0nLTYyLjI4NzgyOSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTkuNzIyMjYgMEg0NS44NTY4OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni4xMDY4OSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMwLjk2MzM1LDQuMTcyOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUyLjYwMDQ5MywtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01Mi42MDA0OTMnIHk9Jy02Mi4yODc4MjknPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtMTAuMTA5N1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCw1Ni45MDU1LC0xMC4zNTk3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMzAuMDM2MDcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Mi42MDA0OTMsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTIuNjAwNDkzJyB5PSctNjIuMjg3ODI5Jz5tPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjU5ODk0LTU2LjkwNTVINDguMDk5OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMzQ5OTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI2LjI1NzQsLTY0LjU3ODQxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNjAwNDkzLC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTUyLjYwMDQ5MycgeT0nLTYyLjI4NzgyOSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = {f^{*}(A_{1})},
      nw/style = {pullback},
      ne = {A_{1}},
      sw = B,
      se = A,
      north = g,
      east = m,
      east/style = {>->},
      south = f,
      west = {n},
      west/style = {>->},
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Then by <fr:link
type="local"
href="ct-001A.xml"
addr="ct-001A"
title="Beck-Chevalley condition">Beck-Chevalley</fr:link> condition we have</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {aligned}       f^{*}(A_{1} \Rightarrow  A_{2}) &:= f^{*}\forall _{m}m^{*}(A_{2})\\                                       &\cong  \forall _{n}g^{*}m^{*}(A_{2}) && \text {since $mg = fn$}\\                                       &\cong  \forall _{n}n^{*}f^{*}(A_{2})\\                                       &=: f^{*}(A_{1}) \Rightarrow  f^{*}(A_{2})     \end {aligned}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1229</fr:anchor><fr:addr
type="user">fnd-000A</fr:addr><fr:route>fnd-000A.xml</fr:route><fr:title
text="Heyting category">Heyting category</fr:title><fr:taxon>Section</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="frankndrssn.xml"
addr="frankndrssn"
title="Frank Tsai">Frank Tsai</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>764</fr:anchor><fr:addr
type="user">ct-0019</fr:addr><fr:route>ct-0019.xml</fr:route><fr:title
text="Heyting category">Heyting category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="ct-000X.xml"
addr="ct-000X"
title="Coherent category">coherent category</fr:link> <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a <fr:em><fr:strong>Heyting category</fr:strong></fr:em> if for every morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the pullback functor <fr:tex
display="inline"><![CDATA[f^{*}\colon \mathsf {Sub}(B)\to \mathsf {Sub}(A)]]></fr:tex> admits a right adjoint <fr:tex
display="inline"><![CDATA[\forall _{f}\colon \mathsf {Sub}(A)\to \mathsf {Sub}(B)]]></fr:tex>.
  A <fr:em><fr:strong>Heyting functor</fr:strong></fr:em> between Heyting categories is a coherent functor such that for any morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> and any subobject <fr:tex
display="inline"><![CDATA[m\colon A'\rightarrowtail A]]></fr:tex>, <fr:tex
display="inline"><![CDATA[F\forall _{f}(m) \cong  \forall _{Ff}(Fm)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(FB)]]></fr:tex>.
  Note that this definition makes sense since coherent functors preserve monomorphisms.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>765</fr:anchor><fr:addr
type="user">ct-001A</fr:addr><fr:route>ct-001A.xml</fr:route><fr:title
text="Beck-Chevalley condition">Beck-Chevalley condition</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-0019.xml"
addr="ct-0019"
title="Heyting category">Heyting category</fr:link> and the following square be a pullback in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="d804ae405338fd0a02688b09c61d7252"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNy40MDc2NTZwdCcgaGVpZ2h0PScxMTQuOTAyMzMxcHQnIHZpZXdCb3g9Jy03MiAtNzIgNzguMjcxNzcxIDc2LjYwMTU1NCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdVQUFvQUFBQUFCdGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjB4Mk50WVhBQUFBRTRBQUFBTWdBQUFEd0FnZ0RDWjJ4NVpnQUFBV3dBQUFMQ0FBQURuUEtyWjJSb1pXRmtBQUFFTUFBQUFDOEFBQUEyS0FIQ1dXaG9aV0VBQUFSZ0FBQUFJQUFBQUNRRnFnR2NhRzEwZUFBQUJJQUFBQUFVQUFBQUZBeFVBUkZzYjJOaEFBQUVsQUFBQUF3QUFBQU1BYTRDb20xaGVIQUFBQVNnQUFBQUdBQUFBQ0FBQ0FCWWJtRnRaUUFBQkxnQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRmlBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUttZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTVdRek0vd0g4cGtoMGtocS9nT0ZBZG1BRFRnQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS1pqQmsvLzhQNUtlQjZQK3ovODhFcXdJQ0FKbU5DVDRBQUhqYWJkTkxiOU5BRUFkd3o2d2ZzUk43NDllNlRWSTNpWjExcXFaSjI2Uk9XMExhTkFXcDd4WUpTaEdDRXlCeFF1S0NRT0lUSUlRUUI2N2MrQXJjSy9YTWh3R0pTOHVhOGpoUTcyMW5EL09iLzFnQ2FlZWlnMC94cTdRdVNVQW9xSm9GV3AwblEraXlnS2thbTRZaHJKRkk1V25RSFVKZjNDK3l3SUtJSnp6dDh3NVlTS0diTWpXQlQ2dEZ1VmpTUnd2TlZZRFk1d1RvTktVMHJwR3BOdDBOMGFWSDFMZllSalF6QUlpWXFCZERTaDBuTkhLbGgxa1pQcHlmYnR2clBXOU1lQlJXTVZhVHZJNGc3L2dmdngyVHVnYkhKK1dFTitKL0paamtjMi9sZWc0azhhSFV1cGpEQnB4S2JXbWNhWVJFL1NVUkhYdXFGckF1U3dWZ1RTRGJrS1Q5N0lRUUNKVjRRTllnVFFSSzFiSVJzR0F4ZTRxMVovcnpGNTBIc3VqWFptQTVGYnZtRGFJSzA0TCsxdWdFeVlqYVd5Zk5KWk9VSE5PSDl4MENudDhyamF0KzBRYWVoQnVWZ2dZdnowZWRld1Q5MWxUTmRmT2hvU0RrSzVQejFmdGRHWTRQSCsyN2RKTkF6SW9NaXZiNWp5ODAzNGhrYUM3eDBmcEJIeHBWYWdvYlNIc1gzL0VWbmtrN21VeTBIS0ttWHNibHExbXphVGNJaFZjY2tWNVBZREllVDdJWlVGbmsxWWFsdmpzRUhsMkcyMCtaQnFQOXlxMlZtNzBDb0lkdXdUUklaWHJnb0cyb0VPVHRhTmhjQm1KYWpDR3k1dUJ3Z2lwdVZjOFpnZTdZeWpzWmFhd1hBU3h0czlVQS9IeCtWdXVDMHVtWjdZRjZyVnlyMlhWY3UrNGdCdk1CYTh1ZG1VSytHbStNRi93RnhIR1Q1YmRmOHpMTmcyc3kzRFNwSVJzMHA4bWs4TnQ1UXpqdlpNNHNnMFhtLzEwM29jM01ZalBGOFNqeFdIQzVrOW5GSHp6dnA0bklsNElGZFg0Rit2SDAzZVRvTmhjakZ5c1lWQzF2OWlEaHdVUzFSK204akVRQjZ2RlpnMmlHcmdJVURhK3lrb3dSRkFLd3ZSeFJPZUJYOFo5WXU0Mmxsb0JqYk1VNUMyQ1YxenpSZ3FLekZVTTN5Njc0a2VTOW1CcUlodEl1VjlweU43VWNTMjBteXB0VlorSy9RVWpTVHd5d2RSSUFBSGphWTJCa1lHQUE0akN1ZTF2aitXMitNakN6TUlEQVl5SDc5UWo2dnk3VE1hYUxRQzRIQXhOSUZBQWJFd296QUhqYVkyQmtZR0JtK00vQXdNQjBqRUhuL3dXbWFnYWdDQXBnQlFCbVlBUktBc1lBQUFJNkFFc0NPZ0FzQXF3QVRRSnVBRTBBQUFBQUFHWUExQUZJQWM1NDJtTmdaR0JnWUdVSVoyQmlBQUZHQmpRQUFBbUVBR0Y0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVWtBQW9BQUFBQUJmUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUYyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1haMng1WmdBQUFXUUFBQUpZQUFBQ3VKSGpjY2xvWldGa0FBQUR2QUFBQUM4QUFBQTJLSExESVdob1pXRUFBQVBzQUFBQUhnQUFBQ1FHWGdJbGFHMTBlQUFBQkF3QUFBQVVBQUFBRkE2b0FLdHNiMk5oQUFBRUlBQUFBQXdBQUFBTUFXSUNERzFoZUhBQUFBUXNBQUFBR0FBQUFDQUFDUUE2Ym1GdFpRQUFCRVFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGR0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtZXNjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJoWnZnUDVETkRwSkhVL0FjS0F3RDcxUTFqZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1Fndmd1Ly84RFNjZi8vLzhmQVBNWkFGTEtCcUI0MmpYUnYwOFRZUnpIOGVmemZOdm5hR252S2xmdWFxRFhsSlllWUZvSXZkd0JpY1ZRcVFpeC9LaEJnbzFFRXlTU2lEOUFaR0RvZ0RFYUdJd0ppWEZ3ME0wNHV6ZzVNVG01T3FpVDhVOHdiWDJPaE9kWm5ueHp3L3Y3T3NaWnR0M21QL2tQTnN4R0dmUGdlcU9HcWNlTm9tdUlZU2gyem5aYzAzQzlZYVFWRVRkTTExUWg1LzY0V0lKWHBNOVlGL0dvUU1uSWR5TVMzR2wwQkJIdDFCMEtLYTEyTmRxclJ3blI0TVpLQkpGUVgrbk4zL1F1WDQ0aHBEVWJoa1pKQlVUZ0hab0NSTXk3MHdmeGJBeGNVNFUvRG1zQ21STXNNWG1JWFdnM1NmQXZ6R0pEYkV5VzZrN0dGckl0YmFGYmhXTEJGQnFFa2hhbnZib2Y1K2JzVEU0b2RQWW0rVUh4dzFHUG5kUTByTlR2VUtNMlZ3Ty9FcnYycFBXNlYxVW5ySGZIYXpzY2hmSkJTZzl1SGRaM09SK1orVm9KQU9vQ0h6L0hxVmNCWDV5WTNkREMxZkc1S2JVVThEZUFqbWw2WE1sZTV0RE9Oei9TMDJyL0FyVitkNGt3WTJERjloL3E1Ti85WnBDS2pCU2RoSk96WmJNZmJGcndKSzlmbUlJbEY1RHpBbXpYODY5aEdxWW4xNkh3SlJMaFVCQWN5L1BUejBZcVBjSkFZUC9xd0pycjVFVWdwQVFwWHhsOFZONTdTMVJ6WnJjUGFvTURZa1pGaEorMC9xbXlXZEZ5cTV0QWVXeGxMVkhQNzk3bTZCc3ExQk9kQUkvY24rb3ZnbzRiTDNabW5TVUtaUHZWZVpXVE5PZHNVSnA3MGp6QjhyNjRld1p1Q3NXL1o5YW5ycWEvd2lSY3V3QkZxcjgvUXRtS1NlYnRmZEQ4ME5obW8vVXBxVW5pWDRjKzU4dGJlK1pFb3FNTC9GNTFLNlZMM1JoUlV2NzJWdytlUDd5WXYwNWtDUW5MeTgxdjBoR0JoZFRpemZRTmUzMFYwR1RhZi9RQmQxZDQybU5nWkdCZ0FPTGpBbGFlOGZ3Mlh4bVlXUmhBNExHUS9Yb0UvZjhsc3puVFhTQ1hnNEVKSkFvQUJtNEoxQUI0Mm1OZ1pHQmdadmpQQUNUOUdWVCtYMkEyWndDS29BQldBRlVyQTRrQUFBSjJBQUFEQUFBa0F3Z0FLd0xiQURNRFR3QXBBQUFBQUFCVUFMQUJEZ0ZjZU5wallHUmdZR0Jsc0dSZ1pnQUJSZ1kwQUFBR3JRQkVlTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02MS4zNDIwMzUnIHk9Jy02MS44MDM1Myc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy45MzEyNCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTcuNjg0MDUsLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPms8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuNjI3MDMsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02MS4zNDIwMzUnIHk9Jy02MS44MDM1Myc+RDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NCAwSDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY1MTgsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5oPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjQ4Njc5LTU2LjkwNTVINDcuNTcxNDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuODIxNDksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI2LjIwMjkxLC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = A,
    nw/style = {pullback},
    ne = B,
    sw = C,
    se = D,
    north = h,
    south = g,
    west = k,
    east = f,
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Then the following square commutes up to isomorphism.</fr:p>
    
      
      <fr:figure><fr:resource
hash="4e921109a6b663fb65b4091b43e7e844"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0NS41NDM3NDFwdCcgaGVpZ2h0PScxMTkuMTA2NTlwdCcgdmlld0JveD0nLTcyIC03MiA5Ny4wMjkxNjEgNzkuNDA0Mzk0Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWS9DT1dob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMm9OM0Q4YnoyM3hsWUdaaEFJSEhRdllia0dtV1VNWTdRSXFEZ1FuRUF3QXNmd21OQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNa0FBb0FBQUFBQTRRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVrQUFBQmdxa21VUzJOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKVFoyeDVaZ0FBQVd3QUFBQmdBQUFBWUw3dmtMZG9aV0ZrQUFBQnpBQUFBQzhBQUFBMktNekRFR2hvWldFQUFBSDhBQUFBSGdBQUFDUUZ1di9VYUcxMGVBQUFBaHdBQUFBSUFBQUFDQVluQUJCc2IyTmhBQUFDSkFBQUFBWUFBQUFHQURBQUFHMWhlSEFBQUFJc0FBQUFGZ0FBQUNBQUJRQVlibUZ0WlFBQUFrUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQURGQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1GbWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4b0FBSEdDT2x1Q3lkZ1UySlFZbUJXZkdQRVFPUVpENEhGR1pFS1AzL240RUJBTXNRRGNnQUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVb00vLzlEeUh1TVlIa0dBRWsyQlg4QUFBQUNBQkQvN0FLSUFzY0FFd0FXQUFBSkFRY0dCeVluQVNjMk54WWZBU0UzUGdFWEZnRWJBUUtBL3VrR0FoVVZCdjdtQndJWUZBWmVBVk5lQnlnRUF2NHZsWk1DbXYxeERCQURBaFVDbHhNWUFnSVczTjRWQVJvQi92WCtwQUZjQUhqYVkyQmtZR0FBWWljblBjRjRmcHV2RE13c0RDRHdXTWgrQTRMKy80WjVJdE54SUplRGdRa2tDZ0R2eGdtR0FIamFZMkJrWUdCVy9HTUVKQ2N5Q0REd01YVXdBRVZRQUJNQVF6Z0Nrd0FBQTVFQUFBS1dBQkFBQUFBQUFEQUFBSGphWTJCa1lHQmdZaEFIWWhCZ1pFQURBQUx6QUI0QUFIamFUWXc5YjhJd0VJYWZpQVNKZE9oU2RlZ0FIcGl0b0ZSaVkyRmdZbVhxQXRpZ0RIR1FIU0pGcWpyeXUzdTRIbnJENlhrLzdvQ1NIektlay9FYTkzTnlDbEYvWFBEQ1crS3BxRVhpa2crV1RNanltVGh6Tm9selNiNFNGN3h6U1R3Vi96dHh5U2VQYmRmZTdyMzFhdDhaNjkyNURlUDZZSDFvT3FkV3VvcDZaNTMxeDk0YWRScVZHWm93WEZ0VjYwclhiT2xvdVhHbngrSlI3TVV4a1IxbnlRSWphdzdSQ1RTU09tbXQwRlQvOHAza0xuYU84Wk9SemtrU0pUVElWWkI5bGJhaWpwZWEraGZ6ZVRCUEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTRUFBb0FBQUFBQlR3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWUYxV0dOdFlYQUFBQUU0QUFBQU1RQUFBRHdBZ2dDK1oyeDVaZ0FBQVd3QUFBSEFBQUFDRE5BT2V2Sm9aV0ZrQUFBRExBQUFBQzhBQUFBMktJL0NYV2hvWldFQUFBTmNBQUFBSGdBQUFDUUdRd0pQYUcxMGVBQUFBM3dBQUFBTUFBQUFEQWtZQVBwc2IyTmhBQUFEaUFBQUFBZ0FBQUFJQUhJQkJtMWhlSEFBQUFPUUFBQUFGd0FBQUNBQUJRQmZibUZ0WlFBQUE2Z0FBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUVlQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm01bUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBxbU1XUXpNL3dIOHBraDBraHEvZ09GQWJHTERNb0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtwakZrLy84UDVJUHAvN1AvVHdlckFnSUFtVWtKT2dBQUFIamFIWkE5Y3ROQUdJYjFmbHJ2eXJaK0xGbmVkWnpZeEpKblpUdTJUSkF0OFdkNzZCZ0dacElpQlFVVTBHV0dobzZoNEFBTWNJVWNnSjZHbHVFQUhJSVQwQ2FzTXU4V1d6ekY5endXckk4M1MvcEZmNnlubGdVN0FCYytCTmZaRG9WVU1SZnlEbmFveWozS0t1VjZzeTVWVWY5dko1V1BWR2U2clBRS2llQUJpbExHZ2d2OGZlQTF3MEgwWkptOHNESHJ6ZTI0Ri9qZDRhUVJSa2RoKzZYWGpZUFhQbWQ5eDB2UHA4OE1JdWMyM0ZFbjZBNVV5KzIvODJMSFp2aDgvV09YUEo0TkNrS1NKNG1kaGVPV0FGSFoyMTllWFQ0RTkrSW16c2JINjA2NFlwZ3Nhb1JudmtQb2QvYmZ3QS9hTml5alpYMjYrVWZmNmJmMXFuWXNLeU4wcjc0OXk3SFJSaTFIYXFUTk03SlNTY0VWbDhwQXBvRWFtUnBtaWRHc3lrelhTMnRVWjFYWGhERGlKbFo1RzBqMkpENjhmVlJVYndwOUNscEVmWWxnM0dSQnVMaFkrR3RaM085c0dIZ0Q2QnpOVnNKdWVxNkQySTJTN2VvNWdUR3dQSXhPZXpuSlljcllGMFp3L0xRZEVYRzc4ZFdOUVZmWDd3OFgrUlluZW40TUhQcnN4R2NOZ2MzRW0zb1VjYlYxMVpCRlUySm5JNzlGSk84ZXFCV3JTaEVIempMa3JQblQxWVNKb2szRU9RZVpmcTRwNUtMaE1aUHBQd29LUHgxNDJtTmdaR0JnQU9LRlg0NXF4dlBiZkdWZ1ptRUFnY2RDOWhzUTlIOWQ1aENteTBBdUJ3TVRTQlFBTUdjS1ZnQjQybU5nWkdCZ1p2alBBQ1JER0tyL2YyYzZ5Z0FVUVFITUFHc2dCSmNBQUFOVUFBQUN2QUI3QXdnQWZ3QUFBQUFBY2dFR2VOcGpZR1JnWUdCbWlHTUEwUXhRRWdrQUFBbm1BR1VBZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmd3TnFGZ1ltVnFRdGdGMld3alp3UUNhbnEyTi9kaC9IUU4xeWQrMkVETlQ4VTNLOWdsdlIrSlpXNEIxZE1tV2VlaUh2TFhMUGduU2VLOGxtU1Z6NHlsOUo4WnE1NDRTdnpSUEx2ekRVcmZqZkJYYTZEaldvWGpJMys1RnkzM3R2WWQ4R3JwVzZTMzFwdjQyR3dSaDF2eW94ZFA1NmRhbldqV3pZRUhCZXVERmdpaXAwa0pySG5KSjJqWTgwK0piMXdrRnl4Uk5QODY3ZlMrN1E1cEorTWJJN2NSQTJqTEhyUnMyd1ZiWHFwYWY4QXlCRXY3d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVrQUFvQUFBQUFCZlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDFGMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNYWjJ4NVpnQUFBV1FBQUFKWUFBQUN1SkhqY2Nsb1pXRmtBQUFEdkFBQUFDOEFBQUEyS0hMREkyaG9aV0VBQUFQc0FBQUFIZ0FBQUNRR1hnSWxhRzEwZUFBQUJBd0FBQUFVQUFBQUZBNm9BS3RzYjJOaEFBQUVJQUFBQUF3QUFBQU1BV0lDREcxaGVIQUFBQVFzQUFBQUdBQUFBQ0FBQ1FBNmJtRnRaUUFBQkVRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRkdBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaFp2Z1A1RE5EcEpIVS9BY0tBd0Q3MVExamVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZndS8vOERTY2YvLy84ZkFQTVpBRkxLQnFCNDJqWFJ2MDhUWVJ6SDhlZnpmTnZuYUdudktsZnVhcURYbEpZZVlGb0l2ZHdCaWNWUXFRaXgvS2hCZ28xRUV5U1NpRDlBWkdEb2dERWFHSXdKaVhGdzBNMDR1emc1TVRtNU9xaVQ4VTh3YlgyT2hPZFpubnh6dy92N09zWlp0dDNtUC9rUE5zeEdHZlBnZXFPR3FjZU5vbXVJWVNoMnpuWmMwM0M5WWFRVkVUZE0xMVFoNS82NFdJSlhwTTlZRi9Hb1FNbklkeU1TM0dsMEJCSHQxQjBLS2ExMk5kcXJSd25SNE1aS0JKRlFYK25OMy9RdVg0NGhwRFViaGtaSkJVVGdIWm9DUk15NzB3ZnhiQXhjVTRVL0Rtc0NtUk1zTVhtSVhXZzNTZkF2ekdKRGJFeVc2azdHRnJJdGJhRmJoV0xCRkJxRWtoYW52Ym9mNStic1RFNG9kUFltK1VIeHcxR1BuZFEwck5UdlVLTTJWd08vRXJ2MnBQVzZWMVVuckhmSGF6c2NoZkpCU2c5dUhkWjNPUitaK1ZvSkFPb0NIei9IcVZjQlg1eVkzZERDMWZHNUtiVVU4RGVBam1sNlhNbGU1dERPTnovUzAyci9BclYrZDRrd1kyREY5aC9xNU4vOVpwQ0tqQlNkaEpPelpiTWZiRnJ3Sks5Zm1JSWxGNUR6QW16WDg2OWhHcVluMTZId0pSTGhVQkFjeS9QVHowWXFQY0pBWVAvcXdKcnI1RVVncEFRcFh4bDhWTjU3UzFSelpyY1Bhb01EWWtaRmhKKzAvcW15V2RGeXE1dEFlV3hsTFZIUDc5N202QnNxMUJPZEFJL2NuK292Z280YkwzWm1uU1VLWlB2VmVaV1ROT2RzVUpwNzBqekI4cjY0ZXdadUNzVy9aOWFucnFhL3dpUmN1d0JGcXI4L1F0bUtTZWJ0ZmREODBOaG1vL1VwcVVuaVg0Yys1OHRiZStaRW9xTUwvRjUxSzZWTDNSaFJVdjcyVncrZVA3eVl2MDVrQ1FuTHk4MXYwaEdCaGRUaXpmUU5lMzBWMEdUYWYvUUJkMWQ0Mm1OZ1pHQmdBT0xqQWxhdThmdzJYeG1ZV1JoQTRMR1EvUVlFL2Y4bHN6blRYU0NYZzRFSkpBb0FCZkFKMGdCNDJtTmdaR0JnWnZqUEFDVDlHVlQrWDJBMlp3Q0tvQUJXQUZVckE0a0FBQUoyQUFBREFBQWtBd2dBS3dMYkFETURUd0FwQUFBQUFBQlVBTEFCRGdGY2VOcGpZR1JnWUdCbHNHUmdaZ0FCUmdZMEFBQUdyUUJFZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJRQUFvQUFBQUFCT3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjAyMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUM3WjJ4NVpnQUFBV1FBQUFHU0FBQUJ4T2JSakxSb1pXRmtBQUFDK0FBQUFDOEFBQUEyS0FIQ1VXaG9aV0VBQUFNb0FBQUFId0FBQUNRRnFRSGZhRzEwZUFBQUEwZ0FBQUFNQUFBQURBZXNBSGxzYjJOaEFBQURWQUFBQUFnQUFBQUlBRzRBNG0xaGVIQUFBQU5jQUFBQUdBQUFBQ0FBQmdCTmJtRnRaUUFBQTNRQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRVJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbTZtT2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTJRd00vd0g4cGtoMGtocS9nT0ZBZUdqRFUwQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZnWi8vOER5ZlQvLy8vUEF2TVpBRlhHQnNSNDJoMlF6VzdUUUJSR2ZlODRNNDMvSnJiakdXaU5hOGVKN1VyQmJ1dkVCaEVjM0VSSUJWRXFOcWdJc2V1K0VodFVKSjRCOFJTOEFudWt2aEVTbXhRYmZkdXpPT2RUVUpuZlA4WVovRlp5WmFNb1FDeGdORWtiS0UrRkhGTW1SU21xdW9FMVVKWkRXdFg5QXBBTjFCMUExbENsU1pwUVJwa0ZRcDcyS0VZM3c4OWZpazhxeE1JV1lEbStIWTFYc1MrWXJNL2JLeVF0dDgrdnNxVko5aDNUZ3g4RmdiRzMyTitFM3NpR0pBM09mSVBCN2E0dFBoRDA1bzhpMTlVRGJZQ2crdytQdzQrbEN1OHZyeTljdmlVd0ZTTUJJM3YzOXhmWFo3RUsyVEpwWDd5dFlSWnlVK2xpbERmM2YvQXIzaW12KzdKT09VQkdPZlN1SHUxbHExSUdYVyszU1pJdXVwZytMMG43RDdocVFaekRzblliU09MSi8wdnFTakJvTC94M1QxOHVETUF4dW9hcEVmOXc1YUN0VVpDNkhUZlpFeUNtSlFTaXlGYVhEL2pBRFlkN21odzY5dUM3aW53NkhBRlliRHVmQWY3YzNVVWxESXFGbWEvb3M0TW9zaWU0ZnU0Z3ltTXBjclU0TXZSd2VyWTU4VTRRTjVuUVgzMUxEcmdPcmlsd2EzSk4xZmdlVTRueEQ3alBPOHNBQUhqYVkyQmtZR0FBNHFxNjVkM3gvRFpmR1poWkdFRGdzWkQ5QmdUOVg1ZnBHTk54SUplRGdRa2tDZ0FsTFFwaUFIamFZMkJrWUdCbStNL0F3TUIwakVHSFFaU3BtZ0VvZ2dLWUFVRWRBbzRBQXNZQUFBSTZBQ3dDckFCTkFBQUFBQUJ1QU9KNDJtTmdaR0JnWUdid1lXQmlBQUZHQmpRQUFBZzdBRlI0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMko3dkNYV2hvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaXp5c25UWTdudC9uS3dNekNBQUtQaGV3M0lPai9ERXdOekNBdUJ3TVRpQUlBTVlRSndBQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoWGQwZzJOdFlYQUFBQUU0QUFBQU13QUFBRVFBZGdFeVoyeDVaZ0FBQVd3QUFBRTZBQUFCVUNpQ2IyZG9aV0ZrQUFBQ3FBQUFBQzhBQUFBMkoyWERJbWhvWldFQUFBTFlBQUFBSHdBQUFDUUZOd0ZnYUcxMGVBQUFBdmdBQUFBT0FBQUFEZ2JFQUlGc2IyTmhBQUFEQ0FBQUFBb0FBQUFLQVBvQWhtMWhlSEFBQUFNVUFBQUFHQUFBQUNBQUJ3QXlibUZ0WlFBQUF5d0FBQURUQUFBQlBxa3JkZHR3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1VbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvR001UXljLzRIOHBrNUdkSFUvQWNLQXdDNmFnenFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1U0NHWklZU3YvL1I3RCtyL3UvNEg4ZldDMFlBQUR1aGd1aUFIamFQWTZ4VHNKUUFFWGZmVlVhSFFxdkRUVUlGZ3RDb1FZcUpmQ0NHZ2l4RVRFR0dqVEI2S0k0cUluT2F0VE53ZEZmY0RYeEU1ZzcrZ082T0RtNHVvTFBHRTN1Y3U0ZDdpRWdoZkVIeHZTTkxCRUN1UWhMZ1d4ZzVqOENRMW1MRytCMWNESC9KdnREcm83WGNLTFhhSFZBNDdKdUwzcWJLVFVOZW5Qc1huamh0U3R6dlFQTVJ0UkNvN0NSWEpGd2ZjYjM2Rk12bGdOdE95bDdVb3RNTXlPanRkemQyd2trODl1VmVVcjlpbGxTVkJhZU1zeG1zM3NweFFnaGxPeU12L0JKQXhJaENVSTBWdjh6RXliUk5OT2lPdGVyUWs1VzhPajBrKzE5S3AxM3k1N3ErOWFxZXlCSi9aTE5hVEI2V1loQnVqODZ2YU93VkVjVUQrOGVoVDhZQ00yYytBSHBpWjhoQXFJS1lPbUtnblFSbkpWWlNIZXJuR0c0WlIzYWRRYytuVHRwQWNHb1ZqTGphTmJRSHoybk1ud1orVytuZEVCU0FBQjQybU5nWkdCZ0FPTGVHWDZUNC9sdHZqSXdzekNBd0dNaCt3MEkrdjhMSmkybXUwQXVCd01UU0JRQUl6QUtjd0I0Mm1OZ1pHQmc1dnpQd01EQVpNR2d5NkRDK0o4QktJSUNtQUUvWUFLY0FBSXFBQUFDT0FBdEFoQUFWQUJTQUFBQUFBQUFBRklBaGdDb0FBQjQybU5nWkdCZ1lHRXdaR0JpQUFGR0JqUUFBQVd6QURwNDJrMk9zV3JETUJDR1AxUGJVTGZRcVIwNkZFMFpoWTM3QUlVTW1iSm1MQ1NSTUM1WURwSmo4Rkw2QUhub1hCUU52WU9mVC8vOWR3aW8rQ1hqVmhrdlVXK1ZVOHJyemdWUHZDWXVwVlhpaW5kV1BKRGxqK0o4OEpVNDU1bnZ4QVZ2L0NRdXhmOUxYUEhKWlQwT3AvTmt2ZHFPeG5wM0hFSm82cDMxb1IrZGFuUjlOemJXV2IrZnJGR0hSWm01RDNNM3FGYlh1bVhOeU1DSk14TVdMei9iaW1NaU80NHlDOUlOTmJ2b0JYcVpPOGsxYUhIL0p6YVNjREcxajllTXBBNHNvb1paOW9Kb0ozbEZHM2MxN1JYK0NERDdBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUxLjY1ODkxLC02MS4zMjIyNzIpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTUuODc2NzUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MS4zMjIyNzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjEuMzIyMjcyJz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYxLjMyMjI3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjEuMzIyMjcyJz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yMy44OTgzNzInIHk9Jy02MS4zMjIyNzInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE2LjExMTgzLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYxLjMyMjI3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTEuNjU4OTEnIHk9Jy02MS4zMjIyNzInPlN1YjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzUuODI5MzU1JyB5PSctNjEuMzIyMjcyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zMS45NTQ5ODEnIHk9Jy02MS4zMjIyNzInPkQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTIzLjQyOTk5MicgeT0nLTYxLjMyMjI3Mic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC04LjkwOTczVi00Ny40OTU3NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDcuNzQ1NzcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMi4zMDIxMiwtMzAuMjAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjEuMzIyMjcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01MS42NTg5MScgeT0nLTYxLjMyMjI3Mic+4oiAPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny4xNDgwMjUnIHk9Jy02MC4yNjUxMjUnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMzIyMTQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MS4zMjIyNzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjEuMzIyMjcyJz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYxLjMyMjI3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjEuMzIyMjcyJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNC40ODI5ODInIHk9Jy02MS4zMjIyNzInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMTQwOSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MS4zMjIyNzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjEuMzIyMjcyJz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYxLjMyMjI3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjEuMzIyMjcyJz5DPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNC4xMjE4NjcnIHk9Jy02MS4zMjIyNzInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTIwLjQzMjMgMEgzNi4yNjY2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM2LjUxNjYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4xNjgyNywyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYxLjMyMjI3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTEuNjU4OTEnIHk9Jy02MS4zMjIyNzInPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2Ljk5NDY1MScgeT0nLTY0LjMyODc5Jz7iiJc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtOC45MDk3M1YtNDcuNDk1NzcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00Ny43NDU3NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTMwLjIwMjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYxLjMyMjI3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuNjU4OTEnIHk9Jy02MS4zMjIyNzInPuKIgDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuMTQ4MDI1JyB5PSctNjAuMjY1MTI1Jz5rPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00yMC42NjczNy01Ni45MDU1SDM2LjA4NTM2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM2LjMzNTM2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC40NTk4NCwtNjUuMDYxNDgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjEuMzIyMjcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01MS42NTg5MScgeT0nLTYxLjMyMjI3Mic+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDcuNTIxOTU5JyB5PSctNjQuMzI4NzknPuKIlzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = {\mathsf {Sub}(B)},
    ne = {\mathsf {Sub}(A)},
    sw = {\mathsf {Sub}(D)},
    se = {\mathsf {Sub}(C)},
    north = {h^{*}},
    west = {\forall _{f}},
    south = {g^{*}},
    east = {\forall _{k}},
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>766</fr:anchor><fr:addr
type="machine">#276</fr:addr><fr:route>unstable-276.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Consider the corresponding left adjoint square.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="ed07d9d46bf3793064647aa72d9389df"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0NS41NDM3NDFwdCcgaGVpZ2h0PScxMjAuMTYxODEzcHQnIHZpZXdCb3g9Jy03MiAtNzIgOTcuMDI5MTYxIDgwLjEwNzg3NSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1nQUFvQUFBQUFBNHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FreVVUbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pXWjJ4NVpnQUFBV3dBQUFCY0FBQUFhSjVnVklab1pXRmtBQUFCeUFBQUFDOEFBQUEyS016RERtaG9aV0VBQUFINEFBQUFIZ0FBQUNRRnV3QVVhRzEwZUFBQUFoZ0FBQUFJQUFBQUNBWW5BRkJzYjJOaEFBQUNJQUFBQUFZQUFBQUdBRFFBQUcxaGVIQUFBQUlvQUFBQUZ3QUFBQ0FBQkFBZmJtRnRaUUFBQWtBQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBREVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtYWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhvQUFIR0NPbHVDeWRnVTJKV1ltWldmR1BFUU1Ec3lMek9hQXdJMExwLy84TURBREx4QTNPQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyTS8vOUR5THYvd1BJTUFGQnRCb0VBQUhqYVkyQmtDUGovbjhtRDZRU0RMQU1EbzZBWW03b2ltNXFKbWJpaUlCcHRKc2JremlnbytTK0tUMHFTbjNIT3YwSWVTUmsreHE1L0tXRCtNa2xCcHZsL082WDRHUms1VkRnWUdTVWhsRGdqcHpJbkk2TUFBd0Q3TmhITmVOcGpZR1JnWUFEaTVwQ2xzdkg4Tmw4Wm1Ga1lRT0N4a1AxU0JQMy9QL05FcGhOQUxnY0RFMGdVQUJSVENsb0FlTnBqWUdSZ1lGYjhZd1FrSnpJRU1QZ3hlVEFBUlZBQUV3QkplQUxUQUFBRGtRQUFBcFlBVUFBQUFBQUFOQUFBZU5wallHUmdZR0Jpa0dNQTBReFFFZ2tBQUFPTEFDUUFlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ1ZHSmpZV0JpWmVvQzJLQU1jWkFkSWtXcU92SzdlN2dlZXNQcGVUL3VnSklmTXA2VDhScjNjM0lLVVg5YzhNSmI0cW1vUmVLU0Q1Wk15UEtaT0hNMmlYTkp2aElYdkhOSlBCWC9PM0hKSjQ5dDE5N3V2ZlZxM3hucjNia040L3BnZldnNnAxYTZpbnBubmZYSDNocDFHcFVabWpCY1cxWHJTdGRzNldpNWNhZkg0bEhzeFRHUkhXZkpBaU5yRHRFSk5KSTZhYTNRVlAveW5lUXVkbzd4azVIT1NSSWxOTWhWa0gyVnRxS09sNXI2Ri9ONU1FOEFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUlFBQW9BQUFBQUJRZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMHltTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWdnQytaMng1WmdBQUFXd0FBQUdNQUFBQjJBdloyckJvWldGa0FBQUMrQUFBQUM4QUFBQTJLQUhDUjJob1pXRUFBQU1vQUFBQUlBQUFBQ1FGdUFHYWFHMTBlQUFBQTBnQUFBQU1BQUFBREFkdUFKaHNiMk5oQUFBRFZBQUFBQWdBQUFBSUFHWUE3RzFoZUhBQUFBTmNBQUFBRndBQUFDQUFCUUJZYm1GdFpRQUFBM1FBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFUkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1LY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F6TS93SDhwa2gwa2hxL2dPRkFkcVhEVHNBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpGay8vOFA1SVBwLzdQL1R3ZXJBZ0lBbVVrSk9nQUFBSGphUlpFN2J4TkJGSVgzek16dWVBYzhkMk92WjBNYy9OcnhURkNDQTNHeVN5eGs4cUxKUXlnRkJDbzZrUGd0Q0ZGUTBOTHhRNUNvK1RGUUpzd3FFdHpUbmRPYzc5d0kwZG5OTnZ2QWZrVUhVUVJPU0tTR25EaS94TndVSnBGbWlDV2U4VEp4VlRGZm9nNytqaWswU3VkZFZidHRhRWFZVnlieCtMYklSTGFXSGo3ZVdBQzI1emhvU0VSMnpPL1A2SHpBdW5SSlBXMk95Z2RQZ2RLRVBCc1FkVG9EMVZwNzI4VDRjdjNqZE9WZ056L21yaHlNbUUzOG5aUkJuUFcrL3I3aUU0bXJOMzN2cHZaL2hIdnU0U2N4YVNFS2gramk1Zzk3em41R3J4cVdLblRkTWIxL1ZRTllneGVvZ25MaXVTbHVlUnBESmtFQjI5V1ZuOEVUTkNadXIrNHU0Y3JiTmVyS1NCeStHNzcybHk4ZGJGTy9HT2w4ODRWM3hlcG9sK2lSWUR3RzVXNVRjYW5TQk1oVXZyN3ZqeGxpRHB3K0tVa1ViaVgrTEJqWk5BTzBQTm1hZ24yL2ZxL1BwM3RiL2ZHWVdXMWJHbGk0Y1I0cXhLblpWMm03M3cxUEVCZVdGR01xbnZYWFoySmU2WTVPTm56OGNkRlo3YllOTzJtVEVvcGFVdkM3WVlxLzR4UTVTSGphWTJCa1lHQUFZdjB2WEgvaitXMitNakN6TUlEQVl5SDdwUWo2dno3VE1hYUxRQzRIQXhOSUZBQWpMUXBZQUhqYVkyQmtZR0JtK00vQXdNQjBqTUg3L3dXbUxBYWdDQXBnQmdCbjVBUldBc1lBQUFJNkFFc0NiZ0JOQUFBQUFBQm1BT3g0Mm1OZ1pHQmdZR1lJWndEUkRGQVNDUUFBQ1RjQVhnQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJjQUFvQUFBQUFCUGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFjbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUM3WjJ4NVpnQUFBV1FBQUFHZUFBQUIwRWdYV254b1pXRmtBQUFEQkFBQUFDOEFBQUEyS0kvQ09taG9aV0VBQUFNMEFBQUFIZ0FBQUNRR1dnS2JhRzEwZUFBQUExUUFBQUFNQUFBQURBbHdBT1JzYjJOaEFBQURZQUFBQUFnQUFBQUlBR3dBNkcxaGVIQUFBQU5vQUFBQUdBQUFBQ0FBQmdCUmJtRnRaUUFBQTRBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRVVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVZtV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTJRd00vd0g4cGtoMGtocS9nT0ZBYnZjRE9VQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZnWi8vOER5ZlQvLy8vUEF2TVpBRlhHQnNSNDJoMlFNVy9UVUJTRmZhN3Q1OFIrdFJQYjd6bEFIRnFiMkNta2NacTJ0cXFHcEdvb1ZFclVWcXdncEFyQkFtc0hKaVlraEFSc3pQd01aaVRFRDBKTVNDM1AxVG5EMVQxM09OL1ZTSHQxUGFSUCtLV050SVdtUVhlUnNnSlpQc05FaXBCWjhpN2tqT1p3WVkyUWwxV3RpWXpLcWdkaFZXVjlxaUlYb29kcVZwcyt2QTIvdmluMm5CMEQvWW0wVzVSc1JmTW5IZGJ4VjVQbGE5S1AyLzc1UlhKNHE1MEV3YmN0Q0NPYWJwN0l1RXY3NjRQajJHM2k4bXExUEtHbXpvdTRmOXRyZEQyVEFIczg3bDYwK29UblQxK3VBdTlJdjVQa2dIRC8vYkJUbGhnWXA4WGx4c0VReUdQUFV5RGErK3UvOUlkK2EyYzFsV3FtK2pJUHRRV0xicHJ1UkRJS0xhYWt5SGJuS0pXcjNTeTk0ZkZJZlNMTHEwQXRzd0lzcTluVkxJWEV1M1A1WW5tNnBNQU1iYytpalh6bUdnM09tNGg1ZTdBb0RxRzN1Q0NoZ3VtejlkQzFFOHZzdGxMRCtHd1FHbTdxK0VSTU43L3dFUFQ5Nm1lODBMRW83eC93L1U0ZXRsS2RIZzI5SnBFVGJvZCtvY0EydVpQM0hyTHBLQm5RNCsxZSt1QmpKeEM0RjlHZXp4Z0RnYTF4UndlSHVXYjhCODVTUGdnQUFIamFZMkJrWUdBQTRvMC9PUnpqK1cyK01qQ3pNSURBWXlIN3BRajZ2dzV6Q05OeElKZURnUWtrQ2dBVkp3bWpBSGphWTJCa1lHQm0rTThBSkVNWVVobWNtVDR6QUVWUUFETUFSK0lDL0FBQUExUUFBQUxOQUdVRFR3Qi9BQUFBQUFCc0FPaDQybU5nWkdCZ1lHWUlZR0JpQUFGR0JqUUFBQWlmQUZoNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWS9DSTJob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMm9OMzM4YnoyM3hsWUdaaEFJSEhRdlpMa1dtV1VNWTdRSXFEZ1FuRUF3QXg2UW1qQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMko3dkNSMmhvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaXp5c243WS9udC9uS3dNekNBQUtQaGV5WEl1ai9ERXdOekNBdUJ3TVRpQUlBTnU0SjFnQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVa0FBb0FBQUFBQmZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxRjJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDWFoyeDVaZ0FBQVdRQUFBSllBQUFDdUpIamNjbG9aV0ZrQUFBRHZBQUFBQzhBQUFBMktITEREV2hvWldFQUFBUHNBQUFBSGdBQUFDUUdYZ0lsYUcxMGVBQUFCQXdBQUFBVUFBQUFGQTZvQUt0c2IyTmhBQUFFSUFBQUFBd0FBQUFNQVdJQ0RHMWhlSEFBQUFRc0FBQUFHQUFBQUNBQUNRQTZibUZ0WlFBQUJFUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZHQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmhadmdQNURORHBKSFUvQWNLQXdENzFRMWplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2Z3UvLzhEU2NmLy8vOGZBUE1aQUZMS0JxQjQyalhSdjA4VFlSekg4ZWZ6Zk52bmFHbnZLbGZ1YXFEWGxKWWVZRm9JdmR3QmljVlFxUWl4L0toQmdvMUVFeVNTaUQ5QVpHRG9nREVhR0l3SmlYRncwTTA0dXpnNU1UbTVPcWlUOFU4d2JYMk9oT2Rabm54encvdjdPc1padHQzbVAva1BOc3hHR2ZQZ2VxT0dxY2VOb211SVlTaDJ6blpjMDNDOVlhUVZFVGRNMTFRaDUvNjRXSUpYcE05WUYvR29RTW5JZHlNUzNHbDBCQkh0MUIwS0thMTJOZHFyUnduUjRNWktCSkZRWCtuTjMvUXVYNDRocERVYmhrWkpCVVRnSFpvQ1JNeTcwd2Z4YkF4Y1U0VS9EbXNDbVJNc01YbUlYV2czU2ZBdnpHSkRiRXlXNms3R0ZySXRiYUZiaFdMQkZCcUVraGFudmJvZjUrYnNURTRvZFBZbStVSHh3MUdQbmRRMHJOVHZVS00yVndPL0VydjJwUFc2VjFVbnJIZkhhenNjaGZKQlNnOXVIZFozT1IrWitWb0pBT29DSHovSHFWY0JYNXlZM2REQzFmRzVLYlVVOERlQWptbDZYTWxlNXRET056L1MwMnIvQXJWK2Q0a3dZMkRGOWgvcTVOLzlacENLakJTZGhKT3paYk1mYkZyd0pLOWZtSUlsRjVEekFtelg4NjloR3FZbjE2SHdKUkxoVUJBY3kvUFR6MFlxUGNKQVlQL3F3SnJyNUVVZ3BBUXBYeGw4Vk41N1MxUnpacmNQYW9NRFlrWkZoSiswL3FteVdkRnlxNXRBZVd4bExWSFA3OTdtNkJzcTFCT2RBSS9jbitvdmdvNGJMM1ptblNVS1pQdlZlWldUTk9kc1VKcDcwanpCOHI2NGV3WnVDc1cvWjlhbnJxYS93aVJjdXdCRnFyOC9RdG1LU2VidGZkRDgwTmhtby9VcHFVbmlYNGMrNTh0YmUrWkVvcU1ML0Y1MUs2VkwzUmhSVXY3MlZ3K2VQN3lZdjA1a0NRbkx5ODF2MGhHQmhkVGl6ZlFOZTMwVjBHVGFmL1FCZDFkNDJtTmdaR0JnQU9MakFsYUY4ZncyWHhtWVdSaEE0TEdRL1ZJRS9mOGxzem5UWFNDWGc0RUpKQW9BQzFvSjZBQjQybU5nWkdCZ1p2alBBQ1Q5R1ZUK1gyQTJad0NLb0FCV0FGVXJBNGtBQUFKMkFBQURBQUFrQXdnQUt3TGJBRE1EVHdBcEFBQUFBQUJVQUxBQkRnRmNlTnBqWUdSZ1lHQmxzR1JnWmdBQlJnWTBBQUFHclFCRWVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3MxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFhkMGcyTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWRnRXlaMng1WmdBQUFXd0FBQUU2QUFBQlVDaUNiMmRvWldGa0FBQUNxQUFBQUM4QUFBQTJKMlhEREdob1pXRUFBQUxZQUFBQUh3QUFBQ1FGTndGZ2FHMTBlQUFBQXZnQUFBQU9BQUFBRGdiRUFJRnNiMk5oQUFBRENBQUFBQW9BQUFBS0FQb0FobTFoZUhBQUFBTVVBQUFBR0FBQUFDQUFCd0F5Ym1GdFpRQUFBeXdBQUFEVEFBQUJQcWtyZGR0d2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtVW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb0dNNVF5Yy80SDhwazVHZEhVL0FjS0F3QzZhZ3pxZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVNDR1pJWVN2Ly9SN0Qrci91LzRIOGZXQzBZQUFEdWhndWlBSGphUFk2eFRzSlFBRVhmZlZVYUhRcXZEVFVJRmd0Q29RWXFKZkNDR2dpeEVURUdHalRCNktJNHFJbk9hdFROd2RGZmNEWHhFNWc3K2dPNk9EbTR1b0xQR0UzdWN1NGQ3aUVnaGZFSHh2U05MQkVDdVFoTGdXeGc1ajhDUTFtTEcrQjFjREgvSnZ0RHJvN1hjS0xYYUhWQTQ3SnVMM3FiS1RVTmVuUHNYbmpodFN0enZRUE1SdFJDbzdDUlhKRndmY2IzNkZNdmxnTnRPeWw3VW90TU15T2p0ZHpkMndrazg5dVZlVXI5aWxsU1ZCYWVNc3htczNzcHhRZ2hsT3lNdi9CSkF4SWhDVUkwVnY4ekV5YlJOTk9pT3RlclFrNVc4T2owaysxOUtwMTN5NTdxKzlhcWV5QkovWkxOYVRCNldZaEJ1ajg2dmFPd1ZFY1VEKzhlaFQ4WUNNMmMrQUhwaVo4aEFxSUtZT21LZ25RUm5KVlpTSGVybkdHNFpSM2FkUWMrblR0cEFjR29WakxqYU5iUUh6Mm5NbndaK1crbmRFQlNBQUI0Mm1OZ1pHQmdBT0xlR1g3NzQvbHR2akl3c3pDQXdHTWgrNlVJK3Y4TEppMm11MEF1QndNVFNCUUFLSm9LaVFCNDJtTmdaR0JnNXZ6UHdNREFaTUdneTZEQytKOEJLSUlDbUFFL1lBS2NBQUlxQUFBQ09BQXRBaEFBVkFCU0FBQUFBQUFBQUZJQWhnQ29BQUI0Mm1OZ1pHQmdZR0V3WkdCaUFBRkdCalFBQUFXekFEcDQyazJPc1dyRE1CQ0dQMVBiVUxmUXFSMDZGRTBaaFkzN0FJVU1tYkptTENTUk1DNVlEcEpqOEZMNkFIbm9YQlFOdllPZlQvLzlkd2lvK0NYalZoa3ZVVytWVThycnpnVlB2Q1l1cFZYaWluZFdQSkRsaitKODhKVTQ1NW52eEFWdi9DUXV4ZjlMWFBISlpUME9wL05rdmRxT3hucDNIRUpvNnAzMW9SK2RhblI5TnpiV1diK2ZyRkdIUlptNUQzTTNxRmJYdW1YTnlNQ0pNeE1XTHovYmltTWlPNDR5QzlJTk5idm9CWHFaTzhrMWFISC9KemFTY0RHMWo5ZU1wQTRzb29aWjlvSm9KM2xGRzNjMTdSWCtDREQ3QUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE1Ljg3Njc1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01MS42NTg5MScgeT0nLTYwLjc0NjM2OCc+U3ViPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zNS44MjkzNTUnIHk9Jy02MC43NDYzNjgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMxLjk1NDk4MScgeT0nLTYwLjc0NjM2OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjMuODk4MzcyJyB5PSctNjAuNzQ2MzY4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNi4xMTE4MywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MC43NDYzNjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjAuNzQ2MzY4Jz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYwLjc0NjM2OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjAuNzQ2MzY4Jz5EPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yMy40Mjk5OTInIHk9Jy02MC43NDYzNjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOS40MDk3M1YtNDcuOTk1NzcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwwLjAsLTkuMTU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMi4xMjg1NCwtMzAuMjAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01MS42NTg5MScgeT0nLTYwLjc0NjM2OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDYuOTkyMzI1JyB5PSctNjMuNzUyODg1Jz7iiJc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMzIyMTQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MC43NDYzNjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjAuNzQ2MzY4Jz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYwLjc0NjM2OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjAuNzQ2MzY4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNC40ODI5ODInIHk9Jy02MC43NDYzNjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMTQwOSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MC43NDYzNjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjAuNzQ2MzY4Jz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYwLjc0NjM2OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjAuNzQ2MzY4Jz5DPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNC4xMjE4NjcnIHk9Jy02MC43NDYzNjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTIwLjkzMjMgMEgzNi43NjY2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDIwLjY4MjMsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4wMTY2NiwzLjg3MjkyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYwLjc0NjM2OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuNjU4OTEnIHk9Jy02MC43NDYzNjgnPuKIgzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuMTQ4MDI1JyB5PSctNTkuNjg5MjIxJz5oPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTkuNDA5NzNWLTQ3Ljk5NTc3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwtOS4xNTk3MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTMwLjIwMjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYwLjc0NjM2OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTEuNjU4OTEnIHk9Jy02MC43NDYzNjgnPms8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ3LjI1NTI1NScgeT0nLTYzLjc1Mjg4NSc+4oiXPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00yMS4xNjczNy01Ni45MDU1SDM2LjU4NTM2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDIwLjkxNzM3LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4yNzEzMiwtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01MS42NTg5MScgeT0nLTYwLjc0NjM2OCc+4oiDPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny4xNDgwMjUnIHk9Jy01OS43NTAxMDQnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = {\mathsf {Sub}(B)},
      ne = {\mathsf {Sub}(A)},
      sw = {\mathsf {Sub}(D)},
      se = {\mathsf {Sub}(C)},
      north = {\exists _{h}},
      north/style = {<-},
      west = {f^{*}},
      west/style = {<-},
      south = {\exists _{g}},
      south/style = {<-},
      east = {k^{*}},
      east/style = {<-},
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />, the two composites can be constructed as <fr:tex
display="inline"><![CDATA[f^{*}\mathsf {Img}\Sigma _{g}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathsf {Img}\Sigma _{h}k^{*}]]></fr:tex> respectively.
    Since images commute with pullbacks in a regular category, we have <fr:tex
display="inline"><![CDATA[f^{*}\mathsf {Img}\Sigma _{g} \cong  \mathsf {Img}f^{*}\Sigma _{g}]]></fr:tex>.
    Then by the <fr:link
type="local"
href="ct-0008.xml"
addr="ct-0008"
title="Pasting lemma of pullbacks">pasting lemma</fr:link>, <fr:tex
display="inline"><![CDATA[f^{*}\Sigma _{g}(m) \cong  \Sigma _{h}k^{*}(m)]]></fr:tex> for any subobject <fr:tex
display="inline"><![CDATA[m \in  \mathsf {Sub}(C)]]></fr:tex>, which assembles into a natural isomorphism <fr:tex
display="inline"><![CDATA[f^{*}\Sigma _{g} \cong  \Sigma _{h}k^{*}]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="3daae68dc6dbc9f518795c108aad88f9"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMC44NjUzN3B0JyBoZWlnaHQ9JzExNC45MDIzMzFwdCcgdmlld0JveD0nLTcyIC03MiAxMzMuOTEwMjQ3IDc2LjYwMTU1NCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS012Q21XaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZHF6NTlqT2UzK2NyQXpNSUFBbytGN0RjZzA4d1RtV3lBRkFjREU0Z0hBRHR1Q1pVQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV1VBQW9BQUFBQUJ0Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMHgyTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWdnRENaMng1WmdBQUFXd0FBQUxDQUFBRG5QS3JaMlJvWldGa0FBQUVNQUFBQUM4QUFBQTJLQUhDVzJob1pXRUFBQVJnQUFBQUlBQUFBQ1FGcWdHY2FHMTBlQUFBQklBQUFBQVVBQUFBRkF4VUFSRnNiMk5oQUFBRWxBQUFBQXdBQUFBTUFhNENvbTFoZUhBQUFBU2dBQUFBR0FBQUFDQUFDQUJZYm1GdFpRQUFCTGdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGaUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtS21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F6TS93SDhwa2gwa2hxL2dPRkFkbUFEVGdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLWmpCay8vOFA1S2VCNlArei84OEVxd0lDQUptTkNUNEFBSGphYmROTGI5TkFFQWR3ejZ3ZnNSTjc0OWU2VFZJM2laMTFxcVpKMjZST1cwTGFOQVdwN3hZSlNoR0NFeUJ4UXVLQ1FPSVRJSVFRQjY3YytBcmNLL1hNaHdHSlM4dWE4amhRNzIxbkQvT2IvMWdDYWVlaWcwL3hxN1F1U1VBb3FKb0ZXcDBuUStpeWdLa2FtNFlockpGSTVXblFIVUpmM0MreXdJS0lKenp0OHc1WVNLR2JNaldCVDZ0RnVWalNSd3ZOVllEWTV3VG9OS1UwcnBHcE50ME4wYVZIMUxmWVJqUXpBSWlZcUJkRFNoMG5OSEtsaDFrWlBweWZidHZyUFc5TWVCUldNVmFUdkk0ZzcvZ2Z2eDJUdWdiSEorV0VOK0ovSlpqa2MyL2xlZzRrOGFIVXVwakRCcHhLYldtY2FZUkUvU1VSSFh1cUZyQXVTd1ZnVFNEYmtLVDk3SVFRQ0pWNFFOWWdUUVJLMWJJUnNHQXhlNHExWi9yekY1MEhzdWpYWm1BNUZidm1EYUlLMDRMKzF1Z0V5WWphV3lmTkpaT1VITk9IOXgwQ250OHJqYXQrMFFhZWhCdVZnZ1l2ejBlZGV3VDkxbFROZGZPaG9TRGtLNVB6MWZ0ZEdZNFBIKzI3ZEpOQXpJb01pdmI1ank4MDM0aGthQzd4MGZwQkh4cFZhZ29iU0hzWDMvRVZua2s3bVV5MEhLS21Yc2JscTFtemFUY0loVmNja1Y1UFlESWVUN0laVUZuazFZYWx2anNFSGwyRzIwK1pCcVA5eXEyVm03MENvSWR1d1RSSVpYcmdvRzJvRU9UdGFOaGNCbUphakNHeTV1QndnaXB1VmM4WmdlN1l5anNaYWF3WEFTeHRzOVVBL0h4K1Z1dUMwdW1aN1lGNnJWeXIyWFZjdSs0Z0J2TUJhOHVkbVVLK0dtK01GL3dGeEhHVDViZGY4ekxOZzJzeTNEU3BJUnMwcDhtazhOdDVRemp2Wk00c2cwWG0vMTAzb2MzTVlqUEY4U2p4V0hDNWs5bkZIenp2cDRuSWw0SUZkWDRGK3ZIMDNlVG9OaGNqRnlzWVZDMXY5aURod1VTMVIrbThqRVFCNnZGWmcyaUdyZ0lVRGEreWtvd1JGQUt3dlJ4Uk9lQlg4WjlZdTQybGxvQmpiTVU1QzJDVjF6elJncUt6RlVNM3k2NzRrZVM5bUJxSWh0SXVWOXB5TjdVY1MyMG15cHRWWitLL1FValNUd3l3ZFJJQUFIamFZMkJrWUdBQTRqQ3VleHZqK1cyK01qQ3pNSURBWXlIN0RRajZ2eTdUTWFhTFFDNEhBeE5JRkFBYWxRb3hBSGphWTJCa1lHQm0rTS9Bd01CMGpFSG4vd1dtYWdhZ0NBcGdCUUJtWUFSS0FzWUFBQUk2QUVzQ09nQXNBcXdBVFFKdUFFMEFBQUFBQUdZQTFBRklBYzU0Mm1OZ1pHQmdZR1VJWjJCaUFBRkdCalFBQUFtRUFHRjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVa0FBb0FBQUFBQmZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxRjJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDWFoyeDVaZ0FBQVdRQUFBSllBQUFDdUpIamNjbG9aV0ZrQUFBRHZBQUFBQzhBQUFBMktITERJMmhvWldFQUFBUHNBQUFBSGdBQUFDUUdYZ0lsYUcxMGVBQUFCQXdBQUFBVUFBQUFGQTZvQUt0c2IyTmhBQUFFSUFBQUFBd0FBQUFNQVdJQ0RHMWhlSEFBQUFRc0FBQUFHQUFBQUNBQUNRQTZibUZ0WlFBQUJFUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZHQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmhadmdQNURORHBKSFUvQWNLQXdENzFRMWplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2Z3UvLzhEU2NmLy8vOGZBUE1aQUZMS0JxQjQyalhSdjA4VFlSekg4ZWZ6Zk52bmFHbnZLbGZ1YXFEWGxKWWVZRm9JdmR3QmljVlFxUWl4L0toQmdvMUVFeVNTaUQ5QVpHRG9nREVhR0l3SmlYRncwTTA0dXpnNU1UbTVPcWlUOFU4d2JYMk9oT2Rabm54encvdjdPc1padHQzbVAva1BOc3hHR2ZQZ2VxT0dxY2VOb211SVlTaDJ6blpjMDNDOVlhUVZFVGRNMTFRaDUvNjRXSUpYcE05WUYvR29RTW5JZHlNUzNHbDBCQkh0MUIwS0thMTJOZHFyUnduUjRNWktCSkZRWCtuTjMvUXVYNDRocERVYmhrWkpCVVRnSFpvQ1JNeTcwd2Z4YkF4Y1U0VS9EbXNDbVJNc01YbUlYV2czU2ZBdnpHSkRiRXlXNms3R0ZySXRiYUZiaFdMQkZCcUVraGFudmJvZjUrYnNURTRvZFBZbStVSHh3MUdQbmRRMHJOVHZVS00yVndPL0VydjJwUFc2VjFVbnJIZkhhenNjaGZKQlNnOXVIZFozT1IrWitWb0pBT29DSHovSHFWY0JYNXlZM2REQzFmRzVLYlVVOERlQWptbDZYTWxlNXRET056L1MwMnIvQXJWK2Q0a3dZMkRGOWgvcTVOLzlacENLakJTZGhKT3paYk1mYkZyd0pLOWZtSUlsRjVEekFtelg4NjloR3FZbjE2SHdKUkxoVUJBY3kvUFR6MFlxUGNKQVlQL3F3SnJyNUVVZ3BBUXBYeGw4Vk41N1MxUnpacmNQYW9NRFlrWkZoSiswL3FteVdkRnlxNXRBZVd4bExWSFA3OTdtNkJzcTFCT2RBSS9jbitvdmdvNGJMM1ptblNVS1pQdlZlWldUTk9kc1VKcDcwanpCOHI2NGV3WnVDc1cvWjlhbnJxYS93aVJjdXdCRnFyOC9RdG1LU2VidGZkRDgwTmhtby9VcHFVbmlYNGMrNTh0YmUrWkVvcU1ML0Y1MUs2VkwzUmhSVXY3MlZ3K2VQN3lZdjA1a0NRbkx5ODF2MGhHQmhkVGl6ZlFOZTMwVjBHVGFmL1FCZDFkNDJtTmdaR0JnQU9MakFsYXU4ZncyWHhtWVdSaEE0TEdRL1FZRS9mOGxzem5UWFNDWGc0RUpKQW9BQmZBSjBnQjQybU5nWkdCZ1p2alBBQ1Q5R1ZUK1gyQTJad0NLb0FCV0FGVXJBNGtBQUFKMkFBQURBQUFrQXdnQUt3TGJBRE1EVHdBcEFBQUFBQUJVQUxBQkRnRmNlTnBqWUdSZ1lHQmxzR1JnWmdBQlJnWTBBQUFHclFCRWVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNzAzNTU3LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNS43MDM1NTcnIHk9Jy02MS44MDM1Myc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy45MzEyNCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNzAzNTU3LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNS43MDM1NTcnIHk9Jy02MS44MDM1Myc+QzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03LjY4NDA1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNzAzNTU3LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNS43MDM1NTcnIHk9Jy02MS44MDM1Myc+azwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjcwMzU1NywtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNzAzNTU3JyB5PSctNjEuODAzNTMnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuNjI3MDMsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjcwMzU1NywtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNzAzNTU3JyB5PSctNjEuODAzNTMnPkQ8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQgMEg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1Ljk2NTE4LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjcwMzU1NywtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTUuNzAzNTU3JyB5PSctNjEuODAzNTMnPmg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjQ4Njc5LTU2LjkwNTVINDcuNTcxNDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuODIxNDksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI2LjIwMjkxLC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNTEuMjE1MDQtMTQuMjI2MzZILTQyLjY3OTE0Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi4wNTgyOSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzEuNzY4NDQyJyB5PSctNjUuNDE4ODk0Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjIzOTUyLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5DPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzIuMTI5NTU3JyB5PSctNjUuNDE4ODk0Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00NC44MTU5NS01Ni45MDU1SC04Ljk4Njc5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLC00NC41NjU5NSwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTguNzM2NzksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDQuOTk3MTggMEgtOC44MDU1NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwtNDQuNzQ3MTgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOC41NTU1NCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J00tNTYuOTA1NS02LjQwOTczVi00Ny40Nzc5NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLC01Ni45MDU1LC00Ny43Mjc5NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw = A,
        nw/style = {pullback},
        ne = B,
        sw = C,
        se = D,
        north = h,
        south = g,
        west = k,
        east = f,
      }
      \node  [left = of nw,pullback] (1) {$A'$};
      \node  [left = of sw] (2) {$C'$};
      \draw  [>->,morphism] (2) to (sw);
      \draw  [>->,morphism] (1) to (nw);
      \draw  [->,morphism] (1) to (2);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Thus, we can extend this natural isomorphism as follows:</fr:p>
  <fr:tex
display="block"><![CDATA[     f^{*}\mathsf {Img}\Sigma _{g} \cong  \mathsf {Img}f^{*}\Sigma _{g} \cong  \mathsf {Img}\Sigma _{h}k^{*}   ]]></fr:tex>
  <fr:p>Then both <fr:tex
display="inline"><![CDATA[\forall _{k}h^{*}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g^{*}\forall _{f}]]></fr:tex> are right adjoint to <fr:tex
display="inline"><![CDATA[f^{*}\exists _{g}]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[\forall _{k}h^{*} \cong  g^{*}\forall _{f}]]></fr:tex> by the uniqueness of adjoint.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>767</fr:anchor><fr:addr
type="user">ct-001C</fr:addr><fr:route>ct-001C.xml</fr:route><fr:title
text="Heyting implication">Heyting implication</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex> be two subobjects of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>.
  The <fr:em><fr:strong>Heyting implication</fr:strong></fr:em> <fr:tex
display="inline"><![CDATA[A_{1} \Rightarrow  A_{2}]]></fr:tex> is the largest subobject of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[A_{1} \cap  (A_{1} \Rightarrow  A_{2})]]></fr:tex> is contained in <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>768</fr:anchor><fr:addr
type="user">ct-001D</fr:addr><fr:route>ct-001D.xml</fr:route><fr:title
text="Heyting categories admit Heyting implications"><fr:link
type="local"
href="ct-0019.xml"
addr="ct-0019"
title="Heyting category">Heyting categories</fr:link> admit <fr:link
type="local"
href="ct-001C.xml"
addr="ct-001C"
title="Heyting implication">Heyting implications</fr:link></fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex> be two subobjects of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in a Heyting category.
  Then the Heyting implication <fr:tex
display="inline"><![CDATA[A_{1} \Rightarrow  A_{2}]]></fr:tex> exists.
  Moreover, for any morphism <fr:tex
display="inline"><![CDATA[f\colon B\to A]]></fr:tex>, <fr:tex
display="inline"><![CDATA[f^{*}(A_{1} \Rightarrow  A_{2}) \cong  f^{*}(A_{1}) \Rightarrow  f^{*}(A_{2})]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(B)]]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>769</fr:anchor><fr:addr
type="machine">#275</fr:addr><fr:route>unstable-275.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Fix a subobject <fr:tex
display="inline"><![CDATA[m\colon A_{1}\rightarrowtail A]]></fr:tex>.
    Recall from <fr:ref
addr="ct-0011"
href="ct-0011.xml"
taxon="Lemma" /> that <fr:tex
display="inline"><![CDATA[A_{1} \cap  (\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]]></fr:tex> may be described as <fr:tex
display="inline"><![CDATA[\exists _{m}m^{*}]]></fr:tex>.
    Then take <fr:tex
display="inline"><![CDATA[A_{1} \Rightarrow  (\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]]></fr:tex> to be the right adjoint of <fr:tex
display="inline"><![CDATA[A_{1} \cap  (\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]]></fr:tex> given as follows:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="d485e6138ca3770ee9491aeaeea909f8"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMxNC41NjE4NzNwdCcgaGVpZ2h0PSc0NC4zODc1NTJwdCcgdmlld0JveD0nLTcyIC03MiAyMDkuNzA3OTE1IDI5LjU5MTcwMSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBJQUFvQUFBQUFCRlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRTBBQUFCZ3FrcGlmV050WVhBQUFBRkVBQUFBTkFBQUFFUWlHQUxMWjJ4NVpnQUFBWGdBQUFEdUFBQUJGTjBFMjZKb1pXRmtBQUFDYUFBQUFDOEFBQUEyS016REcyaG9aV0VBQUFLWUFBQUFIZ0FBQUNRRnV2L1dhRzEwZUFBQUFyZ0FBQUFRQUFBQUVBdVNBTEJzYjJOaEFBQUN5QUFBQUFvQUFBQUtBTG9BWkcxaGVIQUFBQUxVQUFBQUdBQUFBQ0FBQndBZmJtRnRaUUFBQXV3QUFBRE9BQUFCT0JOL0tydHdiM04wQUFBRHZBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUFCQmdZSEdEdWx1Q3lkZ1UySjRVRWlzK0lmSXdZR1prWG1jMEJoUm9UcS8vOFpHQUE3RHcvSEFBQUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUUF1V1VHSlNZSHlUKy80OWczV084KzE5K0VWZ3RHQUFBN1JJTEFYamFYWSt4U3NOUUdJWC84eXMzRFNScFFzMU43NDFGMGtqaVZoQkpObGNkQlRlUlRyNUEzOEJGVVZjUlFRUVg4VkZhSDhGQkhBWEIxYkYvYkZOd2NEcDh3emtmaDVqQzVwdXZlRVk5MGtRdUhPVVVKY3FxMWx2STZuMGtHaW40WEw0VXg3R1NUNGY3RzJxTTQ3R3pzODR5dXJ2bGgvbkVDOWM0NXZ0ZW4xbS9mOFN3a0I5NXhpa1I2S2hwK0pCZmFiQ0FTS3N5VThWZWxXVFJ2NncwSHlBeWNoSlkwOFdqVER5ekdlQkd6bHArTVJFL3phOXRGK2hzZHdDemlnUnU3Z0poNnlId0pVOFhQMXJQc0tqL0ZFVzFxL21pclVqdW0wR0F0eVVzRjczVStzaFhhMFBmcGtUMEM2QnJNem9BQUhqYVkyQmtZR0FBNG0wQ1JvSHgvRFpmR1poWkdFRGdzWkQ5VmdUOS93M3pSS1lUUUM0SEF4TklGQUFJUkFvWEFIamFZMkJrWUdCVy9HTUVKQ2N5Q0REd01YVXdBRVZRQUFzQVF6b0NsUUFBQTVFQUFBS1dBQkFDbGdCUUF0VUFVQUFBQUFBQU1BQmtBSW9BQUhqYVkyQmtZR0JnWVpCallHSUFBVVlHTkFBQUE5Z0FKM2phVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9GUmlZMkZnWW1YcUF0aWdESEdRSFNKRnFqcnl1M3U0SG5yRDZYay83b0NTSHpLZWsvRWE5M055Q2xGL1hQRENXK0twcUVYaWtnK1dUTWp5bVRoek5vbHpTYjRTRjd4elNUd1YvenR4eVNlUGJkZmU3cjMxYXQ4WjY5MjVEZVA2WUgxb09xZFd1b3A2WjUzMXg5NGFkUnFWR1pvd1hGdFY2MHJYYk9sb3VYR254K0pSN01VeGtSMW55UUlqYXc3UkNUU1NPbW10MEZULzhwM2tMbmFPOFpPUnpra1NKVFRJVlpCOWxiYWlqcGVhK2hmemVUQlBBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFQZ0FBb0FBQUFBQkd3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWWgxdTJOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFEQVoyeDVaZ0FBQVdRQUFBRWtBQUFCU05SOVhyOW9aV0ZrQUFBQ2lBQUFBQzhBQUFBMktSZkNJMmhvWldFQUFBSzRBQUFBSHdBQUFDUUhEZ05CYUcxMGVBQUFBdGdBQUFBSUFBQUFDQWJUQURCc2IyTmhBQUFDNEFBQUFBWUFBQUFHQUtRQUFHMWhlSEFBQUFMb0FBQUFGd0FBQUNBQUJBQnZibUZ0WlFBQUF3QUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUQwQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm16bVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBybU11UXlNL3dIOHBraDBraHEvZ09GQWRYYkRUUUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aTUvLzlEeVA5VHdId0dBRll6QnNrQUFBQjQyaldNd1U3Q1FCaUU5Ly9YdHRLRmx0TGRMa3BwS0FnRm1oU1EwZ1lwTGFZYUR4NDBldEFuOE9iUnR6THhCVHo3RkQ2SFYyMVFNOGtrTTVQNUNKRDU5eGY5aEEveVRNaXdnQnhHZ1VGTk5PZ29LR2l5aXFzSW1nRXppQ0JKYzNSa0RtbXlkMGQ2b0trbXFOVXNWSG1hcE1seVgxWHFqNEs0d0tyNXUvOEM0eFRlUTVNaUQ5ZlhvYUYxdVZJVExnYzlyRFBWdEwwK1V6U2RxY0N0V2xCZWFQSmhON25UMjQrWFYyMlhBWEswbWFIVGJ1K3NoYTJhQ2s3ZEdtekhhNkNOb1VBVWsrem15R0NhSzVSRHB5TkF1WC9ON01HU1lwYjczWmRiYmhyUXRLWnY4MGcyaFF1d2kzaUZSUFBjczA5d3V2STNpTlBkb0VSRnR1TkdsS21ianU5YmZTeTJMVVE1bDA1ME1KdlVXZStwWElnRllqa1d4OTQvVkxFSklUOUFnaWRTZU5wallHUmdZQURpMmZtc252SDhObDhabUZrWVFPQ3hrUDFXQlAzL0cvTWR4bU5BTGdjREUwZ1VBQTlNQ25nQWVOcGpZR1JnWUdiNHo4REF3TUxMWU1CZ3lIeUhBU2lDQXBnQU9TNENXQUFDeGdBQUJBMEFNQUFBQUFBQXBBQUFlTnBqWUdSZ1lHQml5R01BMFF4UUVna0FBQXRiQUhRQWVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE5UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MDRXTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ1VaMng1WmdBQUFXUUFBQUNvQUFBQXFML3NEZVZvWldGa0FBQUNEQUFBQUM4QUFBQTJLQnpEUTJob1pXRUFBQUk4QUFBQUhRQUFBQ1FHQndJaWFHMTBlQUFBQWx3QUFBQUlBQUFBQ0FWMkFDUnNiMk5oQUFBQ1pBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSnNBQUFBRmdBQUFDQUFCUUEwYm1GdFpRQUFBb1FBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtMnMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJrWnZnUDVETkRwSkhVL0FjS0F3RG85dzB0ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlPLy85RHlQOEh3SHdHQUZLWEJwMEFBQUFBQWdBay8vOEM0UUxkQUM4QU1nQUFOd0UyTnpJV0Z4TVVGak0yRmdZdkFRY25KaWMwTmhjV05qY3ZBU0VIQmhRV0Z6WVhEZ0V2QVFjbUp6UTJNejRCTnpNRHR3RmxCaFFOQmdFK0ZpMFZBUXdGZElBSUJRRU5DeE0wQXdrSC92OU9EUndURFFNQkRRVm5XQXdCREFraVBwbnJJWFlDVmhBQkNRLzlnQllQQXgwSEFRTURBUUlJRHdjQkFRd1haa1dFRkNRUUFRSVBEZ1lCQXdNQkNnOEdBU1BJQVZJQUFBQjQybU5nWkdCZ0FPS0doeExPOGZ3Mlh4bVlXUmhBNExHUS9WWUUvZjgvMDBPbXUwQXVCd01UU0JRQUlvRUxBUUI0Mm1OZ1pHQmdadmpQQUNJWlZCamttUjR5QUVWUUFCTUFOWXdDTUFBQUFBSjJBQUFEQUFBa0FBQUFBQUJVQUFCNDJtTmdaR0JnWUdJd0JtSVFZR1JBQXdBRnJ3QTZBQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOb0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQzBBQUFBMktZL0NRMmhvWldFQUFBSkFBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbUFBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDYUFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKd0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURXQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGkyb04zMThiejIzeGxZR1poQUlISFF2WmJrV21XVU1ZN1FJcURnUW5FQXdBcUNRbURBQUFBZU5wallHUmdZTmI2WThuQXdCTEswTWZRejVUTUFCUkJBVXdBVW9BRFFnQUVWUUFBQXZJQWpnQUFBQUFBVkFBQWVOcGpZR1JnWUdCaU1HVUEwUXhRRWdrQUFBWEtBRHNBZU5wTmpEMXZ3akFRaHArSUJJbDA2RkoxNkFBZW1LMmdsSldGZ1ltVnFRdGdnekxFUVhhSUZLbnF5Ty91NFhyb0RhZm4vYmdEU243SWVFN0dhOXpQeVNsRS9YSEJDMitKcDZJV2lVcytXREloeTJmaXpOa2t6aVg1U2x6d3ppWHhWUHp2eENXZlBMWmRlN3YzMXF0OVo2eDM1emFNNjRQMW9lbWNXdWtxNnAxMTFoOTdhOVJwVkdab3duQnRWYTByWGJPbG8rWEduUjZMUjdFWHgwUjJuQ1VMakt3NVJDZlFTT3FrdFVKVC9jdDNrcnZZT2NaUFJqb25TWlRRSUZkQjlsWGFpanBlYXVwZjcra3dSd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5nQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTno3R050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDZ0FBQUFyS0FDSGFSb1pXRmtBQUFDQkFBQUFDNEFBQUEySjd2Q1oyaG9aV0VBQUFJMEFBQUFId0FBQUNRRWp3RzhhRzEwZUFBQUFsUUFBQUFLQUFBQUNnUkdBR1JzYjJOaEFBQUNZQUFBQUFnQUFBQUlBQ3dBVm0xaGVIQUFBQUpvQUFBQUZ3QUFBQ0FBQlFBWmJtRnRaUUFBQW9BQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRFVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXZNYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWU5Ca1p2Z1A1RE5EcEpIVS9BY0tBd0R2a1EwZWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaRWo1ejhBWXdzekFJTTdBd0NxaXBLYXV4Mml1Wm1adXgyakV6OGpIS000bUpNOG94aGdzbG15b0tjUElLS05tbUNiR3lCUG53Y2prRXMvUC9JMHJLVDVpbGEzVHd0RGtWQjZCeEQvdGxmLytwUWl5TUFBQkk0TWwwRnhOaUxtTVltenNmSXhLcGtCVDFVM1U5Qm5Wek0yTXhNVGxHQmsxd0NhSzhzWjZNUVg3Q0RFek1vcUM3V0dBbXBqMHQzWGhCMThoRmlhd1BRQVZKQ0ZNZU5wallHUmdZQURpenlzbjFjZnoyM3hsWUdaaEFJSEhRdlpiRWZSL0JxWUdaaENYZzRFSlJBRUFMdzRKdGdBQWVOcGpZR1JnWUdiNHo4REF3TlRBWU1sZ3lSakNBQlJCQVV3QU8yd0NVQUFDZ0FBQUFZMEFaQUE1QUFBQUFBQUFBQ3dBVm5qYVkyQmtZR0JnWnBCZ0FORU1VQklKQUFBREVBQWZBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUDBBQW9BQUFBQUJId0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFloMmNHTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBREFaMng1WmdBQUFXUUFBQUUxQUFBQldDd3hFcWRvWldGa0FBQUNuQUFBQUM4QUFBQTJLY2pDSTJob1pXRUFBQUxNQUFBQUh3QUFBQ1FINndSSWFHMTBlQUFBQXV3QUFBQUlBQUFBQ0FnOUFGeHNiMk5oQUFBQzlBQUFBQVlBQUFBR0FLd0FBRzFoZUhBQUFBTDhBQUFBRndBQUFDQUFCQUIxYm1GdFpRQUFBeFFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFENUFBQUFCQUFBQUFnQUFNQUFYamFZMkJta1dPY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcm1NdVF5TS93SDhwa2gwa2hxL2dPRkFicjZET29BZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1Fndmk1Ly85RHlQOVR3SHdHQUZZekJza0FBQUI0MmkyTVQwN0NVQmpFKzMwdHIrM2p0YVdsZlVYYUFLWFFCeWdVQkVwWVNQMUQxS2d4Y1dOaW9qdmpCYnlBU3pkdVBJRnJMK0tKWENzbFpDYVp6R1R5azBCNi9QdFZQdUJIZXBXa2JnN1pmSmJFSnFnbVdMSUo3VVRrU2piUEVyR2RZcEdJWkpFVmFnTDNWN0JMNUI2eG9MQkhpblVGVTUvN3JrbzJHb0hJRnNWVEZJM3NxTE1GOW5xTXRNUTBaOGtFNjY2dWh3RUhFbE9ERXJEcnJZU2h6Z3dOd0tiVnhwSVBXRjhObnE2anNUV2l6ZWZQVytTS2IxSVpvMjV1S1RwakdvUkdwYjlPY3dEZEhTSmUzUnpXN0s1R0Job05RZzlLRDEvVHdHNzNVTERPSFhtNWIxWXR4Mm04RDhkRGJ0Z2R3SXNSMVJGcEtRM0RWRUdidUVldE14a3JtbmUrdjhhVDVjRnhlUldGNVVvc3cybHFiWjVsZCtJNnFRTGovcDZUdnFXWHFFeDRiZWI2MzF1d1dwWCtBWGo5S1BrQUFBQjQybU5nWkdCZ0FPSm4vRE5WNC9sdHZqSXdzekNBd0dNaCs2MEkrdjlYbGw3RzQwQXVCd01UU0JRQUcxRUtoUUI0Mm1OZ1pHQmdadmpQd01EQThwSWhoaUdHcFpjQktJSUNtQUJRWEFNOUFBTlVBQUFFNlFCY0FBQUFBQUNzQUFCNDJtTmdaR0JnWUdJb1lRRFJERkFTQ1FBQUMvRUFlZ0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTVFBQW9BQUFBQUEzZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MG8yTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUJZQUFBQVdPYStkQlZvWldGa0FBQUJ2QUFBQUMwQUFBQTJLQTNERUdob1pXRUFBQUhzQUFBQUlBQUFBQ1FGVmdJNWFHMTBlQUFBQWd3QUFBQUlBQUFBQ0FVYUFIQnNiMk5oQUFBQ0ZBQUFBQVlBQUFBR0FDd0FBRzFoZUhBQUFBSWNBQUFBRndBQUFDQUFCQUFiYm1GdFpRQUFBalFBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEQUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd5TS93SDhwa2gwa2hxL2dPRkFkU0JETjhBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy85RHlQOFh3SHdHQUZGSEJvMEFBQUFBQVFCd0FBQUI1QUtwQUJrQUFBRVJCaFk3QVJVdkFROEJOVE15TmljUkRnRW5OUlkyTnpZV0FWY0RJRWtuWjFCd1JpZEpJQU1zVkJRaGRETVZDd0tML2NrYUZTVURBUUlDSlJVYUFnb1VDUUVrQWhZdUFRb0FlTnBqWUdSZ1lBRGkzaTlpOCtQNWJiNHlNTE13Z01CaklmdXR5RFRUWmFhVlFJcURnUW5FQXdBVmR3azdBQUFBZU5wallHUmdZR2I0ejhEQXdIU1pvWUFobWZFSkExQUVCVEFCQUZhYUE1UUMwd0FBQWtjQWNBQUFBQUFBTEFBQWVOcGpZR1JnWUdCaWtHSUEwUXhRRWdrQUFBTW5BQ0FBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktIN2k0T1RpNU9yek5taUFkbWtwYWl5N2lUL2MyQkcvZzhOMXp6ZzJROFNKaG1JUjUwR0ZTZWZQSVkzNVlSSjZJdjRxYzhjdWFFVWs2RTJmRkxuTEtsUC9JWTVhVWtTZmlQeUpuL1BIZU4vWHQzbG12am8yeDNsMXF2ejFaMzFhTlV4dWREK3ZCT3V2UG5UV3FmQ3JUVjIxL3JWV2hjMTJ3cDZIbXhwME9pMGR4Rk1jRWRsd2s4Mnc1aGIybGtzeEpaNE1tLzZZSFNWMW9uTU12UmhvbFQxRkRMemV0NkZXNmlpTGNhWW9QV0t3dVN3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCSmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hYZDBnMk50WVhBQUFBRTRBQUFBTXdBQUFFUUFkZ0V5WjJ4NVpnQUFBV3dBQUFFNkFBQUJVQ2lDYjJkb1pXRmtBQUFDcUFBQUFDOEFBQUEySjJYRExHaG9aV0VBQUFMWUFBQUFId0FBQUNRRk53RmdhRzEwZUFBQUF2Z0FBQUFPQUFBQURnYkVBSUZzYjJOaEFBQURDQUFBQUFvQUFBQUtBUG9BaG0xaGVIQUFBQU1VQUFBQUdBQUFBQ0FBQndBeWJtRnRaUUFBQXl3QUFBRFRBQUFCUHFrcmRkdHdiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVVtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9HTTVReWMvNEg4cGs1R2RIVS9BY0tBd0M2YWd6cWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VTQ0daSVlTdi8vUjdEK3IvdS80SDhmV0MwWUFBRHVoZ3VpQUhqYVBZNnhUc0pRQUVYZmZWVWFIUXF2RFRVSUZndENvUVlxSmZDQ0dnaXhFVEVHR2pUQjZLSTRxSW5PYXRUTndkRmZjRFh4RTVnNytnTzZPRG00dW9MUEdFM3VjdTRkN2lFZ2hmRUh4dlNOTEJFQ3VRaExnV3hnNWo4Q1ExbUxHK0IxY0RIL0p2dERybzdYY0tMWGFIVkE0N0p1TDNxYktUVU5lblBzWG5qaHRTdHp2UVBNUnRSQ283Q1JYSkZ3ZmNiMzZGTXZsZ050T3lsN1VvdE1NeU9qdGR6ZDJ3a2s4OXVWZVVyOWlsbFNWQmFlTXN4bXMzc3B4UWdobE95TXYvQkpBeEloQ1VJMFZ2OHpFeWJSTk5PaU90ZXJRazVXOE9qMGsrMTlLcDEzeTU3cSs5YXFleUJKL1pMTmFUQjZXWWhCdWo4NnZhT3dWRWNVRCs4ZWhUOFlDTTJjK0FIcGlaOGhBcUlLWU9tS2duUVJuSlZaU0hlcm5HRzRaUjNhZFFjK25UdHBBY0dvVmpMamFOYlFIejJuTW53WitXK25kRUJTQUFCNDJtTmdaR0JnQU9MZUdYNzE4ZncyWHhtWVdSaEE0TEdRL1ZZRS9mOEZreGJUWFNDWGc0RUpKQW9BSUxvS2FRQjQybU5nWkdCZzV2elB3TURBWk1HZ3k2REMrSjhCS0lJQ21BRS9ZQUtjQUFJcUFBQUNPQUF0QWhBQVZBQlNBQUFBQUFBQUFGSUFoZ0NvQUFCNDJtTmdaR0JnWUdFd1pHQmlBQUZHQmpRQUFBV3pBRHA0MmsyT3NXckRNQkNHUDFQYlVMZlFxUjA2RkUwWmhZMzdBSVVNbWJKbUxDU1JNQzVZRHBKajhGTDZBSG5vWEJRTnZZT2ZULy85ZHdpbytDWGpWaGt2VVcrVlU4cnJ6Z1ZQdkNZdXBWWGlpbmRXUEpEbGorSjg4SlU0NTVudnhBVnYvQ1F1eGY5TFhQSEpaVDBPcC9Oa3ZkcU94bnAzSEVKbzZwMzFvUitkYW5SOU56YldXYitmckZHSFJabTVEM00zcUZiWHVtWE55TUNKTXhNV0x6L2JpbU1pTzQ0eUM5SU5OYnZvQlhxWk84azFhSEgvSnphU2NERzFqOWVNcEE0c29vWlo5b0pvSjNsRkczYzE3UlgrQ0REN0FIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3MxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTIuMTg1NDA4LC01Ny4yMDQxNTUpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTUuNTgzMzYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUyLjE4NTQwOCwtNTcuMjA0MTU1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01Mi4xODU0MDgnIHk9Jy01Ny4yMDQxNTUnPlN1YjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzYuMzU1ODUzJyB5PSctNTcuMjA0MTU1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zMi40ODE0NzknIHk9Jy01Ny4yMDQxNTUnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTI1LjAwOTQ4JyB5PSctNTcuMjA0MTU1Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDY3LjUzMTgzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Mi4xODU0MDgsLTU3LjIwNDE1NSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTIuMTg1NDA4JyB5PSctNTcuMjA0MTU1Jz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM2LjM1NTg1MycgeT0nLTU3LjIwNDE1NSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzIuNDgxNDc5JyB5PSctNTcuMjA0MTU1Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0yNS4wMDk0OCcgeT0nLTU1LjcwOTc3NCc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjAuNTQwMTExJyB5PSctNTcuMjA0MTU1Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE1NS4xMzMxNiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuMTg1NDA4LC01Ny4yMDQxNTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUyLjE4NTQwOCcgeT0nLTU3LjIwNDE1NSc+U3ViPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zNi4zNTU4NTMnIHk9Jy01Ny4yMDQxNTUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMyLjQ4MTQ3OScgeT0nLTU3LjIwNDE1NSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjUuMDA5NDgnIHk9Jy01Ny4yMDQxNTUnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTIwLjEzODktMy42MTY2Mkg2Mi40NzYyOScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2Mi43MjYyOSwtMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzUuOTE5MjQsLTExLjc3MjU4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuMTg1NDA4LC01Ny4yMDQxNTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUyLjE4NTQwOCcgeT0nLTU3LjIwNDE1NSc+bTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDUuMTE1ODAyJyB5PSctNjAuMjEwNjcyJz7iiJc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwNy43NDAyMy0zLjYxNjYySDE1MC4wNzc2MicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNTAuMzI3NjIsLTMuNjE2NjIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEyMy41NzQ5NywtMTEuMjg5NTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Mi4xODU0MDgsLTU3LjIwNDE1NSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTIuMTg1NDA4JyB5PSctNTcuMjA0MTU1Jz7iiIA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTQ3LjY3NDUyMycgeT0nLTU2LjIwNzg5MSc+bTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNjIuOTc2MjkgMy42MTY2MkgyMC42Mzg5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDIwLjM4ODksMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzUuOTczNjUsNy40Mjg0NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUyLjE4NTQwOCwtNTcuMjA0MTU1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01Mi4xODU0MDgnIHk9Jy01Ny4yMDQxNTUnPuKIgzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuNjc0NTIzJyB5PSctNTYuMjA3ODkxJz5tPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xNTAuNTc3NjIgMy42MTY2MkgxMDguMjQwMjMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTA3Ljk5MDIzLDMuNjE2NjIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEyMy41MjA1OCw2LjQyODQ0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuMTg1NDA4LC01Ny4yMDQxNTUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUyLjE4NTQwOCcgeT0nLTU3LjIwNDE1NSc+bTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDUuMTE1ODAyJyB5PSctNjAuMjEwNjcyJz7iiJc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwzOS44MDc2LDIuNDc5MTcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Mi4xODU0MDgsLTU3LjIwNDE1NSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTIuMTg1NDA4JyB5PSctNTcuMjA0MTU1Jz7ugaE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwxMjcuNDA4OTQsMi40NzkxNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUyLjE4NTQwOCwtNTcuMjA0MTU1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01Mi4xODU0MDgnIHk9Jy01Ny4yMDQxNTUnPu6BoTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram,node distance=3cm]
      \node  (1) {$\mathsf {Sub}(A)$};
      \node  [right = of 1] (2) {$\mathsf {Sub}(A_{1})$};
      \node  [right = of 2] (3) {$\mathsf {Sub}(A)$};
      \draw  [->,morphism,offset=1.5] (1) to node[swap] (r1) {$m^{*}$} (2);
      \draw  [->,morphism,offset=1.5] (2) to node[swap] (r2) {$\forall _{m}$} (3);
      \draw  [->,morphism,offset=1.5] (2) to node[swap] (l1) {$\exists _{m}$} (1);
      \draw  [->,morphism,offset=1.5] (3) to node[swap] (l2) {$m^{*}$} (2);
      \draw  [adjoint] (l1) to (r1);
      \draw  [adjoint] (l2) to (r2);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Then for any subobject <fr:tex
display="inline"><![CDATA[A_{2} \in  \mathsf {Sub}(A)]]></fr:tex> the counit of the adjunction <fr:tex
display="inline"><![CDATA[\varepsilon _{A_{2}}\colon A_{1} \cap  (A_{1} \Rightarrow  A_{2})\to A_{2}]]></fr:tex> says precisely that <fr:tex
display="inline"><![CDATA[A_{1} \cap  (A_{1} \Rightarrow  A_{2})]]></fr:tex> is contained in <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex>.
    And <fr:tex
display="inline"><![CDATA[A_{1} \Rightarrow  A_{2}]]></fr:tex> is the largest such subobject by the universal property of right adjoint.</fr:p>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon B\to A]]></fr:tex> be a morphism.
    Form the following pullback.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="df2f19104d0877879b80bdbc2d53a81b"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzNC4xMjQ0NzhwdCcgaGVpZ2h0PScxMTYuOTM2MzY5cHQnIHZpZXdCb3g9Jy03MiAtNzIgODkuNDE2MzE5IDc3Ljk1NzU3OSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTVFBQW9BQUFBQUEzZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MG8yTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUJZQUFBQVdPYStkQlZvWldGa0FBQUJ2QUFBQUMwQUFBQTJLQTNDK21ob1pXRUFBQUhzQUFBQUlBQUFBQ1FGVmdJNWFHMTBlQUFBQWd3QUFBQUlBQUFBQ0FVYUFIQnNiMk5oQUFBQ0ZBQUFBQVlBQUFBR0FDd0FBRzFoZUhBQUFBSWNBQUFBRndBQUFDQUFCQUFiYm1GdFpRQUFBalFBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEQUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd5TS93SDhwa2gwa2hxL2dPRkFkU0JETjhBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy85RHlQOFh3SHdHQUZGSEJvMEFBQUFBQVFCd0FBQUI1QUtwQUJrQUFBRVJCaFk3QVJVdkFROEJOVE15TmljUkRnRW5OUlkyTnpZV0FWY0RJRWtuWjFCd1JpZEpJQU1zVkJRaGRETVZDd0tML2NrYUZTVURBUUlDSlJVYUFnb1VDUUVrQWhZdUFRb0FlTnBqWUdSZ1lBRGkzaTlpcCtQNWJiNHlNTE13Z01CaklmdFZ5RFRUWmFhVlFJcURnUW5FQXdBYTRRbFJBQUFBZU5wallHUmdZR2I0ejhEQXdIU1pvWUFobWZFSkExQUVCVEFCQUZhYUE1UUMwd0FBQWtjQWNBQUFBQUFBTEFBQWVOcGpZR1JnWUdCaWtHSUEwUXhRRWdrQUFBTW5BQ0FBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktIN2k0T1RpNU9yek5taUFkbWtwYWl5N2lUL2MyQkcvZzhOMXp6ZzJROFNKaG1JUjUwR0ZTZWZQSVkzNVlSSjZJdjRxYzhjdWFFVWs2RTJmRkxuTEtsUC9JWTVhVWtTZmlQeUpuL1BIZU4vWHQzbG12am8yeDNsMXF2ejFaMzFhTlV4dWREK3ZCT3V2UG5UV3FmQ3JUVjIxL3JWV2hjMTJ3cDZIbXhwME9pMGR4Rk1jRWRsd2s4Mnc1aGIybGtzeEpaNE1tLzZZSFNWMW9uTU12UmhvbFQxRkRMemV0NkZXNmlpTGNhWW9QV0t3dVN3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmdBQW9BQUFBQUE5UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFVOejdHTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUNnQUFBQXJLQUNIYVJvWldGa0FBQUNCQUFBQUM0QUFBQTJKN3ZDVVdob1pXRUFBQUkwQUFBQUh3QUFBQ1FFandHOGFHMTBlQUFBQWxRQUFBQUtBQUFBQ2dSR0FHUnNiMk5oQUFBQ1lBQUFBQWdBQUFBSUFDd0FWbTFoZUhBQUFBSm9BQUFBRndBQUFDQUFCUUFaYm1GdFpRQUFBb0FBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFEVUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtdk1jNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwVFVZTkJrWnZnUDVETkRwSkhVL0FjS0F3RHZrUTBlZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pFajV6OEFZd3N6QUlNN0F3Q3FpcEthdXgyaXVabVp1eDJqRXo4akhLTTRtSk04b3hoZ3NsbXlvS2NQSUtLTm1tQ2JHeUJQbndjamtFcy9QL0kwcktUNWlsYTNUd3REa1ZCNkJ4RC90bGYvK3BRaXlNQUFCSTRNbDBGeE5pTG1NWW16c2ZJeEtwa0JUMVUzVTlCblZ6TTJNeE1UbEdCazF3Q2FLOHNaNk1RWDdDREV6TW9xQzdXR0FtcGowdDNYaEIxOGhGaWF3UFFBVkpDRk1lTnBqWUdSZ1lBRGl6eXNuclk3bnQvbkt3TXpDQUFLUGhleFhJZWovREV3TnpDQXVCd01UaUFJQU5IZ0p6QUFBZU5wallHUmdZR2I0ejhEQXdOVEFZTWxneVJqQ0FCUkJBVXdBTzJ3Q1VBQUNnQUFBQVkwQVpBQTVBQUFBQUFBQUFDd0FWbmphWTJCa1lHQmdacEJnQU5FTVVCSUpBQUFERUFBZkFIamFSWXd4YjhJd0VJVy9pQVNKZE9oU2RXQUFEOHhXb2pCM1lXQmlaV0lCYktJTWNaQVRJaUdoanYzZFBZd2xibmo2N3IxM0IrVDhrdkNjaE0rZ3owbkpaSHR4eGdkZmthZXlMU1BuekZreElVbG40aXo0aVp4S2NvaWM4YzBsOGxUOFIrU2NOWCticnIzZUJ1dlZyalBXdTNQcnkySnZmZDkwVHBXNkNQdldPdXVQZ3pYcWRGZG1iUHF4YmxXbEMxMnhvYVBseW8wQmkwZXhFOGNFZHB3bDg1UVU3SVBUMDBqcXBGV2l4WDNuVzhsZDZCekRKeU9kRTNkUnd5aFh2V2d0YlVVVkxqWFZQMk05THc4QUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOa0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUNVUTJOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2RBQUFBcVA1ZC95Vm9aV0ZrQUFBQ0RBQUFBQzBBQUFBMktNdkNMV2hvWldFQUFBSThBQUFBSGdBQUFDUUZlUUFpYUcxMGVBQUFBbHdBQUFBSUFBQUFDQVhvQUZ0c2IyTmhBQUFDWkFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKc0FBQUFGd0FBQUNBQUJBQTNibUZ0WlFBQUFvUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQURWQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm0rc0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzK0lmSXdZR1prWG1jMEJoUm9UUy8vOFpHQUFoNGc3V0FBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFOY2s5Q3NJd0dBYmc3MDF0MnNhUUdHaXNnNlNnYURjTDFiYURZSEYyY3BaTzNzQnI2Q1lpT0hzc2IrS2c0TS82UEFUYTBSaFBQS2drbWlRT2xnYzhSd3FGMFRTck5adG1pNnBCTmtOWjFVV0tuSzB3ZDlCb1dEK0plWUROTFZUTWNYNlJQbXhzWVU0eWNrenA4OGVGUFBxQ3dZcEVzTjV2WG11dnE1Mkh6djVRR0tYTXZRM2hPU1Y1ODQyb1hXNEhSbUdvci8raE54V0lGWEFBQUFCNDJtTmdaR0JnQU9MRFgvMTE0L2x0dmpJd3N6Q0F3R01oKzFYSU5QTkV4anRBaW9PQkNjUURBQkxkQ1JRQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWtRenhERCtaZ0NLb0FBbUFGalFBNTRBQUFPUkFBQUNWd0JiQUFBQUFBQlVBQUI0Mm1OZ1pHQmdZR0l3WXdEUkRGQVNDUUFBQmVNQVBBQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV01BQW9BQUFBQUJ4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFlGMUpXTnRZWEFBQUFFNEFBQUFOUUFBQUR3QWh3QytaMng1WmdBQUFYQUFBQUsxQUFBRDRQcGJlTHRvWldGa0FBQUVLQUFBQUM4QUFBQTJLUmZDVDJob1pXRUFBQVJZQUFBQUlBQUFBQ1FIQ3dMamFHMTBlQUFBQkhnQUFBQVVBQUFBRkE0YUFOZHNiMk5oQUFBRWpBQUFBQXdBQUFBTUFkNEN4RzFoZUhBQUFBU1lBQUFBR0FBQUFDQUFDQUJ2Ym1GdFpRQUFCTEFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGZ0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNRNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUk1ZOGhqWnZnUDVETkRwSkhVL0FjS0F3RDY1ZzJXZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpQay9mOFA1S2N4NVA3Ly8zLzIvMmxnVlVBQUFKbThDVDhBQUFCNDJuMlN6V3NUUVJUQTU3MUpkcHRzc3BQOW1tM1R6VGJKSnJ0SjAyNlNKdG5ZTnMxSFU1RmFzVlhCV0JFOTZVRVFCQkZFOEYvd0lCNjg2bG53TEhnczNyMzdieWg0YVoya2xvTFE3c0RDdkRmemVML2ZHd0prNzZTT1QvRUhHUklDbElFa3F5QVgvYUFQTFc1elNlWkwwSWNCOVNRL3NsdDk2SXI0R3JkVjhQekFqN3ArSFZSazBJcTRGTURIalV3c2swMk1tcFVOZ0pMbFUyQkxqTEZTZ2VaQ2RzTkZnOTFpbHNxM3ZXb1B3T01pbjNFWjAzVTNPWmQ5TkUzRCsrT2o2OXF3Ylk2cDc3bDVMRW1Ca2tDSTdWa2ZmazFvVVliSjRXTGdsMHZuS1Zqd1Y5L0dpbk5BeElkazVXUVZ5M0JFUWpLZTBnZ1NhVVlpT2pZbDJlWXRIZ21BZ1lBTUlZaTYwK1dDTGFqRUFUcUFLQkJRa2p4VndPMjE2VkVzUEUrOGVGVi9HQlA5YWh4VTNkRUtaczl6dUd4M2QwZUhTRWRNMnoyc2ROSTBxNmN0ZUZlbllGcnQ3RGh2WlRUd0EzZmJTY253K25oVXYwL1JXc2tWREVOeGszRUV4VmxvNUIrMFlqQTVlSHpUWURzVVNqekRJYU1kLy9uS2xMSVhnMHJISHczM3UxRE9zN1JnQTlJNCtVMS93bmZ5akpEeVFNekVEMVRLVUtWK01LQlJweTIySVBxdVF3aWljZVJUcW1qMjU3WXJQSnhPMXBLbVhGRnJGaEpMRExvOVFCSDVkLzIwWUxzTDMycU1vbGxiMzZ1cGNzNk1KeXpIaEdRdHBVak1jSXRLWEU0cUVwaGFJaGp2eVBaa1dMMmRuTDkzOWRxOG93Q2FhQ2hxa3VieUd6cnFDUWw0U3ZPMkt1dEEwMlVMMGFyMjloZFVSWGFzK0J4ZnRDQis1M1BQOEZvVWUvMUM3dVdCeVZRaFlmbExJN1F6bGdNd0RFMVJFdG5JTlVxNDNDbHNJaTRQdlRIRzdmbDJPdXhKbTR1RmdsYkV3WmFPYURkc0hzYnExWlNTZnpKdVdrM0VjY1hLdW1kRjR3WTU4NGlmaE1kOVFpNFRkNWt3bUQyZDh3Rzh1VkRNeWwwNkZaSktKNm1UMzlSUlMwcGdLNXJYcjF3Qm1tS2M0LytTUjVleGg3c1hNNWUyeDAzOVA1SGtMOE9HZmlzQUFBQjQybU5nWkdCZ0FHTGJZOXQyeC9QYmZHVmdabUVBZ2NkQzlxc1E5SDlkNWp0TUY0RmNEZ1lta0NnQU1na0t3UUI0Mm1OZ1pHQmdadmpQd01EQXdzdWc4LzhDOHgwR29BZ0tZQVVBVzhvRDlRTEdBQUFDT2dCTEFqb0FMQVFOQURBQzB3QXdBQUFBQUFCbUFOUUJlQUh3ZU5wallHUmdZR0JseUdOZ1lnQUJSZ1kwQUFBTHd3QjRlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUzhBQW9BQUFBQUJXd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MDUyTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QW5RQjdaMng1WmdBQUFXd0FBQUhxQUFBQ0xMbEdXV2hvWldGa0FBQURXQUFBQUM4QUFBQTJLRUhDWEdob1pXRUFBQU9JQUFBQUhnQUFBQ1FHTFFITmFHMTBlQUFBQTZnQUFBQVFBQUFBRUFwekFJVnNiMk5oQUFBRHVBQUFBQW9BQUFBS0FXb0FzRzFoZUhBQUFBUEVBQUFBR0FBQUFDQUFDQUJDYm1GdFpRQUFBOXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFc0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtbXNNNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaRWhqWnZnUDVETkRwSkhVL0FjS0F3RGg1UTB6ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pHay9mOFA1RHVDNlA4SC9zOEZxd0lDQUpSZkNSSUFBSGphTmRFeGI5TkFGQWZ3KzkvRjV5VFlQaFBIZHF2RVNSeW5OaW9pS1hXdzJ3b01hbWhBclJJVktsQ0hTa2hJMEEwaDFCYllNblNFQ1lFRUN3c2JINEFCSmlZK0FDc0RZdVF6Sk9GY2ladnUvdThOdjNlUFVOS1p6K2x2K292MHlDb2hLWkowMVhHdHFoTW5EdTlCamNLb243aE9rdmJncTd6cXVJbHJRT1o1SEdkSVkvWUZqM2hWNThpY1N6WTA1V2hTVktDZnMvcXNwTTdtWTcxdTZReTZjcml2UVN1MXMvZC8vUk42MzBSSlRDZU9ZSjRLeGtDTFFnVTA5L0hXYWJWamdncUQ1M0ZaY0FRL2NKZkl3OGpGK1pSeCtvMDB5REpaazFLckgwUmMydndHYkFOcUF5NFg0S3JQejd4V2prdkNLQWk1eXY3Zm1XeUlQNzJ1Ulo0UTJEOTR5Q1o3TzN1Z3Q4elI4ZXhOM1RBMkdoL2ZQVGlpNkE1T201Ynk1TlhCQ2FVcnQ3OFBDNEN4UzlmUFUxWlhRZTlzYkIrSzhuaDlaOVBJQ3ZrRXNMREZuZzA3TnluRTR2UXplejVlMm1XelB4VmVKZ1FrbVhmcEZmcVQzSkNQSEtCS2JEdU1Nc1R5b3gwdTRhbmtXVUh1anE4amd5dHpBNEhzQ1pPMEM1V3JYTkI4SFJGZVpJWWlYT1BxY2lzQkFsdllvRzVnZW9VbzFFWUR6eFREaGZMaXVPWW5GRzFiT01CQ1N6UUx2bENLbW4ydkJsUGd3K3pyd0xwMnVibEpPNEhYcWxUMHNDQlh4NTZPOEpaNUhDOHZiSy9Rb0hOV1dWTHlTbE1QMTQ3enNRbjVCeGtuVklJQUFIamFZMkJrWUdBQTRnYVBrdi94L0RaZkdaaFpHRURnc1pEOUtnVDlYNCtaamVrdWtNdkJ3QVFTQlFBZHRnbS9BSGphWTJCa1lHQm0rTThBSkRrWVZQNGZZR1pqQUlxZ0FCWUFTVWdEQUFBQUFuWUFBQU1BQUNRRENBQXJBZlVBTmdBQUFBQUFWQUN3QVJZQUFIamFZMkJrWUdCZ1lYQmtZR1lBQVVZR05BQUFCMW9BUzNqYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01Mi42MDA0OTMsLTYyLjI4NzgyOSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNS4xNjY3MiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNjAwNDkzLC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUyLjYwMDQ5MycgeT0nLTYyLjI4NzgyOSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNDYuNjUwNTQ2JyB5PSctNjUuOTAzMTkzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQyLjA3MDQ5MicgeT0nLTYyLjI4NzgyOSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMzguMTk2MTE4JyB5PSctNjIuMjg3ODI5Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0zMC43MjQxMTknIHk9Jy02MC43OTM0NDgnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTI2LjI1NDc0OScgeT0nLTYyLjI4NzgyOSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNC4wNDM0LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNjAwNDkzLC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUyLjYwMDQ5MycgeT0nLTYyLjI4NzgyOSc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC0xMS4xMDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwwLjAsLTExLjM1OTczKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04LjIwNzIxLC0zMC41MzYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUyLjYwMDQ5MywtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01Mi42MDA0OTMnIHk9Jy02Mi4yODc4MjknPm48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTAuOTEyNDMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUyLjYwMDQ5MywtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01Mi42MDA0OTMnIHk9Jy02Mi4yODc4MjknPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ1LjEyODQ5NCcgeT0nLTYwLjc5MzQ0OCc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1My4xNTU1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNjAwNDkzLC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUyLjYwMDQ5MycgeT0nLTYyLjI4NzgyOSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTkuNzIyMjYgMEg0NS44NTY4OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni4xMDY4OSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMwLjk2MzM1LDQuMTcyOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUyLjYwMDQ5MywtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01Mi42MDA0OTMnIHk9Jy02Mi4yODc4MjknPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtMTAuMTA5N1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCw1Ni45MDU1LC0xMC4zNTk3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMzAuMDM2MDcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Mi42MDA0OTMsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTIuNjAwNDkzJyB5PSctNjIuMjg3ODI5Jz5tPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjU5ODk0LTU2LjkwNTVINDguMDk5OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMzQ5OTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI2LjI1NzQsLTY0LjU3ODQxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNjAwNDkzLC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTUyLjYwMDQ5MycgeT0nLTYyLjI4NzgyOSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = {f^{*}(A_{1})},
      nw/style = {pullback},
      ne = {A_{1}},
      sw = B,
      se = A,
      north = g,
      east = m,
      east/style = {>->},
      south = f,
      west = {n},
      west/style = {>->},
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Then by <fr:link
type="local"
href="ct-001A.xml"
addr="ct-001A"
title="Beck-Chevalley condition">Beck-Chevalley</fr:link> condition we have</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {aligned}       f^{*}(A_{1} \Rightarrow  A_{2}) &:= f^{*}\forall _{m}m^{*}(A_{2})\\                                       &\cong  \forall _{n}g^{*}m^{*}(A_{2}) && \text {since $mg = fn$}\\                                       &\cong  \forall _{n}n^{*}f^{*}(A_{2})\\                                       &=: f^{*}(A_{1}) \Rightarrow  f^{*}(A_{2})     \end {aligned}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Related">Related</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1231</fr:anchor><fr:addr
type="user">ct-001A</fr:addr><fr:route>ct-001A.xml</fr:route><fr:title
text="Beck-Chevalley condition">Beck-Chevalley condition</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-0019.xml"
addr="ct-0019"
title="Heyting category">Heyting category</fr:link> and the following square be a pullback in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="d804ae405338fd0a02688b09c61d7252"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNy40MDc2NTZwdCcgaGVpZ2h0PScxMTQuOTAyMzMxcHQnIHZpZXdCb3g9Jy03MiAtNzIgNzguMjcxNzcxIDc2LjYwMTU1NCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdVQUFvQUFBQUFCdGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjB4Mk50WVhBQUFBRTRBQUFBTWdBQUFEd0FnZ0RDWjJ4NVpnQUFBV3dBQUFMQ0FBQURuUEtyWjJSb1pXRmtBQUFFTUFBQUFDOEFBQUEyS0FIQ1dXaG9aV0VBQUFSZ0FBQUFJQUFBQUNRRnFnR2NhRzEwZUFBQUJJQUFBQUFVQUFBQUZBeFVBUkZzYjJOaEFBQUVsQUFBQUF3QUFBQU1BYTRDb20xaGVIQUFBQVNnQUFBQUdBQUFBQ0FBQ0FCWWJtRnRaUUFBQkxnQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRmlBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUttZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTVdRek0vd0g4cGtoMGtocS9nT0ZBZG1BRFRnQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS1pqQmsvLzhQNUtlQjZQK3ovODhFcXdJQ0FKbU5DVDRBQUhqYWJkTkxiOU5BRUFkd3o2d2ZzUk43NDllNlRWSTNpWjExcXFaSjI2Uk9XMExhTkFXcDd4WUpTaEdDRXlCeFF1S0NRT0lUSUlRUUI2N2MrQXJjSy9YTWh3R0pTOHVhOGpoUTcyMW5EL09iLzFnQ2FlZWlnMC94cTdRdVNVQW9xSm9GV3AwblEraXlnS2thbTRZaHJKRkk1V25RSFVKZjNDK3l3SUtJSnp6dDh3NVlTS0diTWpXQlQ2dEZ1VmpTUnd2TlZZRFk1d1RvTktVMHJwR3BOdDBOMGFWSDFMZllSalF6QUlpWXFCZERTaDBuTkhLbGgxa1pQcHlmYnR2clBXOU1lQlJXTVZhVHZJNGc3L2dmdngyVHVnYkhKK1dFTitKL0paamtjMi9sZWc0azhhSFV1cGpEQnB4S2JXbWNhWVJFL1NVUkhYdXFGckF1U3dWZ1RTRGJrS1Q5N0lRUUNKVjRRTllnVFFSSzFiSVJzR0F4ZTRxMVovcnpGNTBIc3VqWFptQTVGYnZtRGFJSzA0TCsxdWdFeVlqYVd5Zk5KWk9VSE5PSDl4MENudDhyamF0KzBRYWVoQnVWZ2dZdnowZWRld1Q5MWxUTmRmT2hvU0RrSzVQejFmdGRHWTRQSCsyN2RKTkF6SW9NaXZiNWp5ODAzNGhrYUM3eDBmcEJIeHBWYWdvYlNIc1gzL0VWbmtrN21VeTBIS0ttWHNibHExbXphVGNJaFZjY2tWNVBZREllVDdJWlVGbmsxWWFsdmpzRUhsMkcyMCtaQnFQOXlxMlZtNzBDb0lkdXdUUklaWHJnb0cyb0VPVHRhTmhjQm1KYWpDR3k1dUJ3Z2lwdVZjOFpnZTdZeWpzWmFhd1hBU3h0czlVQS9IeCtWdXVDMHVtWjdZRjZyVnlyMlhWY3UrNGdCdk1CYTh1ZG1VSytHbStNRi93RnhIR1Q1YmRmOHpMTmcyc3kzRFNwSVJzMHA4bWs4TnQ1UXpqdlpNNHNnMFhtLzEwM29jM01ZalBGOFNqeFdIQzVrOW5GSHp6dnA0bklsNElGZFg0Rit2SDAzZVRvTmhjakZ5c1lWQzF2OWlEaHdVUzFSK204akVRQjZ2RlpnMmlHcmdJVURhK3lrb3dSRkFLd3ZSeFJPZUJYOFo5WXU0Mmxsb0JqYk1VNUMyQ1YxenpSZ3FLekZVTTN5Njc0a2VTOW1CcUlodEl1VjlweU43VWNTMjBteXB0VlorSy9RVWpTVHd5d2RSSUFBSGphWTJCa1lHQUE0akN1ZTF2aitXMitNakN6TUlEQVl5SDc5UWo2dnk3VE1hYUxRQzRIQXhOSUZBQWJFd296QUhqYVkyQmtZR0JtK00vQXdNQjBqRUhuL3dXbWFnYWdDQXBnQlFCbVlBUktBc1lBQUFJNkFFc0NPZ0FzQXF3QVRRSnVBRTBBQUFBQUFHWUExQUZJQWM1NDJtTmdaR0JnWUdVSVoyQmlBQUZHQmpRQUFBbUVBR0Y0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVWtBQW9BQUFBQUJmUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUYyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1haMng1WmdBQUFXUUFBQUpZQUFBQ3VKSGpjY2xvWldGa0FBQUR2QUFBQUM4QUFBQTJLSExESVdob1pXRUFBQVBzQUFBQUhnQUFBQ1FHWGdJbGFHMTBlQUFBQkF3QUFBQVVBQUFBRkE2b0FLdHNiMk5oQUFBRUlBQUFBQXdBQUFBTUFXSUNERzFoZUhBQUFBUXNBQUFBR0FBQUFDQUFDUUE2Ym1GdFpRQUFCRVFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGR0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtZXNjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJoWnZnUDVETkRwSkhVL0FjS0F3RDcxUTFqZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1Fndmd1Ly84RFNjZi8vLzhmQVBNWkFGTEtCcUI0MmpYUnYwOFRZUnpIOGVmemZOdm5hR252S2xmdWFxRFhsSlllWUZvSXZkd0JpY1ZRcVFpeC9LaEJnbzFFRXlTU2lEOUFaR0RvZ0RFYUdJd0ppWEZ3ME0wNHV6ZzVNVG01T3FpVDhVOHdiWDJPaE9kWm5ueHp3L3Y3T3NaWnR0M21QL2tQTnN4R0dmUGdlcU9HcWNlTm9tdUlZU2gyem5aYzAzQzlZYVFWRVRkTTExUWg1LzY0V0lKWHBNOVlGL0dvUU1uSWR5TVMzR2wwQkJIdDFCMEtLYTEyTmRxclJ3blI0TVpLQkpGUVgrbk4zL1F1WDQ0aHBEVWJoa1pKQlVUZ0hab0NSTXk3MHdmeGJBeGNVNFUvRG1zQ21STXNNWG1JWFdnM1NmQXZ6R0pEYkV5VzZrN0dGckl0YmFGYmhXTEJGQnFFa2hhbnZib2Y1K2JzVEU0b2RQWW0rVUh4dzFHUG5kUTByTlR2VUtNMlZ3Ty9FcnYycFBXNlYxVW5ySGZIYXpzY2hmSkJTZzl1SGRaM09SK1orVm9KQU9vQ0h6L0hxVmNCWDV5WTNkREMxZkc1S2JVVThEZUFqbWw2WE1sZTV0RE9Oei9TMDJyL0FyVitkNGt3WTJERjloL3E1Ti85WnBDS2pCU2RoSk96WmJNZmJGcndKSzlmbUlJbEY1RHpBbXpYODY5aEdxWW4xNkh3SlJMaFVCQWN5L1BUejBZcVBjSkFZUC9xd0pycjVFVWdwQVFwWHhsOFZONTdTMVJ6WnJjUGFvTURZa1pGaEorMC9xbXlXZEZ5cTV0QWVXeGxMVkhQNzk3bTZCc3ExQk9kQUkvY24rb3ZnbzRiTDNabW5TVUtaUHZWZVpXVE5PZHNVSnA3MGp6QjhyNjRld1p1Q3NXL1o5YW5ycWEvd2lSY3V3QkZxcjgvUXRtS1NlYnRmZEQ4ME5obW8vVXBxVW5pWDRjKzU4dGJlK1pFb3FNTC9GNTFLNlZMM1JoUlV2NzJWdytlUDd5WXYwNWtDUW5MeTgxdjBoR0JoZFRpemZRTmUzMFYwR1RhZi9RQmQxZDQybU5nWkdCZ0FPTGpBbGFlOGZ3Mlh4bVlXUmhBNExHUS9Yb0UvZjhsc3puVFhTQ1hnNEVKSkFvQUJtNEoxQUI0Mm1OZ1pHQmdadmpQQUNUOUdWVCtYMkEyWndDS29BQldBRlVyQTRrQUFBSjJBQUFEQUFBa0F3Z0FLd0xiQURNRFR3QXBBQUFBQUFCVUFMQUJEZ0ZjZU5wallHUmdZR0Jsc0dSZ1pnQUJSZ1kwQUFBR3JRQkVlTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02MS4zNDIwMzUnIHk9Jy02MS44MDM1Myc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy45MzEyNCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTcuNjg0MDUsLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPms8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuNjI3MDMsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02MS4zNDIwMzUnIHk9Jy02MS44MDM1Myc+RDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NCAwSDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY1MTgsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5oPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjQ4Njc5LTU2LjkwNTVINDcuNTcxNDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuODIxNDksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI2LjIwMjkxLC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = A,
    nw/style = {pullback},
    ne = B,
    sw = C,
    se = D,
    north = h,
    south = g,
    west = k,
    east = f,
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Then the following square commutes up to isomorphism.</fr:p>
    
      
      <fr:figure><fr:resource
hash="4e921109a6b663fb65b4091b43e7e844"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0NS41NDM3NDFwdCcgaGVpZ2h0PScxMTkuMTA2NTlwdCcgdmlld0JveD0nLTcyIC03MiA5Ny4wMjkxNjEgNzkuNDA0Mzk0Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWS9DT1dob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMm9OM0Q4YnoyM3hsWUdaaEFJSEhRdllia0dtV1VNWTdRSXFEZ1FuRUF3QXNmd21OQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNa0FBb0FBQUFBQTRRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVrQUFBQmdxa21VUzJOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKVFoyeDVaZ0FBQVd3QUFBQmdBQUFBWUw3dmtMZG9aV0ZrQUFBQnpBQUFBQzhBQUFBMktNekRFR2hvWldFQUFBSDhBQUFBSGdBQUFDUUZ1di9VYUcxMGVBQUFBaHdBQUFBSUFBQUFDQVluQUJCc2IyTmhBQUFDSkFBQUFBWUFBQUFHQURBQUFHMWhlSEFBQUFJc0FBQUFGZ0FBQUNBQUJRQVlibUZ0WlFBQUFrUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQURGQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1GbWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4b0FBSEdDT2x1Q3lkZ1UySlFZbUJXZkdQRVFPUVpENEhGR1pFS1AzL240RUJBTXNRRGNnQUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVb00vLzlEeUh1TVlIa0dBRWsyQlg4QUFBQUNBQkQvN0FLSUFzY0FFd0FXQUFBSkFRY0dCeVluQVNjMk54WWZBU0UzUGdFWEZnRWJBUUtBL3VrR0FoVVZCdjdtQndJWUZBWmVBVk5lQnlnRUF2NHZsWk1DbXYxeERCQURBaFVDbHhNWUFnSVczTjRWQVJvQi92WCtwQUZjQUhqYVkyQmtZR0FBWWljblBjRjRmcHV2RE13c0RDRHdXTWgrQTRMKy80WjVJdE54SUplRGdRa2tDZ0R2eGdtR0FIamFZMkJrWUdCVy9HTUVKQ2N5Q0REd01YVXdBRVZRQUJNQVF6Z0Nrd0FBQTVFQUFBS1dBQkFBQUFBQUFEQUFBSGphWTJCa1lHQmdZaEFIWWhCZ1pFQURBQUx6QUI0QUFIamFUWXc5YjhJd0VJYWZpQVNKZE9oU2RlZ0FIcGl0b0ZSaVkyRmdZbVhxQXRpZ0RIR1FIU0pGcWpyeXUzdTRIbnJENlhrLzdvQ1NIektlay9FYTkzTnlDbEYvWFBEQ1crS3BxRVhpa2crV1RNanltVGh6Tm9selNiNFNGN3h6U1R3Vi96dHh5U2VQYmRmZTdyMzFhdDhaNjkyNURlUDZZSDFvT3FkV3VvcDZaNTMxeDk0YWRScVZHWm93WEZ0VjYwclhiT2xvdVhHbngrSlI3TVV4a1IxbnlRSWphdzdSQ1RTU09tbXQwRlQvOHAza0xuYU84Wk9SemtrU0pUVElWWkI5bGJhaWpwZWEraGZ6ZVRCUEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTRUFBb0FBQUFBQlR3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWUYxV0dOdFlYQUFBQUU0QUFBQU1RQUFBRHdBZ2dDK1oyeDVaZ0FBQVd3QUFBSEFBQUFDRE5BT2V2Sm9aV0ZrQUFBRExBQUFBQzhBQUFBMktJL0NYV2hvWldFQUFBTmNBQUFBSGdBQUFDUUdRd0pQYUcxMGVBQUFBM3dBQUFBTUFBQUFEQWtZQVBwc2IyTmhBQUFEaUFBQUFBZ0FBQUFJQUhJQkJtMWhlSEFBQUFPUUFBQUFGd0FBQUNBQUJRQmZibUZ0WlFBQUE2Z0FBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUVlQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm01bUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBxbU1XUXpNL3dIOHBraDBraHEvZ09GQWJHTERNb0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtwakZrLy84UDVJUHAvN1AvVHdlckFnSUFtVWtKT2dBQUFIamFIWkE5Y3ROQUdJYjFmbHJ2eXJaK0xGbmVkWnpZeEpKblpUdTJUSkF0OFdkNzZCZ0dacElpQlFVVTBHV0dobzZoNEFBTWNJVWNnSjZHbHVFQUhJSVQwQ2FzTXU4V1d6ekY5endXckk4M1MvcEZmNnlubGdVN0FCYytCTmZaRG9WVU1SZnlEbmFveWozS0t1VjZzeTVWVWY5dko1V1BWR2U2clBRS2llQUJpbExHZ2d2OGZlQTF3MEgwWkptOHNESHJ6ZTI0Ri9qZDRhUVJSa2RoKzZYWGpZUFhQbWQ5eDB2UHA4OE1JdWMyM0ZFbjZBNVV5KzIvODJMSFp2aDgvV09YUEo0TkNrS1NKNG1kaGVPV0FGSFoyMTllWFQ0RTkrSW16c2JINjA2NFlwZ3Nhb1JudmtQb2QvYmZ3QS9hTml5alpYMjYrVWZmNmJmMXFuWXNLeU4wcjc0OXk3SFJSaTFIYXFUTk03SlNTY0VWbDhwQXBvRWFtUnBtaWRHc3lrelhTMnRVWjFYWGhERGlKbFo1RzBqMkpENjhmVlJVYndwOUNscEVmWWxnM0dSQnVMaFkrR3RaM085c0dIZ0Q2QnpOVnNKdWVxNkQySTJTN2VvNWdUR3dQSXhPZXpuSlljcllGMFp3L0xRZEVYRzc4ZFdOUVZmWDd3OFgrUlluZW40TUhQcnN4R2NOZ2MzRW0zb1VjYlYxMVpCRlUySm5JNzlGSk84ZXFCV3JTaEVIempMa3JQblQxWVNKb2szRU9RZVpmcTRwNUtMaE1aUHBQd29LUHgxNDJtTmdaR0JnQU9LRlg0NXF4dlBiZkdWZ1ptRUFnY2RDOWhzUTlIOWQ1aENteTBBdUJ3TVRTQlFBTUdjS1ZnQjQybU5nWkdCZ1p2alBBQ1JER0tyL2YyYzZ5Z0FVUVFITUFHc2dCSmNBQUFOVUFBQUN2QUI3QXdnQWZ3QUFBQUFBY2dFR2VOcGpZR1JnWUdCbWlHTUEwUXhRRWdrQUFBbm1BR1VBZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmd3TnFGZ1ltVnFRdGdGMld3alp3UUNhbnEyTi9kaC9IUU4xeWQrMkVETlQ4VTNLOWdsdlIrSlpXNEIxZE1tV2VlaUh2TFhMUGduU2VLOGxtU1Z6NHlsOUo4WnE1NDRTdnpSUEx2ekRVcmZqZkJYYTZEaldvWGpJMys1RnkzM3R2WWQ4R3JwVzZTMzFwdjQyR3dSaDF2eW94ZFA1NmRhbldqV3pZRUhCZXVERmdpaXAwa0pySG5KSjJqWTgwK0piMXdrRnl4Uk5QODY3ZlMrN1E1cEorTWJJN2NSQTJqTEhyUnMyd1ZiWHFwYWY4QXlCRXY3d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVrQUFvQUFBQUFCZlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDFGMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNYWjJ4NVpnQUFBV1FBQUFKWUFBQUN1SkhqY2Nsb1pXRmtBQUFEdkFBQUFDOEFBQUEyS0hMREkyaG9aV0VBQUFQc0FBQUFIZ0FBQUNRR1hnSWxhRzEwZUFBQUJBd0FBQUFVQUFBQUZBNm9BS3RzYjJOaEFBQUVJQUFBQUF3QUFBQU1BV0lDREcxaGVIQUFBQVFzQUFBQUdBQUFBQ0FBQ1FBNmJtRnRaUUFBQkVRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRkdBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaFp2Z1A1RE5EcEpIVS9BY0tBd0Q3MVExamVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZndS8vOERTY2YvLy84ZkFQTVpBRkxLQnFCNDJqWFJ2MDhUWVJ6SDhlZnpmTnZuYUdudktsZnVhcURYbEpZZVlGb0l2ZHdCaWNWUXFRaXgvS2hCZ28xRUV5U1NpRDlBWkdEb2dERWFHSXdKaVhGdzBNMDR1emc1TVRtNU9xaVQ4VTh3YlgyT2hPZFpubnh6dy92N09zWlp0dDNtUC9rUE5zeEdHZlBnZXFPR3FjZU5vbXVJWVNoMnpuWmMwM0M5WWFRVkVUZE0xMVFoNS82NFdJSlhwTTlZRi9Hb1FNbklkeU1TM0dsMEJCSHQxQjBLS2ExMk5kcXJSd25SNE1aS0JKRlFYK25OMy9RdVg0NGhwRFViaGtaSkJVVGdIWm9DUk15NzB3ZnhiQXhjVTRVL0Rtc0NtUk1zTVhtSVhXZzNTZkF2ekdKRGJFeVc2azdHRnJJdGJhRmJoV0xCRkJxRWtoYW52Ym9mNStic1RFNG9kUFltK1VIeHcxR1BuZFEwck5UdlVLTTJWd08vRXJ2MnBQVzZWMVVuckhmSGF6c2NoZkpCU2c5dUhkWjNPUitaK1ZvSkFPb0NIei9IcVZjQlg1eVkzZERDMWZHNUtiVVU4RGVBam1sNlhNbGU1dERPTnovUzAyci9BclYrZDRrd1kyREY5aC9xNU4vOVpwQ0tqQlNkaEpPelpiTWZiRnJ3Sks5Zm1JSWxGNUR6QW16WDg2OWhHcVluMTZId0pSTGhVQkFjeS9QVHowWXFQY0pBWVAvcXdKcnI1RVVncEFRcFh4bDhWTjU3UzFSelpyY1Bhb01EWWtaRmhKKzAvcW15V2RGeXE1dEFlV3hsTFZIUDc5N202QnNxMUJPZEFJL2NuK292Z280YkwzWm1uU1VLWlB2VmVaV1ROT2RzVUpwNzBqekI4cjY0ZXdadUNzVy9aOWFucnFhL3dpUmN1d0JGcXI4L1F0bUtTZWJ0ZmREODBOaG1vL1VwcVVuaVg0Yys1OHRiZStaRW9xTUwvRjUxSzZWTDNSaFJVdjcyVncrZVA3eVl2MDVrQ1FuTHk4MXYwaEdCaGRUaXpmUU5lMzBWMEdUYWYvUUJkMWQ0Mm1OZ1pHQmdBT0xqQWxhdThmdzJYeG1ZV1JoQTRMR1EvUVlFL2Y4bHN6blRYU0NYZzRFSkpBb0FCZkFKMGdCNDJtTmdaR0JnWnZqUEFDVDlHVlQrWDJBMlp3Q0tvQUJXQUZVckE0a0FBQUoyQUFBREFBQWtBd2dBS3dMYkFETURUd0FwQUFBQUFBQlVBTEFCRGdGY2VOcGpZR1JnWUdCbHNHUmdaZ0FCUmdZMEFBQUdyUUJFZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJRQUFvQUFBQUFCT3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjAyMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUM3WjJ4NVpnQUFBV1FBQUFHU0FBQUJ4T2JSakxSb1pXRmtBQUFDK0FBQUFDOEFBQUEyS0FIQ1VXaG9aV0VBQUFNb0FBQUFId0FBQUNRRnFRSGZhRzEwZUFBQUEwZ0FBQUFNQUFBQURBZXNBSGxzYjJOaEFBQURWQUFBQUFnQUFBQUlBRzRBNG0xaGVIQUFBQU5jQUFBQUdBQUFBQ0FBQmdCTmJtRnRaUUFBQTNRQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRVJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbTZtT2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTJRd00vd0g4cGtoMGtocS9nT0ZBZUdqRFUwQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZnWi8vOER5ZlQvLy8vUEF2TVpBRlhHQnNSNDJoMlF6VzdUUUJSR2ZlODRNNDMvSnJiakdXaU5hOGVKN1VyQmJ1dkVCaEVjM0VSSUJWRXFOcWdJc2V1K0VodFVKSjRCOFJTOEFudWt2aEVTbXhRYmZkdXpPT2RUVUpuZlA4WVovRlp5WmFNb1FDeGdORWtiS0UrRkhGTW1SU21xdW9FMVVKWkRXdFg5QXBBTjFCMUExbENsU1pwUVJwa0ZRcDcyS0VZM3c4OWZpazhxeE1JV1lEbStIWTFYc1MrWXJNL2JLeVF0dDgrdnNxVko5aDNUZ3g4RmdiRzMyTitFM3NpR0pBM09mSVBCN2E0dFBoRDA1bzhpMTlVRGJZQ2crdytQdzQrbEN1OHZyeTljdmlVd0ZTTUJJM3YzOXhmWFo3RUsyVEpwWDd5dFlSWnlVK2xpbERmM2YvQXIzaW12KzdKT09VQkdPZlN1SHUxbHExSUdYVyszU1pJdXVwZytMMG43RDdocVFaekRzblliU09MSi8wdnFTakJvTC94M1QxOHVETUF4dW9hcEVmOXc1YUN0VVpDNkhUZlpFeUNtSlFTaXlGYVhEL2pBRFlkN21odzY5dUM3aW53NkhBRlliRHVmQWY3YzNVVWxESXFGbWEvb3M0TW9zaWU0ZnU0Z3ltTXBjclU0TXZSd2VyWTU4VTRRTjVuUVgzMUxEcmdPcmlsd2EzSk4xZmdlVTRueEQ3alBPOHNBQUhqYVkyQmtZR0FBNHFxNjVkM3gvRFpmR1poWkdFRGdzWkQ5QmdUOVg1ZnBHTk54SUplRGdRa2tDZ0FsTFFwaUFIamFZMkJrWUdCbStNL0F3TUIwakVHSFFaU3BtZ0VvZ2dLWUFVRWRBbzRBQXNZQUFBSTZBQ3dDckFCTkFBQUFBQUJ1QU9KNDJtTmdaR0JnWUdid1lXQmlBQUZHQmpRQUFBZzdBRlI0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMko3dkNYV2hvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaXp5c25UWTdudC9uS3dNekNBQUtQaGV3M0lPai9ERXdOekNBdUJ3TVRpQUlBTVlRSndBQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoWGQwZzJOdFlYQUFBQUU0QUFBQU13QUFBRVFBZGdFeVoyeDVaZ0FBQVd3QUFBRTZBQUFCVUNpQ2IyZG9aV0ZrQUFBQ3FBQUFBQzhBQUFBMkoyWERJbWhvWldFQUFBTFlBQUFBSHdBQUFDUUZOd0ZnYUcxMGVBQUFBdmdBQUFBT0FBQUFEZ2JFQUlGc2IyTmhBQUFEQ0FBQUFBb0FBQUFLQVBvQWhtMWhlSEFBQUFNVUFBQUFHQUFBQUNBQUJ3QXlibUZ0WlFBQUF5d0FBQURUQUFBQlBxa3JkZHR3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1VbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvR001UXljLzRIOHBrNUdkSFUvQWNLQXdDNmFnenFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1U0NHWklZU3YvL1I3RCtyL3UvNEg4ZldDMFlBQUR1aGd1aUFIamFQWTZ4VHNKUUFFWGZmVlVhSFFxdkRUVUlGZ3RDb1FZcUpmQ0NHZ2l4RVRFR0dqVEI2S0k0cUluT2F0VE53ZEZmY0RYeEU1ZzcrZ082T0RtNHVvTFBHRTN1Y3U0ZDdpRWdoZkVIeHZTTkxCRUN1UWhMZ1d4ZzVqOENRMW1MRytCMWNESC9KdnREcm83WGNLTFhhSFZBNDdKdUwzcWJLVFVOZW5Qc1huamh0U3R6dlFQTVJ0UkNvN0NSWEpGd2ZjYjM2Rk12bGdOdE95bDdVb3RNTXlPanRkemQyd2trODl1VmVVcjlpbGxTVkJhZU1zeG1zM3NweFFnaGxPeU12L0JKQXhJaENVSTBWdjh6RXliUk5OT2lPdGVyUWs1VzhPajBrKzE5S3AxM3k1N3ErOWFxZXlCSi9aTE5hVEI2V1loQnVqODZ2YU93VkVjVUQrOGVoVDhZQ00yYytBSHBpWjhoQXFJS1lPbUtnblFSbkpWWlNIZXJuR0c0WlIzYWRRYytuVHRwQWNHb1ZqTGphTmJRSHoybk1ud1orVytuZEVCU0FBQjQybU5nWkdCZ0FPTGVHWDZUNC9sdHZqSXdzekNBd0dNaCt3MEkrdjhMSmkybXUwQXVCd01UU0JRQUl6QUtjd0I0Mm1OZ1pHQmc1dnpQd01EQVpNR2d5NkRDK0o4QktJSUNtQUUvWUFLY0FBSXFBQUFDT0FBdEFoQUFWQUJTQUFBQUFBQUFBRklBaGdDb0FBQjQybU5nWkdCZ1lHRXdaR0JpQUFGR0JqUUFBQVd6QURwNDJrMk9zV3JETUJDR1AxUGJVTGZRcVIwNkZFMFpoWTM3QUlVTW1iSm1MQ1NSTUM1WURwSmo4Rkw2QUhub1hCUU52WU9mVC8vOWR3aW8rQ1hqVmhrdlVXK1ZVOHJyemdWUHZDWXVwVlhpaW5kV1BKRGxqK0o4OEpVNDU1bnZ4QVZ2L0NRdXhmOUxYUEhKWlQwT3AvTmt2ZHFPeG5wM0hFSm82cDMxb1IrZGFuUjlOemJXV2IrZnJGR0hSWm01RDNNM3FGYlh1bVhOeU1DSk14TVdMei9iaW1NaU80NHlDOUlOTmJ2b0JYcVpPOGsxYUhIL0p6YVNjREcxajllTXBBNHNvb1paOW9Kb0ozbEZHM2MxN1JYK0NERDdBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUxLjY1ODkxLC02MS4zMjIyNzIpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTUuODc2NzUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MS4zMjIyNzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjEuMzIyMjcyJz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYxLjMyMjI3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjEuMzIyMjcyJz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yMy44OTgzNzInIHk9Jy02MS4zMjIyNzInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE2LjExMTgzLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYxLjMyMjI3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTEuNjU4OTEnIHk9Jy02MS4zMjIyNzInPlN1YjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzUuODI5MzU1JyB5PSctNjEuMzIyMjcyJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zMS45NTQ5ODEnIHk9Jy02MS4zMjIyNzInPkQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTIzLjQyOTk5MicgeT0nLTYxLjMyMjI3Mic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC04LjkwOTczVi00Ny40OTU3NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDcuNzQ1NzcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMi4zMDIxMiwtMzAuMjAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjEuMzIyMjcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01MS42NTg5MScgeT0nLTYxLjMyMjI3Mic+4oiAPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny4xNDgwMjUnIHk9Jy02MC4yNjUxMjUnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMzIyMTQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MS4zMjIyNzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjEuMzIyMjcyJz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYxLjMyMjI3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjEuMzIyMjcyJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNC40ODI5ODInIHk9Jy02MS4zMjIyNzInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMTQwOSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MS4zMjIyNzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjEuMzIyMjcyJz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYxLjMyMjI3Mic+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjEuMzIyMjcyJz5DPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNC4xMjE4NjcnIHk9Jy02MS4zMjIyNzInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTIwLjQzMjMgMEgzNi4yNjY2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM2LjUxNjYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4xNjgyNywyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYxLjMyMjI3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTEuNjU4OTEnIHk9Jy02MS4zMjIyNzInPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2Ljk5NDY1MScgeT0nLTY0LjMyODc5Jz7iiJc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtOC45MDk3M1YtNDcuNDk1NzcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00Ny43NDU3NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTMwLjIwMjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYxLjMyMjI3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuNjU4OTEnIHk9Jy02MS4zMjIyNzInPuKIgDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuMTQ4MDI1JyB5PSctNjAuMjY1MTI1Jz5rPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00yMC42NjczNy01Ni45MDU1SDM2LjA4NTM2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM2LjMzNTM2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC40NTk4NCwtNjUuMDYxNDgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjEuMzIyMjcyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01MS42NTg5MScgeT0nLTYxLjMyMjI3Mic+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDcuNTIxOTU5JyB5PSctNjQuMzI4NzknPuKIlzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = {\mathsf {Sub}(B)},
    ne = {\mathsf {Sub}(A)},
    sw = {\mathsf {Sub}(D)},
    se = {\mathsf {Sub}(C)},
    north = {h^{*}},
    west = {\forall _{f}},
    south = {g^{*}},
    east = {\forall _{k}},
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>766</fr:anchor><fr:addr
type="machine">#276</fr:addr><fr:route>unstable-276.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Consider the corresponding left adjoint square.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="ed07d9d46bf3793064647aa72d9389df"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0NS41NDM3NDFwdCcgaGVpZ2h0PScxMjAuMTYxODEzcHQnIHZpZXdCb3g9Jy03MiAtNzIgOTcuMDI5MTYxIDgwLjEwNzg3NSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1nQUFvQUFBQUFBNHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FreVVUbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pXWjJ4NVpnQUFBV3dBQUFCY0FBQUFhSjVnVklab1pXRmtBQUFCeUFBQUFDOEFBQUEyS016RERtaG9aV0VBQUFINEFBQUFIZ0FBQUNRRnV3QVVhRzEwZUFBQUFoZ0FBQUFJQUFBQUNBWW5BRkJzYjJOaEFBQUNJQUFBQUFZQUFBQUdBRFFBQUcxaGVIQUFBQUlvQUFBQUZ3QUFBQ0FBQkFBZmJtRnRaUUFBQWtBQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBREVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUZtYWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhvQUFIR0NPbHVDeWRnVTJKV1ltWldmR1BFUU1Ec3lMek9hQXdJMExwLy84TURBREx4QTNPQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyTS8vOUR5THYvd1BJTUFGQnRCb0VBQUhqYVkyQmtDUGovbjhtRDZRU0RMQU1EbzZBWW03b2ltNXFKbWJpaUlCcHRKc2JremlnbytTK0tUMHFTbjNIT3YwSWVTUmsreHE1L0tXRCtNa2xCcHZsL082WDRHUms1VkRnWUdTVWhsRGdqcHpJbkk2TUFBd0Q3TmhITmVOcGpZR1JnWUFEaTVwQ2xzdkg4Tmw4Wm1Ga1lRT0N4a1AxU0JQMy9QL05FcGhOQUxnY0RFMGdVQUJSVENsb0FlTnBqWUdSZ1lGYjhZd1FrSnpJRU1QZ3hlVEFBUlZBQUV3QkplQUxUQUFBRGtRQUFBcFlBVUFBQUFBQUFOQUFBZU5wallHUmdZR0Jpa0dNQTBReFFFZ2tBQUFPTEFDUUFlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ1ZHSmpZV0JpWmVvQzJLQU1jWkFkSWtXcU92SzdlN2dlZXNQcGVUL3VnSklmTXA2VDhScjNjM0lLVVg5YzhNSmI0cW1vUmVLU0Q1Wk15UEtaT0hNMmlYTkp2aElYdkhOSlBCWC9PM0hKSjQ5dDE5N3V2ZlZxM3hucjNia040L3BnZldnNnAxYTZpbnBubmZYSDNocDFHcFVabWpCY1cxWHJTdGRzNldpNWNhZkg0bEhzeFRHUkhXZkpBaU5yRHRFSk5KSTZhYTNRVlAveW5lUXVkbzd4azVIT1NSSWxOTWhWa0gyVnRxS09sNXI2Ri9ONU1FOEFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUlFBQW9BQUFBQUJRZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMHltTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWdnQytaMng1WmdBQUFXd0FBQUdNQUFBQjJBdloyckJvWldGa0FBQUMrQUFBQUM4QUFBQTJLQUhDUjJob1pXRUFBQU1vQUFBQUlBQUFBQ1FGdUFHYWFHMTBlQUFBQTBnQUFBQU1BQUFBREFkdUFKaHNiMk5oQUFBRFZBQUFBQWdBQUFBSUFHWUE3RzFoZUhBQUFBTmNBQUFBRndBQUFDQUFCUUJZYm1GdFpRQUFBM1FBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFUkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtcW1LY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F6TS93SDhwa2gwa2hxL2dPRkFkcVhEVHNBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpGay8vOFA1SVBwLzdQL1R3ZXJBZ0lBbVVrSk9nQUFBSGphUlpFN2J4TkJGSVgzek16dWVBYzhkMk92WjBNYy9OcnhURkNDQTNHeVN5eGs4cUxKUXlnRkJDbzZrUGd0Q0ZGUTBOTHhRNUNvK1RGUUpzd3FFdHpUbmRPYzc5d0kwZG5OTnZ2QWZrVUhVUVJPU0tTR25EaS94TndVSnBGbWlDV2U4VEp4VlRGZm9nNytqaWswU3VkZFZidHRhRWFZVnlieCtMYklSTGFXSGo3ZVdBQzI1emhvU0VSMnpPL1A2SHpBdW5SSlBXMk95Z2RQZ2RLRVBCc1FkVG9EMVZwNzI4VDRjdjNqZE9WZ056L21yaHlNbUUzOG5aUkJuUFcrL3I3aUU0bXJOMzN2cHZaL2hIdnU0U2N4YVNFS2gramk1Zzk3em41R3J4cVdLblRkTWIxL1ZRTllneGVvZ25MaXVTbHVlUnBESmtFQjI5V1ZuOEVUTkNadXIrNHU0Y3JiTmVyS1NCeStHNzcybHk4ZGJGTy9HT2w4ODRWM3hlcG9sK2lSWUR3RzVXNVRjYW5TQk1oVXZyN3ZqeGxpRHB3K0tVa1ViaVgrTEJqWk5BTzBQTm1hZ24yL2ZxL1BwM3RiL2ZHWVdXMWJHbGk0Y1I0cXhLblpWMm03M3cxUEVCZVdGR01xbnZYWFoySmU2WTVPTm56OGNkRlo3YllOTzJtVEVvcGFVdkM3WVlxLzR4UTVTSGphWTJCa1lHQUFZdjB2WEgvaitXMitNakN6TUlEQVl5SDdwUWo2dno3VE1hYUxRQzRIQXhOSUZBQWpMUXBZQUhqYVkyQmtZR0JtK00vQXdNQjBqTUg3L3dXbUxBYWdDQXBnQmdCbjVBUldBc1lBQUFJNkFFc0NiZ0JOQUFBQUFBQm1BT3g0Mm1OZ1pHQmdZR1lJWndEUkRGQVNDUUFBQ1RjQVhnQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVJjQUFvQUFBQUFCUGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZSjFjbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUM3WjJ4NVpnQUFBV1FBQUFHZUFBQUIwRWdYV254b1pXRmtBQUFEQkFBQUFDOEFBQUEyS0kvQ09taG9aV0VBQUFNMEFBQUFIZ0FBQUNRR1dnS2JhRzEwZUFBQUExUUFBQUFNQUFBQURBbHdBT1JzYjJOaEFBQURZQUFBQUFnQUFBQUlBR3dBNkcxaGVIQUFBQU5vQUFBQUdBQUFBQ0FBQmdCUmJtRnRaUUFBQTRBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRVVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVZtV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTTJRd00vd0g4cGtoMGtocS9nT0ZBYnZjRE9VQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZnWi8vOER5ZlQvLy8vUEF2TVpBRlhHQnNSNDJoMlFNVy9UVUJTRmZhN3Q1OFIrdFJQYjd6bEFIRnFiMkNta2NacTJ0cXFHcEdvb1ZFclVWcXdncEFyQkFtc0hKaVlraEFSc3pQd01aaVRFRDBKTVNDM1AxVG5EMVQxM09OL1ZTSHQxUGFSUCtLV050SVdtUVhlUnNnSlpQc05FaXBCWjhpN2tqT1p3WVkyUWwxV3RpWXpLcWdkaFZXVjlxaUlYb29kcVZwcyt2QTIvdmluMm5CMEQvWW0wVzVSc1JmTW5IZGJ4VjVQbGE5S1AyLzc1UlhKNHE1MEV3YmN0Q0NPYWJwN0l1RXY3NjRQajJHM2k4bXExUEtHbXpvdTRmOXRyZEQyVEFIczg3bDYwK29UblQxK3VBdTlJdjVQa2dIRC8vYkJUbGhnWXA4WGx4c0VReUdQUFV5RGErK3UvOUlkK2EyYzFsV3FtK2pJUHRRV0xicHJ1UkRJS0xhYWt5SGJuS0pXcjNTeTk0ZkZJZlNMTHEwQXRzd0lzcTluVkxJWEV1M1A1WW5tNnBNQU1iYytpalh6bUdnM09tNGg1ZTdBb0RxRzN1Q0NoZ3VtejlkQzFFOHZzdGxMRCtHd1FHbTdxK0VSTU43L3dFUFQ5Nm1lODBMRW83eC93L1U0ZXRsS2RIZzI5SnBFVGJvZCtvY0EydVpQM0hyTHBLQm5RNCsxZSt1QmpKeEM0RjlHZXp4Z0RnYTF4UndlSHVXYjhCODVTUGdnQUFIamFZMkJrWUdBQTRvMC9PUnpqK1cyK01qQ3pNSURBWXlIN3BRajZ2dzV6Q05OeElKZURnUWtrQ2dBVkp3bWpBSGphWTJCa1lHQm0rTThBSkVNWVVobWNtVDR6QUVWUUFETUFSK0lDL0FBQUExUUFBQUxOQUdVRFR3Qi9BQUFBQUFCc0FPaDQybU5nWkdCZ1lHWUlZR0JpQUFGR0JqUUFBQWlmQUZoNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTm9BQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUMwQUFBQTJLWS9DSTJob1pXRUFBQUpBQUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQW1BQUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ2FBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSndBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb2dBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEV0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpMm9OMzM4YnoyM3hsWUdaaEFJSEhRdlpMa1dtV1VNWTdRSXFEZ1FuRUF3QXg2UW1qQUFBQWVOcGpZR1JnWU5iNlk4bkF3QkxLME1mUXo1VE1BQlJCQVV3QVVvQURRZ0FFVlFBQUF2SUFqZ0FBQUFBQVZBQUFlTnBqWUdSZ1lHQmlNR1VBMFF4UUVna0FBQVhLQURzQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMko3dkNSMmhvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaXp5c243WS9udC9uS3dNekNBQUtQaGV5WEl1ai9ERXdOekNBdUJ3TVRpQUlBTnU0SjFnQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVa0FBb0FBQUFBQmZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxRjJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDWFoyeDVaZ0FBQVdRQUFBSllBQUFDdUpIamNjbG9aV0ZrQUFBRHZBQUFBQzhBQUFBMktITEREV2hvWldFQUFBUHNBQUFBSGdBQUFDUUdYZ0lsYUcxMGVBQUFCQXdBQUFBVUFBQUFGQTZvQUt0c2IyTmhBQUFFSUFBQUFBd0FBQUFNQVdJQ0RHMWhlSEFBQUFRc0FBQUFHQUFBQUNBQUNRQTZibUZ0WlFBQUJFUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZHQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmhadmdQNURORHBKSFUvQWNLQXdENzFRMWplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2Z3UvLzhEU2NmLy8vOGZBUE1aQUZMS0JxQjQyalhSdjA4VFlSekg4ZWZ6Zk52bmFHbnZLbGZ1YXFEWGxKWWVZRm9JdmR3QmljVlFxUWl4L0toQmdvMUVFeVNTaUQ5QVpHRG9nREVhR0l3SmlYRncwTTA0dXpnNU1UbTVPcWlUOFU4d2JYMk9oT2Rabm54encvdjdPc1padHQzbVAva1BOc3hHR2ZQZ2VxT0dxY2VOb211SVlTaDJ6blpjMDNDOVlhUVZFVGRNMTFRaDUvNjRXSUpYcE05WUYvR29RTW5JZHlNUzNHbDBCQkh0MUIwS0thMTJOZHFyUnduUjRNWktCSkZRWCtuTjMvUXVYNDRocERVYmhrWkpCVVRnSFpvQ1JNeTcwd2Z4YkF4Y1U0VS9EbXNDbVJNc01YbUlYV2czU2ZBdnpHSkRiRXlXNms3R0ZySXRiYUZiaFdMQkZCcUVraGFudmJvZjUrYnNURTRvZFBZbStVSHh3MUdQbmRRMHJOVHZVS00yVndPL0VydjJwUFc2VjFVbnJIZkhhenNjaGZKQlNnOXVIZFozT1IrWitWb0pBT29DSHovSHFWY0JYNXlZM2REQzFmRzVLYlVVOERlQWptbDZYTWxlNXRET056L1MwMnIvQXJWK2Q0a3dZMkRGOWgvcTVOLzlacENLakJTZGhKT3paYk1mYkZyd0pLOWZtSUlsRjVEekFtelg4NjloR3FZbjE2SHdKUkxoVUJBY3kvUFR6MFlxUGNKQVlQL3F3SnJyNUVVZ3BBUXBYeGw4Vk41N1MxUnpacmNQYW9NRFlrWkZoSiswL3FteVdkRnlxNXRBZVd4bExWSFA3OTdtNkJzcTFCT2RBSS9jbitvdmdvNGJMM1ptblNVS1pQdlZlWldUTk9kc1VKcDcwanpCOHI2NGV3WnVDc1cvWjlhbnJxYS93aVJjdXdCRnFyOC9RdG1LU2VidGZkRDgwTmhtby9VcHFVbmlYNGMrNTh0YmUrWkVvcU1ML0Y1MUs2VkwzUmhSVXY3MlZ3K2VQN3lZdjA1a0NRbkx5ODF2MGhHQmhkVGl6ZlFOZTMwVjBHVGFmL1FCZDFkNDJtTmdaR0JnQU9MakFsYUY4ZncyWHhtWVdSaEE0TEdRL1ZJRS9mOGxzem5UWFNDWGc0RUpKQW9BQzFvSjZBQjQybU5nWkdCZ1p2alBBQ1Q5R1ZUK1gyQTJad0NLb0FCV0FGVXJBNGtBQUFKMkFBQURBQUFrQXdnQUt3TGJBRE1EVHdBcEFBQUFBQUJVQUxBQkRnRmNlTnBqWUdSZ1lHQmxzR1JnWmdBQlJnWTBBQUFHclFCRWVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3MxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFhkMGcyTnRZWEFBQUFFNEFBQUFNd0FBQUVRQWRnRXlaMng1WmdBQUFXd0FBQUU2QUFBQlVDaUNiMmRvWldGa0FBQUNxQUFBQUM4QUFBQTJKMlhEREdob1pXRUFBQUxZQUFBQUh3QUFBQ1FGTndGZ2FHMTBlQUFBQXZnQUFBQU9BQUFBRGdiRUFJRnNiMk5oQUFBRENBQUFBQW9BQUFBS0FQb0FobTFoZUhBQUFBTVVBQUFBR0FBQUFDQUFCd0F5Ym1GdFpRQUFBeXdBQUFEVEFBQUJQcWtyZGR0d2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtVW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb0dNNVF5Yy80SDhwazVHZEhVL0FjS0F3QzZhZ3pxZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVNDR1pJWVN2Ly9SN0Qrci91LzRIOGZXQzBZQUFEdWhndWlBSGphUFk2eFRzSlFBRVhmZlZVYUhRcXZEVFVJRmd0Q29RWXFKZkNDR2dpeEVURUdHalRCNktJNHFJbk9hdFROd2RGZmNEWHhFNWc3K2dPNk9EbTR1b0xQR0UzdWN1NGQ3aUVnaGZFSHh2U05MQkVDdVFoTGdXeGc1ajhDUTFtTEcrQjFjREgvSnZ0RHJvN1hjS0xYYUhWQTQ3SnVMM3FiS1RVTmVuUHNYbmpodFN0enZRUE1SdFJDbzdDUlhKRndmY2IzNkZNdmxnTnRPeWw3VW90TU15T2p0ZHpkMndrazg5dVZlVXI5aWxsU1ZCYWVNc3htczNzcHhRZ2hsT3lNdi9CSkF4SWhDVUkwVnY4ekV5YlJOTk9pT3RlclFrNVc4T2owaysxOUtwMTN5NTdxKzlhcWV5QkovWkxOYVRCNldZaEJ1ajg2dmFPd1ZFY1VEKzhlaFQ4WUNNMmMrQUhwaVo4aEFxSUtZT21LZ25RUm5KVlpTSGVybkdHNFpSM2FkUWMrblR0cEFjR29WakxqYU5iUUh6Mm5NbndaK1crbmRFQlNBQUI0Mm1OZ1pHQmdBT0xlR1g3NzQvbHR2akl3c3pDQXdHTWgrNlVJK3Y4TEppMm11MEF1QndNVFNCUUFLSm9LaVFCNDJtTmdaR0JnNXZ6UHdNREFaTUdneTZEQytKOEJLSUlDbUFFL1lBS2NBQUlxQUFBQ09BQXRBaEFBVkFCU0FBQUFBQUFBQUZJQWhnQ29BQUI0Mm1OZ1pHQmdZR0V3WkdCaUFBRkdCalFBQUFXekFEcDQyazJPc1dyRE1CQ0dQMVBiVUxmUXFSMDZGRTBaaFkzN0FJVU1tYkptTENTUk1DNVlEcEpqOEZMNkFIbm9YQlFOdllPZlQvLzlkd2lvK0NYalZoa3ZVVytWVThycnpnVlB2Q1l1cFZYaWluZFdQSkRsaitKODhKVTQ1NW52eEFWdi9DUXV4ZjlMWFBISlpUME9wL05rdmRxT3hucDNIRUpvNnAzMW9SK2RhblI5TnpiV1diK2ZyRkdIUlptNUQzTTNxRmJYdW1YTnlNQ0pNeE1XTHovYmltTWlPNDR5QzlJTk5idm9CWHFaTzhrMWFISC9KemFTY0RHMWo5ZU1wQTRzb29aWjlvSm9KM2xGRzNjMTdSWCtDREQ3QUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE1Ljg3Njc1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01MS42NTg5MScgeT0nLTYwLjc0NjM2OCc+U3ViPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zNS44MjkzNTUnIHk9Jy02MC43NDYzNjgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMxLjk1NDk4MScgeT0nLTYwLjc0NjM2OCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjMuODk4MzcyJyB5PSctNjAuNzQ2MzY4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNi4xMTE4MywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MC43NDYzNjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjAuNzQ2MzY4Jz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYwLjc0NjM2OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjAuNzQ2MzY4Jz5EPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yMy40Mjk5OTInIHk9Jy02MC43NDYzNjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOS40MDk3M1YtNDcuOTk1NzcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwwLjAsLTkuMTU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMi4xMjg1NCwtMzAuMjAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01MS42NTg5MScgeT0nLTYwLjc0NjM2OCc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDYuOTkyMzI1JyB5PSctNjMuNzUyODg1Jz7iiJc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMzIyMTQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MC43NDYzNjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjAuNzQ2MzY4Jz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYwLjc0NjM2OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjAuNzQ2MzY4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNC40ODI5ODInIHk9Jy02MC43NDYzNjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDEuMTQwOSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUxLjY1ODkxLC02MC43NDYzNjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjY1ODkxJyB5PSctNjAuNzQ2MzY4Jz5TdWI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTM1LjgyOTM1NScgeT0nLTYwLjc0NjM2OCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzEuOTU0OTgxJyB5PSctNjAuNzQ2MzY4Jz5DPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yNC4xMjE4NjcnIHk9Jy02MC43NDYzNjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTIwLjkzMjMgMEgzNi43NjY2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDIwLjY4MjMsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4wMTY2NiwzLjg3MjkyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYwLjc0NjM2OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTEuNjU4OTEnIHk9Jy02MC43NDYzNjgnPuKIgzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuMTQ4MDI1JyB5PSctNTkuNjg5MjIxJz5oPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTkuNDA5NzNWLTQ3Ljk5NTc3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsNTYuOTA1NSwtOS4xNTk3MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTMwLjIwMjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTEuNjU4OTEsLTYwLjc0NjM2OClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTEuNjU4OTEnIHk9Jy02MC43NDYzNjgnPms8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ3LjI1NTI1NScgeT0nLTYzLjc1Mjg4NSc+4oiXPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00yMS4xNjczNy01Ni45MDU1SDM2LjU4NTM2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDIwLjkxNzM3LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC4yNzEzMiwtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01MS42NTg5MSwtNjAuNzQ2MzY4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01MS42NTg5MScgeT0nLTYwLjc0NjM2OCc+4oiDPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Ny4xNDgwMjUnIHk9Jy01OS43NTAxMDQnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = {\mathsf {Sub}(B)},
      ne = {\mathsf {Sub}(A)},
      sw = {\mathsf {Sub}(D)},
      se = {\mathsf {Sub}(C)},
      north = {\exists _{h}},
      north/style = {<-},
      west = {f^{*}},
      west/style = {<-},
      south = {\exists _{g}},
      south/style = {<-},
      east = {k^{*}},
      east/style = {<-},
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />, the two composites can be constructed as <fr:tex
display="inline"><![CDATA[f^{*}\mathsf {Img}\Sigma _{g}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathsf {Img}\Sigma _{h}k^{*}]]></fr:tex> respectively.
    Since images commute with pullbacks in a regular category, we have <fr:tex
display="inline"><![CDATA[f^{*}\mathsf {Img}\Sigma _{g} \cong  \mathsf {Img}f^{*}\Sigma _{g}]]></fr:tex>.
    Then by the <fr:link
type="local"
href="ct-0008.xml"
addr="ct-0008"
title="Pasting lemma of pullbacks">pasting lemma</fr:link>, <fr:tex
display="inline"><![CDATA[f^{*}\Sigma _{g}(m) \cong  \Sigma _{h}k^{*}(m)]]></fr:tex> for any subobject <fr:tex
display="inline"><![CDATA[m \in  \mathsf {Sub}(C)]]></fr:tex>, which assembles into a natural isomorphism <fr:tex
display="inline"><![CDATA[f^{*}\Sigma _{g} \cong  \Sigma _{h}k^{*}]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="3daae68dc6dbc9f518795c108aad88f9"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMC44NjUzN3B0JyBoZWlnaHQ9JzExNC45MDIzMzFwdCcgdmlld0JveD0nLTcyIC03MiAxMzMuOTEwMjQ3IDc2LjYwMTU1NCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS012Q21XaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9MZHF6NTlqT2UzK2NyQXpNSUFBbytGN0RjZzA4d1RtV3lBRkFjREU0Z0hBRHR1Q1pVQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV1VBQW9BQUFBQUJ0Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMHgyTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWdnRENaMng1WmdBQUFXd0FBQUxDQUFBRG5QS3JaMlJvWldGa0FBQUVNQUFBQUM4QUFBQTJLQUhDVzJob1pXRUFBQVJnQUFBQUlBQUFBQ1FGcWdHY2FHMTBlQUFBQklBQUFBQVVBQUFBRkF4VUFSRnNiMk5oQUFBRWxBQUFBQXdBQUFBTUFhNENvbTFoZUhBQUFBU2dBQUFBR0FBQUFDQUFDQUJZYm1GdFpRQUFCTGdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGaUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtS21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NV1F6TS93SDhwa2gwa2hxL2dPRkFkbUFEVGdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLWmpCay8vOFA1S2VCNlArei84OEVxd0lDQUptTkNUNEFBSGphYmROTGI5TkFFQWR3ejZ3ZnNSTjc0OWU2VFZJM2laMTFxcVpKMjZST1cwTGFOQVdwN3hZSlNoR0NFeUJ4UXVLQ1FPSVRJSVFRQjY3YytBcmNLL1hNaHdHSlM4dWE4amhRNzIxbkQvT2IvMWdDYWVlaWcwL3hxN1F1U1VBb3FKb0ZXcDBuUStpeWdLa2FtNFlockpGSTVXblFIVUpmM0MreXdJS0lKenp0OHc1WVNLR2JNaldCVDZ0RnVWalNSd3ZOVllEWTV3VG9OS1UwcnBHcE50ME4wYVZIMUxmWVJqUXpBSWlZcUJkRFNoMG5OSEtsaDFrWlBweWZidHZyUFc5TWVCUldNVmFUdkk0ZzcvZ2Z2eDJUdWdiSEorV0VOK0ovSlpqa2MyL2xlZzRrOGFIVXVwakRCcHhLYldtY2FZUkUvU1VSSFh1cUZyQXVTd1ZnVFNEYmtLVDk3SVFRQ0pWNFFOWWdUUVJLMWJJUnNHQXhlNHExWi9yekY1MEhzdWpYWm1BNUZidm1EYUlLMDRMKzF1Z0V5WWphV3lmTkpaT1VITk9IOXgwQ250OHJqYXQrMFFhZWhCdVZnZ1l2ejBlZGV3VDkxbFROZGZPaG9TRGtLNVB6MWZ0ZEdZNFBIKzI3ZEpOQXpJb01pdmI1ank4MDM0aGthQzd4MGZwQkh4cFZhZ29iU0hzWDMvRVZua2s3bVV5MEhLS21Yc2JscTFtemFUY0loVmNja1Y1UFlESWVUN0laVUZuazFZYWx2anNFSGwyRzIwK1pCcVA5eXEyVm03MENvSWR1d1RSSVpYcmdvRzJvRU9UdGFOaGNCbUphakNHeTV1QndnaXB1VmM4WmdlN1l5anNaYWF3WEFTeHRzOVVBL0h4K1Z1dUMwdW1aN1lGNnJWeXIyWFZjdSs0Z0J2TUJhOHVkbVVLK0dtK01GL3dGeEhHVDViZGY4ekxOZzJzeTNEU3BJUnMwcDhtazhOdDVRemp2Wk00c2cwWG0vMTAzb2MzTVlqUEY4U2p4V0hDNWs5bkZIenp2cDRuSWw0SUZkWDRGK3ZIMDNlVG9OaGNqRnlzWVZDMXY5aURod1VTMVIrbThqRVFCNnZGWmcyaUdyZ0lVRGEreWtvd1JGQUt3dlJ4Uk9lQlg4WjlZdTQybGxvQmpiTVU1QzJDVjF6elJncUt6RlVNM3k2NzRrZVM5bUJxSWh0SXVWOXB5TjdVY1MyMG15cHRWWitLL1FValNUd3l3ZFJJQUFIamFZMkJrWUdBQTRqQ3VleHZqK1cyK01qQ3pNSURBWXlIN0RRajZ2eTdUTWFhTFFDNEhBeE5JRkFBYWxRb3hBSGphWTJCa1lHQm0rTS9Bd01CMGpFSG4vd1dtYWdhZ0NBcGdCUUJtWUFSS0FzWUFBQUk2QUVzQ09nQXNBcXdBVFFKdUFFMEFBQUFBQUdZQTFBRklBYzU0Mm1OZ1pHQmdZR1VJWjJCaUFBRkdCalFBQUFtRUFHRjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVa0FBb0FBQUFBQmZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxRjJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDWFoyeDVaZ0FBQVdRQUFBSllBQUFDdUpIamNjbG9aV0ZrQUFBRHZBQUFBQzhBQUFBMktITERJMmhvWldFQUFBUHNBQUFBSGdBQUFDUUdYZ0lsYUcxMGVBQUFCQXdBQUFBVUFBQUFGQTZvQUt0c2IyTmhBQUFFSUFBQUFBd0FBQUFNQVdJQ0RHMWhlSEFBQUFRc0FBQUFHQUFBQUNBQUNRQTZibUZ0WlFBQUJFUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZHQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmhadmdQNURORHBKSFUvQWNLQXdENzFRMWplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2Z3UvLzhEU2NmLy8vOGZBUE1aQUZMS0JxQjQyalhSdjA4VFlSekg4ZWZ6Zk52bmFHbnZLbGZ1YXFEWGxKWWVZRm9JdmR3QmljVlFxUWl4L0toQmdvMUVFeVNTaUQ5QVpHRG9nREVhR0l3SmlYRncwTTA0dXpnNU1UbTVPcWlUOFU4d2JYMk9oT2Rabm54encvdjdPc1padHQzbVAva1BOc3hHR2ZQZ2VxT0dxY2VOb211SVlTaDJ6blpjMDNDOVlhUVZFVGRNMTFRaDUvNjRXSUpYcE05WUYvR29RTW5JZHlNUzNHbDBCQkh0MUIwS0thMTJOZHFyUnduUjRNWktCSkZRWCtuTjMvUXVYNDRocERVYmhrWkpCVVRnSFpvQ1JNeTcwd2Z4YkF4Y1U0VS9EbXNDbVJNc01YbUlYV2czU2ZBdnpHSkRiRXlXNms3R0ZySXRiYUZiaFdMQkZCcUVraGFudmJvZjUrYnNURTRvZFBZbStVSHh3MUdQbmRRMHJOVHZVS00yVndPL0VydjJwUFc2VjFVbnJIZkhhenNjaGZKQlNnOXVIZFozT1IrWitWb0pBT29DSHovSHFWY0JYNXlZM2REQzFmRzVLYlVVOERlQWptbDZYTWxlNXRET056L1MwMnIvQXJWK2Q0a3dZMkRGOWgvcTVOLzlacENLakJTZGhKT3paYk1mYkZyd0pLOWZtSUlsRjVEekFtelg4NjloR3FZbjE2SHdKUkxoVUJBY3kvUFR6MFlxUGNKQVlQL3F3SnJyNUVVZ3BBUXBYeGw4Vk41N1MxUnpacmNQYW9NRFlrWkZoSiswL3FteVdkRnlxNXRBZVd4bExWSFA3OTdtNkJzcTFCT2RBSS9jbitvdmdvNGJMM1ptblNVS1pQdlZlWldUTk9kc1VKcDcwanpCOHI2NGV3WnVDc1cvWjlhbnJxYS93aVJjdXdCRnFyOC9RdG1LU2VidGZkRDgwTmhtby9VcHFVbmlYNGMrNTh0YmUrWkVvcU1ML0Y1MUs2VkwzUmhSVXY3MlZ3K2VQN3lZdjA1a0NRbkx5ODF2MGhHQmhkVGl6ZlFOZTMwVjBHVGFmL1FCZDFkNDJtTmdaR0JnQU9MakFsYXU4ZncyWHhtWVdSaEE0TEdRL1FZRS9mOGxzem5UWFNDWGc0RUpKQW9BQmZBSjBnQjQybU5nWkdCZ1p2alBBQ1Q5R1ZUK1gyQTJad0NLb0FCV0FGVXJBNGtBQUFKMkFBQURBQUFrQXdnQUt3TGJBRE1EVHdBcEFBQUFBQUJVQUxBQkRnRmNlTnBqWUdSZ1lHQmxzR1JnWmdBQlJnWTBBQUFHclFCRWVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNzAzNTU3LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNS43MDM1NTcnIHk9Jy02MS44MDM1Myc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy45MzEyNCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNzAzNTU3LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNS43MDM1NTcnIHk9Jy02MS44MDM1Myc+QzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03LjY4NDA1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTUuNzAzNTU3LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNS43MDM1NTcnIHk9Jy02MS44MDM1Myc+azwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjcwMzU1NywtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNzAzNTU3JyB5PSctNjEuODAzNTMnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuNjI3MDMsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjcwMzU1NywtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUuNzAzNTU3JyB5PSctNjEuODAzNTMnPkQ8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQgMEg0Ny44MDY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wNTY1NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI1Ljk2NTE4LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01LjcwMzU1NywtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTUuNzAzNTU3JyB5PSctNjEuODAzNTMnPmg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjQ4Njc5LTU2LjkwNTVINDcuNTcxNDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuODIxNDksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI2LjIwMjkxLC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNTEuMjE1MDQtMTQuMjI2MzZILTQyLjY3OTE0Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi4wNTgyOSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzEuNzY4NDQyJyB5PSctNjUuNDE4ODk0Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjIzOTUyLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNS43MDM1NTcsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01LjcwMzU1NycgeT0nLTYxLjgwMzUzJz5DPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzIuMTI5NTU3JyB5PSctNjUuNDE4ODk0Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00NC44MTU5NS01Ni45MDU1SC04Ljk4Njc5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLC00NC41NjU5NSwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTguNzM2NzksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDQuOTk3MTggMEgtOC44MDU1NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwtNDQuNzQ3MTgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOC41NTU1NCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J00tNTYuOTA1NS02LjQwOTczVi00Ny40Nzc5NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLC01Ni45MDU1LC00Ny43Mjc5NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw = A,
        nw/style = {pullback},
        ne = B,
        sw = C,
        se = D,
        north = h,
        south = g,
        west = k,
        east = f,
      }
      \node  [left = of nw,pullback] (1) {$A'$};
      \node  [left = of sw] (2) {$C'$};
      \draw  [>->,morphism] (2) to (sw);
      \draw  [>->,morphism] (1) to (nw);
      \draw  [->,morphism] (1) to (2);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Thus, we can extend this natural isomorphism as follows:</fr:p>
  <fr:tex
display="block"><![CDATA[     f^{*}\mathsf {Img}\Sigma _{g} \cong  \mathsf {Img}f^{*}\Sigma _{g} \cong  \mathsf {Img}\Sigma _{h}k^{*}   ]]></fr:tex>
  <fr:p>Then both <fr:tex
display="inline"><![CDATA[\forall _{k}h^{*}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g^{*}\forall _{f}]]></fr:tex> are right adjoint to <fr:tex
display="inline"><![CDATA[f^{*}\exists _{g}]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[\forall _{k}h^{*} \cong  g^{*}\forall _{f}]]></fr:tex> by the uniqueness of adjoint.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1232</fr:anchor><fr:addr
type="user">ct-001C</fr:addr><fr:route>ct-001C.xml</fr:route><fr:title
text="Heyting implication">Heyting implication</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex> be two subobjects of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>.
  The <fr:em><fr:strong>Heyting implication</fr:strong></fr:em> <fr:tex
display="inline"><![CDATA[A_{1} \Rightarrow  A_{2}]]></fr:tex> is the largest subobject of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[A_{1} \cap  (A_{1} \Rightarrow  A_{2})]]></fr:tex> is contained in <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1233</fr:anchor><fr:addr
type="user">ct-0019</fr:addr><fr:route>ct-0019.xml</fr:route><fr:title
text="Heyting category">Heyting category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>12</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="ct-000X.xml"
addr="ct-000X"
title="Coherent category">coherent category</fr:link> <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a <fr:em><fr:strong>Heyting category</fr:strong></fr:em> if for every morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the pullback functor <fr:tex
display="inline"><![CDATA[f^{*}\colon \mathsf {Sub}(B)\to \mathsf {Sub}(A)]]></fr:tex> admits a right adjoint <fr:tex
display="inline"><![CDATA[\forall _{f}\colon \mathsf {Sub}(A)\to \mathsf {Sub}(B)]]></fr:tex>.
  A <fr:em><fr:strong>Heyting functor</fr:strong></fr:em> between Heyting categories is a coherent functor such that for any morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> and any subobject <fr:tex
display="inline"><![CDATA[m\colon A'\rightarrowtail A]]></fr:tex>, <fr:tex
display="inline"><![CDATA[F\forall _{f}(m) \cong  \forall _{Ff}(Fm)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(FB)]]></fr:tex>.
  Note that this definition makes sense since coherent functors preserve monomorphisms.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1234</fr:anchor><fr:addr
type="user">ct-0011</fr:addr><fr:route>ct-0011.xml</fr:route><fr:title
text="Coherent categories admit distributive law"><fr:link
type="local"
href="ct-000X.xml"
addr="ct-000X"
title="Coherent category">Coherent categories</fr:link> admit distributive law</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a coherent category.
  Then intersections distribute over unions, i.e., for any three subobjects <fr:tex
display="inline"><![CDATA[A_{1}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[A_{2}]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[A_{3}]]></fr:tex> of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, the following holds.</fr:p><fr:tex
display="block"><![CDATA[   A_{1} \cap  (A_{2} \cup  A_{3}) \cong  (A_{1} \cap  A_{2}) \cup  (A_{1} \cap  A_{3}) ]]></fr:tex>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>757</fr:anchor><fr:addr
type="machine">#282</fr:addr><fr:route>unstable-282.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  Let <fr:tex
display="inline"><![CDATA[m\colon A_{1}\rightarrowtail A]]></fr:tex> be a subobject of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
  Then by <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />, <fr:tex
display="inline"><![CDATA[A_{1} \cap  (\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]]></fr:tex> can be described as the composite <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A) \xrightarrow {m^{*}} \mathsf {Sub}(A_{1}) \xrightarrow {\exists _{m}} \mathsf {Sub}(A)]]></fr:tex>.
  Thus, we have
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  <fr:tex
display="block"><![CDATA[   \begin {align*}     A_{1} \cap  (A_{2} \cup  A_{3}) &\cong  \exists _{m}m^{*}(A_{2} \cup  A_{3}) && \text {$m^{*}$ preserves finite unions}\\                             &\cong  \exists _{m}(m^{*}(A_{2}) \cup  m^{*}(A_{3})) && \text {left adjoint preserves finite unions}\\                             &\cong  \exists _{m}m^{*}(A_{2}) \cup  \exists _{m}m^{*}(A_{3})\\                             &\cong  (A_{1} \cap  A_{2}) \cup  (A_{1} \cap  A_{3})   \end {align*} ]]></fr:tex></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>