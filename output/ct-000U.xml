<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1893</fr:anchor><fr:addr
type="user">ct-000U</fr:addr><fr:route>ct-000U.xml</fr:route><fr:title
text="Free construction">Free construction</fr:title><fr:taxon>Intuition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Given a pair of functors <fr:tex
display="inline"><![CDATA[U\colon \mathcal {C}\to \mathcal {D}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[F\colon \mathcal {D}\to \mathcal {C}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[F \dashv  U]]></fr:tex>.
  We may considered <fr:tex
display="inline"><![CDATA[U]]></fr:tex> as a presentation of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex>. For any object <fr:tex
display="inline"><![CDATA[d \in  \mathcal {D}]]></fr:tex>, the <fr:em><fr:strong>category of constructions on <fr:tex
display="inline"><![CDATA[d]]></fr:tex></fr:strong></fr:em> is the comma category <fr:tex
display="inline"><![CDATA[{d}\downarrow {U}]]></fr:tex>. Then the <fr:em><fr:strong>free construction</fr:strong></fr:em> on <fr:tex
display="inline"><![CDATA[d]]></fr:tex> is the initial object of <fr:tex
display="inline"><![CDATA[{d}\downarrow {U}]]></fr:tex>. This is precisely the object <fr:tex
display="inline"><![CDATA[(Fd, \eta _{d}\colon d\to UFd)]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\eta ]]></fr:tex> is the unit of the adjunction.</fr:p>
    
      
      <fr:figure><fr:resource
hash="14e3f9e4f8ab6c7578b6d3f0706c4483"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNy40NDQ4ODJwdCcgaGVpZ2h0PScxMDguODEyNjk3cHQnIHZpZXdCb3g9Jy03MiAtNzIgNzguMjk2NTg4IDcyLjU0MTc5OCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU44QUFvQUFBQUFBK2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2lWRjRMR050WVhBQUFBRThBQUFBS2dBQUFEUUFEQVFLWjJ4NVpnQUFBV2dBQUFDN0FBQUF4T1BiLy9Sb1pXRmtBQUFDSkFBQUFDOEFBQUEyS0dDaTltaG9aV0VBQUFKVUFBQUFId0FBQUNRRmVBSGRhRzEwZUFBQUFuUUFBQUFJQUFBQUNBVWdBREJzYjJOaEFBQUNmQUFBQUFZQUFBQUdBR0lBQUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQkFBL2JtRnRaUUFBQXB3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRGJBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbW1zQTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU1HQmlTUVVseVd6c0RHdkIwSUdmNEQrY3dNakNCaFJvU0svMEJoQUE4V0RuTUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdVZ0RRTEVBTDV6TnYvLzRlUWY3ekE4Z3dBWEljSEZnQUFlTm90eU1zT3dVQVlCdEQ1L3FyU3kwd2JNNjFRamJpMExra1JSUVFsa1JBN2F5OWh3M041Q3l2UDVMS3dPemtNYlB6cDBnRlB0bUVNR29mUmlwTkZKYWM0K1psREVOZmlaS3ZOWjlsL1JrZ3hYK1RrQnptQ2lBUm9mU1ZWNHhLRlcwRWp2Nzg2VjRWcE5LUmVWcUdFT2JTdG9xaEVMVXMzVEtzSVg5ako4bFNhWHBySHpBWVF2TGQybTF4UDRlVlVleE9pZlUvVm92dFpDZzdYR3p6R2FlQ3FFTmlsMGdLUnV3LzlKbldYcXc3cG84eXBNOGErclBFV3BBQjQybU5nWkdCZ0FPTGF4WCs1NC9sdHZqSXdzekNBd0dQSERlMEkrcjhxMHpIR1kwQXVCd01UU0JRQU8vRUxSQUI0Mm1OZ1pHQmdadmpQd01EQWRJekJnRUdFeVkwQktJSUNtQUE5ZEFKYkFBTEdBQUFDV2dBd0FBQUFBQUJpQUFCNDJtTmdaR0JnWUdLd1l3RFJERkFTQ1FBQUJxc0FSQUI0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9rQUFvQUFBQUFCQXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hYOTFiV050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUMzWjJ4NVpnQUFBV1FBQUFEb0FBQUE2SHZ3SUQ5b1pXRmtBQUFDVEFBQUFDOEFBQUEyS082a3gyaG9aV0VBQUFKOEFBQUFIZ0FBQUNRR0tnS1FhRzEwZUFBQUFwd0FBQUFJQUFBQUNBWkpBR3hzYjJOaEFBQUNwQUFBQUFZQUFBQUdBSFFBQUcxaGVIQUFBQUtzQUFBQUZnQUFBQ0FBQlFCS2JtRnRaUUFBQXNRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGxBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVZtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTUtRd00vd0g4cGtoMGtocS9nT0ZBYnF1RE4wQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZncC8vOUR5UDl6d1h3R0FGVjJCc0FBQUFBQUFnQnMvL1VDdkFMSEFEVUFTQUFBQVFNR0ZRWVhOamMrQVRNWEZoY1VCZ2NHQnlJbUp3NEJCeTRCSnpZM05qYzJOeDRCRno4Qk5pWXZBUVltTkRjMlB3RTJGaFVXQXpjdUFTTWlCZ2NPQVJVZUFUYytBVDhCTmdLbWpRVUJLalliQXdrTkRBZ0JGQlVlUENOR0R3dFhRRTlpQWdORUVoTlFZekE5RGpnRkFRZ09Jd3NTQmdNRmpnMFRBZVF2RGpra0lVY2ZIQ0FDT3gwblNoMFJCQUtnL2M4UUVUTURBWElOQ2dJQ0N3YytJRFlESWlVTU9BTUJZVkJqVHhRUlJBTUJKeGJnRndZR0FRSUJCaGtMQXdFTUFRVU5CUDNYd1M0cktDb3JmaWMrS3dFQktTQVZCd0FBZU5wallHUmdZQURpQVAyRHIrUDViYjR5TUxNd2dNQmp4dzN0Q1ByL1YrWVFwdU5BTGdjREUwZ1VBRUZTQzZnQWVOcGpZR1JnWUdiNHp3QWtReGh5R0N5WjlqQUFSVkFBRXdCRG13TEJBQUFEVkFBQUF2VUFiQUFBQUFBQWRBQUFlTnBqWUdSZ1lHQmk4QVJpRUdCa1FBTUFCOVVBVUFBQWVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnd05xRmdZbVZxUXRnRjJXd2pad1FDYW5xMk4vZGgvSFFOMXlkKzJFRE5UOFUzSzlnbHZSK0paVzRCMWRNbVdlZWlIdkxYTFBnblNlSzhsbVNWejR5bDlKOFpxNTQ0U3Z6UlBMdnpEVXJmamZCWGE2RGpXb1hqSTMrNUZ5MzN0dllkOEdycFc2UzMxcHY0Mkd3UmgxdnlveGRQNTZkYW5Xald6WUVIQmV1REZnaWlwMGtKckhuSkoyalk4MCtKYjF3a0Z5eFJOUDg2N2ZTKzdRNXBKK01iSTdjUkEyakxIclJzMndWYlhxcGFmOEF5QkV2N3dBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV1VBQW9BQUFBQUJvZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFdGMG1XTnRZWEFBQUFFNEFBQUFOZ0FBQUVRQWFRRVVaMng1WmdBQUFYQUFBQUs2QUFBRFBJeWdDVWxvWldGa0FBQUVMQUFBQUM4QUFBQTJLS1NrdTJob1pXRUFBQVJjQUFBQUlBQUFBQ1FHTkFGUmFHMTBlQUFBQkh3QUFBQVVBQUFBRkF1UUFMMXNiMk5oQUFBRWtBQUFBQXdBQUFBTUFab0NkbTFoZUhBQUFBU2NBQUFBR0FBQUFDQUFDQUJNYm1GdFpRQUFCTFFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGaUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtQ21DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcTZNYVF3TS93SDhwa2gwa2hxL2dPRkFjYXFET29BZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0F5QU5BY1FndVRjR0VJWlV2Ny9oN0tTLy8vL3Yvdi8ydjhMd0dyQkFBRG4rUXQzQUFCNDJqMlN6Vy9UV0JURmZlNnpuNTNFSDNGc1A3Y2tUZHE2MkczVHBxVnA3QkpLQTYwS293SlNBV21rMFdnS29vQW91OUZzT250R2xkak1naEVTUzhSZndHSTBJTmdpeEpvL2dQV3NFYnVoNGFaQzg2NzBQblNlbnM3dm5xZEJ5NFpEQVhxdDdXZ2FUQmxMMWFLVk9KUkxNTE0wVzgxamxSZkJBQjFJM2svbHlrT1lEdERMMHpaU2FZb3V5M204MGdJTExwTHByTWl6UEUyUUR3ekFqdktHMEQzejJWSEpnT2YybThhUkRwdys2MVh4SmJCRlZJZEI1MzQ1YWdYRzV0NGc5NFJ0Q29LK0pneXpRcUpNTkZuZzJsQlJxVVFFMjVVUUxKYzhDUVJOYXZxbVkrb05FeWdGTHh0NmVmbFV2MEIxL1BnL3pKNkx5WkRrZm5JczIyNmJha3pqQVcxcitDKy8rVmJiNElOd1lYYVFwUU9SOTFhVGpORmFLR0xGMk5rSVNucG9vcnVCSWlqeU5KUFpCbGhXTFFiTVhORGpueWVlMzczNUcxRnBkckVpNjltRUl4ODlzaGd3N0Uzbyt4WVJYZXJ0UG1uY0FocHRUOEEySGg2Y0FPanJpN1I3L05lRFAzWGMzd3V6RjMrM1krbVRZQVRCQVZndW8wVDE0MStUYUd4ekM3OGY0TERpMTltcGU2THJjclRPTWNmODhBdit3VHR0bVRrNlNKakVSUlNxV0Ewd2lrS0ZwdVRxY0VURnFKcUlSN21Nb2l4eVBMVlg2dTJyNC9YR3dyTGRkOWZQbTdMU2NXcjkyN3MvaW90K2NIVnY3UUl3RlhzSzBsYjRJd3F4dHJoeW1DeGRZQitHdjEwQmpjMVh5bk02N2Y5dzUzcFV1eVJ3Sm0wbGZpQWpwNlpwcE0wTlAxT1YzbXZkazk4azJKbUt1WTNjWFJWOXQ4VWR6SGorM3h5N1RoT1o1ZDBpNzZwWThIRUphVGJObHozd3BFYi9MNmZxRTUxUWlacUpUWTVwbEN3MzdzMTA1ZEsydjM0Rm91L1h0bThrSGVlOFFIVW1CcHpMQzE2SlBxNEtlTHJmbWR3WTkydDZsZE5JMWZwMGhkNThmYW5LMDAzUVRqY2k3dnZwcVZaUG9EM1ZPMFg0YWVmZVRSVmVGcGlaK0J4YVplRUZsZzc5NjZzUHZwVllpYjdhU2JlY3pkbkpBV0Z5M3Y0R1lGeHdLd0FBZU5wallHUmdZQURpYTYzT24rUDViYjR5TUxNd2dNQmp4dzN0Q1ByL1MyWXVwdU5BTGdjREUwZ1VBRSsrQzdnQWVOcGpZR1JnWUdiNHo4REF3TFNMUWYzL1JHWXVCcUFJQ21BRkFGZEhBNG9DZGdBQUFwSUFKd0s2QUVNQnVnQXFBaFFBS1FBQUFBQUFkQURZQVNZQm5uamFZMkJrWUdCZ1pmQm1ZR0lBQVVZR05BQUFDRmdBVlhqYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTY1LjExNzgzOCwtNjIuMjg3ODI5KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIuNjAyNDMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTY1LjExNzgzOCwtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02NS4xMTc4MzgnIHk9Jy02Mi4yODc4MjknPmQ8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDYuNDM0MzMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTY1LjExNzgzOCwtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02NS4xMTc4MzgnIHk9Jy02Mi4yODc4MjknPlU8dHNwYW4geD0nLTU3LjIyOTM5Jz5GPC90c3Bhbj48dHNwYW4geD0nLTQ5LjQzOTEzNCc+ZDwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUwLjc4MjcxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjUuMTE3ODM4LC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTY1LjExNzgzOCcgeT0nLTYyLjI4NzgyOSc+VTx0c3BhbiB4PSctNTcuMjI5MzknPmM8L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2UtZGFzaGFycmF5PSczLjAsMi4wJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNy4xNTc5NyAwSDQxLjM3ODc4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQxLjYyODc4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjAuMzU5MDIsNC4xNzI5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjUuMTE3ODM4LC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTY1LjExNzgzOCcgeT0nLTYyLjI4NzgyOSc+zrc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjAxMzA1JyB5PSctNjEuMjMwNjgyJz5kPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002LjQwNjc4LTYuNDA5NzNMNDguMzEzNjctNDguMzA4OTQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNSwtMC43MDcwMywwLjcwNzAzLDAuNzA3MTUsNDguNDkwNDYsLTQ4LjQ4NTcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
    \node  (1) {$d$};
    \node  [right = of 1] (2) {$UFd$};
    \node  [below = of 2] (3) {$Uc$};
    \draw  [->,morphism,exists] (2) to (3);
    \draw  [->,morphism] (1) to node {$\eta _{d}$} (2);
    \draw  [->,morphism] (1) to (3);
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></fr:figure>
    
  </fr:mainmatter><fr:backmatter /></fr:tree>