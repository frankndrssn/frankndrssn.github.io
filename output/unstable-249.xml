<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>626</fr:anchor><fr:addr
type="machine">#249</fr:addr><fr:route>unstable-249.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By the recursion scheme (<fr:ref
addr="set-0010"
href="set-0010.xml"
taxon="Proposition" />), we can define a function <fr:tex
display="inline"><![CDATA[f]]></fr:tex> with domain <fr:tex
display="inline"><![CDATA[X]]></fr:tex> as follows:
    <fr:tex
display="block"><![CDATA[       f(x) = \mathsf {ran}(f{\upharpoonright }x)     ]]></fr:tex>
    We take <fr:tex
display="inline"><![CDATA[\mathsf {ran}(f)]]></fr:tex> to be the underlying set of <fr:tex
display="inline"><![CDATA[\mathsf {Ord}(X,<)]]></fr:tex>.
    As an example, consider <fr:tex
display="inline"><![CDATA[X = \mathbb {N}]]></fr:tex> equipped with the usual ordering <fr:tex
display="inline"><![CDATA[<]]></fr:tex>.
    In this case, <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is the usual von Neumann encoding of natural numbers: <fr:tex
display="inline"><![CDATA[f(0) = \varnothing ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[f(1) = {\mathopen {}\{\varnothing \}\mathclose {}}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[f(2) = {\mathopen {}\{\varnothing , {\mathopen {}\{\varnothing \}\mathclose {}}\}\mathclose {}}]]></fr:tex>, and so on.</fr:p>
  <fr:p>It is routine to verify that <fr:tex
display="inline"><![CDATA[(\mathsf {ran}(f),\in )]]></fr:tex> is an ordinal and <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is an order isomorphism.</fr:p>
</fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>627</fr:anchor><fr:addr
type="user">set-0021</fr:addr><fr:route>set-0021.xml</fr:route><fr:title
text="Ordinal numbers"><fr:link
type="local"
href="set-0011.xml"
addr="set-0011"
title="Ordinal">Ordinal</fr:link> numbers</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For any strict <fr:link
type="local"
href="set-000Y.xml"
addr="set-000Y"
title="Well orders">well order</fr:link> <fr:tex
display="inline"><![CDATA[(X,<)]]></fr:tex>, there is an ordinal <fr:tex
display="inline"><![CDATA[\mathsf {Ord}(X,<)]]></fr:tex> that is order isomorphic to <fr:tex
display="inline"><![CDATA[(X,<)]]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>569</fr:anchor><fr:addr
type="machine">#249</fr:addr><fr:route>unstable-249.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>By the recursion scheme (<fr:ref
addr="set-0010"
href="set-0010.xml"
taxon="Proposition" />), we can define a function <fr:tex
display="inline"><![CDATA[f]]></fr:tex> with domain <fr:tex
display="inline"><![CDATA[X]]></fr:tex> as follows:
    <fr:tex
display="block"><![CDATA[       f(x) = \mathsf {ran}(f{\upharpoonright }x)     ]]></fr:tex>
    We take <fr:tex
display="inline"><![CDATA[\mathsf {ran}(f)]]></fr:tex> to be the underlying set of <fr:tex
display="inline"><![CDATA[\mathsf {Ord}(X,<)]]></fr:tex>.
    As an example, consider <fr:tex
display="inline"><![CDATA[X = \mathbb {N}]]></fr:tex> equipped with the usual ordering <fr:tex
display="inline"><![CDATA[<]]></fr:tex>.
    In this case, <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is the usual von Neumann encoding of natural numbers: <fr:tex
display="inline"><![CDATA[f(0) = \varnothing ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[f(1) = {\mathopen {}\{\varnothing \}\mathclose {}}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[f(2) = {\mathopen {}\{\varnothing , {\mathopen {}\{\varnothing \}\mathclose {}}\}\mathclose {}}]]></fr:tex>, and so on.</fr:p>
  <fr:p>It is routine to verify that <fr:tex
display="inline"><![CDATA[(\mathsf {ran}(f),\in )]]></fr:tex> is an ordinal and <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is an order isomorphism.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>