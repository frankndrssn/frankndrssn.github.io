<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1268</fr:anchor><fr:addr
type="machine">#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[p,q\colon C\rightrightarrows A]]></fr:tex> be the kernel pair of a cover <fr:tex
display="inline"><![CDATA[f\colon A\twoheadrightarrow B]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g\colon A\to D]]></fr:tex> be a morphism such that <fr:tex
display="inline"><![CDATA[gp = gq]]></fr:tex>.
    Consider the <fr:em>joint</fr:em> cover-mono factorization of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, i.e., the cover-mono factorization of the morphism <fr:tex
display="inline"><![CDATA[(f,g)\colon A\to B \times  D]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="25a16084d5f6237108378ff250de2a42"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIxMC4xMTk2MTFwdCcgaGVpZ2h0PScxMTUuNzI0MTQ0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTQwLjA3OTc0MSA3Ny4xNDk0Myc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVU4QUFvQUFBQUFCaUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVZDBqV050WVhBQUFBRTRBQUFBTlFBQUFEd0F0QUJQWjJ4NVpnQUFBWEFBQUFKb0FBQUM1R1ZNU3o1b1pXRmtBQUFEMkFBQUFDOEFBQUEySi82QXQyaG9aV0VBQUFRSUFBQUFJQUFBQUNRRnFnR2NhRzEwZUFBQUJDZ0FBQUFVQUFBQUZBdEJBVGRzYjJOaEFBQUVQQUFBQUF3QUFBQU1BU2dDQW0xaGVIQUFBQVJJQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQkdBQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRk1BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWNtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHJxTUdRd00vd0g4cGtoMGtocS9nT0ZBYjRvRE1RQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUSzZqQmsvUDhQNU9zd3BQMy8vLy9xL3psZ1ZVQUFBSkhnQ1AwQUFBQjQya1dSTVcvVFFCaUcvZDA1ZDBrYysrdzRQdFBVZGVMWU9hZFNtelJ4WWtNSlNkTlVTRzJoRkphb0NOR0poUW1wRWtJZzhSTVFRZ3lzYlB3RjlrcWQyZmdqUldKSk9MY0Q5MDJuOTlQZCs3eXZBc3JGYWxlNVZ0NHFYRkV5U21nWGhtbm1nME1ZRUNyaU5KdkE3NHBtZTQxbVBZclVkcW5OTkF3a2FaaEZDaEFNQW9CSmZ6SFNCNEIwV3VpZksvS0Fjcnpxb2Rmb2w3SW5MemgveUFEYUV2RUVFdTV5UW5rREpqREZJUkdwbTB4QWZwRU11R3RBS0dLUlpxSUhCbUtRcEp6RThIM1hWTTE2YWRidjdBSkVqc0RBR295eEtNQWJYZmJJUnpaN3loeUQ3NGViWTRDUVM5MzBHYXRXL1hLeGZwN0w4SFY1ZVdUdERXdHpMRUsvaVNJU2F5VUU2ckh6N1hxQld4UVdaK3V4YUVmL0pWZ1QyNS9VVmhGeUZxUnNyYlpSR3k2VnJqTFBhU1FKdVNHUmptdUV1anpoZVVaVHlLT1RjZVhqZ3l1cDVBS2VRaHBMS0VMekNMZzd5RmRSOEtaMDhhNzNVcFYrTFE1RzFiT0MyamowT0hXenc5a1p3ak5tSFo1MVJqcXVWM1VIdnZRdzFKeGhmZDUwVEF0RTdPOTdGUXJ2bDdQZWM0eWNyWTNBdGpXL1hFQ2dlV3M3elJlSkNvdlRWeWMyTzhBUWNaT0RhUzMvL21SYU8xU2hNeEt6dlNjWnRKdE12K25wOGVvUCtvQ3VsT09jVEZyMkVTVzNkVGtrTjVzbXJpOTU1Y2oyaGhJbXh4TnhuZ0ZUWlY5ZEdHWDJCRVI0VzI2V2NncXpFKy9adllmRENxQWFzaXQ2R1h1TmNSVlpaUUt1Wm9XVHpsM0F1c0U1UXJ3elByM0RDbmF6VkN5N3BhcFYrS3dpRnBWTUFJTWViTFVCL1ZoZUJRa1Vla085T3liMzE0UEFhcUhwZ3lwQzdvN0x1MnB2czZJMW8vMTUzK2tqTk85dzdlaWpXR2NhMkRwSEJ6b3JxMlZXcENxdS9BTlJCR0R5ZU5wallHUmdZQURpRXNGRm1mSDhObDhabUZrWVFPQ3h3THg3Q1BxL0x0TXhwb3RBTGdjREUwZ1VBQ1I4Q3VnQWVOcGpZR1JnWUdiNHo4REF3SFNNUWVmL0JhWnFCcUFJQ21BRkFHWmdCRW9DeGdBQUFWc0Fjd0k2QUVzQ09nQXNBcXdBVFFBQUFBQUFLZ0NRQVA0QmNuamFZMkJrWUdCZ1pmQmhZR0lBQVVZR05BQUFDSEVBVm5qYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUlBQW9BQUFBQUEyZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYUR4aWhHTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJFQUFBQVJCNWFqSGRvWldGa0FBQUJzQUFBQUMwQUFBQTJLWXlBOVdob1pXRUFBQUhnQUFBQUh3QUFBQ1FGQmdEWmFHMTBlQUFBQWdBQUFBQUlBQUFBQ0FZWUFGOXNiMk5oQUFBQ0NBQUFBQVlBQUFBR0FDSUFBRzFoZUhBQUFBSVFBQUFBRndBQUFDQUFCQUFTYm1GdFpRQUFBaWdBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFDK0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtNW1HY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnEwL2xnd016RnJNeDRIQ2pBZ1YvLzh6TUFBQSt3TVBmd0I0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQUY4QUp3RjdBandBRUFBQUFRTUdJeWNtSnpjVFBnRTNNaFlYQmdjQmNkUUdEQllUQXdTZUF4a2VHU1lCQVFRQjNQNWNFUWNIRFJBQnV3NGdBU0FjREF3QWVOcGpZR1JnWUFCaTlzMExIT1A1YmI0eU1MTXdnTUJqZ1huM2tHbVdVQ1liSU1YQndBVGlBUUFIdFFqREFBQUFlTnBqWUdSZ1lOYjZZOG5Bd0JMS0VNL2d3VmpOQUJSQkFVd0FTaWdDNHdBRVZRQUFBY01BWHdBQUFBQUFJZ0FBZU5wallHUmdZR0JpRUdRQTBReFFFZ2tBQUFKR0FCY0FlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ2xKV0ZnWW1WcVF0Z2d6TEVRWGFJRktucXlPL3U0WHJvRGFmbi9iZ0RTbjdJZUU3R2E5elB5U2xFL1hIQkMyK0pwNklXaVVzK1dESWh5MmZpek5ra3ppWDVTbHp3emlYeFZQenZ4Q1dmUExaZGU3djMxcXQ5WjZ4MzV6YU02NFAxb2VtY1d1a3E2cDExMWg5N2E5UnBWR1pvd25CdFZhMHJYYk9sbytYR25SNkxSN0VYeDBSMm5DVUxqS3c1UkNmUVNPcWt0VUpUL2N0M2tydllPY1pQUmpvblNaVFFJRmRCOWxYYWlqcGVhdXBmNytrd1J3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5BQUFvQUFBQUFBNlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ2lPUnpHMk50WVhBQUFBRkFBQUFBS1FBQUFEUUFEQUVxWjJ4NVpnQUFBV3dBQUFCNEFBQUFlSk1TUEpGb1pXRmtBQUFCNUFBQUFDMEFBQUEyS0ZPQXNXaG9aV0VBQUFJVUFBQUFIZ0FBQUNRR05mL2RhRzEwZUFBQUFqUUFBQUFHQUFBQUJnT3dBQUJzYjJOaEFBQUNQQUFBQUFZQUFBQUdBRHdBQUcxaGVIQUFBQUpFQUFBQUZ3QUFBQ0FBQkFBa2JtRnRaUUFBQWx3QUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRE1BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWxtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVUQXhKSUtTNUxCMHBlWjdqT0xQVkhrNEdCV1lyNU9sQ1lFYUhpLzM4R0JnRHJuUTd2QUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeENDK05mLy80ZVEvN1hBZkFZQVh1VUhNd0FBQUFBQkFKUUFDUUtHQWZnQUlnQUFBVGMyRnhZWEJnOENId0VXQndZSEppOEJCdzRCSXlZbkpqOEJKeVkzTmpjeUZ3R095dzRLRXdFQ0F4cTdwVElFQVFFVEN3WFV5d2tJQmhFREF4RE56UkFEQXhFR0JBRWR5aEVCQWhNS0F4cTdwVElJQXhNQ0FnVFV5d29GQWhNSERjN09EUWNUQWdJQUFIamFZMkJrWUdBQTRsWGFIcXZqK1cyK01qQ3pNSURBWTRGNTk1QnBaaG5HSDBDS2c0RUp4QU1BRk5vSmNRQUFBSGphWTJCa1lHQ1crcU1KSkdVWXBqQk1ZMnBqQUlxZ0FFWUFUTW9ERndBQUF4d0FBQUNVQUFBQUFBQUFBRHdBQUhqYVkyQmtZR0JnWWxCbUFORU1VQklKQUFBRUNBQXBBSGphVFk2eGFzTXdFSVkvVThkUUo1Q3BIVG9VVFJtRmpmTUFoUXlac21Zc0pKRUlEbGdPa21Qd1V2SUFmZWhlRkEwOXdmSHB2KytFZ0pJZk1oNlZzWXo5VVRtRjNKNDhZODViNGtLT1Nsenl3WW9Yc3Z4VmtrKytFdWNzK0U0ODQ1MUw0a0x5ZStLU05iK2J2cnZlQnV2VnJqZld1MU1YcHJyYVd4L2EzcWxhVjg5Z2E1MzFoOEVhZFp5VUdkc3duanZWNkVvM2JPanB1SEpqd09MbFp6dEpUR1RIU1dhQmlacUtmY3dDcmN5ZGVEVmEwdi9HVmd3WHJVTjh6WWgxbEprU0dtVXZTRCtMcjJqaXJxYjVBd2xSTVJNQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0F1QXVtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhOY2k2L0g4OXQ4WldCbVlRQ0J4d0x6N2lIby80eE1sNWxCWEE0R0poQUZBRG9sQ3JVQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU1VBQW9BQUFBQUJUd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUhHTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QVdRQ2RaMng1WmdBQUFXd0FBQUhEQUFBQi9OWjNEOEJvWldGa0FBQURNQUFBQUM4QUFBQTJLRytCazJob1pXRUFBQU5nQUFBQUhnQUFBQ1FHWFFKV2FHMTBlQUFBQTRBQUFBQVFBQUFBRUF2TkFIaHNiMk5oQUFBRGtBQUFBQW9BQUFBS0FWSUFzRzFoZUhBQUFBT2NBQUFBR0FBQUFDQUFDQUE2Ym1GdFpRQUFBN1FBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFaUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtK3N3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJoWnZnUDVETkRwSkhVL0FjS0F3RDlwZzFvZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pHNC9QOFA1RHVDNlA4SC91OEhxd0lDQUpDRkNQQUFBSGphTmRCQmF4TlJFQWZ3OTMrVHZKZkU3TDYxbSs2cm1HeFlFN05ZU1NOTjJHMERSakMyaXNXWVd0R2lSVUdvUlE5VnRGWVBIbklvQ05JZVJCQThlZENiZVBiaXlaTW52NEVIOWVoblNPTGJRbVl1dzU4NS9HWVlaOVh4bVAvbXYxaUR6VE1XSTRyblBlMFd2R2JraVFaa1dBdGJrZmFpdUlGQWlvS25JMjNENUVuYzdDQnUwbGRzaW9JbDBQSHEwOGluZHdhWk5Ld2pib3V5Y2pUdVdVWFhJbGpwcmZVODh0a1RuZmYvZ2wxK3cwRldEUWVlb3BJRUVYaEdTU0N2N3kvdEZhb091TEpGRXVlVVFPVUhyakZUeEU2UGh5VDROK2F6V2JaZ3BHNnJFZ3BqQzN4TTI1QSt0RkFRTWhDSFhqZkJSYld3VWhPU0pqT1poZWFuZytOaFNTbXNiOXlqd2RyS0d2aEY1OHF6MGR1aWJiZjlEKy91N25ETWRmZktibnA3ZjJPWDh6T1h2aStuQUx2UEY0OXlLa3J3MWZibExaWHJMYTZjdHp1cDVBSzRXS0lueTlVTEhPclk4RE05NzUzczAranZsTWd4eHRrcDQ0Nk5lNGJWRTNVMFFXc2hrNTU0RDIwNmdaNURGTTVCR3ZuSEEzUjl4MUNmdmdSZG5WMTRPQmg5S1NuRC9MT2ZrRjdmZWFIYk01a3A4QWU5N2JKcmhBNVJ5Ynp1emFOWGo4L1dyeFA1d3VCNGQvalRXSkRxbDFkdkJ6ZkR6VnVBTWkvOUQxbnFWOXdBZU5wallHUmdZQUJpWi8zTzAvSDhObDhabUZrWVFPQ3h3THg3Q1ByL1gyWnpwcnRBTGdjREUwZ1VBREtkQzJ3QWVOcGpZR1JnWUdiNHp3QWsvUmxVR0ppWXpSbUFJaWlBQlFBdVdnRzdBQUFDZGdBQUF3QUFKQU1JQUNzRFR3QXBBQUFBQUFCVUFMQUEvZ0FBZU5wallHUmdZR0Joc0dSZ1pnQUJSZ1kwQUFBR2tnQkRlTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTkuNjcyNjA1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My45NzQ1NTgnIHk9Jy01OS42NzI2MDUnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTkuMzc4MDgsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My45NzQ1NTgnIHk9Jy01OS42NzI2MDUnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUzLjcwNDA4MycgeT0nLTU5LjY3MjYwNSc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQzLjc0MTQ3JyB5PSctNTkuNjcyNjA1Jz5EPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU2LjkwNTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTMuMTU1NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My45NzQ1NTgnIHk9Jy01OS42NzI2MDUnPkE8L3RleHQ+CjxyZWN0IHg9Jy02My45NzQ1NTgnIHk9Jy01OC40NzcxNTInIGhlaWdodD0nLjM5ODQ4NCcgd2lkdGg9JzcuNDcxOTk1Jy8+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQgMEg5NC4zMjI1NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NC41NzI1NCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQyLjM2NTY4LDQuNTYxODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTU5LjY3MjYwNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjMuOTc0NTU4JyB5PSctNTkuNjcyNjA1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02MC44NjEyMTUnIHk9Jy01OS42NzI2MDUnPmY8dHNwYW4geD0nLTU2LjYyMzU3OSc+LDwvdHNwYW4+PHRzcGFuIHg9Jy01Mi44OTY4MDInPmc8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDguNzU5ODUyJyB5PSctNTkuNjcyNjA1Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002LjQwNjc4LTYuNDA5NzNMNDUuOTk5NzktNDUuOTk1NDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNSwtMC43MDcwMywwLjcwNzAzLDAuNzA3MTUsNDUuOTExMzksLTQ1LjkwNzA3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTkuNTkxNCwtMzUuMjA4OTgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTU5LjY3MjYwNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjMuOTc0NTU4JyB5PSctNTkuNjcyNjA1Jz5oPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002Ni43MDA5OS00Ny4xMDdMMTA2LjIxODYxLTcuNTk2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNzA3MTUsLTAuNzA3MDMsMC43MDcwMywtMC43MDcxNSw2Ni44Nzc3OCwtNDYuOTMwMjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTUsMC43MDcwMywtMC43MDcwMywwLjcwNzE1LDEwNi4zOTU0LC03LjQxOTgpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg5LjEyMjYsLTM2LjU2MDEzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC01OS42NzI2MDUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYzLjk3NDU1OCcgeT0nLTU5LjY3MjYwNSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjAuODYxMjE1JyB5PSctNTkuNjcyNjA1Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01Ni4xOTQ2MycgeT0nLTYyLjY3OTEyMyc+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01My40OTk4NTYnIHk9Jy01OS42NzI2MDUnPiw8dHNwYW4geD0nLTQ5Ljc3MzA3OSc+ZzwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00NS42MzYxMjknIHk9Jy02Mi42NzkxMjMnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDIuOTQxMzU0JyB5PSctNTkuNjcyNjA1Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram,node distance = 4cm]
      \node  (1) {$A$};
      \node  [right = of 1] (2) {$B \times  D$};
      \node  [between = 1 and 2] (ref) {};
      \node  [below = 2cm of ref] (3) {$\underline {A}$};
      \draw  [->,morphism] (1) to node {$(f,g)$} (2);
      \draw  [cover,morphism] (1) to node[swap] {$h$} (3);
      \draw  [>->,morphism] (3) to node[swap] {$(f',g')$} (2);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>We show that <fr:tex
display="inline"><![CDATA[f']]></fr:tex> and <fr:tex
display="inline"><![CDATA[h]]></fr:tex> form a cover-mono factorization of the cover <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[f']]></fr:tex> is an isomorphism.
    Suppose that <fr:tex
display="inline"><![CDATA[f'a = f'b]]></fr:tex>.
    We need to show that <fr:tex
display="inline"><![CDATA[a = b]]></fr:tex>.
    To this end, it suffices to show that <fr:tex
display="inline"><![CDATA[g'a = g'b]]></fr:tex> since <fr:tex
display="inline"><![CDATA[f']]></fr:tex> and <fr:tex
display="inline"><![CDATA[g']]></fr:tex> are jointly monic.
    Consider the joint pullback of <fr:tex
display="inline"><![CDATA[a]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b]]></fr:tex> along <fr:tex
display="inline"><![CDATA[h]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="746bceda00af12135868dcf0640ccba1"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzOC40NDc5NnB0JyBoZWlnaHQ9JzEyMi4wMjE1NTlwdCcgdmlld0JveD0nLTcyIC03MiA5Mi4yOTg2NCA4MS4zNDc3MDYnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0F1QTJtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhOY2k2Zkg4OXQ4WldCbVlRQ0J4d0x6M2lIby80eE1sNWxCWEE0R0poQUZBREpGQ3BVQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUTBBQW9BQUFBQUJNUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCtHTnRZWEFBQUFFNEFBQUFNUUFBQUR3QVd3Q2FaMng1WmdBQUFXd0FBQUZzQUFBQmpDZEJpZjFvWldGa0FBQUMyQUFBQUM4QUFBQTJLRWlCczJob1pXRUFBQU1JQUFBQUhRQUFBQ1FHTndIb2FHMTBlQUFBQXlnQUFBQU1BQUFBREFocUFFdHNiMk5oQUFBRE5BQUFBQWdBQUFBSUFGUUF4bTFoZUhBQUFBTThBQUFBR0FBQUFDQUFCZ0JNYm1GdFpRQUFBMVFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFS0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtT3NjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJsWnZnUDVETkRwSkhVL0FjS0F3RHdVZzFFZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pLNC92OFA1SVBwL3dmKzd3V3JBZ0lBa0lBSTd3QUFBSGphSlk4eFQ5dEFBSVh2M2RsM2NXTDczSnc1RitvRWhRUmJBa0VrT3prcnJYQ0UxQ3dkT2pDZ0RsWFZoU0F4ViszS2dNVE15SC9vMGdueEQvZ0RqQ0F4SW9RWW1aTGdxRzk2K3Q0YjNpT1U5QllMK2tEdlNKOWtoQlF3UmFZakZlcmNhTjZIU0pOMFlDSnRpajQ2Z29jNk1wR1BpaTl4WHFMSTJSV09lT2h4bEhwbkJhNzk2N1JtdzJ1b0FYUEVmUEhWaTVYSDRObkgzMXk0emtaNStkVDVUUThET0hKMnFpVnJDVEFHV3BNQ2NLUHA1Q3pzQmFEUzUwdGNseHpkR3h5UVNpRHBZc1lDZWsyK0VMSXBmSFE3L1A4d05jWXVscjVqdEVTWWpPblFKS0tiY0ltOGlvMk9CRStHZzhLa0prbTdUSUxuVVRhdWZwcHNIZlQyaCtVR3MrZVc5RCsyN1hNTDJCekpnTnBObDRVeFlOSDk3eGZyeXQ3NytYbm9zUWlmclBmTW9Td3VwNU9xNnYvOVkyUzJoUldLbDN2WFptME9xRFp0dnhPZXNPTHFrYVAreFZaZHhXdmxFQWhXWDdFelVtaThhRmEzeExaUUh6Qi9iUEk2ZG4xejByRDRHemZOTzhSNDJtTmdaR0JnQU9KVjMyWStqK2UzK2NyQXpNSUFBbzhGNXIxRDBQLy9NZ3N3M1FWeU9SaVlRS0lBY0hNTXZ3QjQybU5nWkdCZ1p2alBBQ0laVlA0L1lSWmdBSXFnQUdZQVRERURKUUFBQUFKMkFBQURBQUFrQXZRQUp3QUFBQUFBVkFER2VOcGpZR1JnWUdCbThHWmdZZ0FCUmdZMEFBQUlJZ0JUZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOQUFBb0FBQUFBQTZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdpT1J6RzJOdFlYQUFBQUZBQUFBQUtRQUFBRFFBREFFcVoyeDVaZ0FBQVd3QUFBQjRBQUFBZUpNU1BKRm9aV0ZrQUFBQjVBQUFBQzBBQUFBMktGT0EwV2hvWldFQUFBSVVBQUFBSGdBQUFDUUdOZi9kYUcxMGVBQUFBalFBQUFBR0FBQUFCZ093QUFCc2IyTmhBQUFDUEFBQUFBWUFBQUFHQUR3QUFHMWhlSEFBQUFKRUFBQUFGd0FBQUNBQUJBQWtibUZ0WlFBQUFsd0FBQURUQUFBQlBxODNkZUZ3YjNOMEFBQURNQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1sbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFVEF4SklLUzVMQjBwZVo3ak9MUFZIazRHQldZcjVPbENZRWFIaS8zOEdCZ0RyblE3dkFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hDQytOZi8vNGVRLzdYQWZBWUFYdVVITXdBQUFBQUJBSlFBQ1FLR0FmZ0FJZ0FBQVRjMkZ4WVhCZzhDSHdFV0J3WUhKaThCQnc0Qkl5WW5KajhCSnlZM05qY3lGd0dPeXc0S0V3RUNBeHE3cFRJRUFRRVRDd1hVeXdrSUJoRURBeEROelJBREF4RUdCQUVkeWhFQkFoTUtBeHE3cFRJSUF4TUNBZ1RVeXdvRkFoTUhEYzdPRFFjVEFnSUFBSGphWTJCa1lHQUE0bFhhSHRueC9EWmZHWmhaR0VEZ3NjQzhkOGcwc3d6akR5REZ3Y0FFNGdFQURQb0pVUUFBQUhqYVkyQmtZR0NXK3FNSkpHVVlwakJNWTJwakFJcWdBRVlBVE1vREZ3QUFBeHdBQUFDVUFBQUFBQUFBQUR3QUFIamFZMkJrWUdCZ1lsQm1BTkVNVUJJSkFBQUVDQUFwQUhqYVRZNnhhc013RUlZL1U4ZFFKNUNwSFRvVVRSbUZqZk1BaFF5WnNtWXNKSkVJRGxnT2ttUHdVdklBZmVoZUZBMDl3ZkhwdisrRWdKSWZNaDZWc1l6OVVUbUYzSjQ4WTg1YjRrS09TbHp5d1lvWHN2eFZraysrRXVjcytFNDg0NTFMNGtMeWUrS1NOYitidnJ2ZUJ1dlZyamZXdTFNWHBycmFXeC9hM3FsYVY4OWdhNTMxaDhFYWRaeVVHZHN3bmp2VjZFbzNiT2pwdUhKandPTGxaenRKVEdUSFNXYUJpWnFLZmN3Q3JjeWRlRFZhMHYvR1Znd1hyVU44elloMWxKa1NHbVV2U0QrTHIyamlycWI1QXdsUk1STUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBYTBBQW9BQUFBQUNSUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVkMDRHTnRZWEFBQUFFNEFBQUFSUUFBQUZRQThRR0paMng1WmdBQUFZQUFBQU81QUFBRnJQUXBPbjVvWldGa0FBQUZQQUFBQUM4QUFBQTJLUlNBMm1ob1pXRUFBQVZzQUFBQUh3QUFBQ1FIRGdNcGFHMTBlQUFBQll3QUFBQWdBQUFBSUJSSUFkRnNiMk5oQUFBRnJBQUFBQklBQUFBU0JmQUVjRzFoZUhBQUFBWEFBQUFBR0FBQUFDQUFDd0J2Ym1GdFpRQUFCZGdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFHcUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtNm1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcnFNQlF4TS93SDhwa2gwa2hxL2dPRkFkblBEUmNBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0J5QU5BOERCMUNPaFVHSElZa2hneUdQb2VqL2Y2Q29Ea01pa0pjTDR2Mi8rbi9oL3puL1oveWZDdFlIQndEUWRCQnhBQUFBZU5xTmxNdHY0MVFZeGUvMzNmZ1IyL0dONDFmYUpNN0RpWjBtcmRNMHJ6NHlUdE9rUlcyWmFabEJsSTU0ckVCaXdRckJwZ0t4WThzL3dJWVZDeVRZc0VCaWlaZ2RiRmtnSWNGZndHSzZteWszNlhRRUJTSnN5WXQ3cmZ1ZDN6bkhKa0RldTlvbWo4a0h4Q0ZrSUlsU0JOMyt3QU5iWkNCS1FkZ2Z4UEN6cHByNVltbTVXazNVa2pXbVVoQTd4YlFzQVpRM3lnQngrNnlYMmdCTVNVTDdUY0l2SlBIVll6eUU3OGthMlNVRVl0aHdYSVk2MkpianhqQ0NmaEVjMXhMNU5ERUlkZUF6K1p6WjdRRWQ5TU1nREVTSkwzdkFody82OExWUXlGbVFzUjBweWN5U0w4c0pSUkhCTkhKOWQ4L3dEaHVUTTBpTW1IbjBzTlp0ZDhDeU8rNkJiMVlBVnIxS1Z3N2dFOGRNRzZkM1g3TWozY2tEN29jNUVSQVZZVnpxVU1pdGVYV0ExMTk4NnlVemMwQ2g4dlRYSDdWYU5ZSDFIZi9qdFVFRVdKVHoxMHlUcTB2NERSK1JDdWx6SmpwVDVyaHpsN2o4WU1RWEFyOFNoREYwK0lZMDI0K2hGNEZmNFNqOExjNE8rb0c3Vjk5OGc5SngrZWg4L0RLQXVCWXBJckpxMGdCZzBuUzFDb1A2dnBrdFFOTWJ4cnFjOE9RVi9PTHA3dzZIZVhEK3pxay9wWEIra3E1OCswM0RUU2tKaGNsU2dtcFBIc0l3WEwvd3U2MHBZL3BGZlNuYTVnTEozYXRMdk9CNmo1K3A5VkNhcStVeGlPNEdkN3ZqZWpDTFFPS3F1enlVV1FMek9FU1cwTUdQb0Rjdy93NEY0M3Y1KzFzSFhRM1FRbE5MS1RSZkhHYlE0R200cXVISDlVMmdLZDF4RUozNjhEVExCTE9VbEJVM21UR0VUeE16ekRTQXpqRnJ3S2tlbFRzZ3RMcXBhQ2p1NU1wbG80S2pPeGxFZDkxMW9rUnJSVk5MMWIxSjIyNGpUdXFPZXZSUmtHTXFtQ2tIcHluMm5KMXpybDlkMGwvZ0IvSXVJYlVSN3hwSG9MeHNOQWhIdE4vcnpvbDBhRUhFQ1dPY0ZYQVdISDg2Yy80Rmx1Q05JVHpBK1lIZEFYelhaQlN0NXRaeFU1Y0tscEMwOHhZb1RVMFZtZWxWVkVGU1ZCRXNJeGxPcHBKN3RydHlYOG0rdXY5Q05xL09IVk4xaFJaSzJ4bk1KRVZ3Tk1PL1U5L2lqdFZzUkh0bGVMS2txMUxlRm1Rblo0UHc0TXVoNlhjb0R1Tnk0ZjFUaSttUU5ocGZyVWR1MnM0RDdFWVdQeExaMkRPcjJPaVZkeEFidS80RUJUZTd5TkczYnd5MWw3MmJRd1Z6MXUrNWovZzU5L0dFa0VYRy9hOE9QUXZndy84MFp2VVYrcnhDcFoxYkZkTFlyRUszVEI0dllvOE9GN2NvYzh2SUcxNk44Mjd5L3g0REhTci9XcGc1YzkvbFB6RCtTWERHL2lCb3dYVWw0STlRbHJQTC84emZOclN3WUUvVGszc3JZNFNhR1ZCcktaM09saHZ5Y2czWlQ1OFZtZjdYTE9QMWE1NUowUzBBRk5hTzBhK1hpbGhsNVdTU0l0aVN0U2x2OFlqK0JBVjh1a29BQUFCNDJtTmdaR0JnQUdKVDEva3I0L2x0dmpJd3N6Q0F3R09CZWU4UTlIOHI1anRNeDRGY0RnWW1rQ2dBTU9zTFZBQjQybU5nWkdCZ1p2alB3TURBd3N0Z3dDRE1mSWNCS0lJQ09BQTJ2Z0pBQUFMR0FBQUJXd0J6QW5vQVBnSUNBRU1DckFCTkJBMEFNQUxUQURBQ0h3QXdBQUFBQUFBcUFKUUE3QUZnQWdRQ2ZBTFdBQUI0Mm1OZ1pHQmc0R0RJWTJCaUFBRkdCalFBQUF3VUFIdDQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU00QUFvQUFBQUFBNWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ2lPSnpvR050WVhBQUFBRkFBQUFBS1FBQUFEUUFEQUVxWjJ4NVpnQUFBV3dBQUFCMEFBQUFkQmY4TlNSb1pXRmtBQUFCNEFBQUFDOEFBQUEyS01tQTJtaG9aV0VBQUFJUUFBQUFIZ0FBQUNRR3NnQjZhRzEwZUFBQUFqQUFBQUFHQUFBQUJnUkVBQUJzYjJOaEFBQUNPQUFBQUFZQUFBQUdBRG9BQUcxaGVIQUFBQUpBQUFBQUZ3QUFBQ0FBQkFBamJtRnRaUUFBQWxnQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBREtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbW5zZzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU1tQmlTUVVseVdEcFM4em5DZFdmR1BFUU1Ec3lMek9hQXdJMExGLy84TURBQVhzdzl5QUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeENDK05mLy80ZVEvN1hBZkFZQVh1VUhNd0FBQUFBQkFMUC83Z0xjQWhNQUlRQUFBUWNmQVJZVkJpTWlMd0VIQmljbUp5WS9BU2NtTnpZM05oOEJQd0UyTXpJWEZnTE40SUJwQlFRVUNnZnA0ZzBLR0FJREU5L2ZFUUVDR0FzTTR1QU5CUWdVQkFFQjRPQ0FhZ1FLR1FYcDRBOEJBaGNIRTkvZkR3b1hBZ0VQNE44TUF4a0pBQUFBZU5wallHUmdZQURpSzRkZlo4ZnoyM3hsWUdaaEFJSEhBdlBlSWVqLzc1Z25NZ2tEdVJ3TVRDQlJBR1ZLRERRQWVOcGpZR1JnWUZiOFl3UWtKekpzWnRqS2RJY0JLSUlDR0FGbHl3UXdBQUFEa1FBQUFMTUFBQUFBQUFBQU9nQUFlTnBqWUdSZ1lHQmlVR0lBMFF4UUVna0FBQVB2QUNnQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnVkdKallXQmlaZW9DMktBTWNaQWRJa1dxT3ZLN2U3Z2Vlc1BwZVQvdWdKSWZNcDZUOFJyM2MzSUtVWDljOE1KYjRxbW9SZUtTRDVaTXlQS1pPSE0yaVhOSnZoSVh2SE5KUEJYL08zSEpKNDl0MTk3dXZmVnEzeG5yM2JrTjQvcGdmV2c2cDFhNmlucG5uZlhIM2hwMUdwVVptakJjVzFYclN0ZHM2V2k1Y2FmSDRsSHN4VEdSSFdmSkFpTnJEdEVKTkpJNmFhM1FWUC95bmVRdWRvN3hrNUhPU1JJbE5NaFZrSDJWdHFLT2w1cjZGL041TUU4QUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNTUFBb0FBQUFBQTNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVnQUFBQmdpQlIzZjJOdFlYQUFBQUU4QUFBQUtnQUFBRFFBREFNdFoyeDVaZ0FBQVdnQUFBQk1BQUFBVElCRXRWbG9aV0ZrQUFBQnRBQUFBQzBBQUFBMko3ZUJ0V2hvWldFQUFBSGtBQUFBSFFBQUFDUUdBUU1pYUcxMGVBQUFBZ1FBQUFBSUFBQUFDQVdBQVI1c2IyTmhBQUFDREFBQUFBWUFBQUFHQUNZQUFHMWhlSEFBQUFJVUFBQUFGZ0FBQUNBQUJRQVVibUZ0WlFBQUFpd0FBQUROQUFBQk9JTGhLcWx3YjNOMEFBQUMvQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Pc0E0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FNRkJpU1FVbHlXenNER2RJdnBGalBEZnlDZm1ZRVJKTXlJVVBFZktBd0FGVndPaDNqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnVWdEUUxFQUw1VExmKy80ZVFmOVhCOGd3QVgxQUhPQUFBQUFJQkhnSXFBZUVDM0FBS0FCSUFBQUVPQVFjdUFTYytBVElXQnhZM0pnY21CeFlCNFFFMkt5ZzRBUUUxVmpaZ1JRTURSa1VEQXdLRUpqTUJBVEluSXpVemFBSkZSUUlDUmtVQUFIamFZMkJrWUdBQVlnMjc2OVh4L0RaZkdaaFpHRURnc2NDOGQ4ZzBVd1BUSFNERndjQUU0Z0VBR0JjSnlRQUFBSGphWTJCa1lHQm0rTThBSWhubEdPVVpIeklBUlZBQUV3QTFIQUlyQUFBQUFvQUFBQU1BQVI0QUFBQUFBQ1lBQUhqYVkyQmtZR0JnWWhBR1loQmdaRUFEQUFLUEFCb0FBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02MS44MzIxMSwtNTkuNjcyNjA1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjgzMjExLC01OS42NzI2MDUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYxLjgzMjExJyB5PSctNjEuNDM0MDUxJz7LmjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuODMyMTEnIHk9Jy01OS42NzI2MDUnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuOTc5MTYsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS44MzIxMSwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02MS44MzIxMScgeT0nLTU5LjY3MjYwNSc+RTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00NC44OTAzNCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDQuNzY1MzQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNy4xOTIxNCwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS44MzIxMSwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02MS44MzIxMScgeT0nLTU5LjY3MjYwNSc+cjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0My4yOTQ0MiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuODMyMTEsLTU5LjY3MjYwNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuODMyMTEnIHk9Jy01OS42NzI2MDUnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUyLjE0NjI0NScgeT0nLTU5LjY3MjYwNSc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQyLjE4MzYzMScgeT0nLTU5LjY3MjYwNSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0My4yOTQ0MiwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjgzMjExLC01OS42NzI2MDUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjgzMjExJyB5PSctNTkuNjcyNjA1Jz5BPC90ZXh0Pgo8cmVjdCB4PSctNjEuODMyMTEnIHk9Jy01OC40NzcxNTInIGhlaWdodD0nLjM5ODQ4NCcgd2lkdGg9JzcuNDcxOTk1Jy8+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUyLjE0NjI0OCcgeT0nLTU5LjY3MjYwNSc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQyLjE4MzYzNScgeT0nLTU5LjY3MjYwNSc+QTwvdGV4dD4KPHJlY3QgeD0nLTQyLjE4MzYzNScgeT0nLTU4LjQ3NzE1MicgaGVpZ2h0PScuMzk4NDg0JyB3aWR0aD0nNy40NzE5OTUnLz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NCAwSDM4LjIzODg4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM4LjQ4ODg4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTIuNTA3MSw0LjU2MTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuODMyMTEsLTU5LjY3MjYwNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNjEuODMyMTEnIHk9Jy01OS42NzI2MDUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTU4LjcxODc2NycgeT0nLTU5LjY3MjYwNSc+bSw8dHNwYW4geD0nLTQ3LjkyMjM4NCc+bjwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Mi45OTc1MjEnIHk9Jy01OS42NzI2MDUnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNy4yNDMwNFYtNDQuODkwMzQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00NC43NjUzNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lam9pbj0nbWl0ZXInPgogPHBhdGggZD0nTTMuMzk3MTMgMEwuMjUgMS44NzQ5NFYwVi0xLjg3NDk0WicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS43MDI3NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjgzMjExLC01OS42NzI2MDUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYxLjgzMjExJyB5PSctNTkuNjcyNjA1Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01NS4zNTM2NzEnIHk9Jy01OS42NzI2MDUnPsOXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Ny4zMTI4MScgeT0nLTU5LjY3MjYwNSc+aDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC41MzQ3LTU2LjkwNTVIMzguMjM4ODgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguNDg4ODgsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE0LjcxNDI1LC02NC45NjczMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjgzMjExLC01OS42NzI2MDUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTYxLjgzMjExJyB5PSctNTkuNjcyNjA1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01OC43MTg3NjcnIHk9Jy01OS42NzI2MDUnPmEsPHRzcGFuIHg9Jy01MC42NzA1NDYnPmI8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuMTY3MDA4JyB5PSctNTkuNjcyNjA1Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = \AA ,
      nw/style = {pullback},
      ne = A \times  A,
      sw = E,
      se = \underline {A} \times  \underline {A},
      north = {(m,n)},
      west = r,
      west/style = {cover},
      south = {(a,b)},
      east = h \times  h,
      east/style = {cover},
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Note that <fr:tex
display="inline"><![CDATA[h \times  h]]></fr:tex> is a cover by <fr:ref
addr="ct-000W"
href="ct-000W.xml"
taxon="Lemma" />, and since covers are stable under pullback in a regular category, <fr:tex
display="inline"><![CDATA[r]]></fr:tex> is also a cover.
    Now we have that</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       fm &= f'hm\\          &= f'ar && \text {by hypothesis $f'a = f'b$}\\          &= f'br\\          &= f'hn\\          &= fn     \end {align*}   ]]></fr:tex>
  <fr:p>Thus, <fr:tex
display="inline"><![CDATA[m]]></fr:tex> and <fr:tex
display="inline"><![CDATA[n]]></fr:tex> may be expressed in terms of the kernel pair of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="10397cc81fd20b29f515a14cf895a4bf"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3Ni43ODc1NTdwdCcgaGVpZ2h0PScxNzcuMjUzMDc2cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE3Ljg1ODM3MSAxMTguMTY4NzE3Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTU1BQW9BQUFBQUEzQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFZ0FBQUJnaUJSM2YyTnRZWEFBQUFFOEFBQUFLZ0FBQURRQURBTXRaMng1WmdBQUFXZ0FBQUJNQUFBQVRJQkV0VmxvWldGa0FBQUJ0QUFBQUMwQUFBQTJKN2VCcTJob1pXRUFBQUhrQUFBQUhRQUFBQ1FHQVFNaWFHMTBlQUFBQWdRQUFBQUlBQUFBQ0FXQUFSNXNiMk5oQUFBQ0RBQUFBQVlBQUFBR0FDWUFBRzFoZUhBQUFBSVVBQUFBRmdBQUFDQUFCUUFVYm1GdFpRQUFBaXdBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFDL0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtT3NBNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTUZCaVNRVWx5V3pzREdkSXZwRmpQRGZ5Q2ZtWUVSSk15SVVQRWZLQXdBRlZ3T2gzamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ1VnRFFMRUFMNVRMZisvNGVRZjlYQjhnd0FYMUFIT0FBQUFBSUJIZ0lxQWVFQzNBQUtBQklBQUFFT0FRY3VBU2MrQVRJV0J4WTNKZ2NtQnhZQjRRRTJLeWc0QVFFMVZqWmdSUU1EUmtVREF3S0VKak1CQVRJbkl6VXphQUpGUlFJQ1JrVUFBSGphWTJCa1lHQUFZZzI3Ni8zeC9EWmZHWmhaR0VEZ3NjQzhsOGcwVXdQVEhTREZ3Y0FFNGdFQUdvMEowd0FBQUhqYVkyQmtZR0JtK004QUlobmxHT1VaSHpJQVJWQUFFd0ExSEFJckFBQUFBb0FBQUFNQUFSNEFBQUFBQUNZQUFIamFZMkJrWUdCZ1loQUdZaEJnWkVBREFBS1BBQm9BQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQWJjQUFvQUFBQUFDUFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZRjArMk50WVhBQUFBRTRBQUFBUUFBQUFFd0JCZ0ZGWjJ4NVpnQUFBWGdBQUFQdUFBQUZuRU1UTmlGb1pXRmtBQUFGYUFBQUFERUFBQUEyS1JPQXoyaG9aV0VBQUFXY0FBQUFJQUFBQUNRRzNnTGxhRzEwZUFBQUJid0FBQUFjQUFBQUhCSjdBVEZzYjJOaEFBQUYyQUFBQUJBQUFBQVFCRXdGMUcxaGVIQUFBQVhvQUFBQUdBQUFBQ0FBQ2dCdmJtRnRaUUFBQmdBQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRzBBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVdzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWXlobVp2Z1A1RE5EcEpIVS9BY0tBd0RxWkExc2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdDeUFOQmNEQjFDT2lTR05JWStoa0tINC8zK2dXQnBETGtNQmlQMS85ditwLzZmOG53eldBUVVBWVI0T1FuamFmWlRMYitORUdNRDl6VGgyYkNjZVAyZVNOSEVlZHV5a2FaMW5uVzJiSm1tekQyM2JWVmtXdGwwa1FBS0J4R01QSFBhRVZvSWpGMDRjT0hDQkF5Y2t6a2djZDdseFFIQmJPUEJIc0RjMlROTHRVbFhhMnBZbHo0eEgzKy8zemZjSklCek0yK2hEOUpzd0ZRVEFCQ1JaQjdrV1JtUG9VMFlsbVpaaERCUHNTMkhDK21NWTh2RWVaVHI0WVJRbXc3QU5PaUxRVDZnVXdiZGJobWdVbE4xdVl3c2djRU1NcEV3SUNhcTRGSk5ERDlua05uRjF1dWMzUndBKzVmT0dSNGhsZVdxNjhQWmlHcjU2OW1qZm5BNmNHUTU5cjRJQ0tkSVVCT0tCKy9VL3g3Z213L0c5bFNpc0IvOVBRVDVjLzFLc3BVSGdGd2lkK1ZQOEovd2kzQmVFK29USEhVWTZKa2pIWVRUQnljYUFmd0xIYTBNTXlYQ01LT004eWZKTm1RZXlkRXJ2U3F5WERKUCtjb2pmWE1aZ2d2akk4OTlQTnh3TTRlY1d3Y2hwYlI2MGRMbmtwQlMzNklEYXltZ1NzYjJhbHBKVlRRTEhWS0xaVlprZFQ1dXZxcm1UYXpkeVJRMlFnMnhOVjNHcHNtVWhTNUdBWmt4L3A3RUpPRnQzRVhLYm82Tzhyc2xGTjVXbUt5Nms3dnd3c3YwK1JxTnh0ZlRnRllmb1lKaXJQM1ppWnJoRmdHbnM4QzBSMmZYc0FLMXVWTGNSV3AzNk01Uml1VUUySGtuYks5V3FXVU9USFFzaDFtRTBGdHZOakZaNWY5WjF1d2pOR203Qk85czBaYi93aUw3akhvOEU0VEp4bHduakMwK1ZQVS9BdzVlS1didUxGMEl5V1JVWEs5c1dNbFVKbUdiNjQ4WVZ3QmxDS2Jvb2VmY3k5dmpteTVtRHZWblh1aUJTRU5COFByK0N0dUN4TUJKdUNRS3poeGVBejA3SkFubEpHRU8wWUhkNWNmU282MGgrSkV2UklPRWFiRmxpeTdWajJJaDVrVWkzSHVCejFKUmtJaSsvUytoaDU4cGJHTzhhMXNIZHVLZll0aXdDcWFsR1Z2NzRSTU9tVmpJZkoyRFRmdU9hblN0Qnk4dnZQNFRmeStlSWpWbVJWZ0M4Rm1zanVIUHZneVBIbkdIVU5HZXZGM1ZwVVRPcXJvZ2ltRVFHQTU3OGxha0hLUmhGblUvOVFSdENubU1rak9lYlNJTkh3cG93T2EzOGN6RGhHQmhOSm9oTDRLakxUQTQ5V0JhSzYrQmhFdkhpWHpZS0R4WmFoa2o1UW9RRmdLbkw5ejhpWUNqcmhYUStZMTVkbXgyRE9DSDIvaHZkRGRscUs5bHYrdUM0ZlhiZHQyc0FhenQ3WlFYRDkvOCtNZVFYTWFPU0RHQTMzK2tiSVlJM0Q5KzdiVnZYTWVxYWhTYWdiUHJaSDc5cTlicUlHdHYrWit0REhseWd5YWRuOXViOEtmek5jempqSHpGdlljdVQ2WlFYV0x5Um5SM01SZnRpanNRRDc5TkZacVA0N0FtWGxNbWl0OFVvZ1orc0hVdGZwMlp1cytHMXpUVVJGYk9zODhuaENlOWNMQkRMZWZ0R1ZSMVZLZ3p3MU9uSFZvWUJ5cWxtNDkzdWF4alZYUW9NUGk5a1FjNXFnVlhYMDZLdEZNYWxIclZpY1NPdStTRXJwM0kycEEybm80Y3JTTkYxTlNqbDJnWnBwYURacTFPdWNrWDRENCtpdGlVQUFIamFZMkJrWUdBQTRubVNLN2JHODl0OFpXQm1ZUUNCeHdMelhzTG8vLy8vNnpQZllib0k1SEl3TUlGRUFXRmREWmtBQUFCNDJtTmdaR0JnWnZqUHdNREF3dnYvLy84THpIY1lnQ0lvZ0IwQWhxa0Z5UUxHQUFBQ09nQkxCQTBBTUFMVEFEQUNXdi8vQWhnQVBnSW9BRWtBQUFBQUFHWUJDZ0dDQWZ3Q1pBTE9lTnBqWUdSZ1lHQm55R05nWWdBQlJnWTBBQUFMK1FCNmVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTMEFBb0FBQUFBQlZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwL21OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDV1oyeDVaZ0FBQVdRQUFBSHFBQUFDSFBUL0V6dG9aV0ZrQUFBRFVBQUFBQzhBQUFBMktFT0JsV2hvWldFQUFBT0FBQUFBSGdBQUFDUUdNZ0hkYUcxMGVBQUFBNkFBQUFBUUFBQUFFQXRaQUlKc2IyTmhBQUFEc0FBQUFBb0FBQUFLQVdJQXNHMWhlSEFBQUFPOEFBQUFHQUFBQUNBQUNBQTZibUZ0WlFBQUE5UUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVxQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c1k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQm1admdQNURORHBKSFUvQWNLQXdEekFBMUtlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2ak8vLzhEU2NmLy8vOGZBUE1aQUZLNUJwOTQyalhRejJvVFVSUUc4UHZkazduVEpKT1o2S1F6bGFaVDB2eVp0cEtrZElhWnRvc29qWWsxeGJRMlVJSUVnb0lXQkFVMVJoY3Vzb2dMUVZkQ1FWeTRjZWNEdUhIbHFnL2cxb1c0RWg5QmtuaEg2TG1idzhkZC9MN0RPQ3ZNWnZ3bi84R3FiSk94RUVHNGFkbG14dklDUzFTaHVpWFhEMndyQ0t2SXFTSmoyWUd0UStaUjdOVVFldlFGOTBRbUpWQ3p5dlBRbE1Gb1RrRXFhZm9VVjZlemRpcHJwZ2dwNWFTclFZdXYxTjcveVEzNWNScHhZekt5REZwU1FRUStaNmlBWnQ5dmpET0ZOTGloaXloT0dBTDVNeHd4T2NRdXp5WWsrRmZtc0hXMkphV21uM2VGdE9VY3pPdFFIZGpDZ0ZCejRyL1hqSEJCeWMyWGhFcm5POGtQM3FlM2krNlNZYURidTB1anpuNEgvSHI2NXJQcHU2eXU3emdmVC9zRGprcDl2R3dxajk3MGhweHY3SDFyeGdEOWtHOWY0SlJWd1cvdHRFNk1SSHQ3ZjFldnhhSUdNTkdnSjgzQ05RN2owdVF6UFc4WEQybjY2NkpJTUFibXpYNVRrbitQekNBZGVYblJLL0JMcmpSSFlOdEJLTThiQ1pmaHlBSXlyOEFOd3VoWnRtV0hzZzRscnBKSXhCVndIQjgwWG0wMEY0V0YyTXNicS8zQUw0dFlYRldvM0Z4N1hIL3hnYWpqdDU2T08ydXJZaytIeHMrbWYzVnBWbzNTN1FkQWZhdmJYK2lWaDNjNFZ0WXJ2WVVrd0xXSHUwVVBkRHA2UFdqNVJ4UXJGUFVEblJOai93QWQwbHIrQUFCNDJtTmdaR0JnQUdJTy9XYkhlSDZicnd6TUxBd2c4RmhnM2tzRS9mOGxNemZUWFNDWGc0RUpKQW9BRGw4S2R3QjQybU5nWkdCZ1p2alBBQ1E1R0ZUK1gyRG1aZ0NLb0FBV0FFcjNBeFVBQUFKMkFBQURBQUFrQXdnQUt3TGJBRE1BQUFBQUFGUUFzQUVPQUFCNDJtTmdaR0JnWUdHd1pHQm1BQUZHQmpRQUFBYVNBRU40MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIxLjc1NTQzOCwtMjIuMDc2Njk3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuOTMxMjQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjc1NTQzOCwtMjIuMDc2Njk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0yMS43NTU0MzgnIHk9Jy0yMi4wNzY2OTcnPkM8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS43NTU0MzgsLTIyLjA3NjY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMjEuNzU1NDM4JyB5PSctMjIuMDc2Njk3Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTcuMzg2MjMsLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNzU1NDM4LC0yMi4wNzY2OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTIxLjc1NTQzOCcgeT0nLTIyLjA3NjY5Nyc+cDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1My4xNTU1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS43NTU0MzgsLTIyLjA3NjY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMjEuNzU1NDM4JyB5PSctMjIuMDc2Njk3Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjg2MjEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS43NTU0MzgsLTIyLjA3NjY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMjEuNzU1NDM4JyB5PSctMjIuMDc2Njk3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjQ4Njc5IDBINDguMDk5OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMzQ5OTYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNi41ODUyLDQuMTcyOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjc1NTQzOCwtMjIuMDc2Njk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0yMS43NTU0MzgnIHk9Jy0yMi4wNzY2OTcnPnE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNzU1NDM4LC0yMi4wNzY2OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTIxLjc1NTQzOCcgeT0nLTIyLjA3NjY5Nyc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NC01Ni45MDU1SDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNS45NjQsLTY0LjU3ODQxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNzU1NDM4LC0yMi4wNzY2OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTIxLjc1NTQzOCcgeT0nLTIyLjA3NjY5Nyc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDMuOTg4MywzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNzU1NDM4LC0yMi4wNzY2OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIxLjc1NTQzOCcgeT0nLTIzLjgzODE0Myc+y5o8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIxLjc1NTQzOCcgeT0nLTIyLjA3NjY5Nyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTQxLjA4MTE4IDMzLjgyODU3Qy00Ni40NzQ0OS0xLjEzNDM1LTM1Ljg4NzYtMjguMzg1My04LjY5NTM2LTUwLjIyNDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43Nzk2NSwtMC42MjYxNiwwLjYyNjE2LDAuNzc5NjUsLTguNTAwNDYsLTUwLjM4MTA0KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDcuNDE5MSwtMTguOTg0MTgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS43NTU0MzgsLTIyLjA3NjY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMjEuNzU1NDM4JyB5PSctMjIuMDc2Njk3Jz5tPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tMzEuOTMyNzUgNDEuMzMwNDdDMi40NjM1OCA0Ni4yNTcgMjkuMTIwNzQgMzUuNTY3ODMgNTAuMjc2NjQgOC42MzYyMicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjYxNzcsLTAuNzg2MzYsMC43ODYzNiwwLjYxNzcsNTAuNDMxMDYsOC40Mzk2NCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTcuNDM5NTgsMzkuNjkyOCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjc1NTQzOCwtMjIuMDc2Njk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0yMS43NTU0MzgnIHk9Jy0yMi4wNzY2OTcnPm48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00tMzMuODI4ODcgMzMuODI4NTdMLTguNTkyOTQgOC41OTY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE0LC0wLjcwNzAzLDAuNzA3MDMsMC43MDcxNCwtOC40MTYxNSw4LjQxOTgpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTS0yNS45MjEzIDE2LjI4NTgxSC0xNi4xNDY5OFYyNS4yOTk3SC0yNS45MjEzWicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIyLjkyMTMsMTkuMjg1ODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS43NTU0MzgsLTIyLjA3NjY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMjEuNzU1NDM4JyB5PSctMjIuMDc2Njk3Jz5zPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw = C,
        nw/style = {pullback},
        ne = A,
        sw = A,
        se = B,
        north = q,
        west = p,
        south = f,
        east = f,
      }
      \node  [above left = of nw] (aa) {$\AA $};
      \draw  [->,morphism,bend right] (aa) to node[swap] {$m$} (sw);
      \draw  [->,morphism,bend left] (aa) to node {$n$} (ne);
      \draw  [->,morphism,exists] (aa) to node[desc] {$s$} (nw);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>To show <fr:tex
display="inline"><![CDATA[g'a = g'b]]></fr:tex>, it suffices to show <fr:tex
display="inline"><![CDATA[g'ar = g'br]]></fr:tex> since <fr:tex
display="inline"><![CDATA[r]]></fr:tex> is epic.</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       g'ar &= g'hm\\            &= gm\\            &= gps && \text {by hypothesis $gp = gq$}\\            &= gqs\\            &= gn\\            &= g'hn\\            &= g'br     \end {align*}   ]]></fr:tex>
  <fr:p>Finally, <fr:tex
display="inline"><![CDATA[g]]></fr:tex> can be factored as follows:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="a89156e69332696fb4b58cdd48938010"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMwMS43Nzc3MzNwdCcgaGVpZ2h0PScxNTYuNzM3MDUxcHQnIHZpZXdCb3g9Jy03MiAtNzIgMjAxLjE4NTE1NiAxMDQuNDkxMzY3Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNY0FBb0FBQUFBQTRRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVXgxRzJOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDRVoyeDVaZ0FBQVdRQUFBQmtBQUFBWkRGdUFySm9aV0ZrQUFBQnlBQUFBQzBBQUFBMktJbUJibWhvWldFQUFBSDRBQUFBSGdBQUFDUUZ5d0xXYUcxMGVBQUFBaGdBQUFBSUFBQUFDQVlLQUpKc2IyTmhBQUFDSUFBQUFBWUFBQUFHQURJQUFHMWhlSEFBQUFJb0FBQUFGd0FBQUNBQUJBQWdibUZ0WlFBQUFrQUFBQURLQUFBQk11c0lrZVp3YjNOMEFBQUREQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1abVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvYU1oZ3lNL3dIOHBraDBraHEvZ09GQWFOM0RGZ0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aUcvLzlEeVA4WHdId0dBRkZIQm8wQUFBQUFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FlTnBqWUdSZ1lBRGlINmNyYjhiejIzeGxZR1poQUlISEF2TWVJOVBNUVV5cmdSUUhBeE9JQndCUGhRcXlBQUFBZU5wallHUmdZR2I0endBa2d4Z21NVFF5bVRNQVJWQUFFd0JDM0FLb0FBQURVZ0FBQXJnQWtnQUFBQUFBTWdBQWVOcGpZR1JnWUdCaWtHY0EwUXhRRWdrQUFBT2tBQ1VBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktuNXViZzVPcnc5dXNDZEtocWFTMTZDTCtkRzlEOEFZTzN6M24zQUFaTHhLR1NaZ0hIU2FWTjQ4ODVvZEY1SW40cThnWnY2d1prYVF6Y1Zic0lxZE0rWTg4WmtrWmVTTCtJM0xHSCs5OVU5L3VuZlhxMkJqcjNhWDIyNVAxYmRVNHRkSDVzQjZzcy83Y1dhUEtweko5MWZiWFdoVTYxd1Y3R21wdTNPbXdlQlJIY1V4Z3gwVXl6NVpUMkZzcXlaeDBObWp5YjNxUTFJWEdPZnhpcEZIeUZEWDBjdE9LWHFXcktNS2RwdmdBVlRJdVF3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTklBQW9BQUFBQUE2Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFMEFBQUJncWw1aThXTnRZWEFBQUFGRUFBQUFNd0FBQUR5ZVgyUlJaMng1WmdBQUFYZ0FBQUI0QUFBQWVJWXFoTEZvWldGa0FBQUI4QUFBQUN3QUFBQTJLWXlBLzJob1pXRUFBQUljQUFBQUhnQUFBQ1FIT3dDU2FHMTBlQUFBQWp3QUFBQU1BQUFBREFuSUFRUnNiMk5oQUFBQ1NBQUFBQWdBQUFBSUFCb0FQRzFoZUhBQUFBSlFBQUFBRndBQUFDQUFCUUFTYm1GdFpRQUFBbWdBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFET0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtcm1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFBNE1EakoxU1hKYk93S1lrOU1DQVdldVBKUU1Ec3hiemNhQXdJMEwxLy84TURBQVRDUTlRQUFBQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWm1SZ1VoSjZZUEQvUHdNRGhMNzdYdjRTV0JVUUFBQ203Z210QUFBQkFLVUE0Z093QVI0QUN3QUFKU0VHSmpRMkZ5RTJGaFFHQTRYOVN3MGVIZzBDdFEwZUh1TUJDaWdLQVFFS0tBb0FBQUFBQVFCZkFDY0Jld0k4QUJBQUFBRURCaU1uSmljM0V6NEJOeklXRndZSEFYSFVCZ3dXRXdNRW5nTVpIaGttQVFFRUFkeitYQkVIQncwUUFic09JQUVnSEF3TUFIamFZMkJrWUdBQTR1eThKWUx4L0RaZkdaaFpHRURnc2NDOHg4ZzBTeWlURFpEaVlHQUM4UUFIRWdqQWVOcGpZR1JnWU5iNlk4bkF3QkxLRUE5a2IyQUFpcUFBWmdCSVdBTFRBQUFFVlFBQUE3QUFwUUhEQUY4QUFBQUFBQm9BUEhqYVkyQmtZR0JnWmhCa0FORU1VQklKQUFBQ1lRQVlBSGphVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9KU1ZoWUdKbGFrTFlJTXl4RUYyaUJTcDZzanY3dUY2NkEybjUvMjRBMHAreUhoT3htdmN6OGtwUlAxeHdRdHZpYWVpRm9sTFBsZ3lJY3RuNHN6WkpNNGwrVXBjOE00bDhWVDg3OFFsbnp5MlhYdTc5OWFyZldlc2QrYzJqT3VEOWFIcG5GcnBLdXFkZGRZZmUydlVhVlJtYU1Kd2JWV3RLMTJ6cGFQbHhwMGVpMGV4RjhkRWRwd2xDNHlzT1VRbjBFanFwTFZDVS8zTGQ1SzcyRG5HVDBZNkowbVUwQ0JYUWZaVjJvbzZYbXJxWCsvcE1FY0FBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV2tBQW9BQUFBQUJxZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMHEyTnRZWEFBQUFFNEFBQUFOUUFBQUR3QWpRQzdaMng1WmdBQUFYQUFBQUxKQUFBRGJPRUxEY2xvWldGa0FBQUVQQUFBQURFQUFBQTJKLzJBd1dob1pXRUFBQVJ3QUFBQUlBQUFBQ1FGYkFHY2FHMTBlQUFBQkpBQUFBQVVBQUFBRkF1dEFMUnNiMk5oQUFBRXBBQUFBQXdBQUFBTUFiUUNpbTFoZUhBQUFBU3dBQUFBR0FBQUFDQUFDQUJQYm1GdFpRQUFCTWdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGbUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtQ21XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NUlF5TS93SDhwa2gwa2hxL2dPRkFjM1VEUndBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpNVS92OFA1S2N4RlB6Ly8zLzIvOGxnVlVBQUFKb1RDVUlBQUFCNDJsMlN6Vy9UU0JqRy9jeTRuanB1UEhZY2owazJjZE00c1ZPUnhtMmQybXpwSmswRGxmckJseENVSWo0a0pBN3NoNFNFVmxydENva3JGdzZJQXdjdVhQZ2Z1SmNqQndRM3hKK3hoejFzdzdoRmdCaExjNWozT1R5LzkyY0Z5czRrSnIrU2Q4cTZvb0J5YU13RWE0YlJBSW53aE1iRUxBWVkwa0FMVXk4WklKUHZ5OEl6RVlSUm1HWmhESk53SktuUUlyeGN0VlNycW8rV09xdEF5dzBwK0N6bnZEVkg2ejIrNnhPSFgrS3VLVGFDK1RVZ0VISnUrWnlYU241aHVubzdIK1BaNGNHMnZkNHZqMmtZK0EzUzBpSkRKMUIzM09mLzd0RW13OTcrVDFIWWJuMGJvUkl1UEZHYjAxRGtJVXAzc2tEYU9GQjZ5amlua1NUYUVZbHNYTmFZSnhLUlNvQ2hoT3doU3JQODgrRkpLaG1nUTZTUmhOSll2Z0xoTGVkUk1uZGZmL0JYZkV1VmZXMEJzMVN6NThwclFVMHdMOXNhN1JNNjR2YldmbWVsU0t1bG9vdW5NVVhaN1ZmSERkZXlFVWIrUm0yRzRlL0RVWHlkRXJkYm4zTWN3eTlNRVJpMXltTGpScUppNytMZDh3NC9ROUVTbG9CbEgvNzNtaHZ0UUVWbkpSeXRYOGpRYnZCaXpqYVpURTZSVmJ4UjFwUnppdUk1V1QrTUpKK0pHRDNrVmJOVWVNZDNUbkJFcUVtZHJoUzRMTnl5RmtSTWkvcXA1SEtZNWgxbEIxanBTWkhhdVQ4cGQveW1NY1VLaGdiQlp5Sy9NdUppZC9IVUxVcEhWbW5uYW05WmR4eW1namNMVnBIOWZzMmd0bEczMzZSd1JOSTU2NXlvNDZSZjJYNkk5N051RFZqdmxRMFFZbzFyb2dINEo3Mlk0UEwrdlF0bGUwekp2RDIrVWpPMTNHdkIxRlVWTm1ldzhQSFRUTHMxaGJWbzhaK2dIeU04OGptWS9Fd002Yk9yREkvL3p1OWd3Z0U4a1E2SlhNSVBNbVdBWmw5Y3lxbVBmQzBaMFIrcnlBRnNrLzN4RzRlbEwxU25LelAybWU1NEQrcVFPOXZYbDFaWUtkYUxMeElwTWZFMkE2Y0pkSC9abU5VcFh2My8wV0pmTzVNNkE1ejVPNGtWRXR6Y3ZYdkpLVzFTc21SWDUwR0swNGNmM2hydHRrbzZwNE5IQzVrczF6S1l4UGtNdy9wM2FBQUFBSGphWTJCa1lHQUE0cW8vNG5maitXMitNakN6TUlEQVk0RjVqMkgwLy8vL2RabU9NVjBFY2prWW1FQ2lBRzQ2RGNvQUFBQjQybU5nWkdCZ1p2alB3TURBZE96Ly8vOFhtTElZZ0NJb2dCVUFqL29HQ3dMR0FBQUNPZ0JMQWpvQUxBSmEvLzhDR0FBK0FBQUFBQUJtQU5RQlRnRzJlTnBqWUdSZ1lHQmw4R05nWWdBQlJnWTBBQUFJb3dCWWVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVa0FBb0FBQUFBQmZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxRjJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDWFoyeDVaZ0FBQVdRQUFBSllBQUFDdUpIamNjbG9aV0ZrQUFBRHZBQUFBQzhBQUFBMktHK0JpV2hvWldFQUFBUHNBQUFBSGdBQUFDUUdYZ0lsYUcxMGVBQUFCQXdBQUFBVUFBQUFGQTZvQUt0c2IyTmhBQUFFSUFBQUFBd0FBQUFNQVdJQ0RHMWhlSEFBQUFRc0FBQUFHQUFBQUNBQUNRQTZibUZ0WlFBQUJFUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZHQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmhadmdQNURORHBKSFUvQWNLQXdENzFRMWplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2Z3UvLzhEU2NmLy8vOGZBUE1aQUZMS0JxQjQyalhSdjA4VFlSekg4ZWZ6Zk52bmFHbnZLbGZ1YXFEWGxKWWVZRm9JdmR3QmljVlFxUWl4L0toQmdvMUVFeVNTaUQ5QVpHRG9nREVhR0l3SmlYRncwTTA0dXpnNU1UbTVPcWlUOFU4d2JYMk9oT2Rabm54encvdjdPc1padHQzbVAva1BOc3hHR2ZQZ2VxT0dxY2VOb211SVlTaDJ6blpjMDNDOVlhUVZFVGRNMTFRaDUvNjRXSUpYcE05WUYvR29RTW5JZHlNUzNHbDBCQkh0MUIwS0thMTJOZHFyUnduUjRNWktCSkZRWCtuTjMvUXVYNDRocERVYmhrWkpCVVRnSFpvQ1JNeTcwd2Z4YkF4Y1U0VS9EbXNDbVJNc01YbUlYV2czU2ZBdnpHSkRiRXlXNms3R0ZySXRiYUZiaFdMQkZCcUVraGFudmJvZjUrYnNURTRvZFBZbStVSHh3MUdQbmRRMHJOVHZVS00yVndPL0VydjJwUFc2VjFVbnJIZkhhenNjaGZKQlNnOXVIZFozT1IrWitWb0pBT29DSHovSHFWY0JYNXlZM2REQzFmRzVLYlVVOERlQWptbDZYTWxlNXRET056L1MwMnIvQXJWK2Q0a3dZMkRGOWgvcTVOLzlacENLakJTZGhKT3paYk1mYkZyd0pLOWZtSUlsRjVEekFtelg4NjloR3FZbjE2SHdKUkxoVUJBY3kvUFR6MFlxUGNKQVlQL3F3SnJyNUVVZ3BBUXBYeGw4Vk41N1MxUnpacmNQYW9NRFlrWkZoSiswL3FteVdkRnlxNXRBZVd4bExWSFA3OTdtNkJzcTFCT2RBSS9jbitvdmdvNGJMM1ptblNVS1pQdlZlWldUTk9kc1VKcDcwanpCOHI2NGV3WnVDc1cvWjlhbnJxYS93aVJjdXdCRnFyOC9RdG1LU2VidGZkRDgwTmhtby9VcHFVbmlYNGMrNTh0YmUrWkVvcU1ML0Y1MUs2VkwzUmhSVXY3MlZ3K2VQN3lZdjA1a0NRbkx5ODF2MGhHQmhkVGl6ZlFOZTMwVjBHVGFmL1FCZDFkNDJtTmdaR0JnQU9Malluc3I0L2x0dmpJd3N6Q0F3R09CZVk4UjlQK1h6T1pNZDRGY0RnWW1rQ2dBUU5RTHJ3QjQybU5nWkdCZ1p2alBBQ1Q5R1ZUK1gyQTJad0NLb0FCV0FGVXJBNGtBQUFKMkFBQURBQUFrQXdnQUt3TGJBRE1EVHdBcEFBQUFBQUJVQUxBQkRnRmNlTnBqWUdSZ1lHQmxzR1JnWmdBQlJnWTBBQUFHclFCRWVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYzLjc5Mzk5MSwtNTguNjg0NzE3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuOTMxMjQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc5Mzk5MSwtNTguNjg0NzE3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02My43OTM5OTEnIHk9Jy01OC42ODQ3MTcnPkM8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODEuNjA4MjYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc5Mzk5MSwtNTguNjg0NzE3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02My43OTM5OTEnIHk9Jy01OC42ODQ3MTcnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTY2LjY3MzEzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43OTM5OTEsLTU4LjY4NDcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuNzkzOTkxJyB5PSctNTguNjg0NzE3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE2Ni40MzgwNSwtODcuODU4MjYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43OTM5OTEsLTU4LjY4NDcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuNzkzOTkxJyB5PSctNTguNjg0NzE3Jz5EPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE2Ni45NjY1MiwtNDUuMTc5MTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43OTM5OTEsLTU4LjY4NDcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuNzkzOTkxJyB5PSctNTguNjg0NzE3Jz5BPC90ZXh0Pgo8cmVjdCB4PSctNjMuNzkzOTkxJyB5PSctNTcuNDg5MjY1JyBoZWlnaHQ9Jy4zOTg0ODQnIHdpZHRoPSc3LjQ3MTk5NScvPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjQ4Njc5IDMuNjE2NjJINzYuNTUyNzInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzYuODAyNzIsMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDAuNzA4NTcsNy43ODk1MiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc5Mzk5MSwtNTguNjg0NzE3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43OTM5OTEnIHk9Jy01OC42ODQ3MTcnPnA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguNDg2NzktMy42MTY2Mkg3Ni41NTI3MicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3Ni44MDI3MiwtMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDAuODExNTgsLTkuNDQyMzIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43OTM5OTEsLTU4LjY4NDcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjMuNzkzOTkxJyB5PSctNTguNjg0NzE3Jz5xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005My42NjM4IDBIMTU4LjM0NTQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE1OC4yMjA0NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMjUuNTQ4NjUsNC4xNzI5MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc5Mzk5MSwtNTguNjg0NzE3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43OTM5OTEnIHk9Jy01OC42ODQ3MTcnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkxLjc2MjItNi40MDk3M0wxNjIuMTI4MzQtNzYuNzYxNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE3LC0wLjcwNzAzLDAuNzA3MDMsMC43MDcxNywxNjIuMzA1MTMsLTc2LjkzODQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMTkuNzA1NzMsLTQ3LjU4ODE3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzkzOTkxLC01OC42ODQ3MTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjc5Mzk5MScgeT0nLTU4LjY4NDcxNyc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTcwLjcxNjUyLTYuNDA5NzNWLTMzLjkzNjA4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMTcwLjcxNjUyLC0zNC4xODYwOCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTczLjk4MDQxLC0yMi4xNzI5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzkzOTkxLC01OC42ODQ3MTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjc5Mzk5MScgeT0nLTU4LjY4NDcxNyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTkuMTI3NDA3JyB5PSctNjEuNjkxMjM1Jz7ugLA8dHNwYW4geD0nLTU2LjQzMjYzNCcgeT0nLTYxLjk5NTY1Jz7iiJI8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTEuMDM2MTI1JyB5PSctNjEuOTk1NjUnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTE3MC43MTY1Mi01MS4wODg3M1YtNzYuNjE1MjInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwxNzAuNzE2NTIsLTc2Ljg2NTIyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNzMuOTgwNDEsLTY1Ljg1MTk3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzkzOTkxLC01OC42ODQ3MTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjc5Mzk5MScgeT0nLTU4LjY4NDcxNyc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTkuNjU3MDQxJyB5PSctNjEuNjkxMjM1Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram, node distance = 3cm]
      \node  (1) {$C$};
      \node  [right = of 1] (2) {$A$};
      \node  [right = of 2] (3) {$B$};
      \node  [below = of 3] (5) {$D$};
      \node  [between = 3 and 5] (4) {$\underline {A}$};
      \draw  [->,morphism,offset=-1.5] (1) to node {$p$} (2);
      \draw  [->,morphism,offset=1.5] (1) to node[swap] {$q$} (2);
      \draw  [cover,morphism] (2) to node {$f$} (3);
      \draw  [->,morphism] (2) to node[swap] {$g$} (5);
      \draw  [->,morphism] (3) to node {${f'}^{-1}$} (4);
      \draw  [->,morphism] (4) to node {$g'$} (5);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Uniqueness then follows from the fact that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is epic.</fr:p>
</fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1269</fr:anchor><fr:addr
type="user">ct-000T</fr:addr><fr:route>ct-000T.xml</fr:route><fr:title
text="Covers arise from kernel pairs"><fr:link
type="local"
href="ct-000M.xml"
addr="ct-000M"
title="Extremal epimorphism">Covers</fr:link> arise from kernel pairs</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>In a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>, every cover is a coequalizer of the kernel pair of itself.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>714</fr:anchor><fr:addr
type="machine">#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[p,q\colon C\rightrightarrows A]]></fr:tex> be the kernel pair of a cover <fr:tex
display="inline"><![CDATA[f\colon A\twoheadrightarrow B]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g\colon A\to D]]></fr:tex> be a morphism such that <fr:tex
display="inline"><![CDATA[gp = gq]]></fr:tex>.
    Consider the <fr:em>joint</fr:em> cover-mono factorization of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g]]></fr:tex>, i.e., the cover-mono factorization of the morphism <fr:tex
display="inline"><![CDATA[(f,g)\colon A\to B \times  D]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="25a16084d5f6237108378ff250de2a42"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIxMC4xMTk2MTFwdCcgaGVpZ2h0PScxMTUuNzI0MTQ0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTQwLjA3OTc0MSA3Ny4xNDk0Myc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVU4QUFvQUFBQUFCaUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVZDBqV050WVhBQUFBRTRBQUFBTlFBQUFEd0F0QUJQWjJ4NVpnQUFBWEFBQUFKb0FBQUM1R1ZNU3o1b1pXRmtBQUFEMkFBQUFDOEFBQUEySi82QXQyaG9aV0VBQUFRSUFBQUFJQUFBQUNRRnFnR2NhRzEwZUFBQUJDZ0FBQUFVQUFBQUZBdEJBVGRzYjJOaEFBQUVQQUFBQUF3QUFBQU1BU2dDQW0xaGVIQUFBQVJJQUFBQUdBQUFBQ0FBQ0FCTmJtRnRaUUFBQkdBQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRk1BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWNtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHJxTUdRd00vd0g4cGtoMGtocS9nT0ZBYjRvRE1RQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUSzZqQmsvUDhQNU9zd3BQMy8vLy9xL3psZ1ZVQUFBSkhnQ1AwQUFBQjQya1dSTVcvVFFCaUcvZDA1ZDBrYysrdzRQdFBVZGVMWU9hZFNtelJ4WWtNSlNkTlVTRzJoRkphb0NOR0poUW1wRWtJZzhSTVFRZ3lzYlB3RjlrcWQyZmdqUldKSk9MY0Q5MDJuOTlQZCs3eXZBc3JGYWxlNVZ0NHFYRkV5U21nWGhtbm1nME1ZRUNyaU5KdkE3NHBtZTQxbVBZclVkcW5OTkF3a2FaaEZDaEFNQW9CSmZ6SFNCNEIwV3VpZksvS0Fjcnpxb2Rmb2w3SW5MemgveUFEYUV2RUVFdTV5UW5rREpqREZJUkdwbTB4QWZwRU11R3RBS0dLUlpxSUhCbUtRcEp6RThIM1hWTTE2YWRidjdBSkVqc0RBR295eEtNQWJYZmJJUnpaN3loeUQ3NGViWTRDUVM5MzBHYXRXL1hLeGZwN0w4SFY1ZVdUdERXdHpMRUsvaVNJU2F5VUU2ckh6N1hxQld4UVdaK3V4YUVmL0pWZ1QyNS9VVmhGeUZxUnNyYlpSR3k2VnJqTFBhU1FKdVNHUmptdUV1anpoZVVaVHlLT1RjZVhqZ3l1cDVBS2VRaHBMS0VMekNMZzd5RmRSOEtaMDhhNzNVcFYrTFE1RzFiT0MyamowT0hXenc5a1p3ak5tSFo1MVJqcXVWM1VIdnZRdzFKeGhmZDUwVEF0RTdPOTdGUXJ2bDdQZWM0eWNyWTNBdGpXL1hFQ2dlV3M3elJlSkNvdlRWeWMyTzhBUWNaT0RhUzMvL21SYU8xU2hNeEt6dlNjWnRKdE12K25wOGVvUCtvQ3VsT09jVEZyMkVTVzNkVGtrTjVzbXJpOTU1Y2oyaGhJbXh4TnhuZ0ZUWlY5ZEdHWDJCRVI0VzI2V2NncXpFKy9adllmRENxQWFzaXQ2R1h1TmNSVlpaUUt1Wm9XVHpsM0F1c0U1UXJ3elByM0RDbmF6VkN5N3BhcFYrS3dpRnBWTUFJTWViTFVCL1ZoZUJRa1Vla085T3liMzE0UEFhcUhwZ3lwQzdvN0x1MnB2czZJMW8vMTUzK2tqTk85dzdlaWpXR2NhMkRwSEJ6b3JxMlZXcENxdS9BTlJCR0R5ZU5wallHUmdZQURpRXNGRm1mSDhObDhabUZrWVFPQ3h3THg3Q1BxL0x0TXhwb3RBTGdjREUwZ1VBQ1I4Q3VnQWVOcGpZR1JnWUdiNHo4REF3SFNNUWVmL0JhWnFCcUFJQ21BRkFHWmdCRW9DeGdBQUFWc0Fjd0k2QUVzQ09nQXNBcXdBVFFBQUFBQUFLZ0NRQVA0QmNuamFZMkJrWUdCZ1pmQmhZR0lBQVVZR05BQUFDSEVBVm5qYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUlBQW9BQUFBQUEyZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYUR4aWhHTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJFQUFBQVJCNWFqSGRvWldGa0FBQUJzQUFBQUMwQUFBQTJLWXlBOVdob1pXRUFBQUhnQUFBQUh3QUFBQ1FGQmdEWmFHMTBlQUFBQWdBQUFBQUlBQUFBQ0FZWUFGOXNiMk5oQUFBQ0NBQUFBQVlBQUFBR0FDSUFBRzFoZUhBQUFBSVFBQUFBRndBQUFDQUFCQUFTYm1GdFpRQUFBaWdBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFDK0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtNW1HY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnEwL2xnd016RnJNeDRIQ2pBZ1YvLzh6TUFBQSt3TVBmd0I0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQUY4QUp3RjdBandBRUFBQUFRTUdJeWNtSnpjVFBnRTNNaFlYQmdjQmNkUUdEQllUQXdTZUF4a2VHU1lCQVFRQjNQNWNFUWNIRFJBQnV3NGdBU0FjREF3QWVOcGpZR1JnWUFCaTlzMExIT1A1YmI0eU1MTXdnTUJqZ1huM2tHbVdVQ1liSU1YQndBVGlBUUFIdFFqREFBQUFlTnBqWUdSZ1lOYjZZOG5Bd0JMS0VNL2d3VmpOQUJSQkFVd0FTaWdDNHdBRVZRQUFBY01BWHdBQUFBQUFJZ0FBZU5wallHUmdZR0JpRUdRQTBReFFFZ2tBQUFKR0FCY0FlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ2xKV0ZnWW1WcVF0Z2d6TEVRWGFJRktucXlPL3U0WHJvRGFmbi9iZ0RTbjdJZUU3R2E5elB5U2xFL1hIQkMyK0pwNklXaVVzK1dESWh5MmZpek5ra3ppWDVTbHp3emlYeFZQenZ4Q1dmUExaZGU3djMxcXQ5WjZ4MzV6YU02NFAxb2VtY1d1a3E2cDExMWg5N2E5UnBWR1pvd25CdFZhMHJYYk9sbytYR25SNkxSN0VYeDBSMm5DVUxqS3c1UkNmUVNPcWt0VUpUL2N0M2tydllPY1pQUmpvblNaVFFJRmRCOWxYYWlqcGVhdXBmNytrd1J3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5BQUFvQUFBQUFBNlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ2lPUnpHMk50WVhBQUFBRkFBQUFBS1FBQUFEUUFEQUVxWjJ4NVpnQUFBV3dBQUFCNEFBQUFlSk1TUEpGb1pXRmtBQUFCNUFBQUFDMEFBQUEyS0ZPQXNXaG9aV0VBQUFJVUFBQUFIZ0FBQUNRR05mL2RhRzEwZUFBQUFqUUFBQUFHQUFBQUJnT3dBQUJzYjJOaEFBQUNQQUFBQUFZQUFBQUdBRHdBQUcxaGVIQUFBQUpFQUFBQUZ3QUFBQ0FBQkFBa2JtRnRaUUFBQWx3QUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRE1BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWxtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVUQXhKSUtTNUxCMHBlWjdqT0xQVkhrNEdCV1lyNU9sQ1lFYUhpLzM4R0JnRHJuUTd2QUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeENDK05mLy80ZVEvN1hBZkFZQVh1VUhNd0FBQUFBQkFKUUFDUUtHQWZnQUlnQUFBVGMyRnhZWEJnOENId0VXQndZSEppOEJCdzRCSXlZbkpqOEJKeVkzTmpjeUZ3R095dzRLRXdFQ0F4cTdwVElFQVFFVEN3WFV5d2tJQmhFREF4RE56UkFEQXhFR0JBRWR5aEVCQWhNS0F4cTdwVElJQXhNQ0FnVFV5d29GQWhNSERjN09EUWNUQWdJQUFIamFZMkJrWUdBQTRsWGFIcXZqK1cyK01qQ3pNSURBWTRGNTk1QnBaaG5HSDBDS2c0RUp4QU1BRk5vSmNRQUFBSGphWTJCa1lHQ1crcU1KSkdVWXBqQk1ZMnBqQUlxZ0FFWUFUTW9ERndBQUF4d0FBQUNVQUFBQUFBQUFBRHdBQUhqYVkyQmtZR0JnWWxCbUFORU1VQklKQUFBRUNBQXBBSGphVFk2eGFzTXdFSVkvVThkUUo1Q3BIVG9VVFJtRmpmTUFoUXlac21Zc0pKRUlEbGdPa21Qd1V2SUFmZWhlRkEwOXdmSHB2KytFZ0pJZk1oNlZzWXo5VVRtRjNKNDhZODViNGtLT1Nsenl3WW9Yc3Z4VmtrKytFdWNzK0U0ODQ1MUw0a0x5ZStLU05iK2J2cnZlQnV2VnJqZld1MU1YcHJyYVd4L2EzcWxhVjg5Z2E1MzFoOEVhZFp5VUdkc3duanZWNkVvM2JPanB1SEpqd09MbFp6dEpUR1RIU1dhQmlacUtmY3dDcmN5ZGVEVmEwdi9HVmd3WHJVTjh6WWgxbEprU0dtVXZTRCtMcjJqaXJxYjVBd2xSTVJNQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0F1QXVtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhOY2k2L0g4OXQ4WldCbVlRQ0J4d0x6N2lIby80eE1sNWxCWEE0R0poQUZBRG9sQ3JVQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU1VBQW9BQUFBQUJUd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUhHTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QVdRQ2RaMng1WmdBQUFXd0FBQUhEQUFBQi9OWjNEOEJvWldGa0FBQURNQUFBQUM4QUFBQTJLRytCazJob1pXRUFBQU5nQUFBQUhnQUFBQ1FHWFFKV2FHMTBlQUFBQTRBQUFBQVFBQUFBRUF2TkFIaHNiMk5oQUFBRGtBQUFBQW9BQUFBS0FWSUFzRzFoZUhBQUFBT2NBQUFBR0FBQUFDQUFDQUE2Ym1GdFpRQUFBN1FBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFaUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtK3N3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJoWnZnUDVETkRwSkhVL0FjS0F3RDlwZzFvZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pHNC9QOFA1RHVDNlA4SC91OEhxd0lDQUpDRkNQQUFBSGphTmRCQmF4TlJFQWZ3OTMrVHZKZkU3TDYxbSs2cm1HeFlFN05ZU1NOTjJHMERSakMyaXNXWVd0R2lSVUdvUlE5VnRGWVBIbklvQ05JZVJCQThlZENiZVBiaXlaTW52NEVIOWVoblNPTGJRbVl1dzU4NS9HWVlaOVh4bVAvbXYxaUR6VE1XSTRyblBlMFd2R2JraVFaa1dBdGJrZmFpdUlGQWlvS25JMjNENUVuYzdDQnUwbGRzaW9JbDBQSHEwOGluZHdhWk5Ld2pib3V5Y2pUdVdVWFhJbGpwcmZVODh0a1RuZmYvZ2wxK3cwRldEUWVlb3BJRUVYaEdTU0N2N3kvdEZhb091TEpGRXVlVVFPVUhyakZUeEU2UGh5VDROK2F6V2JaZ3BHNnJFZ3BqQzN4TTI1QSt0RkFRTWhDSFhqZkJSYld3VWhPU0pqT1poZWFuZytOaFNTbXNiOXlqd2RyS0d2aEY1OHF6MGR1aWJiZjlEKy91N25ETWRmZktibnA3ZjJPWDh6T1h2aStuQUx2UEY0OXlLa3J3MWZibExaWHJMYTZjdHp1cDVBSzRXS0lueTlVTEhPclk4RE05NzUzczAranZsTWd4eHRrcDQ0Nk5lNGJWRTNVMFFXc2hrNTU0RDIwNmdaNURGTTVCR3ZuSEEzUjl4MUNmdmdSZG5WMTRPQmg5S1NuRC9MT2ZrRjdmZWFIYk01a3A4QWU5N2JKcmhBNVJ5Ynp1emFOWGo4L1dyeFA1d3VCNGQvalRXSkRxbDFkdkJ6ZkR6VnVBTWkvOUQxbnFWOXdBZU5wallHUmdZQUJpWi8zTzAvSDhObDhabUZrWVFPQ3h3THg3Q1ByL1gyWnpwcnRBTGdjREUwZ1VBREtkQzJ3QWVOcGpZR1JnWUdiNHp3QWsvUmxVR0ppWXpSbUFJaWlBQlFBdVdnRzdBQUFDZGdBQUF3QUFKQU1JQUNzRFR3QXBBQUFBQUFCVUFMQUEvZ0FBZU5wallHUmdZR0Joc0dSZ1pnQUJSZ1kwQUFBR2tnQkRlTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTkuNjcyNjA1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My45NzQ1NTgnIHk9Jy01OS42NzI2MDUnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTkuMzc4MDgsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My45NzQ1NTgnIHk9Jy01OS42NzI2MDUnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUzLjcwNDA4MycgeT0nLTU5LjY3MjYwNSc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQzLjc0MTQ3JyB5PSctNTkuNjcyNjA1Jz5EPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU2LjkwNTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTMuMTU1NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My45NzQ1NTgnIHk9Jy01OS42NzI2MDUnPkE8L3RleHQ+CjxyZWN0IHg9Jy02My45NzQ1NTgnIHk9Jy01OC40NzcxNTInIGhlaWdodD0nLjM5ODQ4NCcgd2lkdGg9JzcuNDcxOTk1Jy8+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzA1NTQgMEg5NC4zMjI1NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NC41NzI1NCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQyLjM2NTY4LDQuNTYxODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTU5LjY3MjYwNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNjMuOTc0NTU4JyB5PSctNTkuNjcyNjA1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02MC44NjEyMTUnIHk9Jy01OS42NzI2MDUnPmY8dHNwYW4geD0nLTU2LjYyMzU3OSc+LDwvdHNwYW4+PHRzcGFuIHg9Jy01Mi44OTY4MDInPmc8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDguNzU5ODUyJyB5PSctNTkuNjcyNjA1Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002LjQwNjc4LTYuNDA5NzNMNDUuOTk5NzktNDUuOTk1NDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNSwtMC43MDcwMywwLjcwNzAzLDAuNzA3MTUsNDUuOTExMzksLTQ1LjkwNzA3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTkuNTkxNCwtMzUuMjA4OTgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTU5LjY3MjYwNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjMuOTc0NTU4JyB5PSctNTkuNjcyNjA1Jz5oPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002Ni43MDA5OS00Ny4xMDdMMTA2LjIxODYxLTcuNTk2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNzA3MTUsLTAuNzA3MDMsMC43MDcwMywtMC43MDcxNSw2Ni44Nzc3OCwtNDYuOTMwMjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTUsMC43MDcwMywtMC43MDcwMywwLjcwNzE1LDEwNi4zOTU0LC03LjQxOTgpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg5LjEyMjYsLTM2LjU2MDEzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC01OS42NzI2MDUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYzLjk3NDU1OCcgeT0nLTU5LjY3MjYwNSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjAuODYxMjE1JyB5PSctNTkuNjcyNjA1Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01Ni4xOTQ2MycgeT0nLTYyLjY3OTEyMyc+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01My40OTk4NTYnIHk9Jy01OS42NzI2MDUnPiw8dHNwYW4geD0nLTQ5Ljc3MzA3OSc+ZzwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00NS42MzYxMjknIHk9Jy02Mi42NzkxMjMnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDIuOTQxMzU0JyB5PSctNTkuNjcyNjA1Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram,node distance = 4cm]
      \node  (1) {$A$};
      \node  [right = of 1] (2) {$B \times  D$};
      \node  [between = 1 and 2] (ref) {};
      \node  [below = 2cm of ref] (3) {$\underline {A}$};
      \draw  [->,morphism] (1) to node {$(f,g)$} (2);
      \draw  [cover,morphism] (1) to node[swap] {$h$} (3);
      \draw  [>->,morphism] (3) to node[swap] {$(f',g')$} (2);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>We show that <fr:tex
display="inline"><![CDATA[f']]></fr:tex> and <fr:tex
display="inline"><![CDATA[h]]></fr:tex> form a cover-mono factorization of the cover <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[f']]></fr:tex> is an isomorphism.
    Suppose that <fr:tex
display="inline"><![CDATA[f'a = f'b]]></fr:tex>.
    We need to show that <fr:tex
display="inline"><![CDATA[a = b]]></fr:tex>.
    To this end, it suffices to show that <fr:tex
display="inline"><![CDATA[g'a = g'b]]></fr:tex> since <fr:tex
display="inline"><![CDATA[f']]></fr:tex> and <fr:tex
display="inline"><![CDATA[g']]></fr:tex> are jointly monic.
    Consider the joint pullback of <fr:tex
display="inline"><![CDATA[a]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b]]></fr:tex> along <fr:tex
display="inline"><![CDATA[h]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="746bceda00af12135868dcf0640ccba1"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzOC40NDc5NnB0JyBoZWlnaHQ9JzEyMi4wMjE1NTlwdCcgdmlld0JveD0nLTcyIC03MiA5Mi4yOTg2NCA4MS4zNDc3MDYnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0F1QTJtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNGhOY2k2Zkg4OXQ4WldCbVlRQ0J4d0x6M2lIby80eE1sNWxCWEE0R0poQUZBREpGQ3BVQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUTBBQW9BQUFBQUJNUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCtHTnRZWEFBQUFFNEFBQUFNUUFBQUR3QVd3Q2FaMng1WmdBQUFXd0FBQUZzQUFBQmpDZEJpZjFvWldGa0FBQUMyQUFBQUM4QUFBQTJLRWlCczJob1pXRUFBQU1JQUFBQUhRQUFBQ1FHTndIb2FHMTBlQUFBQXlnQUFBQU1BQUFBREFocUFFdHNiMk5oQUFBRE5BQUFBQWdBQUFBSUFGUUF4bTFoZUhBQUFBTThBQUFBR0FBQUFDQUFCZ0JNYm1GdFpRQUFBMVFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFS0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtT3NjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJsWnZnUDVETkRwSkhVL0FjS0F3RHdVZzFFZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pLNC92OFA1SVBwL3dmKzd3V3JBZ0lBa0lBSTd3QUFBSGphSlk4eFQ5dEFBSVh2M2RsM2NXTDczSnc1RitvRWhRUmJBa0VrT3prcnJYQ0UxQ3dkT2pDZ0RsWFZoU0F4ViszS2dNVE15SC9vMGdueEQvZ0RqQ0F4SW9RWW1aTGdxRzk2K3Q0YjNpT1U5QllMK2tEdlNKOWtoQlF3UmFZakZlcmNhTjZIU0pOMFlDSnRpajQ2Z29jNk1wR1BpaTl4WHFMSTJSV09lT2h4bEhwbkJhNzk2N1JtdzJ1b0FYUEVmUEhWaTVYSDRObkgzMXk0emtaNStkVDVUUThET0hKMnFpVnJDVEFHV3BNQ2NLUHA1Q3pzQmFEUzUwdGNseHpkR3h5UVNpRHBZc1lDZWsyK0VMSXBmSFE3L1A4d05jWXVscjVqdEVTWWpPblFKS0tiY0ltOGlvMk9CRStHZzhLa0prbTdUSUxuVVRhdWZwcHNIZlQyaCtVR3MrZVc5RCsyN1hNTDJCekpnTnBObDRVeFlOSDk3eGZyeXQ3NytYbm9zUWlmclBmTW9Td3VwNU9xNnYvOVkyUzJoUldLbDN2WFptME9xRFp0dnhPZXNPTHFrYVAreFZaZHhXdmxFQWhXWDdFelVtaThhRmEzeExaUUh6Qi9iUEk2ZG4xejByRDRHemZOTzhSNDJtTmdaR0JnQU9KVjMyWStqK2UzK2NyQXpNSUFBbzhGNXIxRDBQLy9NZ3N3M1FWeU9SaVlRS0lBY0hNTXZ3QjQybU5nWkdCZ1p2alBBQ0laVlA0L1lSWmdBSXFnQUdZQVRERURKUUFBQUFKMkFBQURBQUFrQXZRQUp3QUFBQUFBVkFER2VOcGpZR1JnWUdCbThHWmdZZ0FCUmdZMEFBQUlJZ0JUZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOQUFBb0FBQUFBQTZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdpT1J6RzJOdFlYQUFBQUZBQUFBQUtRQUFBRFFBREFFcVoyeDVaZ0FBQVd3QUFBQjRBQUFBZUpNU1BKRm9aV0ZrQUFBQjVBQUFBQzBBQUFBMktGT0EwV2hvWldFQUFBSVVBQUFBSGdBQUFDUUdOZi9kYUcxMGVBQUFBalFBQUFBR0FBQUFCZ093QUFCc2IyTmhBQUFDUEFBQUFBWUFBQUFHQUR3QUFHMWhlSEFBQUFKRUFBQUFGd0FBQUNBQUJBQWtibUZ0WlFBQUFsd0FBQURUQUFBQlBxODNkZUZ3YjNOMEFBQURNQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1sbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFVEF4SklLUzVMQjBwZVo3ak9MUFZIazRHQldZcjVPbENZRWFIaS8zOEdCZ0RyblE3dkFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hDQytOZi8vNGVRLzdYQWZBWUFYdVVITXdBQUFBQUJBSlFBQ1FLR0FmZ0FJZ0FBQVRjMkZ4WVhCZzhDSHdFV0J3WUhKaThCQnc0Qkl5WW5KajhCSnlZM05qY3lGd0dPeXc0S0V3RUNBeHE3cFRJRUFRRVRDd1hVeXdrSUJoRURBeEROelJBREF4RUdCQUVkeWhFQkFoTUtBeHE3cFRJSUF4TUNBZ1RVeXdvRkFoTUhEYzdPRFFjVEFnSUFBSGphWTJCa1lHQUE0bFhhSHRueC9EWmZHWmhaR0VEZ3NjQzhkOGcwc3d6akR5REZ3Y0FFNGdFQURQb0pVUUFBQUhqYVkyQmtZR0NXK3FNSkpHVVlwakJNWTJwakFJcWdBRVlBVE1vREZ3QUFBeHdBQUFDVUFBQUFBQUFBQUR3QUFIamFZMkJrWUdCZ1lsQm1BTkVNVUJJSkFBQUVDQUFwQUhqYVRZNnhhc013RUlZL1U4ZFFKNUNwSFRvVVRSbUZqZk1BaFF5WnNtWXNKSkVJRGxnT2ttUHdVdklBZmVoZUZBMDl3ZkhwdisrRWdKSWZNaDZWc1l6OVVUbUYzSjQ4WTg1YjRrS09TbHp5d1lvWHN2eFZraysrRXVjcytFNDg0NTFMNGtMeWUrS1NOYitidnJ2ZUJ1dlZyamZXdTFNWHBycmFXeC9hM3FsYVY4OWdhNTMxaDhFYWRaeVVHZHN3bmp2VjZFbzNiT2pwdUhKandPTGxaenRKVEdUSFNXYUJpWnFLZmN3Q3JjeWRlRFZhMHYvR1Znd1hyVU44elloMWxKa1NHbVV2U0QrTHIyamlycWI1QXdsUk1STUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBYTBBQW9BQUFBQUNSUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVkMDRHTnRZWEFBQUFFNEFBQUFSUUFBQUZRQThRR0paMng1WmdBQUFZQUFBQU81QUFBRnJQUXBPbjVvWldGa0FBQUZQQUFBQUM4QUFBQTJLUlNBMm1ob1pXRUFBQVZzQUFBQUh3QUFBQ1FIRGdNcGFHMTBlQUFBQll3QUFBQWdBQUFBSUJSSUFkRnNiMk5oQUFBRnJBQUFBQklBQUFBU0JmQUVjRzFoZUhBQUFBWEFBQUFBR0FBQUFDQUFDd0J2Ym1GdFpRQUFCZGdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFHcUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtNm1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcnFNQlF4TS93SDhwa2gwa2hxL2dPRkFkblBEUmNBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0J5QU5BOERCMUNPaFVHSElZa2hneUdQb2VqL2Y2Q29Ea01pa0pjTDR2Mi8rbi9oL3puL1oveWZDdFlIQndEUWRCQnhBQUFBZU5xTmxNdHY0MVFZeGUvMzNmZ1IyL0dONDFmYUpNN0RpWjBtcmRNMHJ6NHlUdE9rUlcyWmFabEJsSTU0ckVCaXdRckJwZ0t4WThzL3dJWVZDeVRZc0VCaWlaZ2RiRmtnSWNGZndHSzZteWszNlhRRUJTSnN5WXQ3cmZ1ZDN6bkhKa0RldTlvbWo4a0h4Q0ZrSUlsU0JOMyt3QU5iWkNCS1FkZ2Z4UEN6cHByNVltbTVXazNVa2pXbVVoQTd4YlFzQVpRM3lnQngrNnlYMmdCTVNVTDdUY0l2SlBIVll6eUU3OGthMlNVRVl0aHdYSVk2MkpianhqQ0NmaEVjMXhMNU5ERUlkZUF6K1p6WjdRRWQ5TU1nREVTSkwzdkFody82OExWUXlGbVFzUjBweWN5U0w4c0pSUkhCTkhKOWQ4L3dEaHVUTTBpTW1IbjBzTlp0ZDhDeU8rNkJiMVlBVnIxS1Z3N2dFOGRNRzZkM1g3TWozY2tEN29jNUVSQVZZVnpxVU1pdGVYV0ExMTk4NnlVemMwQ2g4dlRYSDdWYU5ZSDFIZi9qdFVFRVdKVHoxMHlUcTB2NERSK1JDdWx6SmpwVDVyaHpsN2o4WU1RWEFyOFNoREYwK0lZMDI0K2hGNEZmNFNqOExjNE8rb0c3Vjk5OGc5SngrZWg4L0RLQXVCWXBJckpxMGdCZzBuUzFDb1A2dnBrdFFOTWJ4cnFjOE9RVi9PTHA3dzZIZVhEK3pxay9wWEIra3E1OCswM0RUU2tKaGNsU2dtcFBIc0l3WEwvd3U2MHBZL3BGZlNuYTVnTEozYXRMdk9CNmo1K3A5VkNhcStVeGlPNEdkN3ZqZWpDTFFPS3F1enlVV1FMek9FU1cwTUdQb0Rjdy93NEY0M3Y1KzFzSFhRM1FRbE5MS1RSZkhHYlE0R200cXVISDlVMmdLZDF4RUozNjhEVExCTE9VbEJVM21UR0VUeE16ekRTQXpqRnJ3S2tlbFRzZ3RMcXBhQ2p1NU1wbG80S2pPeGxFZDkxMW9rUnJSVk5MMWIxSjIyNGpUdXFPZXZSUmtHTXFtQ2tIcHluMm5KMXpybDlkMGwvZ0IvSXVJYlVSN3hwSG9MeHNOQWhIdE4vcnpvbDBhRUhFQ1dPY0ZYQVdISDg2Yy80Rmx1Q05JVHpBK1lIZEFYelhaQlN0NXRaeFU1Y0tscEMwOHhZb1RVMFZtZWxWVkVGU1ZCRXNJeGxPcHBKN3RydHlYOG0rdXY5Q05xL09IVk4xaFJaSzJ4bk1KRVZ3Tk1PL1U5L2lqdFZzUkh0bGVMS2txMUxlRm1Rblo0UHc0TXVoNlhjb0R1Tnk0ZjFUaSttUU5ocGZyVWR1MnM0RDdFWVdQeExaMkRPcjJPaVZkeEFidS80RUJUZTd5TkczYnd5MWw3MmJRd1Z6MXUrNWovZzU5L0dFa0VYRy9hOE9QUXZndy84MFp2VVYrcnhDcFoxYkZkTFlyRUszVEI0dllvOE9GN2NvYzh2SUcxNk44Mjd5L3g0REhTci9XcGc1YzkvbFB6RCtTWERHL2lCb3dYVWw0STlRbHJQTC84emZOclN3WUUvVGszc3JZNFNhR1ZCcktaM09saHZ5Y2czWlQ1OFZtZjdYTE9QMWE1NUowUzBBRk5hTzBhK1hpbGhsNVdTU0l0aVN0U2x2OFlqK0JBVjh1a29BQUFCNDJtTmdaR0JnQUdKVDEva3I0L2x0dmpJd3N6Q0F3R09CZWU4UTlIOHI1anRNeDRGY0RnWW1rQ2dBTU9zTFZBQjQybU5nWkdCZ1p2alB3TURBd3N0Z3dDRE1mSWNCS0lJQ09BQTJ2Z0pBQUFMR0FBQUJXd0J6QW5vQVBnSUNBRU1DckFCTkJBMEFNQUxUQURBQ0h3QXdBQUFBQUFBcUFKUUE3QUZnQWdRQ2ZBTFdBQUI0Mm1OZ1pHQmc0R0RJWTJCaUFBRkdCalFBQUF3VUFIdDQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU00QUFvQUFBQUFBNWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ2lPSnpvR050WVhBQUFBRkFBQUFBS1FBQUFEUUFEQUVxWjJ4NVpnQUFBV3dBQUFCMEFBQUFkQmY4TlNSb1pXRmtBQUFCNEFBQUFDOEFBQUEyS01tQTJtaG9aV0VBQUFJUUFBQUFIZ0FBQUNRR3NnQjZhRzEwZUFBQUFqQUFBQUFHQUFBQUJnUkVBQUJzYjJOaEFBQUNPQUFBQUFZQUFBQUdBRG9BQUcxaGVIQUFBQUpBQUFBQUZ3QUFBQ0FBQkFBamJtRnRaUUFBQWxnQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBREtBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbW5zZzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU1tQmlTUVVseVdEcFM4em5DZFdmR1BFUU1Ec3lMek9hQXdJMExGLy84TURBQVhzdzl5QUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeENDK05mLy80ZVEvN1hBZkFZQVh1VUhNd0FBQUFBQkFMUC83Z0xjQWhNQUlRQUFBUWNmQVJZVkJpTWlMd0VIQmljbUp5WS9BU2NtTnpZM05oOEJQd0UyTXpJWEZnTE40SUJwQlFRVUNnZnA0ZzBLR0FJREU5L2ZFUUVDR0FzTTR1QU5CUWdVQkFFQjRPQ0FhZ1FLR1FYcDRBOEJBaGNIRTkvZkR3b1hBZ0VQNE44TUF4a0pBQUFBZU5wallHUmdZQURpSzRkZlo4ZnoyM3hsWUdaaEFJSEhBdlBlSWVqLzc1Z25NZ2tEdVJ3TVRDQlJBR1ZLRERRQWVOcGpZR1JnWUZiOFl3UWtKekpzWnRqS2RJY0JLSUlDR0FGbHl3UXdBQUFEa1FBQUFMTUFBQUFBQUFBQU9nQUFlTnBqWUdSZ1lHQmlVR0lBMFF4UUVna0FBQVB2QUNnQWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnVkdKallXQmlaZW9DMktBTWNaQWRJa1dxT3ZLN2U3Z2Vlc1BwZVQvdWdKSWZNcDZUOFJyM2MzSUtVWDljOE1KYjRxbW9SZUtTRDVaTXlQS1pPSE0yaVhOSnZoSVh2SE5KUEJYL08zSEpKNDl0MTk3dXZmVnEzeG5yM2JrTjQvcGdmV2c2cDFhNmlucG5uZlhIM2hwMUdwVVptakJjVzFYclN0ZHM2V2k1Y2FmSDRsSHN4VEdSSFdmSkFpTnJEdEVKTkpJNmFhM1FWUC95bmVRdWRvN3hrNUhPU1JJbE5NaFZrSDJWdHFLT2w1cjZGL041TUU4QUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNTUFBb0FBQUFBQTNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVnQUFBQmdpQlIzZjJOdFlYQUFBQUU4QUFBQUtnQUFBRFFBREFNdFoyeDVaZ0FBQVdnQUFBQk1BQUFBVElCRXRWbG9aV0ZrQUFBQnRBQUFBQzBBQUFBMko3ZUJ0V2hvWldFQUFBSGtBQUFBSFFBQUFDUUdBUU1pYUcxMGVBQUFBZ1FBQUFBSUFBQUFDQVdBQVI1c2IyTmhBQUFDREFBQUFBWUFBQUFHQUNZQUFHMWhlSEFBQUFJVUFBQUFGZ0FBQUNBQUJRQVVibUZ0WlFBQUFpd0FBQUROQUFBQk9JTGhLcWx3YjNOMEFBQUMvQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Pc0E0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FNRkJpU1FVbHlXenNER2RJdnBGalBEZnlDZm1ZRVJKTXlJVVBFZktBd0FGVndPaDNqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnVWdEUUxFQUw1VExmKy80ZVFmOVhCOGd3QVgxQUhPQUFBQUFJQkhnSXFBZUVDM0FBS0FCSUFBQUVPQVFjdUFTYytBVElXQnhZM0pnY21CeFlCNFFFMkt5ZzRBUUUxVmpaZ1JRTURSa1VEQXdLRUpqTUJBVEluSXpVemFBSkZSUUlDUmtVQUFIamFZMkJrWUdBQVlnMjc2OVh4L0RaZkdaaFpHRURnc2NDOGQ4ZzBVd1BUSFNERndjQUU0Z0VBR0JjSnlRQUFBSGphWTJCa1lHQm0rTThBSWhubEdPVVpIeklBUlZBQUV3QTFIQUlyQUFBQUFvQUFBQU1BQVI0QUFBQUFBQ1lBQUhqYVkyQmtZR0JnWWhBR1loQmdaRUFEQUFLUEFCb0FBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02MS44MzIxMSwtNTkuNjcyNjA1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjgzMjExLC01OS42NzI2MDUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTYxLjgzMjExJyB5PSctNjEuNDM0MDUxJz7LmjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuODMyMTEnIHk9Jy01OS42NzI2MDUnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuOTc5MTYsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS44MzIxMSwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02MS44MzIxMScgeT0nLTU5LjY3MjYwNSc+RTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00NC44OTAzNCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDQuNzY1MzQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNy4xOTIxNCwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS44MzIxMSwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02MS44MzIxMScgeT0nLTU5LjY3MjYwNSc+cjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0My4yOTQ0MiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuODMyMTEsLTU5LjY3MjYwNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuODMyMTEnIHk9Jy01OS42NzI2MDUnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUyLjE0NjI0NScgeT0nLTU5LjY3MjYwNSc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQyLjE4MzYzMScgeT0nLTU5LjY3MjYwNSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0My4yOTQ0MiwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjgzMjExLC01OS42NzI2MDUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjgzMjExJyB5PSctNTkuNjcyNjA1Jz5BPC90ZXh0Pgo8cmVjdCB4PSctNjEuODMyMTEnIHk9Jy01OC40NzcxNTInIGhlaWdodD0nLjM5ODQ4NCcgd2lkdGg9JzcuNDcxOTk1Jy8+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUyLjE0NjI0OCcgeT0nLTU5LjY3MjYwNSc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQyLjE4MzYzNScgeT0nLTU5LjY3MjYwNSc+QTwvdGV4dD4KPHJlY3QgeD0nLTQyLjE4MzYzNScgeT0nLTU4LjQ3NzE1MicgaGVpZ2h0PScuMzk4NDg0JyB3aWR0aD0nNy40NzE5OTUnLz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NCAwSDM4LjIzODg4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM4LjQ4ODg4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTIuNTA3MSw0LjU2MTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuODMyMTEsLTU5LjY3MjYwNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNjEuODMyMTEnIHk9Jy01OS42NzI2MDUnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTU4LjcxODc2NycgeT0nLTU5LjY3MjYwNSc+bSw8dHNwYW4geD0nLTQ3LjkyMjM4NCc+bjwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00Mi45OTc1MjEnIHk9Jy01OS42NzI2MDUnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNy4yNDMwNFYtNDQuODkwMzQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00NC43NjUzNCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lam9pbj0nbWl0ZXInPgogPHBhdGggZD0nTTMuMzk3MTMgMEwuMjUgMS44NzQ5NFYwVi0xLjg3NDk0WicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS43MDI3NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjgzMjExLC01OS42NzI2MDUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYxLjgzMjExJyB5PSctNTkuNjcyNjA1Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01NS4zNTM2NzEnIHk9Jy01OS42NzI2MDUnPsOXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00Ny4zMTI4MScgeT0nLTU5LjY3MjYwNSc+aDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC41MzQ3LTU2LjkwNTVIMzguMjM4ODgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguNDg4ODgsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE0LjcxNDI1LC02NC45NjczMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjgzMjExLC01OS42NzI2MDUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTYxLjgzMjExJyB5PSctNTkuNjcyNjA1Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01OC43MTg3NjcnIHk9Jy01OS42NzI2MDUnPmEsPHRzcGFuIHg9Jy01MC42NzA1NDYnPmI8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDcuMTY3MDA4JyB5PSctNTkuNjcyNjA1Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = \AA ,
      nw/style = {pullback},
      ne = A \times  A,
      sw = E,
      se = \underline {A} \times  \underline {A},
      north = {(m,n)},
      west = r,
      west/style = {cover},
      south = {(a,b)},
      east = h \times  h,
      east/style = {cover},
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Note that <fr:tex
display="inline"><![CDATA[h \times  h]]></fr:tex> is a cover by <fr:ref
addr="ct-000W"
href="ct-000W.xml"
taxon="Lemma" />, and since covers are stable under pullback in a regular category, <fr:tex
display="inline"><![CDATA[r]]></fr:tex> is also a cover.
    Now we have that</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       fm &= f'hm\\          &= f'ar && \text {by hypothesis $f'a = f'b$}\\          &= f'br\\          &= f'hn\\          &= fn     \end {align*}   ]]></fr:tex>
  <fr:p>Thus, <fr:tex
display="inline"><![CDATA[m]]></fr:tex> and <fr:tex
display="inline"><![CDATA[n]]></fr:tex> may be expressed in terms of the kernel pair of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="10397cc81fd20b29f515a14cf895a4bf"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE3Ni43ODc1NTdwdCcgaGVpZ2h0PScxNzcuMjUzMDc2cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTE3Ljg1ODM3MSAxMTguMTY4NzE3Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTU1BQW9BQUFBQUEzQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFZ0FBQUJnaUJSM2YyTnRZWEFBQUFFOEFBQUFLZ0FBQURRQURBTXRaMng1WmdBQUFXZ0FBQUJNQUFBQVRJQkV0VmxvWldGa0FBQUJ0QUFBQUMwQUFBQTJKN2VCcTJob1pXRUFBQUhrQUFBQUhRQUFBQ1FHQVFNaWFHMTBlQUFBQWdRQUFBQUlBQUFBQ0FXQUFSNXNiMk5oQUFBQ0RBQUFBQVlBQUFBR0FDWUFBRzFoZUhBQUFBSVVBQUFBRmdBQUFDQUFCUUFVYm1GdFpRQUFBaXdBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFDL0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtT3NBNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTUZCaVNRVWx5V3pzREdkSXZwRmpQRGZ5Q2ZtWUVSSk15SVVQRWZLQXdBRlZ3T2gzamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ1VnRFFMRUFMNVRMZisvNGVRZjlYQjhnd0FYMUFIT0FBQUFBSUJIZ0lxQWVFQzNBQUtBQklBQUFFT0FRY3VBU2MrQVRJV0J4WTNKZ2NtQnhZQjRRRTJLeWc0QVFFMVZqWmdSUU1EUmtVREF3S0VKak1CQVRJbkl6VXphQUpGUlFJQ1JrVUFBSGphWTJCa1lHQUFZZzI3Ni8zeC9EWmZHWmhaR0VEZ3NjQzhsOGcwVXdQVEhTREZ3Y0FFNGdFQUdvMEowd0FBQUhqYVkyQmtZR0JtK004QUlobmxHT1VaSHpJQVJWQUFFd0ExSEFJckFBQUFBb0FBQUFNQUFSNEFBQUFBQUNZQUFIamFZMkJrWUdCZ1loQUdZaEJnWkVBREFBS1BBQm9BQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQWJjQUFvQUFBQUFDUFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZRjArMk50WVhBQUFBRTRBQUFBUUFBQUFFd0JCZ0ZGWjJ4NVpnQUFBWGdBQUFQdUFBQUZuRU1UTmlGb1pXRmtBQUFGYUFBQUFERUFBQUEyS1JPQXoyaG9aV0VBQUFXY0FBQUFJQUFBQUNRRzNnTGxhRzEwZUFBQUJid0FBQUFjQUFBQUhCSjdBVEZzYjJOaEFBQUYyQUFBQUJBQUFBQVFCRXdGMUcxaGVIQUFBQVhvQUFBQUdBQUFBQ0FBQ2dCdmJtRnRaUUFBQmdBQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRzBBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVdzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWXlobVp2Z1A1RE5EcEpIVS9BY0tBd0RxWkExc2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdDeUFOQmNEQjFDT2lTR05JWStoa0tINC8zK2dXQnBETGtNQmlQMS85ditwLzZmOG53eldBUVVBWVI0T1FuamFmWlRMYitORUdNRDl6VGgyYkNjZVAyZVNOSEVlZHV5a2FaMW5uVzJiSm1tekQyM2JWVmtXdGwwa1FBS0J4R01QSFBhRVZvSWpGMDRjT0hDQkF5Y2t6a2djZDdseFFIQmJPUEJIc0RjMlROTHRVbFhhMnBZbHo0eEgzKy8zemZjSklCek0yK2hEOUpzd0ZRVEFCQ1JaQjdrV1JtUG9VMFlsbVpaaERCUHNTMkhDK21NWTh2RWVaVHI0WVJRbXc3QU5PaUxRVDZnVXdiZGJobWdVbE4xdVl3c2djRU1NcEV3SUNhcTRGSk5ERDlua05uRjF1dWMzUndBKzVmT0dSNGhsZVdxNjhQWmlHcjU2OW1qZm5BNmNHUTU5cjRJQ0tkSVVCT0tCKy9VL3g3Z213L0c5bFNpc0IvOVBRVDVjLzFLc3BVSGdGd2lkK1ZQOEovd2kzQmVFK29USEhVWTZKa2pIWVRUQnljYUFmd0xIYTBNTXlYQ01LT004eWZKTm1RZXlkRXJ2U3F5WERKUCtjb2pmWE1aZ2d2akk4OTlQTnh3TTRlY1d3Y2hwYlI2MGRMbmtwQlMzNklEYXltZ1NzYjJhbHBKVlRRTEhWS0xaVlprZFQ1dXZxcm1UYXpkeVJRMlFnMnhOVjNHcHNtVWhTNUdBWmt4L3A3RUpPRnQzRVhLYm82Tzhyc2xGTjVXbUt5Nms3dnd3c3YwK1JxTnh0ZlRnRllmb1lKaXJQM1ppWnJoRmdHbnM4QzBSMmZYc0FLMXVWTGNSV3AzNk01Uml1VUUySGtuYks5V3FXVU9USFFzaDFtRTBGdHZOakZaNWY5WjF1d2pOR203Qk85czBaYi93aUw3akhvOEU0VEp4bHduakMwK1ZQVS9BdzVlS1didUxGMEl5V1JVWEs5c1dNbFVKbUdiNjQ4WVZ3QmxDS2Jvb2VmY3k5dmpteTVtRHZWblh1aUJTRU5COFByK0N0dUN4TUJKdUNRS3poeGVBejA3SkFubEpHRU8wWUhkNWNmU282MGgrSkV2UklPRWFiRmxpeTdWajJJaDVrVWkzSHVCejFKUmtJaSsvUytoaDU4cGJHTzhhMXNIZHVLZll0aXdDcWFsR1Z2NzRSTU9tVmpJZkoyRFRmdU9hblN0Qnk4dnZQNFRmeStlSWpWbVJWZ0M4Rm1zanVIUHZneVBIbkdIVU5HZXZGM1ZwVVRPcXJvZ2ltRVFHQTU3OGxha0hLUmhGblUvOVFSdENubU1rak9lYlNJTkh3cG93T2EzOGN6RGhHQmhOSm9oTDRLakxUQTQ5V0JhSzYrQmhFdkhpWHpZS0R4WmFoa2o1UW9RRmdLbkw5ejhpWUNqcmhYUStZMTVkbXgyRE9DSDIvaHZkRGRscUs5bHYrdUM0ZlhiZHQyc0FhenQ3WlFYRDkvOCtNZVFYTWFPU0RHQTMzK2tiSVlJM0Q5KzdiVnZYTWVxYWhTYWdiUHJaSDc5cTlicUlHdHYrWit0REhseWd5YWRuOXViOEtmek5jempqSHpGdlljdVQ2WlFYV0x5Um5SM01SZnRpanNRRDc5TkZacVA0N0FtWGxNbWl0OFVvZ1orc0hVdGZwMlp1cytHMXpUVVJGYk9zODhuaENlOWNMQkRMZWZ0R1ZSMVZLZ3p3MU9uSFZvWUJ5cWxtNDkzdWF4alZYUW9NUGk5a1FjNXFnVlhYMDZLdEZNYWxIclZpY1NPdStTRXJwM0kycEEybm80Y3JTTkYxTlNqbDJnWnBwYURacTFPdWNrWDRENCtpdGlVQUFIamFZMkJrWUdBQTRubVNLN2JHODl0OFpXQm1ZUUNCeHdMelhzTG8vLy8vNnpQZllib0k1SEl3TUlGRUFXRmREWmtBQUFCNDJtTmdaR0JnWnZqUHdNREF3dnYvLy84THpIY1lnQ0lvZ0IwQWhxa0Z5UUxHQUFBQ09nQkxCQTBBTUFMVEFEQUNXdi8vQWhnQVBnSW9BRWtBQUFBQUFHWUJDZ0dDQWZ3Q1pBTE9lTnBqWUdSZ1lHQm55R05nWWdBQlJnWTBBQUFMK1FCNmVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTMEFBb0FBQUFBQlZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwL21OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDV1oyeDVaZ0FBQVdRQUFBSHFBQUFDSFBUL0V6dG9aV0ZrQUFBRFVBQUFBQzhBQUFBMktFT0JsV2hvWldFQUFBT0FBQUFBSGdBQUFDUUdNZ0hkYUcxMGVBQUFBNkFBQUFBUUFBQUFFQXRaQUlKc2IyTmhBQUFEc0FBQUFBb0FBQUFLQVdJQXNHMWhlSEFBQUFPOEFBQUFHQUFBQUNBQUNBQTZibUZ0WlFBQUE5UUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVxQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c1k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQm1admdQNURORHBKSFUvQWNLQXdEekFBMUtlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2ak8vLzhEU2NmLy8vOGZBUE1aQUZLNUJwOTQyalhRejJvVFVSUUc4UHZkazduVEpKT1o2S1F6bGFaVDB2eVp0cEtrZElhWnRvc29qWWsxeGJRMlVJSUVnb0lXQkFVMVJoY3Vzb2dMUVZkQ1FWeTRjZWNEdUhIbHFnL2cxb1c0RWg5QmtuaEg2TG1idzhkZC9MN0RPQ3ZNWnZ3bi84R3FiSk94RUVHNGFkbG14dklDUzFTaHVpWFhEMndyQ0t2SXFTSmoyWUd0UStaUjdOVVFldlFGOTBRbUpWQ3p5dlBRbE1Gb1RrRXFhZm9VVjZlemRpcHJwZ2dwNWFTclFZdXYxTjcveVEzNWNScHhZekt5REZwU1FRUStaNmlBWnQ5dmpET0ZOTGloaXloT0dBTDVNeHd4T2NRdXp5WWsrRmZtc0hXMkphV21uM2VGdE9VY3pPdFFIZGpDZ0ZCejRyL1hqSEJCeWMyWGhFcm5POGtQM3FlM2krNlNZYURidTB1anpuNEgvSHI2NXJQcHU2eXU3emdmVC9zRGprcDl2R3dxajk3MGhweHY3SDFyeGdEOWtHOWY0SlJWd1cvdHRFNk1SSHQ3ZjFldnhhSUdNTkdnSjgzQ05RN2owdVF6UFc4WEQybjY2NkpJTUFibXpYNVRrbitQekNBZGVYblJLL0JMcmpSSFlOdEJLTThiQ1pmaHlBSXlyOEFOd3VoWnRtV0hzZzRscnBKSXhCVndIQjgwWG0wMEY0V0YyTXNicS8zQUw0dFlYRldvM0Z4N1hIL3hnYWpqdDU2T08ydXJZaytIeHMrbWYzVnBWbzNTN1FkQWZhdmJYK2lWaDNjNFZ0WXJ2WVVrd0xXSHUwVVBkRHA2UFdqNVJ4UXJGUFVEblJOai93QWQwbHIrQUFCNDJtTmdaR0JnQUdJTy9XYkhlSDZicnd6TUxBd2c4RmhnM2tzRS9mOGxNemZUWFNDWGc0RUpKQW9BRGw4S2R3QjQybU5nWkdCZ1p2alBBQ1E1R0ZUK1gyRG1aZ0NLb0FBV0FFcjNBeFVBQUFKMkFBQURBQUFrQXdnQUt3TGJBRE1BQUFBQUFGUUFzQUVPQUFCNDJtTmdaR0JnWUdHd1pHQm1BQUZHQmpRQUFBYVNBRU40MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIxLjc1NTQzOCwtMjIuMDc2Njk3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuOTMxMjQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjc1NTQzOCwtMjIuMDc2Njk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0yMS43NTU0MzgnIHk9Jy0yMi4wNzY2OTcnPkM8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS43NTU0MzgsLTIyLjA3NjY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMjEuNzU1NDM4JyB5PSctMjIuMDc2Njk3Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTcuMzg2MjMsLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNzU1NDM4LC0yMi4wNzY2OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTIxLjc1NTQzOCcgeT0nLTIyLjA3NjY5Nyc+cDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1My4xNTU1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS43NTU0MzgsLTIyLjA3NjY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMjEuNzU1NDM4JyB5PSctMjIuMDc2Njk3Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjg2MjEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS43NTU0MzgsLTIyLjA3NjY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMjEuNzU1NDM4JyB5PSctMjIuMDc2Njk3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjQ4Njc5IDBINDguMDk5OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMzQ5OTYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNi41ODUyLDQuMTcyOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjc1NTQzOCwtMjIuMDc2Njk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0yMS43NTU0MzgnIHk9Jy0yMi4wNzY2OTcnPnE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNzU1NDM4LC0yMi4wNzY2OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTIxLjc1NTQzOCcgeT0nLTIyLjA3NjY5Nyc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NC01Ni45MDU1SDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNS45NjQsLTY0LjU3ODQxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNzU1NDM4LC0yMi4wNzY2OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTIxLjc1NTQzOCcgeT0nLTIyLjA3NjY5Nyc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDMuOTg4MywzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjEuNzU1NDM4LC0yMi4wNzY2OTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIxLjc1NTQzOCcgeT0nLTIzLjgzODE0Myc+y5o8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIxLjc1NTQzOCcgeT0nLTIyLjA3NjY5Nyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTQxLjA4MTE4IDMzLjgyODU3Qy00Ni40NzQ0OS0xLjEzNDM1LTM1Ljg4NzYtMjguMzg1My04LjY5NTM2LTUwLjIyNDUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43Nzk2NSwtMC42MjYxNiwwLjYyNjE2LDAuNzc5NjUsLTguNTAwNDYsLTUwLjM4MTA0KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDcuNDE5MSwtMTguOTg0MTgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS43NTU0MzgsLTIyLjA3NjY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMjEuNzU1NDM4JyB5PSctMjIuMDc2Njk3Jz5tPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tMzEuOTMyNzUgNDEuMzMwNDdDMi40NjM1OCA0Ni4yNTcgMjkuMTIwNzQgMzUuNTY3ODMgNTAuMjc2NjQgOC42MzYyMicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjYxNzcsLTAuNzg2MzYsMC43ODYzNiwwLjYxNzcsNTAuNDMxMDYsOC40Mzk2NCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTcuNDM5NTgsMzkuNjkyOCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIxLjc1NTQzOCwtMjIuMDc2Njk3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0yMS43NTU0MzgnIHk9Jy0yMi4wNzY2OTcnPm48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00tMzMuODI4ODcgMzMuODI4NTdMLTguNTkyOTQgOC41OTY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE0LC0wLjcwNzAzLDAuNzA3MDMsMC43MDcxNCwtOC40MTYxNSw4LjQxOTgpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIGZpbGw9JyNmZmYnPgo8ZyBmaWxsPScjZmZmJz4KPHBhdGggZD0nTS0yNS45MjEzIDE2LjI4NTgxSC0xNi4xNDY5OFYyNS4yOTk3SC0yNS45MjEzWicgc3Ryb2tlPSdub25lJy8+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIyLjkyMTMsMTkuMjg1ODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMS43NTU0MzgsLTIyLjA3NjY5NylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMjEuNzU1NDM4JyB5PSctMjIuMDc2Njk3Jz5zPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw = C,
        nw/style = {pullback},
        ne = A,
        sw = A,
        se = B,
        north = q,
        west = p,
        south = f,
        east = f,
      }
      \node  [above left = of nw] (aa) {$\AA $};
      \draw  [->,morphism,bend right] (aa) to node[swap] {$m$} (sw);
      \draw  [->,morphism,bend left] (aa) to node {$n$} (ne);
      \draw  [->,morphism,exists] (aa) to node[desc] {$s$} (nw);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>To show <fr:tex
display="inline"><![CDATA[g'a = g'b]]></fr:tex>, it suffices to show <fr:tex
display="inline"><![CDATA[g'ar = g'br]]></fr:tex> since <fr:tex
display="inline"><![CDATA[r]]></fr:tex> is epic.</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       g'ar &= g'hm\\            &= gm\\            &= gps && \text {by hypothesis $gp = gq$}\\            &= gqs\\            &= gn\\            &= g'hn\\            &= g'br     \end {align*}   ]]></fr:tex>
  <fr:p>Finally, <fr:tex
display="inline"><![CDATA[g]]></fr:tex> can be factored as follows:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="a89156e69332696fb4b58cdd48938010"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMwMS43Nzc3MzNwdCcgaGVpZ2h0PScxNTYuNzM3MDUxcHQnIHZpZXdCb3g9Jy03MiAtNzIgMjAxLjE4NTE1NiAxMDQuNDkxMzY3Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNY0FBb0FBQUFBQTRRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVXgxRzJOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDRVoyeDVaZ0FBQVdRQUFBQmtBQUFBWkRGdUFySm9aV0ZrQUFBQnlBQUFBQzBBQUFBMktJbUJibWhvWldFQUFBSDRBQUFBSGdBQUFDUUZ5d0xXYUcxMGVBQUFBaGdBQUFBSUFBQUFDQVlLQUpKc2IyTmhBQUFDSUFBQUFBWUFBQUFHQURJQUFHMWhlSEFBQUFJb0FBQUFGd0FBQUNBQUJBQWdibUZ0WlFBQUFrQUFBQURLQUFBQk11c0lrZVp3YjNOMEFBQUREQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1abVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvYU1oZ3lNL3dIOHBraDBraHEvZ09GQWFOM0RGZ0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aUcvLzlEeVA4WHdId0dBRkZIQm8wQUFBQUFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FlTnBqWUdSZ1lBRGlINmNyYjhiejIzeGxZR1poQUlISEF2TWVJOVBNUVV5cmdSUUhBeE9JQndCUGhRcXlBQUFBZU5wallHUmdZR2I0endBa2d4Z21NVFF5bVRNQVJWQUFFd0JDM0FLb0FBQURVZ0FBQXJnQWtnQUFBQUFBTWdBQWVOcGpZR1JnWUdCaWtHY0EwUXhRRWdrQUFBT2tBQ1VBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktuNXViZzVPcnc5dXNDZEtocWFTMTZDTCtkRzlEOEFZTzN6M24zQUFaTHhLR1NaZ0hIU2FWTjQ4ODVvZEY1SW40cThnWnY2d1prYVF6Y1Zic0lxZE0rWTg4WmtrWmVTTCtJM0xHSCs5OVU5L3VuZlhxMkJqcjNhWDIyNVAxYmRVNHRkSDVzQjZzcy83Y1dhUEtweko5MWZiWFdoVTYxd1Y3R21wdTNPbXdlQlJIY1V4Z3gwVXl6NVpUMkZzcXlaeDBObWp5YjNxUTFJWEdPZnhpcEZIeUZEWDBjdE9LWHFXcktNS2RwdmdBVlRJdVF3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTklBQW9BQUFBQUE2Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFMEFBQUJncWw1aThXTnRZWEFBQUFGRUFBQUFNd0FBQUR5ZVgyUlJaMng1WmdBQUFYZ0FBQUI0QUFBQWVJWXFoTEZvWldGa0FBQUI4QUFBQUN3QUFBQTJLWXlBLzJob1pXRUFBQUljQUFBQUhnQUFBQ1FIT3dDU2FHMTBlQUFBQWp3QUFBQU1BQUFBREFuSUFRUnNiMk5oQUFBQ1NBQUFBQWdBQUFBSUFCb0FQRzFoZUhBQUFBSlFBQUFBRndBQUFDQUFCUUFTYm1GdFpRQUFBbWdBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFET0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtcm1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFBNE1EakoxU1hKYk93S1lrOU1DQVdldVBKUU1Ec3hiemNhQXdJMEwxLy84TURBQVRDUTlRQUFBQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWm1SZ1VoSjZZUEQvUHdNRGhMNzdYdjRTV0JVUUFBQ203Z210QUFBQkFLVUE0Z093QVI0QUN3QUFKU0VHSmpRMkZ5RTJGaFFHQTRYOVN3MGVIZzBDdFEwZUh1TUJDaWdLQVFFS0tBb0FBQUFBQVFCZkFDY0Jld0k4QUJBQUFBRURCaU1uSmljM0V6NEJOeklXRndZSEFYSFVCZ3dXRXdNRW5nTVpIaGttQVFFRUFkeitYQkVIQncwUUFic09JQUVnSEF3TUFIamFZMkJrWUdBQTR1eThKWUx4L0RaZkdaaFpHRURnc2NDOHg4ZzBTeWlURFpEaVlHQUM4UUFIRWdqQWVOcGpZR1JnWU5iNlk4bkF3QkxLRUE5a2IyQUFpcUFBWmdCSVdBTFRBQUFFVlFBQUE3QUFwUUhEQUY4QUFBQUFBQm9BUEhqYVkyQmtZR0JnWmhCa0FORU1VQklKQUFBQ1lRQVlBSGphVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9KU1ZoWUdKbGFrTFlJTXl4RUYyaUJTcDZzanY3dUY2NkEybjUvMjRBMHAreUhoT3htdmN6OGtwUlAxeHdRdHZpYWVpRm9sTFBsZ3lJY3RuNHN6WkpNNGwrVXBjOE00bDhWVDg3OFFsbnp5MlhYdTc5OWFyZldlc2QrYzJqT3VEOWFIcG5GcnBLdXFkZGRZZmUydlVhVlJtYU1Kd2JWV3RLMTJ6cGFQbHhwMGVpMGV4RjhkRWRwd2xDNHlzT1VRbjBFanFwTFZDVS8zTGQ1SzcyRG5HVDBZNkowbVUwQ0JYUWZaVjJvbzZYbXJxWCsvcE1FY0FBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBV2tBQW9BQUFBQUJxZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFlGMHEyTnRZWEFBQUFFNEFBQUFOUUFBQUR3QWpRQzdaMng1WmdBQUFYQUFBQUxKQUFBRGJPRUxEY2xvWldGa0FBQUVQQUFBQURFQUFBQTJKLzJBd1dob1pXRUFBQVJ3QUFBQUlBQUFBQ1FGYkFHY2FHMTBlQUFBQkpBQUFBQVVBQUFBRkF1dEFMUnNiMk5oQUFBRXBBQUFBQXdBQUFBTUFiUUNpbTFoZUhBQUFBU3dBQUFBR0FBQUFDQUFDQUJQYm1GdFpRQUFCTWdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGbUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtQ21XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcW1NUlF5TS93SDhwa2gwa2hxL2dPRkFjM1VEUndBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpNVS92OFA1S2N4RlB6Ly8zLzIvOGxnVlVBQUFKb1RDVUlBQUFCNDJsMlN6Vy9UU0JqRy9jeTRuanB1UEhZY2owazJjZE00c1ZPUnhtMmQybXpwSmswRGxmckJseENVSWo0a0pBN3NoNFNFVmxydENva3JGdzZJQXdjdVhQZ2Z1SmNqQndRM3hKK3hoejFzdzdoRmdCaExjNWozT1R5LzkyY0Z5czRrSnIrU2Q4cTZvb0J5YU13RWE0YlJBSW53aE1iRUxBWVkwa0FMVXk4WklKUHZ5OEl6RVlSUm1HWmhESk53SktuUUlyeGN0VlNycW8rV09xdEF5dzBwK0N6bnZEVkg2ejIrNnhPSFgrS3VLVGFDK1RVZ0VISnUrWnlYU241aHVubzdIK1BaNGNHMnZkNHZqMmtZK0EzUzBpSkRKMUIzM09mLzd0RW13OTcrVDFIWWJuMGJvUkl1UEZHYjAxRGtJVXAzc2tEYU9GQjZ5amlua1NUYUVZbHNYTmFZSnhLUlNvQ2hoT3doU3JQODgrRkpLaG1nUTZTUmhOSll2Z0xoTGVkUk1uZGZmL0JYZkV1VmZXMEJzMVN6NThwclFVMHdMOXNhN1JNNjR2YldmbWVsU0t1bG9vdW5NVVhaN1ZmSERkZXlFVWIrUm0yRzRlL0RVWHlkRXJkYm4zTWN3eTlNRVJpMXltTGpScUppNytMZDh3NC9ROUVTbG9CbEgvNzNtaHZ0UUVWbkpSeXRYOGpRYnZCaXpqYVpURTZSVmJ4UjFwUnppdUk1V1QrTUpKK0pHRDNrVmJOVWVNZDNUbkJFcUVtZHJoUzRMTnl5RmtSTWkvcXA1SEtZNWgxbEIxanBTWkhhdVQ4cGQveW1NY1VLaGdiQlp5Sy9NdUppZC9IVUxVcEhWbW5uYW05WmR4eW1namNMVnBIOWZzMmd0bEczMzZSd1JOSTU2NXlvNDZSZjJYNkk5N051RFZqdmxRMFFZbzFyb2dINEo3Mlk0UEwrdlF0bGUwekp2RDIrVWpPMTNHdkIxRlVWTm1ldzhQSFRUTHMxaGJWbzhaK2dIeU04OGptWS9Fd002Yk9yREkvL3p1OWd3Z0U4a1E2SlhNSVBNbVdBWmw5Y3lxbVBmQzBaMFIrcnlBRnNrLzN4RzRlbEwxU25LelAybWU1NEQrcVFPOXZYbDFaWUtkYUxMeElwTWZFMkE2Y0pkSC9abU5VcFh2My8wV0pmTzVNNkE1ejVPNGtWRXR6Y3ZYdkpLVzFTc21SWDUwR0swNGNmM2hydHRrbzZwNE5IQzVrczF6S1l4UGtNdy9wM2FBQUFBSGphWTJCa1lHQUE0cW8vNG5maitXMitNakN6TUlEQVk0RjVqMkgwLy8vL2RabU9NVjBFY2prWW1FQ2lBRzQ2RGNvQUFBQjQybU5nWkdCZ1p2alB3TURBZE96Ly8vOFhtTElZZ0NJb2dCVUFqL29HQ3dMR0FBQUNPZ0JMQWpvQUxBSmEvLzhDR0FBK0FBQUFBQUJtQU5RQlRnRzJlTnBqWUdSZ1lHQmw4R05nWWdBQlJnWTBBQUFJb3dCWWVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVa0FBb0FBQUFBQmZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxRjJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDWFoyeDVaZ0FBQVdRQUFBSllBQUFDdUpIamNjbG9aV0ZrQUFBRHZBQUFBQzhBQUFBMktHK0JpV2hvWldFQUFBUHNBQUFBSGdBQUFDUUdYZ0lsYUcxMGVBQUFCQXdBQUFBVUFBQUFGQTZvQUt0c2IyTmhBQUFFSUFBQUFBd0FBQUFNQVdJQ0RHMWhlSEFBQUFRc0FBQUFHQUFBQUNBQUNRQTZibUZ0WlFBQUJFUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZHQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmhadmdQNURORHBKSFUvQWNLQXdENzFRMWplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2Z3UvLzhEU2NmLy8vOGZBUE1aQUZMS0JxQjQyalhSdjA4VFlSekg4ZWZ6Zk52bmFHbnZLbGZ1YXFEWGxKWWVZRm9JdmR3QmljVlFxUWl4L0toQmdvMUVFeVNTaUQ5QVpHRG9nREVhR0l3SmlYRncwTTA0dXpnNU1UbTVPcWlUOFU4d2JYMk9oT2Rabm54encvdjdPc1padHQzbVAva1BOc3hHR2ZQZ2VxT0dxY2VOb211SVlTaDJ6blpjMDNDOVlhUVZFVGRNMTFRaDUvNjRXSUpYcE05WUYvR29RTW5JZHlNUzNHbDBCQkh0MUIwS0thMTJOZHFyUnduUjRNWktCSkZRWCtuTjMvUXVYNDRocERVYmhrWkpCVVRnSFpvQ1JNeTcwd2Z4YkF4Y1U0VS9EbXNDbVJNc01YbUlYV2czU2ZBdnpHSkRiRXlXNms3R0ZySXRiYUZiaFdMQkZCcUVraGFudmJvZjUrYnNURTRvZFBZbStVSHh3MUdQbmRRMHJOVHZVS00yVndPL0VydjJwUFc2VjFVbnJIZkhhenNjaGZKQlNnOXVIZFozT1IrWitWb0pBT29DSHovSHFWY0JYNXlZM2REQzFmRzVLYlVVOERlQWptbDZYTWxlNXRET056L1MwMnIvQXJWK2Q0a3dZMkRGOWgvcTVOLzlacENLakJTZGhKT3paYk1mYkZyd0pLOWZtSUlsRjVEekFtelg4NjloR3FZbjE2SHdKUkxoVUJBY3kvUFR6MFlxUGNKQVlQL3F3SnJyNUVVZ3BBUXBYeGw4Vk41N1MxUnpacmNQYW9NRFlrWkZoSiswL3FteVdkRnlxNXRBZVd4bExWSFA3OTdtNkJzcTFCT2RBSS9jbitvdmdvNGJMM1ptblNVS1pQdlZlWldUTk9kc1VKcDcwanpCOHI2NGV3WnVDc1cvWjlhbnJxYS93aVJjdXdCRnFyOC9RdG1LU2VidGZkRDgwTmhtby9VcHFVbmlYNGMrNTh0YmUrWkVvcU1ML0Y1MUs2VkwzUmhSVXY3MlZ3K2VQN3lZdjA1a0NRbkx5ODF2MGhHQmhkVGl6ZlFOZTMwVjBHVGFmL1FCZDFkNDJtTmdaR0JnQU9Malluc3I0L2x0dmpJd3N6Q0F3R09CZVk4UjlQK1h6T1pNZDRGY0RnWW1rQ2dBUU5RTHJ3QjQybU5nWkdCZ1p2alBBQ1Q5R1ZUK1gyQTJad0NLb0FCV0FGVXJBNGtBQUFKMkFBQURBQUFrQXdnQUt3TGJBRE1EVHdBcEFBQUFBQUJVQUxBQkRnRmNlTnBqWUdSZ1lHQmxzR1JnWmdBQlJnWTBBQUFHclFCRWVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYzLjc5Mzk5MSwtNTguNjg0NzE3KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuOTMxMjQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc5Mzk5MSwtNTguNjg0NzE3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02My43OTM5OTEnIHk9Jy01OC42ODQ3MTcnPkM8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODEuNjA4MjYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc5Mzk5MSwtNTguNjg0NzE3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02My43OTM5OTEnIHk9Jy01OC42ODQ3MTcnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTY2LjY3MzEzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43OTM5OTEsLTU4LjY4NDcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuNzkzOTkxJyB5PSctNTguNjg0NzE3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE2Ni40MzgwNSwtODcuODU4MjYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43OTM5OTEsLTU4LjY4NDcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuNzkzOTkxJyB5PSctNTguNjg0NzE3Jz5EPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE2Ni45NjY1MiwtNDUuMTc5MTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43OTM5OTEsLTU4LjY4NDcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuNzkzOTkxJyB5PSctNTguNjg0NzE3Jz5BPC90ZXh0Pgo8cmVjdCB4PSctNjMuNzkzOTkxJyB5PSctNTcuNDg5MjY1JyBoZWlnaHQ9Jy4zOTg0ODQnIHdpZHRoPSc3LjQ3MTk5NScvPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjQ4Njc5IDMuNjE2NjJINzYuNTUyNzInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzYuODAyNzIsMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDAuNzA4NTcsNy43ODk1MiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc5Mzk5MSwtNTguNjg0NzE3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43OTM5OTEnIHk9Jy01OC42ODQ3MTcnPnA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguNDg2NzktMy42MTY2Mkg3Ni41NTI3MicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3Ni44MDI3MiwtMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDAuODExNTgsLTkuNDQyMzIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43OTM5OTEsLTU4LjY4NDcxNylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjMuNzkzOTkxJyB5PSctNTguNjg0NzE3Jz5xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005My42NjM4IDBIMTU4LjM0NTQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE1OC4yMjA0NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J21pdGVyJz4KIDxwYXRoIGQ9J00zLjM5NzEzIDBMLjI1IDEuODc0OTRWMFYtMS44NzQ5NFonIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMjUuNTQ4NjUsNC4xNzI5MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc5Mzk5MSwtNTguNjg0NzE3KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43OTM5OTEnIHk9Jy01OC42ODQ3MTcnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTkxLjc2MjItNi40MDk3M0wxNjIuMTI4MzQtNzYuNzYxNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE3LC0wLjcwNzAzLDAuNzA3MDMsMC43MDcxNywxNjIuMzA1MTMsLTc2LjkzODQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMTkuNzA1NzMsLTQ3LjU4ODE3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzkzOTkxLC01OC42ODQ3MTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjc5Mzk5MScgeT0nLTU4LjY4NDcxNyc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTcwLjcxNjUyLTYuNDA5NzNWLTMzLjkzNjA4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMTcwLjcxNjUyLC0zNC4xODYwOCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTczLjk4MDQxLC0yMi4xNzI5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzkzOTkxLC01OC42ODQ3MTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjc5Mzk5MScgeT0nLTU4LjY4NDcxNyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTkuMTI3NDA3JyB5PSctNjEuNjkxMjM1Jz7ugLA8dHNwYW4geD0nLTU2LjQzMjYzNCcgeT0nLTYxLjk5NTY1Jz7iiJI8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTEuMDM2MTI1JyB5PSctNjEuOTk1NjUnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTE3MC43MTY1Mi01MS4wODg3M1YtNzYuNjE1MjInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwxNzAuNzE2NTIsLTc2Ljg2NTIyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNzMuOTgwNDEsLTY1Ljg1MTk3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzkzOTkxLC01OC42ODQ3MTcpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjc5Mzk5MScgeT0nLTU4LjY4NDcxNyc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTkuNjU3MDQxJyB5PSctNjEuNjkxMjM1Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram, node distance = 3cm]
      \node  (1) {$C$};
      \node  [right = of 1] (2) {$A$};
      \node  [right = of 2] (3) {$B$};
      \node  [below = of 3] (5) {$D$};
      \node  [between = 3 and 5] (4) {$\underline {A}$};
      \draw  [->,morphism,offset=-1.5] (1) to node {$p$} (2);
      \draw  [->,morphism,offset=1.5] (1) to node[swap] {$q$} (2);
      \draw  [cover,morphism] (2) to node {$f$} (3);
      \draw  [->,morphism] (2) to node[swap] {$g$} (5);
      \draw  [->,morphism] (3) to node {${f'}^{-1}$} (4);
      \draw  [->,morphism] (4) to node {$g'$} (5);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Uniqueness then follows from the fact that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is epic.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>