<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>263</fr:anchor><fr:taxon>Corollary</fr:taxon><fr:addr>ct-000D</fr:addr><fr:route>ct-000D.xml</fr:route><fr:title>Categories with a <fr:link
href="ct-0009.xml"
type="local"
addr="ct-0009">subobject classifier</fr:link> are cartesian</fr:title><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
href="frankndrssn.xml"
type="local"
addr="frankndrssn">Frank Tsai</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex>\mathcal { C }</fr:tex> is a category with pullbacks equipped with a subobject classifier then <fr:tex>\mathcal { C }</fr:tex> is cartesian.</fr:p>
    
      
      <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>261</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
href="frankndrssn.xml"
type="local"
addr="frankndrssn">Frank Tsai</fr:link></fr:author></fr:authors><fr:parent>ct-000D</fr:parent></fr:frontmatter><fr:mainmatter>
  By <fr:ref
addr="ct-000B"
href="ct-000B.xml"
taxon="Corollary"></fr:ref>, <fr:tex>\mathcal { C }</fr:tex> has a terminal object. Thus, it follows that <fr:tex>\mathcal { C }</fr:tex> has all finite limits.
</fr:mainmatter></fr:tree>
    
  </fr:mainmatter><fr:backmatter><fr:contributions></fr:contributions><fr:context></fr:context><fr:related><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>244</fr:anchor><fr:taxon>Corollary</fr:taxon><fr:addr>ct-000B</fr:addr><fr:route>ct-000B.xml</fr:route><fr:title>Domain of the <fr:link
href="ct-000A.xml"
type="local"
addr="ct-000A">generic subobject</fr:link> is terminal</fr:title><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
href="frankndrssn.xml"
type="local"
addr="frankndrssn">Frank Tsai</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex>\top \colon   \Omega '  \rightarrowtail   \Omega</fr:tex> be the generic subobject of a category <fr:tex>\mathcal { C }</fr:tex> with pullbacks, then <fr:tex>\Omega '</fr:tex> is terminal.</fr:p>
    
      
      <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>242</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
href="frankndrssn.xml"
type="local"
addr="frankndrssn">Frank Tsai</fr:link></fr:author></fr:authors><fr:parent>ct-000B</fr:parent></fr:frontmatter><fr:mainmatter>
  Let <fr:tex>A</fr:tex> be any object in <fr:tex>\mathcal { C }</fr:tex>. We need to show that there is a unique morphism <fr:tex>A  \to   \Omega '</fr:tex>.
  <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>238</fr:anchor><fr:taxon>Existence</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
href="frankndrssn.xml"
type="local"
addr="frankndrssn">Frank Tsai</fr:link></fr:author></fr:authors><fr:parent>ct-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Consider <fr:tex>(A, \mathsf {id} _{ A } )</fr:tex>. By <fr:ref
addr="ct-0009"
href="ct-0009.xml"
taxon="Definition"></fr:ref>, there is a pullback square</fr:p>
    
      
      <fr:embedded-tex
hash="3b9c4a8513f3894c0c071728fb543d69"><fr:embedded-tex-preamble>
         
   \RequirePackage {tikz}
   \RequirePackage {amsmath}
   \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

   \definecolor {catccolor}{RGB}{255,244,138}
   \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
   \tikzstyle {catc}=[catccolor!60]
   \tikzstyle {catd}=[orange!40]
   \tikzstyle {cate}=[red!40]
   \tikzstyle {catf}=[blue!10]
   \tikzstyle {catg}=[green!25]


   \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
   \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

   \NewDocumentCommand \CreateRect {D&lt;&gt;{} m m}{
     \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

     \path [spath/save = #1north] (#1nw) to (#1ne);
     \path [spath/save = #1west] (#1nw) to (#1sw);
     \path [spath/save = #1east] (#1ne) to (#1se);
     \path [spath/save = #1south] (#1sw) to (#1se);
  }
 
         
    \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd, quiver}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      font=\scriptsize,
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    % /tikz/pos=&lt;fraction&gt; is a key already
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    fibration/.style = {
      -{Triangle[open]}
    },
    etale/.style = {
      -{Triangle[open]}
    },
    etale cover/.style= {
      &gt;={Triangle[open]},-&gt;.&gt;
    },
    opfibration/.style = {
      -{Triangle}
    },
    lies over/.style = {
      |-{Triangle[open]}
    },
    op lies over/.style = {
      |-{Triangle}
    },
    embedding/.style = {
      {right hook}-&gt;
    },
    open immersion/.style = {
      {right hook}-{Triangle[open]}
    },
    closed immersion/.style = {
      {right hook}-{Triangle}
    },
    closed immersion*/.style = {
      {left hook}-{Triangle}
    },
    embedding*/.style = {
      {left hook}-&gt;
    },
    open immersion*/.style = {
      {left hook}-{Triangle[open]}
    },
    exists/.style = {
      densely dashed
    },
    equal/.style = {
      double
    },
  }

  \newlength{\dontworryaboutit}

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Primitives for drawing commutative squares
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {-&gt;},
    square/south/.style = {-&gt;},
    square/west/.style = {-&gt;},
    square/east/.style = {-&gt;},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn

  \bool_new:N \l_jon_glue_west

  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    glue .choice:,
    glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

    glue~target .tl_set:N = \l_jon_tikz_glue_target,

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
      sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
      se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
      ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
      north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
      south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
      west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
      east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
    \texttt{\textcolor{red}{#1}}
  }

  \keys_set:nn { jon-tikz/diagram } {
    glue~target = {},
  }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2}
    \bool_if:nTF \l_jon_glue_west {
      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    } {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }


  \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }

  \ExplSyntaxOff
  %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Primitives for drawing adjunction diagrams
  \tikzset{
    adj/w/.style = {},
    adj/e/.style = {},
    adj/left/.style = {-&gt;},
    adj/right/.style = {-&gt;},
    adj/left/node/.style = {above},
    adj/right/node/.style = {below},
  }

  \ExplSyntaxOn

  \bool_new:N \l_fnd_glue_west

  \keys_define:nn { fnd-tikz/adj-diagram } {
    w .tl_set:N = \l_fnd_tikz_adj_diagram_w,
    e .tl_set:N = \l_fnd_tikz_adj_diagram_e,

    width .tl_set:N = \l_fnd_tikz_adj_diagram_width,

    left .tl_set:N = \l_fnd_tikz_adj_diagram_left,
    right .tl_set:N = \l_fnd_tikz_adj_diagram_right,

    glue .choice:,
    glue / west .code:n = {\bool_set:Nn \l_fnd_glue_west \c_true_bool},
    glue~target .tl_set:N = \l_fnd_tikz_glue_target,

    w/style .code:n = {\tikzset{adj/w/.style = {#1}}},
    e/style .code:n = {\tikzset{adj/e/.style = {#1}}},

    left/style .code:n = {\tikzset{adj/left/.style = {#1}}},
    left/node/style .code:n = {\tikzset{adj/left/node/.style = {#1}}},
    right/style .code:n = {\tikzset{adj/right/.style = {#1}}},
    right/node/style .code:n = {\tikzset{adj/right/node/.style = {#1}}},

    draft .meta:n = {
      e = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {e}},
      w = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {w}},
      left = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {left}},
      right = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {right}},
    }
  }

  \tl_set:Nn \l_fnd_tikz_adj_diagram_width { 2cm }

  \cs_new:Npn \__fnd_tikz_adj_diagram_fmt_placeholder:n #1 {
    \texttt{\textcolor{red}{#1}}
  }

  \keys_set:nn { fnd-tikz/adj-diagram } {
    glue~target = {},
  }

  \cs_new:Nn \__fnd_tikz_render_adj_diagram:n {
    \group_begin:
    \keys_set:nn {fnd-tikz/adj-diagram} {#1} {
      % gluing will be implemented when I need it
      \node (w) [adj/w] {$\l_fnd_tikz_adj_diagram_w$};
      \node (e) [right=\l_fnd_tikz_adj_diagram_width~of~w,adj/e] {$\l_fnd_tikz_adj_diagram_e$};
        \draw [morphism,adj/left,offset=.15cm] (e) to node[adj/left/node] (n) {$\l_fnd_tikz_adj_diagram_left$} (w);
        \draw [morphism,adj/right,offset=.15cm] (w) to node[adj/right/node] (s) {$\l_fnd_tikz_adj_diagram_right$} (e);
        \path [morphism] (s) to node[rotate=-90] {$\dashv$} (n);
    }
    \group_end:
  }

  \NewDocumentCommand\AdjDiagram{m}{
    \begin{tikzpicture}[diagram]
      \__fnd_tikz_render_adj_diagram:n {#1}
    \end{tikzpicture}
  }
  
  \ExplSyntaxOff
  %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
      </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \DiagramSquare {
        nw = A,
        nw/style = pullback,
        ne =  \Omega ',
        sw = A,
        se =  \Omega ,
        west/style = {double},
        south/style = {-&gt;,exists},
        east =  \top ,
        east/style = {&gt;-&gt;},
      }
    </fr:embedded-tex-body></fr:embedded-tex>
    
  <fr:p>Thus, there is a morphism <fr:tex>A  \to   \Omega '</fr:tex>.</fr:p></fr:mainmatter></fr:tree>
  <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>240</fr:anchor><fr:taxon>Uniqueness</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
href="frankndrssn.xml"
type="local"
addr="frankndrssn">Frank Tsai</fr:link></fr:author></fr:authors><fr:parent>ct-000B</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex>f,g \colon  A  \rightrightarrows   \Omega '</fr:tex>. We need to show that <fr:tex>f = g</fr:tex>. To this end, it suffices to show <fr:tex>\top  f =  \top  g</fr:tex> since <fr:tex>\top</fr:tex> is monic.</fr:p><fr:p>Consider the subobject classified by <fr:tex>\top  f</fr:tex>. Note that by the <fr:link
href="ct-0008.xml"
type="local"
addr="ct-0008">pasting lemma</fr:link>, this subobject is isomorphic to <fr:tex>f ^{*} ( \top ^{*} ( \top ))</fr:tex> in <fr:tex>\mathsf { Sub } (A)</fr:tex>. Since <fr:tex>\top</fr:tex> is monic, <fr:tex>\top ^{*} ( \top )</fr:tex> is an isomorphism. Then since isomorphisms are stable under pullback, the subobject classified by <fr:tex>\top  f</fr:tex> is an isomorphism. Thus, <fr:tex>( \top  f) ^{*} ( \top )  \cong   \mathsf {id} _{ A }</fr:tex> in <fr:tex>\mathsf { Sub } (A)</fr:tex>. Analogously, we have <fr:tex>( \top  g) ^{*} ( \top )  \cong   \mathsf {id} _{ A }</fr:tex> in <fr:tex>\mathsf { Sub } (A)</fr:tex>, so we can conclude that <fr:tex>\top  f</fr:tex> and <fr:tex>\top  g</fr:tex> classify isomorphic subobjects.</fr:p><fr:p>Now apply <fr:ref
addr="ct-000C"
href="ct-000C.xml"
taxon="Lemma"></fr:ref>.</fr:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
    
  </fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>259</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ct-0009</fr:addr><fr:route>ct-0009.xml</fr:route><fr:title><fr:link
href="ct-0006.xml"
type="local"
addr="ct-0006">Subobject</fr:link> classifier</fr:title><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
href="frankndrssn.xml"
type="local"
addr="frankndrssn">Frank Tsai</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex>\mathcal { C }</fr:tex> be a category with pullbacks. The <fr:em><fr:strong>subobject classifier</fr:strong></fr:em> of <fr:tex>\mathcal { C }</fr:tex> is the terminal object (if it exists) of the category <fr:tex>\mathcal { S } _{ \mathcal { C } }</fr:tex> defined by the following data:</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
  
  <html:tr>
    
  <html:th>Objects</html:th>

    
  <html:th>Morphisms</html:th>

  </html:tr>

  
  <html:tr>
    
  <html:td>An object of <fr:tex>\mathcal { S } _{ \mathcal { C } }</fr:tex> is a pair <fr:tex>(A, m)</fr:tex>, where <fr:tex>A</fr:tex> is an object in <fr:tex>\mathcal { C }</fr:tex> and <fr:tex>m \colon  A'  \rightarrowtail  A</fr:tex> is a subobject.</html:td>

    
  <html:td>A morphism <fr:tex>(A,m)  \to  (B,n)</fr:tex> is a morphism <fr:tex>f \colon  A  \to  B</fr:tex> in <fr:tex>\mathcal { C }</fr:tex> such that <fr:tex>m</fr:tex> is a pullback against <fr:tex>n</fr:tex> along <fr:tex>f</fr:tex>. In other words, <fr:tex>m</fr:tex> is isomorphic to the canonical pullback <fr:tex>f ^{*} (n)</fr:tex> in <fr:tex>\mathsf { Sub } (A)</fr:tex>.
      
    
      
      <fr:embedded-tex
hash="8af428247e3f04c43427be58917e1473"><fr:embedded-tex-preamble>
         
   \RequirePackage {tikz}
   \RequirePackage {amsmath}
   \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

   \definecolor {catccolor}{RGB}{255,244,138}
   \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
   \tikzstyle {catc}=[catccolor!60]
   \tikzstyle {catd}=[orange!40]
   \tikzstyle {cate}=[red!40]
   \tikzstyle {catf}=[blue!10]
   \tikzstyle {catg}=[green!25]


   \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
   \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

   \NewDocumentCommand \CreateRect {D&lt;&gt;{} m m}{
     \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

     \path [spath/save = #1north] (#1nw) to (#1ne);
     \path [spath/save = #1west] (#1nw) to (#1sw);
     \path [spath/save = #1east] (#1ne) to (#1se);
     \path [spath/save = #1south] (#1sw) to (#1se);
  }
 
         
    \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd, quiver}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      font=\scriptsize,
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    % /tikz/pos=&lt;fraction&gt; is a key already
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    fibration/.style = {
      -{Triangle[open]}
    },
    etale/.style = {
      -{Triangle[open]}
    },
    etale cover/.style= {
      &gt;={Triangle[open]},-&gt;.&gt;
    },
    opfibration/.style = {
      -{Triangle}
    },
    lies over/.style = {
      |-{Triangle[open]}
    },
    op lies over/.style = {
      |-{Triangle}
    },
    embedding/.style = {
      {right hook}-&gt;
    },
    open immersion/.style = {
      {right hook}-{Triangle[open]}
    },
    closed immersion/.style = {
      {right hook}-{Triangle}
    },
    closed immersion*/.style = {
      {left hook}-{Triangle}
    },
    embedding*/.style = {
      {left hook}-&gt;
    },
    open immersion*/.style = {
      {left hook}-{Triangle[open]}
    },
    exists/.style = {
      densely dashed
    },
    equal/.style = {
      double
    },
  }

  \newlength{\dontworryaboutit}

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Primitives for drawing commutative squares
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {-&gt;},
    square/south/.style = {-&gt;},
    square/west/.style = {-&gt;},
    square/east/.style = {-&gt;},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn

  \bool_new:N \l_jon_glue_west

  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    glue .choice:,
    glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

    glue~target .tl_set:N = \l_jon_tikz_glue_target,

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
      sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
      se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
      ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
      north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
      south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
      west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
      east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
    \texttt{\textcolor{red}{#1}}
  }

  \keys_set:nn { jon-tikz/diagram } {
    glue~target = {},
  }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2}
    \bool_if:nTF \l_jon_glue_west {
      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    } {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }


  \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }

  \ExplSyntaxOff
  %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Primitives for drawing adjunction diagrams
  \tikzset{
    adj/w/.style = {},
    adj/e/.style = {},
    adj/left/.style = {-&gt;},
    adj/right/.style = {-&gt;},
    adj/left/node/.style = {above},
    adj/right/node/.style = {below},
  }

  \ExplSyntaxOn

  \bool_new:N \l_fnd_glue_west

  \keys_define:nn { fnd-tikz/adj-diagram } {
    w .tl_set:N = \l_fnd_tikz_adj_diagram_w,
    e .tl_set:N = \l_fnd_tikz_adj_diagram_e,

    width .tl_set:N = \l_fnd_tikz_adj_diagram_width,

    left .tl_set:N = \l_fnd_tikz_adj_diagram_left,
    right .tl_set:N = \l_fnd_tikz_adj_diagram_right,

    glue .choice:,
    glue / west .code:n = {\bool_set:Nn \l_fnd_glue_west \c_true_bool},
    glue~target .tl_set:N = \l_fnd_tikz_glue_target,

    w/style .code:n = {\tikzset{adj/w/.style = {#1}}},
    e/style .code:n = {\tikzset{adj/e/.style = {#1}}},

    left/style .code:n = {\tikzset{adj/left/.style = {#1}}},
    left/node/style .code:n = {\tikzset{adj/left/node/.style = {#1}}},
    right/style .code:n = {\tikzset{adj/right/.style = {#1}}},
    right/node/style .code:n = {\tikzset{adj/right/node/.style = {#1}}},

    draft .meta:n = {
      e = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {e}},
      w = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {w}},
      left = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {left}},
      right = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {right}},
    }
  }

  \tl_set:Nn \l_fnd_tikz_adj_diagram_width { 2cm }

  \cs_new:Npn \__fnd_tikz_adj_diagram_fmt_placeholder:n #1 {
    \texttt{\textcolor{red}{#1}}
  }

  \keys_set:nn { fnd-tikz/adj-diagram } {
    glue~target = {},
  }

  \cs_new:Nn \__fnd_tikz_render_adj_diagram:n {
    \group_begin:
    \keys_set:nn {fnd-tikz/adj-diagram} {#1} {
      % gluing will be implemented when I need it
      \node (w) [adj/w] {$\l_fnd_tikz_adj_diagram_w$};
      \node (e) [right=\l_fnd_tikz_adj_diagram_width~of~w,adj/e] {$\l_fnd_tikz_adj_diagram_e$};
        \draw [morphism,adj/left,offset=.15cm] (e) to node[adj/left/node] (n) {$\l_fnd_tikz_adj_diagram_left$} (w);
        \draw [morphism,adj/right,offset=.15cm] (w) to node[adj/right/node] (s) {$\l_fnd_tikz_adj_diagram_right$} (e);
        \path [morphism] (s) to node[rotate=-90] {$\dashv$} (n);
    }
    \group_end:
  }

  \NewDocumentCommand\AdjDiagram{m}{
    \begin{tikzpicture}[diagram]
      \__fnd_tikz_render_adj_diagram:n {#1}
    \end{tikzpicture}
  }
  
  \ExplSyntaxOff
  %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
      </fr:embedded-tex-preamble><fr:embedded-tex-body>
         \DiagramSquare {
          nw = A',
          nw/style = pullback,
          ne = B',
          sw = A,
          se = B,
          south = f,
          west = m,
          west/style = {&gt;-&gt;},
          east = n,
          east/style = {&gt;-&gt;},
        }
      </fr:embedded-tex-body></fr:embedded-tex>
    
  
    </html:td>
 
  </html:tr>

</html:table>
<fr:p>Identities and compositions of <fr:tex>\mathcal { S } _{ \mathcal { C } }</fr:tex> are inherited from <fr:tex>\mathcal { C }</fr:tex>.</fr:p>
    
      
      <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>257</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
href="frankndrssn.xml"
type="local"
addr="frankndrssn">Frank Tsai</fr:link></fr:author></fr:authors><fr:parent>ct-0009</fr:parent></fr:frontmatter><fr:mainmatter>
  For the definition to make sense, we need to show that <fr:tex>\mathcal { S } _{ \mathcal { C } }</fr:tex> is a category.
  Since identities and compositions are inherited from <fr:tex>\mathcal { C }</fr:tex>, it suffices to show the followings:
  <fr:ol><fr:li>
      For any object <fr:tex>A  \in   \mathcal { C }</fr:tex> and any subobject <fr:tex>m \colon  A'  \rightarrowtail  A</fr:tex>, the identity morphism <fr:tex>\mathsf {id} _{ A }</fr:tex> gives the required pullback.
      
    
      
      <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>253</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
href="frankndrssn.xml"
type="local"
addr="frankndrssn">Frank Tsai</fr:link></fr:author></fr:authors><fr:parent>ct-0009</fr:parent></fr:frontmatter><fr:mainmatter>
        The following diagram is a pullback.
        
    
      
      <fr:embedded-tex
hash="7f6b7727a0db5e0bfeb72c800a1c7dbe"><fr:embedded-tex-preamble>
         
   \RequirePackage {tikz}
   \RequirePackage {amsmath}
   \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

   \definecolor {catccolor}{RGB}{255,244,138}
   \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
   \tikzstyle {catc}=[catccolor!60]
   \tikzstyle {catd}=[orange!40]
   \tikzstyle {cate}=[red!40]
   \tikzstyle {catf}=[blue!10]
   \tikzstyle {catg}=[green!25]


   \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
   \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

   \NewDocumentCommand \CreateRect {D&lt;&gt;{} m m}{
     \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

     \path [spath/save = #1north] (#1nw) to (#1ne);
     \path [spath/save = #1west] (#1nw) to (#1sw);
     \path [spath/save = #1east] (#1ne) to (#1se);
     \path [spath/save = #1south] (#1sw) to (#1se);
  }
 
         
    \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd, quiver}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      font=\scriptsize,
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    % /tikz/pos=&lt;fraction&gt; is a key already
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    fibration/.style = {
      -{Triangle[open]}
    },
    etale/.style = {
      -{Triangle[open]}
    },
    etale cover/.style= {
      &gt;={Triangle[open]},-&gt;.&gt;
    },
    opfibration/.style = {
      -{Triangle}
    },
    lies over/.style = {
      |-{Triangle[open]}
    },
    op lies over/.style = {
      |-{Triangle}
    },
    embedding/.style = {
      {right hook}-&gt;
    },
    open immersion/.style = {
      {right hook}-{Triangle[open]}
    },
    closed immersion/.style = {
      {right hook}-{Triangle}
    },
    closed immersion*/.style = {
      {left hook}-{Triangle}
    },
    embedding*/.style = {
      {left hook}-&gt;
    },
    open immersion*/.style = {
      {left hook}-{Triangle[open]}
    },
    exists/.style = {
      densely dashed
    },
    equal/.style = {
      double
    },
  }

  \newlength{\dontworryaboutit}

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Primitives for drawing commutative squares
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {-&gt;},
    square/south/.style = {-&gt;},
    square/west/.style = {-&gt;},
    square/east/.style = {-&gt;},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn

  \bool_new:N \l_jon_glue_west

  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    glue .choice:,
    glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

    glue~target .tl_set:N = \l_jon_tikz_glue_target,

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
      sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
      se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
      ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
      north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
      south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
      west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
      east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
    \texttt{\textcolor{red}{#1}}
  }

  \keys_set:nn { jon-tikz/diagram } {
    glue~target = {},
  }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2}
    \bool_if:nTF \l_jon_glue_west {
      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    } {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }


  \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }

  \ExplSyntaxOff
  %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Primitives for drawing adjunction diagrams
  \tikzset{
    adj/w/.style = {},
    adj/e/.style = {},
    adj/left/.style = {-&gt;},
    adj/right/.style = {-&gt;},
    adj/left/node/.style = {above},
    adj/right/node/.style = {below},
  }

  \ExplSyntaxOn

  \bool_new:N \l_fnd_glue_west

  \keys_define:nn { fnd-tikz/adj-diagram } {
    w .tl_set:N = \l_fnd_tikz_adj_diagram_w,
    e .tl_set:N = \l_fnd_tikz_adj_diagram_e,

    width .tl_set:N = \l_fnd_tikz_adj_diagram_width,

    left .tl_set:N = \l_fnd_tikz_adj_diagram_left,
    right .tl_set:N = \l_fnd_tikz_adj_diagram_right,

    glue .choice:,
    glue / west .code:n = {\bool_set:Nn \l_fnd_glue_west \c_true_bool},
    glue~target .tl_set:N = \l_fnd_tikz_glue_target,

    w/style .code:n = {\tikzset{adj/w/.style = {#1}}},
    e/style .code:n = {\tikzset{adj/e/.style = {#1}}},

    left/style .code:n = {\tikzset{adj/left/.style = {#1}}},
    left/node/style .code:n = {\tikzset{adj/left/node/.style = {#1}}},
    right/style .code:n = {\tikzset{adj/right/.style = {#1}}},
    right/node/style .code:n = {\tikzset{adj/right/node/.style = {#1}}},

    draft .meta:n = {
      e = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {e}},
      w = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {w}},
      left = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {left}},
      right = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {right}},
    }
  }

  \tl_set:Nn \l_fnd_tikz_adj_diagram_width { 2cm }

  \cs_new:Npn \__fnd_tikz_adj_diagram_fmt_placeholder:n #1 {
    \texttt{\textcolor{red}{#1}}
  }

  \keys_set:nn { fnd-tikz/adj-diagram } {
    glue~target = {},
  }

  \cs_new:Nn \__fnd_tikz_render_adj_diagram:n {
    \group_begin:
    \keys_set:nn {fnd-tikz/adj-diagram} {#1} {
      % gluing will be implemented when I need it
      \node (w) [adj/w] {$\l_fnd_tikz_adj_diagram_w$};
      \node (e) [right=\l_fnd_tikz_adj_diagram_width~of~w,adj/e] {$\l_fnd_tikz_adj_diagram_e$};
        \draw [morphism,adj/left,offset=.15cm] (e) to node[adj/left/node] (n) {$\l_fnd_tikz_adj_diagram_left$} (w);
        \draw [morphism,adj/right,offset=.15cm] (w) to node[adj/right/node] (s) {$\l_fnd_tikz_adj_diagram_right$} (e);
        \path [morphism] (s) to node[rotate=-90] {$\dashv$} (n);
    }
    \group_end:
  }

  \NewDocumentCommand\AdjDiagram{m}{
    \begin{tikzpicture}[diagram]
      \__fnd_tikz_render_adj_diagram:n {#1}
    \end{tikzpicture}
  }
  
  \ExplSyntaxOff
  %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
      </fr:embedded-tex-preamble><fr:embedded-tex-body>
           \DiagramSquare {
            nw = A',
            nw/style = pullback,
            ne = A',
            sw = A,
            se = A,
            north/style = {double},
            south/style = {double},
            east = m,
            west = m,
            east/style = {&gt;-&gt;},
            west/style = {&gt;-&gt;},
          }
        </fr:embedded-tex-body></fr:embedded-tex>
    
  
      </fr:mainmatter></fr:tree></fr:li>
    <fr:li>
      For any <fr:tex>f \colon  (A,m)  \to  (B,n)</fr:tex> and any <fr:tex>g \colon  (B,n)  \to  (C,o)</fr:tex>, the composite <fr:tex>gf</fr:tex> gives the required pullback.
      
    
      
      <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>255</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
href="frankndrssn.xml"
type="local"
addr="frankndrssn">Frank Tsai</fr:link></fr:author></fr:authors><fr:parent>ct-0009</fr:parent></fr:frontmatter><fr:mainmatter>
        By definition, the two inner squares of the following diagram are pullbacks.
        
    
      
      <fr:embedded-tex
hash="6b8fe8ed19ec3c6a88a386506285bc90"><fr:embedded-tex-preamble>
         
   \RequirePackage {tikz}
   \RequirePackage {amsmath}
   \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

   \definecolor {catccolor}{RGB}{255,244,138}
   \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
   \tikzstyle {catc}=[catccolor!60]
   \tikzstyle {catd}=[orange!40]
   \tikzstyle {cate}=[red!40]
   \tikzstyle {catf}=[blue!10]
   \tikzstyle {catg}=[green!25]


   \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
   \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

   \NewDocumentCommand \CreateRect {D&lt;&gt;{} m m}{
     \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

     \path [spath/save = #1north] (#1nw) to (#1ne);
     \path [spath/save = #1west] (#1nw) to (#1sw);
     \path [spath/save = #1east] (#1ne) to (#1se);
     \path [spath/save = #1south] (#1sw) to (#1se);
  }
 
         
    \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd, quiver}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      font=\scriptsize,
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    % /tikz/pos=&lt;fraction&gt; is a key already
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    fibration/.style = {
      -{Triangle[open]}
    },
    etale/.style = {
      -{Triangle[open]}
    },
    etale cover/.style= {
      &gt;={Triangle[open]},-&gt;.&gt;
    },
    opfibration/.style = {
      -{Triangle}
    },
    lies over/.style = {
      |-{Triangle[open]}
    },
    op lies over/.style = {
      |-{Triangle}
    },
    embedding/.style = {
      {right hook}-&gt;
    },
    open immersion/.style = {
      {right hook}-{Triangle[open]}
    },
    closed immersion/.style = {
      {right hook}-{Triangle}
    },
    closed immersion*/.style = {
      {left hook}-{Triangle}
    },
    embedding*/.style = {
      {left hook}-&gt;
    },
    open immersion*/.style = {
      {left hook}-{Triangle[open]}
    },
    exists/.style = {
      densely dashed
    },
    equal/.style = {
      double
    },
  }

  \newlength{\dontworryaboutit}

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Primitives for drawing commutative squares
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {-&gt;},
    square/south/.style = {-&gt;},
    square/west/.style = {-&gt;},
    square/east/.style = {-&gt;},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn

  \bool_new:N \l_jon_glue_west

  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    glue .choice:,
    glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

    glue~target .tl_set:N = \l_jon_tikz_glue_target,

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
      sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
      se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
      ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
      north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
      south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
      west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
      east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
    \texttt{\textcolor{red}{#1}}
  }

  \keys_set:nn { jon-tikz/diagram } {
    glue~target = {},
  }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2}
    \bool_if:nTF \l_jon_glue_west {
      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    } {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  \NewDocumentCommand\SpliceDiagramSquare{D&lt;&gt;{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }


  \NewDocumentCommand\DiagramSquare{D&lt;&gt;{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }

  \ExplSyntaxOff
  %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Primitives for drawing adjunction diagrams
  \tikzset{
    adj/w/.style = {},
    adj/e/.style = {},
    adj/left/.style = {-&gt;},
    adj/right/.style = {-&gt;},
    adj/left/node/.style = {above},
    adj/right/node/.style = {below},
  }

  \ExplSyntaxOn

  \bool_new:N \l_fnd_glue_west

  \keys_define:nn { fnd-tikz/adj-diagram } {
    w .tl_set:N = \l_fnd_tikz_adj_diagram_w,
    e .tl_set:N = \l_fnd_tikz_adj_diagram_e,

    width .tl_set:N = \l_fnd_tikz_adj_diagram_width,

    left .tl_set:N = \l_fnd_tikz_adj_diagram_left,
    right .tl_set:N = \l_fnd_tikz_adj_diagram_right,

    glue .choice:,
    glue / west .code:n = {\bool_set:Nn \l_fnd_glue_west \c_true_bool},
    glue~target .tl_set:N = \l_fnd_tikz_glue_target,

    w/style .code:n = {\tikzset{adj/w/.style = {#1}}},
    e/style .code:n = {\tikzset{adj/e/.style = {#1}}},

    left/style .code:n = {\tikzset{adj/left/.style = {#1}}},
    left/node/style .code:n = {\tikzset{adj/left/node/.style = {#1}}},
    right/style .code:n = {\tikzset{adj/right/.style = {#1}}},
    right/node/style .code:n = {\tikzset{adj/right/node/.style = {#1}}},

    draft .meta:n = {
      e = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {e}},
      w = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {w}},
      left = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {left}},
      right = {\__fnd_tikz_adj_diagram_fmt_placeholder:n {right}},
    }
  }

  \tl_set:Nn \l_fnd_tikz_adj_diagram_width { 2cm }

  \cs_new:Npn \__fnd_tikz_adj_diagram_fmt_placeholder:n #1 {
    \texttt{\textcolor{red}{#1}}
  }

  \keys_set:nn { fnd-tikz/adj-diagram } {
    glue~target = {},
  }

  \cs_new:Nn \__fnd_tikz_render_adj_diagram:n {
    \group_begin:
    \keys_set:nn {fnd-tikz/adj-diagram} {#1} {
      % gluing will be implemented when I need it
      \node (w) [adj/w] {$\l_fnd_tikz_adj_diagram_w$};
      \node (e) [right=\l_fnd_tikz_adj_diagram_width~of~w,adj/e] {$\l_fnd_tikz_adj_diagram_e$};
        \draw [morphism,adj/left,offset=.15cm] (e) to node[adj/left/node] (n) {$\l_fnd_tikz_adj_diagram_left$} (w);
        \draw [morphism,adj/right,offset=.15cm] (w) to node[adj/right/node] (s) {$\l_fnd_tikz_adj_diagram_right$} (e);
        \path [morphism] (s) to node[rotate=-90] {$\dashv$} (n);
    }
    \group_end:
  }

  \NewDocumentCommand\AdjDiagram{m}{
    \begin{tikzpicture}[diagram]
      \__fnd_tikz_render_adj_diagram:n {#1}
    \end{tikzpicture}
  }
  
  \ExplSyntaxOff
  %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
      </fr:embedded-tex-preamble><fr:embedded-tex-body>
           \begin {tikzpicture}[diagram]
             \SpliceDiagramSquare {
              nw = B',
              nw/style = pullback,
              ne = C',
              sw = B,
              se = C,
              south = g,
              west = n,
              west/style = {&gt;-&gt;},
              west/node/style = {desc},
              east = o,
              east/style = {&gt;-&gt;},
            }
             \node  [left = of nw, pullback] (A') {$A'$};
             \node  [left = of sw] (A) {$A$};
             \draw  [-&gt;,morphism] (A') to (nw);
             \draw  [&gt;-&gt;,morphism] (A') to node[swap] {$m$} (A);
             \draw  [-&gt;,morphism] (A) to node[swap] {$f$} (sw);
           \end {tikzpicture}
          
        </fr:embedded-tex-body></fr:embedded-tex>
    
  
        Then by the <fr:link
href="ct-0008.xml"
type="local"
addr="ct-0008">pasting lemma of pullbacks</fr:link>, the outer rectangle is also a pullback.
      </fr:mainmatter></fr:tree></fr:li></fr:ol>
</fr:mainmatter></fr:tree>
    
  </fr:mainmatter></fr:tree></fr:related><fr:backlinks></fr:backlinks><fr:references></fr:references></fr:backmatter></fr:tree>