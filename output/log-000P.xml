<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1442</fr:anchor><fr:addr
type="user">log-000P</fr:addr><fr:route>log-000P.xml</fr:route><fr:title
text="Internal language of a category">Internal language of a category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category.
  The <fr:em><fr:strong>internal language</fr:strong></fr:em> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> consists of the signature <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> whose sorts are the objects of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, function symbols are the morphisms of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, and relation symbols are the subobjects in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p><fr:p>We write <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> for the canonical <fr:link
type="local"
href="log-0006.xml"
addr="log-0006"
title="Sigma structure"><fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structure</fr:link> that maps each variable to the appropriate product projection, each function symbol <fr:tex
display="inline"><![CDATA[f\colon A_{1},\ldots ,A_{n}\to B]]></fr:tex> to its underlying morphism <fr:tex
display="inline"><![CDATA[f\colon A_{1} \times  \cdots  \times  A_{n}\to B]]></fr:tex>, and each relation symbol <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1},\ldots ,A_{n}]]></fr:tex> to its underlying subobject <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1} \times  \cdots  \times  A_{n}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1443</fr:anchor><fr:addr
type="user">fnd-000B</fr:addr><fr:route>fnd-000B.xml</fr:route><fr:title
text="Doctrine">Doctrine</fr:title><fr:taxon>Section</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="frankndrssn.xml"
addr="frankndrssn"
title="Frank Tsai">Frank Tsai</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1212</fr:anchor><fr:addr
type="user">log-000C</fr:addr><fr:route>log-000C.xml</fr:route><fr:title
text="Doctrine">Doctrine</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>21</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with finite products.
  A <fr:em><fr:strong>(primitive) doctrine</fr:strong></fr:em> over <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>-indexed category <fr:tex
display="inline"><![CDATA[T\colon \mathcal {C}^\mathrm {op}\to \mathsf {CAT}]]></fr:tex>.
  If <fr:tex
display="inline"><![CDATA[T\colon \mathcal {C}^\mathrm {op}\to \mathsf {CAT}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[U\colon \mathcal {D}^\mathrm {op}\to \mathsf {CAT}]]></fr:tex> are primitive doctrines, then a <fr:em><fr:strong>morphism of doctrines</fr:strong></fr:em> <fr:tex
display="inline"><![CDATA[F\colon T\to U]]></fr:tex> consists of the following data:</fr:p><fr:ul><fr:li>A finite-product preserving functor <fr:tex
display="inline"><![CDATA[F_{0}\colon \mathcal {C}\to \mathcal {D}]]></fr:tex>.</fr:li>
  <fr:li>For each object <fr:tex
display="inline"><![CDATA[X \in  \mathcal {C}]]></fr:tex>, a functor <fr:tex
display="inline"><![CDATA[F_{1,X}\colon TX\to UF_{0}X]]></fr:tex>.</fr:li></fr:ul><fr:p>These data are subject to the condition that for any morphism <fr:tex
display="inline"><![CDATA[f\colon X\to Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the following square commutes:</fr:p>
    
      
      <fr:figure><fr:resource
hash="24d509c281aeb04ea151312bc7fea7ea"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0OS4xNDI4NzRwdCcgaGVpZ2h0PScxMjEuMzA3NTUycHQnIHZpZXdCb3g9Jy03MiAtNzIgOTkuNDI4NTgzIDgwLjg3MTcwMSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUElBQW9BQUFBQUJEUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFV0MUFXTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUVLQUFBQkVLTnhnUXRvWldGa0FBQUNjQUFBQUM4QUFBQTJLT3lrazJob1pXRUFBQUtnQUFBQUhnQUFBQ1FGdWdLa2FHMTBlQUFBQXNBQUFBQUtBQUFBQ2dhY0FFOXNiMk5oQUFBQ3pBQUFBQWdBQUFBSUFGWUFpRzFoZUhBQUFBTFVBQUFBR0FBQUFDQUFCZ0F6Ym1GdFpRQUFBdXdBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEdUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtZXMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUTBZREJrWnZnUDVETkRwSkhVL0FjS0F3RDJpQTA4ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy84RFNZUC8vLzlmQlBNWkFGRkRCbzE0MmhXT3ZVckRVQmlHdis5TG1vT3hGSm8ySjRKUU1Ebk5RZklqR3ByRHFaQjBWR3pyb2tNSjR1YlBvSnRUQzE2QW01T0xONkRYNHVCbE9EdGJQYjd2OUR5OHd3c0VwNzlmZEV0dnNBMzdBTWhaQjVuRFlwbWpqRldzS2xTbDRzRUFBNDY4VkdWdDlIOGRzL01kNCttYVhDWWl2VnJwU0RDWERBMGp2VnpxYU1qYzlYZDRFV3lTaVJzK2lNWnZ0NndldjhRak9Vc1dvbXExS3JGSVpqS2VabzJZMlBaRU5ObDAvVXJwOFo2K3YxSzdkMGhKbGQ3b3gvT1RGRXdRbmdGSTBUc01ESFFkZm9oK0xDT0hqWXFEVW5ZN0tLTlJ3V3MwTnptKzJPRzhTTWVmNDdTWTcxajVXYy96dklyVmVxdERUejhmUVQrekVLMnNIeEI0YmN6SUpUZkhEZmdEMnQ4c2Z3QUFlTnBqWUdSZ1lBQmlvVTJHZ2ZIOE5sOFptRmtZUU9DeDQ0WkdCUDMvSlhNUTAyb2dsNE9CQ1NRS0FCZUJDbzBBZU5wallHUmdZR2I0endBa2d4ajhHZnlaTWhtQUlpaUFDUUE4Y3dKbEFBQURVZ0FBQXJnQVR3Q1NBQUFBQUFBQUFGWUFpSGphWTJCa1lHQmdaakJpWUdJQUFVWUdOQUFBQmJFQU9uamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU3ArYm00T1RxOFBickFuU29hbWt0ZWdpL25SdlEvQUdEdDg5NTl3QUdTOFNoa21ZQngwbWxUZVBQT2FIUmVTSitLdklHYitzR1pHa00zRlc3Q0tuVFBtUFBHWkpHWGtpL2lOeXhoL3ZmVlBmN3AzMTZ0Z1k2OTJsOXR1VDlXM1ZPTFhSK2JBZXJMUCszRm1qeXFjeWZkWDIxMW9WT3RjRmV4cHFidHpwc0hnVVIzRk1ZTWRGTXMrV1U5aGJLc21jZERabzhtOTZrTlNGeGpuOFlxUlI4aFExOUhMVGlsNmxxeWpDbmFiNEFGVXlMa01BQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmNBQW9BQUFBQUE4UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV0MG9tTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ0RaMng1WmdBQUFXUUFBQUNrQUFBQXBMNm1RNE5vWldGa0FBQUNDQUFBQUM4QUFBQTJLRzJrazJob1pXRUFBQUk0QUFBQUh3QUFBQ1FGUndJTGFHMTBlQUFBQWxnQUFBQUlBQUFBQ0FVYUFETnNiMk5oQUFBQ1lBQUFBQVlBQUFBR0FGSUFBRzFoZUhBQUFBSm9BQUFBRmdBQUFDQUFCUUF5Ym1GdFpRQUFBb0FBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEVEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNQmd3TS93SDhwa2gwa2hxL2dPRkFkUkZETjBBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmdHLy85RHlQOFh3WHdHQUZFeUJvd0FBQUFBQWdBei8rd0NFZ0tvQUJvQU1BQUFBUllIRGdFSEJnY21KeTRCSnlZM0pqYytBVGMyTng0QkZ4NEJBeFkyTno0Qk5UWW5MZ0VqSmdZSERnRVhGaGNlQVFJUUFna0hIeDR6YjNBeUh4NElDUUlDQ1FjZ0hqTnZQVnNaSXhydUlWQVNDUVFFRlE5Rkt5Sk5FZ3NGQWdNS0VVd0JSeWROS2xjalB3UUVQeU5YS2swbkowd3NXU1JCQkFFeUpUV0EvbTBCTUVVeGJqbUdWQzB3QVN3N0syMnRPaTQvTW5qYVkyQmtZR0FBNHJ0bW16bmorVzIrTWpDek1JREFZOGNOalFqNi94dW15MHdyZ0Z3T0JpYVFLQUEyK2d1V0FIamFZMkJrWUdCbStNL0F3TUIwbWNHWXdaUkppQUVvZ2dLWUFEM1hBbGdBQXRNQUFBSkhBRE1BQUFBQUFGSUFBSGphWTJCa1lHQmdZakFFWWhCZ1pFQURBQVY5QURnQUFIamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU2grNHVEazR1VHE4elpvZ0hacEtXb3N1NGsvM05nUnY0UERkYzg0TmtQRWlZWmlFZWRCaFVubnp5R04rV0VTZWlMK0tuUEhMbWhGSk9oTm54UzV5eXBUL3lHT1dsSkVuNGo4aVovengzamYxN2Q1WnI0Nk5zZDVkYXI4OVdkOVdqVk1iblEvcndUcnJ6NTAxcW53cTAxZHRmNjFWb1hOZHNLZWg1c2FkRG90SGNSVEhCSFpjSlBOc09ZVzlwWkxNU1dlREp2K21CMGxkYUp6REwwWWFKVTlSUXk4M3JlaFZ1b29pM0dtS0QxaXNMa3NBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVM4QUFvQUFBQUFCWUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVZDFlR050WVhBQUFBRTRBQUFBTlFBQUFEd0Fsd0JkWjJ4NVpnQUFBWEFBQUFIcUFBQUNTRzhjSXE1b1pXRmtBQUFEWEFBQUFDOEFBQUEyS2RXajlXaG9aV0VBQUFPTUFBQUFId0FBQUNRSG9RTFBhRzEwZUFBQUE2d0FBQUFRQUFBQUVBem9BWHRzYjJOaEFBQUR2QUFBQUFvQUFBQUtBVXdBc0cxaGVIQUFBQVBJQUFBQUZ3QUFBQ0FBQmdCYWJtRnRaUUFBQStBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRXNBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXRtS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHJxTUVReU0vd0g4cGtoMGtocS9nT0ZBYnFsRExBQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUSzZqQkUvdjhQNU9zd1JQei8vLy9xLzFWZ1ZVQUFBSkF6Q080QUFBQjQyaTJRelc3VFFCUkc1N3QyWm1ySEhzZVRzVTMrbGFTTkN3SW5DbzBOS2twb2hLb0tJYkZDN1JxV2xEMmJicEJnaTBEc3VzNEtIaUd3NEFVcUhnQ0pGMkNKeENwaFhMR2IrOTJadWZjY0J2WmxleDhGdTJBUlkzczh6WENRRjExRVBBQVhHUlZ6UUllTlRyL2ZHZDZ5VTVuNndvTk1DaGtBdTlNOVlENDdtMFYzQU45M3dsUEdHTmlMN2NZK3BEVTdNMFc5aTd0NUhNVmlEREZJNTBqbUdJMFJFQmM4N2lGTytKaE1YdVJteklLc0RFTSttbzJLcE1nVGlYUWdFcE5uNE9aaGo0bzQwVndNdUtETGI1WE9SR28wSHk0L2hBUlZhVGRSZWYvMmxjUE5HdG9Ud0kzRjhxVzBMRXNlUCszVy9xNHE3YW1zby9IbVkyQWg1TzNXeGVkR0NOMnlUYkU0T2cvSWRiTm5HZDV0dm5zUzNHdVJCVHZVTHNoM3hlL1h6ejNINFQ2UjVmV3VHNEZIMW42citndTZhaFQ1VGJKdHFIb1Y2c2RsRkVVT2FlM0EzS05nUjZPOWIzeWNiN2ZXSC9yS1RoaHpJRXF2QnQxSWtSaFRnRkY2a0NkeHZzQi8rdHlRWHRNTEx1b3cvT2xnbEpwd2dXa3BZQ2dock1ubTZxWURncU51MXhRVVAzN3krSkZDcklyZVRyWVc3YkZVRkMrUFBobGE1YmRqV2tGcXp4NXlEeFRmZXpESmJBK3FPbHRxT3R6OFhQVWR5VzN6Ri9laWNtOFlhZWFBb0wvR2FjMDNnTjJTR3FyMFFjN21DcGFXQ1lscUdjTVNidDIxZHhWai93QUh2MG9uQUFCNDJtTmdaR0JnQU9MUTF2VmI0L2x0dmpJd3N6Q0F3R1BIRFkwSStyOGxpelhUWGlDWGc0RUpKQW9BTjI4SzBRQjQybU5nWkdCZ1p2alB3TURBVXN5US9EK2N4Wm9CS0lJQ1dBQlU1QU40QUFOVUFBQUIxUUNzQkhNQVl3Tk1BR3dBQUFBQUFDZ0FzQUVrQUFCNDJtTmdaR0JnWUdHSVpBRFJERkFTQ1FBQUNZUUFZUUI0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFXTUFBb0FBQUFBQnBnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoV0YxQ0dOdFlYQUFBQUU0QUFBQU5RQUFBRVFBYWdFV1oyeDVaZ0FBQVhBQUFBSzFBQUFEVkhYazU5Sm9aV0ZrQUFBRUtBQUFBQzhBQUFBMktPK2ovMmhvWldFQUFBUllBQUFBSGdBQUFDUUdoQUdzYUcxMGVBQUFCSGdBQUFBVUFBQUFGQTIwQVJ4c2IyTmhBQUFFakFBQUFBd0FBQUFNQWJJQ2dtMWhlSEFBQUFTWUFBQUFGd0FBQUNBQUJ3QklibUZ0WlFBQUJMQUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZnQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0yc3M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFkwaGpadmdQNURORHBKSFUvQWNLQXdEdWZRMVplTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1VGNHRUlaMHY3L0I3TkNRS3ovdS8rdit6OFByQllNQU9oT0Mzb0FBQUI0MmtXU3pXN1RRQlNGZldZbU0zSGNlQnc3bVRScG1rQ2MyaTJGdGhDd1VhbGlHbjRxVVVDd0tBV0VBRkdraXI4bGlDMGJZSUZZZ2NRR0NkNEFDUW14Z0IwdmdNU0tCMkRGQ29rbERkY0ZoR2JqZTgvVnpQbDhyZ1ZyWlRUaVo5aDc2N2hsUWNsNnRWOVBYTXhEZGFPa2JwSTBTTklrbW9la2FtZGlORXdZNVIwVlJsTHhQZzBNME45WDEweUczVGhqU1JUaWNpYlFTVUpvK2VxUlJxVzgySklQT1dCN2NRZSt5OEpxbVFjSXFnWEdoeHN2TzE1aGVUTmJjcmx5UEloVUNkc0RsMkJUQjNGaXBFV0ZpVkJCaUk0Q2drazJYaHBUSlBJdWxiWjUyK1ROL1ZrS2xNM1dDRk9IeW82dWZ2VUx1andSakJ1TGNLemR4RFpEYkVNcXVJWTBIZXd6TmNKamFnNEgvZ0ZHczRpVXBPT0N1aGtHSU5TNnFzbzRUVElrVVV6OHBPSEhZOElvTjVicUFUeDE3dEliUjZIV1BEWE5uOEF4c3hzTDd0aDBUeFJyc3JBc3hueDJyNDFXRDB3Q3FPd0l4dTgwUElmZC92WE5MZGxGeGtTcG9zQWhVT0wwZ1ZxTExTak9xOHJwM25CTDFQVGZhYUwyUDQxRE8zRmxvclhMeWUvQldNNTBlZlNkcjdFUGY1aHkxM09JTXdTVUE5a01aVHhBQjFtT1NmN3pqR1N0alpRNEUwcm5RREtQYUhzaU5TNWlGK3pMeGNuMTg3ZXZQdUN3ejlJanR0ZHdPNHpwd3ZYTm9TUDk4c0cyMkNpeHRYVDRmRTVWRjFxTUh5VmowSVZiTnpYY3d0SXNPN24xWW5ObGhlUEcxZFlzamsyYnNnUVh2a2Z1R1NzSkw0K3RzWFczMTF2TmdQVnJ3ZW1QOTZVZGM4YnRmRVN3aVNMNExtczdxOVhSUEx2SlBsdUgvMlpGZjV4MmtNejJUZDFJUmRFTmtQRXdYOFQrQU50clorb3VRb29uU1FuZFpScjl4TWdZcnhjOTRUWHQ1YjNUaTBDdkZuSG9qdGE2dDVOUHp1bVRiUmJvczdybW1tRTRzd1NFaG5TdnJiWHZ0MHZGNXBWY3hyT3RUeWNxaC9kWGovQW9iTzlnUFJrN05vTllyYjM0dVo0djMvcUZpVGlhNnYyWDBJajJQQlhkSWdqbE45bGtic0lBQUFCNDJtTmdaR0JnQUdMUFRkS3Q4ZncyWHhtWVdSaEE0TEhqaGtZRS9WK2ZPWlRwSXBETHdjQUVFZ1VBSFRvS1VRQjQybU5nWkdCZ1p2alBBQ1JsR1hUK2R6S0hNZ0JGVUFBckFFMW9BellBQUFMR0FBQUM1UUJIQXJJQUxBTWRBRjRDT2dCTEFBQUFBQUJ1QU5nQlJBR3FlTnBqWUdSZ1lHQmxjR2NBMFF4UUVna0FBQWZkQUZBQWVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFZOEFBb0FBQUFBQjhRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoV0YwM1dOdFlYQUFBQUU0QUFBQU9BQUFBRVFBYWdFSloyeDVaZ0FBQVhBQUFBTmFBQUFFY0dJY3hhMW9aV0ZrQUFBRXpBQUFBQzhBQUFBMktRR2twR2hvWldFQUFBVDhBQUFBSGdBQUFDUUdnd0dkYUcxMGVBQUFCUndBQUFBWUFBQUFHQSs2QU1Oc2IyTmhBQUFGTkFBQUFBNEFBQUFPQStRQ25tMWhlSEFBQUFWRUFBQUFGd0FBQUNBQUNBQmhibUZ0WlFBQUJWd0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUdNQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1tczg0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFk0aGtadmdQNURORHBKSFUvQWNLQXdEaUhnMHVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1VGNHRUlaSXYvL0I3TkNHQ0wrLy8rLysvKzYvMnZBYXNFQUFPWmxDMjE0MmsyVHpXL2NWQlRGZmU2ejM1dnhQTnZqamo4NkdZOG43U1Iyb2pTVGttUThUZHBrUkZ1QnFGUzFGZDBCTGFMUXBpd3EwUzZnR3lSS3BmQ3hZQUVibGdqQkJna0pSQkdnU216NEI5aDFnUVJMMkNDeDZJN085SHFtQ2RnTFAvdjY0L3pPT1RaZzVPT3hBUDFvbkRFTUtCbkxxRU9yY1NCWG9QSXNYeS9pcUJnMGh1aEI4dnBRRVhrSXNpSDZSYmFFVENxeHh1TWlYdTJBQnk2NmgvTkJrUmRaRjhYUUFuUllKTUwwMUtlN1ZRdWV1NWxhdXlZd3YrSFY4YkNoUmRpQ1JjZGYydTAwckpPWGhvVW50QklFODVpd1ZJMkVUVFE3d05seFJOVXFFYlFySVhoYzlTVFFTQ24xbGFQTVJBSFZ4amVKYVIrZDJSeWczaHo5aTRYak1WbVMzTitkaXRaTEtqcG84QWFqT1I3VHIvU0RjWUpQaEFxaURncTFoNWt4QW1NeVNvbWxaTGxuK1JEYllPU1kxME94bnFtdWNvRjc3NW4xNk9sTXVKV3Z2OUxNZUdEbTNJSjRYN0NNWU9HVkk5cWVPMnpGa0Z1bTl1bFlDeWxhRUpLZU96dmZxdHAwNDlFZmthNFFDYzlWK3pCaFF0Mkt3MVkyVlhYK1drUjI0N3R5NnY0U1V5MVludDlva3lDUDlaOGEvOFdlM0RlMlMvMHVWQTg1eXlyNjY5MmNvK2xnRUVjY1cxNkdJajMrOE5vMkJnMEd5bVcrRFI0enNJdmNCWDN3UXZ1elY1Ky9SVlJkV0s3SlZ0NTI1TjI3RlE0bzZMZk5LeXlQbnVtZi96aTVEQ1JMbm9DMlhyOCtDY0E4c1V6blI1L3NmR1RpNnFVZy8vemVVaXg5RWttSkFxcXdhSVN0MFJ2ZDhPREpVN2g5SFcvVmZJWjNKNmd3WlhsY1pJNkUrM2FOT1M0eng2QVk5R2hmWGlDN3pNWGllYzM2NHloMHNWZERwdW12b095WW1veml5U2hid1dRMEpORkQ5d2xvbktKOFVZaC92cXdMNmpRQXg3cjVNaU5vdXpjTW00TTcvdHc1dS8yVVZxVGx6WGU0bWJxU3B0Yk9penUxT3FoVFVWeFJiZDJhUHBDZnlad0h0NjNrU0VqbHhlbmRzd20rK05hTkF3MTdIMDZLTklpMlB1eGQvQ24xUVBaZVdibWlCNVQzOExVYnRkZ0phalJ4YWZLQUoyazIxMzhpcmZ0N0ZsR296TkNhZEhXT1BkTHMwZWxwMWg1a0tMbXYvOW5CZitXUTh2OURsK0Z6OWkzMnRHeEdmM0oxZFdvcFhSbEpTeXhibEdadGFQbHVpZUc2bXgxMXlESGZ0bVpLT0djSzU0Ukh4WnQvZXpXMGZBbEhYcjNvNk1yYVZrVFBqbjZUMnYwK1VBd24yazhTOXpqeFlQSE9obzhMamZvK0JTTlMxUi85REQvdzJuWjVYbnJSbE5aaTB6QWVBOUM3ajRnQUFIamFZMkJrWUdBQVlsblBBK3p4L0RaZkdaaFpHRURnc2VPR1JnVDkveVZ6T3RNZUlKZURnUWtrQ2dBVStBcWFBSGphWTJCa1lHQm0rTThBSkFNWUpQKzdNYWN6QUVWUUFCc0FUSVlESmdBQUFuWUFBQUtTQUNjQ1ZnQVpBcm9BUXdOUUFCd0NVZ0FrQUFBQUFBQjBBTlFCT0FIS0FqZ0FBSGphWTJCa1lHQmdZMGhnQU5FTVVCSUpBQUFLYVFCcUFIamFUWTZ4YXNNd0VJWS9VOGRRcDlDcEhUb1VUUm1GamZzQWdReVpzbVlzSkpFSURrZ0tzbVBJRXZvQWZlaGVGQTA5d2ZIZGQ3K0VnSm9iQmZjcWVFMzlYaVdWVEErZU1lY3RjeVZIWmE3NVlNRVRSZmtzNXBObDVwSVh2alBQZU9lVXVSTC9rN25taTk5VmNPZkxhS1BhQkdPalB6alh0ODNXeHFFUFhyVzZlWWkxOVRidVJtdlUvcXJNMUEvVDBhbE9ON3BqUmNCeDVzS0lKY3JQTm1KTVlzOUJkbzZlbG9adGNvTk1RVFpLbkJiN1A3R1doRStwWFhyTlNHclBWYnBoa3N3Zy9TaHBSWmZ1YXJvLzMvUXd1d0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTU1LjMwMTEyLC01OS45MTA2MDQpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNy42MzAyMiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTUuMzAxMTIsLTU5LjkxMDYwNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTUuMzAxMTInIHk9Jy01OS45MTA2MDQnPlQ8dHNwYW4geD0nLTQ4LjA5NTQ3Nyc+WTwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04LjE1MTAzLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTUuMzAxMTIsLTU5LjkxMDYwNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTUuMzAxMTInIHk9Jy01OS45MTA2MDQnPlQ8dHNwYW4geD0nLTQ4LjA5NTQ3Nyc+WDwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEzLjc0NzYyLC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU1LjMwMTEyLC01OS45MTA2MDQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU1LjMwMTEyJyB5PSctNTkuOTEwNjA0Jz5UPHRzcGFuIHg9Jy00OS41MjMxMjMnPmY8L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0My40NzQyNiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTUuMzAxMTIsLTU5LjkxMDYwNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTUuMzAxMTInIHk9Jy01OS45MTA2MDQnPlU8dHNwYW4geD0nLTQ3LjQxMjY3Mic+RjwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00MS4wMDYxMjgnIHk9Jy01OC40MTYyMjQnPjA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTM2LjUzNjc1OCcgeT0nLTU5LjkxMDYwNCc+WTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Mi45NTM0MywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU1LjMwMTEyLC01OS45MTA2MDQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU1LjMwMTEyJyB5PSctNTkuOTEwNjA0Jz5VPHRzcGFuIHg9Jy00Ny40MTI2NzInPkY8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDEuMDA2MTI4JyB5PSctNTguNDE2MjI0Jz4wPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zNi41MzY3NTgnIHk9Jy01OS45MTA2MDQnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEyLjE4NTc2IDBIMzguNDE4NzInIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguNjY4NzIsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNy4xNjM5Niw0Ljc4OTYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01NS4zMDExMiwtNTkuOTEwNjA0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01NS4zMDExMicgeT0nLTU5LjkxMDYwNCc+RjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTAuMjQ4NTAzJyB5PSctNTguOTA4NzkyJz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00Ni44NTgzODInIHk9Jy01OC45MDg3OTInPixZPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTcuOTA5N1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTMwLjAzNjA3KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTUuMzAxMTIsLTU5LjkxMDYwNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTUuMzAxMTInIHk9Jy01OS45MTA2MDQnPlU8dHNwYW4geD0nLTQ5LjEyNjA3Nyc+RjwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00NC4wNzM0NicgeT0nLTU4LjkxNDM0Jz4wPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00MC4xODUyMDknIHk9Jy01OS45MTA2MDQnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEyLjcwNjU3LTU2LjkwNTVIMzcuODk3ODknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguMTQ3ODksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE2Ljk0NTE5LC02NC41MDA2NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU1LjMwMTEyLC01OS45MTA2MDQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU1LjMwMTEyJyB5PSctNTkuOTEwNjA0Jz5GPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01MC4yNDg1MDMnIHk9Jy01OC45MDg3OTInPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ2Ljg1ODM4MicgeT0nLTU4LjkwODc5Mic+LFg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = TY,
    ne = {UF_{0}Y},
    sw = TX,
    se = {UF_{0}X},
    north = {F_{1,Y}},
    south = {F_{1,X}},
    west = {Tf},
    east = {UF_{0}f},
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1213</fr:anchor><fr:addr
type="user">log-000E</fr:addr><fr:route>log-000E.xml</fr:route><fr:title
text="Beck-Chevalley condition">Beck-Chevalley condition</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[T\colon \mathcal {C}^\mathrm {op}\to \mathsf {CAT}]]></fr:tex> be a <fr:link
type="local"
href="log-000C.xml"
addr="log-000C"
title="Doctrine">doctrine</fr:link>.
  Suppose that for each morphism <fr:tex
display="inline"><![CDATA[f\colon X\to Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> admits a left adjoint <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex>.
  Then <fr:tex
display="inline"><![CDATA[T]]></fr:tex> is said to satisfy <fr:em><fr:strong>Beck-Chevalley condition</fr:strong></fr:em> if, whenever there is a pullback shown below, we have <fr:tex
display="inline"><![CDATA[f^{*}\Sigma _{g} \cong  \Sigma _{h}k^{*}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="d804ae405338fd0a02688b09c61d7252"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNy40MDc2NTZwdCcgaGVpZ2h0PScxMTQuOTAyMzMxcHQnIHZpZXdCb3g9Jy03MiAtNzIgNzguMjcxNzcxIDc2LjYwMTU1NCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdVQUFvQUFBQUFCdGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjB4Mk50WVhBQUFBRTRBQUFBTWdBQUFEd0FnZ0RDWjJ4NVpnQUFBV3dBQUFMQ0FBQURuUEtyWjJSb1pXRmtBQUFFTUFBQUFDOEFBQUEyS0dDa0oyaG9aV0VBQUFSZ0FBQUFJQUFBQUNRRnFnR2NhRzEwZUFBQUJJQUFBQUFVQUFBQUZBeFVBUkZzYjJOaEFBQUVsQUFBQUF3QUFBQU1BYTRDb20xaGVIQUFBQVNnQUFBQUdBQUFBQ0FBQ0FCWWJtRnRaUUFBQkxnQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRmlBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUttZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTVdRek0vd0g4cGtoMGtocS9nT0ZBZG1BRFRnQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS1pqQmsvLzhQNUtlQjZQK3ovODhFcXdJQ0FKbU5DVDRBQUhqYWJkTkxiOU5BRUFkd3o2d2ZzUk43NDllNlRWSTNpWjExcXFaSjI2Uk9XMExhTkFXcDd4WUpTaEdDRXlCeFF1S0NRT0lUSUlRUUI2N2MrQXJjSy9YTWh3R0pTOHVhOGpoUTcyMW5EL09iLzFnQ2FlZWlnMC94cTdRdVNVQW9xSm9GV3AwblEraXlnS2thbTRZaHJKRkk1V25RSFVKZjNDK3l3SUtJSnp6dDh3NVlTS0diTWpXQlQ2dEZ1VmpTUnd2TlZZRFk1d1RvTktVMHJwR3BOdDBOMGFWSDFMZllSalF6QUlpWXFCZERTaDBuTkhLbGgxa1pQcHlmYnR2clBXOU1lQlJXTVZhVHZJNGc3L2dmdngyVHVnYkhKK1dFTitKL0paamtjMi9sZWc0azhhSFV1cGpEQnB4S2JXbWNhWVJFL1NVUkhYdXFGckF1U3dWZ1RTRGJrS1Q5N0lRUUNKVjRRTllnVFFSSzFiSVJzR0F4ZTRxMVovcnpGNTBIc3VqWFptQTVGYnZtRGFJSzA0TCsxdWdFeVlqYVd5Zk5KWk9VSE5PSDl4MENudDhyamF0KzBRYWVoQnVWZ2dZdnowZWRld1Q5MWxUTmRmT2hvU0RrSzVQejFmdGRHWTRQSCsyN2RKTkF6SW9NaXZiNWp5ODAzNGhrYUM3eDBmcEJIeHBWYWdvYlNIc1gzL0VWbmtrN21VeTBIS0ttWHNibHExbXphVGNJaFZjY2tWNVBZREllVDdJWlVGbmsxWWFsdmpzRUhsMkcyMCtaQnFQOXlxMlZtNzBDb0lkdXdUUklaWHJnb0cyb0VPVHRhTmhjQm1KYWpDR3k1dUJ3Z2lwdVZjOFpnZTdZeWpzWmFhd1hBU3h0czlVQS9IeCtWdXVDMHVtWjdZRjZyVnlyMlhWY3UrNGdCdk1CYTh1ZG1VSytHbStNRi93RnhIR1Q1YmRmOHpMTmcyc3kzRFNwSVJzMHA4bWs4TnQ1UXpqdlpNNHNnMFhtLzEwM29jM01ZalBGOFNqeFdIQzVrOW5GSHp6dnA0bklsNElGZFg0Rit2SDAzZVRvTmhjakZ5c1lWQzF2OWlEaHdVUzFSK204akVRQjZ2RlpnMmlHcmdJVURhK3lrb3dSRkFLd3ZSeFJPZUJYOFo5WXU0Mmxsb0JqYk1VNUMyQ1YxenpSZ3FLekZVTTN5Njc0a2VTOW1CcUlodEl1VjlweU43VWNTMjBteXB0VlorSy9RVWpTVHd5d2RSSUFBSGphWTJCa1lHQUE0bEJmYWNsNGZwdXZETXdzRENEdzJISEROQVQ5WDVmcEdOTkZJSmVEZ1Fra0NnQUUxQW9rQUhqYVkyQmtZR0JtK00vQXdNQjBqRUhuL3dXbWFnYWdDQXBnQlFCbVlBUktBc1lBQUFJNkFFc0NPZ0FzQXF3QVRRSnVBRTBBQUFBQUFHWUExQUZJQWM1NDJtTmdaR0JnWUdVSVoyQmlBQUZHQmpRQUFBbUVBR0Y0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVWtBQW9BQUFBQUJmUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUYyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1haMng1WmdBQUFXUUFBQUpZQUFBQ3VKSGpjY2xvWldGa0FBQUR2QUFBQUM4QUFBQTJLTkdrNzJob1pXRUFBQVBzQUFBQUhnQUFBQ1FHWGdJbGFHMTBlQUFBQkF3QUFBQVVBQUFBRkE2b0FLdHNiMk5oQUFBRUlBQUFBQXdBQUFBTUFXSUNERzFoZUhBQUFBUXNBQUFBR0FBQUFDQUFDUUE2Ym1GdFpRQUFCRVFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGR0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtZXNjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJoWnZnUDVETkRwSkhVL0FjS0F3RDcxUTFqZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1Fndmd1Ly84RFNjZi8vLzhmQVBNWkFGTEtCcUI0MmpYUnYwOFRZUnpIOGVmemZOdm5hR252S2xmdWFxRFhsSlllWUZvSXZkd0JpY1ZRcVFpeC9LaEJnbzFFRXlTU2lEOUFaR0RvZ0RFYUdJd0ppWEZ3ME0wNHV6ZzVNVG01T3FpVDhVOHdiWDJPaE9kWm5ueHp3L3Y3T3NaWnR0M21QL2tQTnN4R0dmUGdlcU9HcWNlTm9tdUlZU2gyem5aYzAzQzlZYVFWRVRkTTExUWg1LzY0V0lKWHBNOVlGL0dvUU1uSWR5TVMzR2wwQkJIdDFCMEtLYTEyTmRxclJ3blI0TVpLQkpGUVgrbk4zL1F1WDQ0aHBEVWJoa1pKQlVUZ0hab0NSTXk3MHdmeGJBeGNVNFUvRG1zQ21STXNNWG1JWFdnM1NmQXZ6R0pEYkV5VzZrN0dGckl0YmFGYmhXTEJGQnFFa2hhbnZib2Y1K2JzVEU0b2RQWW0rVUh4dzFHUG5kUTByTlR2VUtNMlZ3Ty9FcnYycFBXNlYxVW5ySGZIYXpzY2hmSkJTZzl1SGRaM09SK1orVm9KQU9vQ0h6L0hxVmNCWDV5WTNkREMxZkc1S2JVVThEZUFqbWw2WE1sZTV0RE9Oei9TMDJyL0FyVitkNGt3WTJERjloL3E1Ti85WnBDS2pCU2RoSk96WmJNZmJGcndKSzlmbUlJbEY1RHpBbXpYODY5aEdxWW4xNkh3SlJMaFVCQWN5L1BUejBZcVBjSkFZUC9xd0pycjVFVWdwQVFwWHhsOFZONTdTMVJ6WnJjUGFvTURZa1pGaEorMC9xbXlXZEZ5cTV0QWVXeGxMVkhQNzk3bTZCc3ExQk9kQUkvY24rb3ZnbzRiTDNabW5TVUtaUHZWZVpXVE5PZHNVSnA3MGp6QjhyNjRld1p1Q3NXL1o5YW5ycWEvd2lSY3V3QkZxcjgvUXRtS1NlYnRmZEQ4ME5obW8vVXBxVW5pWDRjKzU4dGJlK1pFb3FNTC9GNTFLNlZMM1JoUlV2NzJWdytlUDd5WXYwNWtDUW5MeTgxdjBoR0JoZFRpemZRTmUzMFYwR1RhZi9RQmQxZDQybU5nWkdCZ0FPSmpRV1ZyNC9sdHZqSXdzekNBd0dQSERkTVE5UCtYek9aTWQ0RmNEZ1lta0NnQVJ0WUx3d0I0Mm1OZ1pHQmdadmpQQUNUOUdWVCtYMkEyWndDS29BQldBRlVyQTRrQUFBSjJBQUFEQUFBa0F3Z0FLd0xiQURNRFR3QXBBQUFBQUFCVUFMQUJEZ0ZjZU5wallHUmdZR0Jsc0dSZ1pnQUJSZ1kwQUFBR3JRQkVlTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjc1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02MS4zNDIwMzUnIHk9Jy02MS44MDM1Myc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy45MzEyNCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTcuNjg0MDUsLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPms8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuNjI3MDMsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02MS4zNDIwMzUnIHk9Jy02MS44MDM1Myc+RDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC4zMDU1NCAwSDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjUuOTY1MTgsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5oPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjM0MjAzNScgeT0nLTYxLjgwMzUzJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjQ4Njc5LTU2LjkwNTVINDcuNTcxNDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuODIxNDksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI2LjIwMjkxLC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuMzQyMDM1JyB5PSctNjEuODAzNTMnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = A,
    nw/style = {pullback},
    ne = B,
    sw = C,
    se = D,
    north = h,
    south = g,
    west = k,
    east = f,
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  <fr:p>Furthermore, if for each morphism <fr:tex
display="inline"><![CDATA[f\colon X\to Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> admits a right adjoint <fr:tex
display="inline"><![CDATA[\Pi _{f}]]></fr:tex>.
  Then this condition implies that <fr:tex
display="inline"><![CDATA[f^{*}\Pi _{g} \cong  \Pi _{h}k^{*}]]></fr:tex> by the uniqueness of adjoint.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1214</fr:anchor><fr:addr
type="user">log-000D</fr:addr><fr:route>log-000D.xml</fr:route><fr:title
text="Frobenius reciprocity">Frobenius reciprocity</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[T\colon \mathcal {C}^\mathrm {op}\to \mathsf {CAT}]]></fr:tex> be a <fr:link
type="local"
href="log-000C.xml"
addr="log-000C"
title="Doctrine">doctrine</fr:link>.
  Suppose that for each object <fr:tex
display="inline"><![CDATA[X \in  \mathcal {C}]]></fr:tex>, the fiber <fr:tex
display="inline"><![CDATA[T(X)]]></fr:tex> has finite products <fr:tex
display="inline"><![CDATA[\wedge ]]></fr:tex> and that for each morphism <fr:tex
display="inline"><![CDATA[f\colon X\to Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> admits a left adjoint <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex>.
  Then <fr:tex
display="inline"><![CDATA[T]]></fr:tex> is said to satisfy <fr:em><fr:strong>Frobenius reciprocity</fr:strong></fr:em> if for each morphism <fr:tex
display="inline"><![CDATA[f\colon X\to Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, objects <fr:tex
display="inline"><![CDATA[\varphi  \in  T(X)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\psi  \in  T(Y)]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[\Sigma _{f}(f^{*}\psi  \wedge  \varphi ) \cong  \psi  \wedge  \Sigma _{f}(\varphi )]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1215</fr:anchor><fr:addr
type="user">log-000F</fr:addr><fr:route>log-000F.xml</fr:route><fr:title
text="Hyperdoctrine">Hyperdoctrine</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:em><fr:strong>(first-order) hyperdoctrine</fr:strong></fr:em> is a <fr:link
type="local"
href="log-000C.xml"
addr="log-000C"
title="Doctrine">doctrine</fr:link> <fr:tex
display="inline"><![CDATA[T\colon \mathcal {C}^\mathrm {op}\to \mathsf {CAT}]]></fr:tex> satisfying the following additional conditions:</fr:p><fr:ul><fr:li>For each object <fr:tex
display="inline"><![CDATA[X \in  \mathcal {C}]]></fr:tex>, the fiber <fr:tex
display="inline"><![CDATA[T(X)]]></fr:tex> is cartesian closed and has finite coproducts.</fr:li>
  <fr:li>For each morphism <fr:tex
display="inline"><![CDATA[f\colon X\to Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> admits both a left adjoint <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> and a right adjoint <fr:tex
display="inline"><![CDATA[\Pi _{f}]]></fr:tex>.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[T]]></fr:tex> satisfies <fr:link
type="local"
href="log-000E.xml"
addr="log-000E"
title="Beck-Chevalley condition">Beck-Chevalley</fr:link>.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[T]]></fr:tex> satisfies <fr:link
type="local"
href="log-000D.xml"
addr="log-000D"
title="Frobenius reciprocity">Frobenius reciprocity</fr:link>.</fr:li></fr:ul><fr:p>A <fr:em><fr:strong>morphism between hyperdoctrines</fr:strong></fr:em> <fr:tex
display="inline"><![CDATA[F\colon T\to U]]></fr:tex> is a <fr:link
type="local"
href="log-000C.xml"
addr="log-000C"
title="Doctrine">morphisms between doctrines</fr:link> satisfying the additional condition that for each morphism <fr:tex
display="inline"><![CDATA[f\colon X\to Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the following squares commute:</fr:p>
    
      
      <fr:figure><fr:resource
hash="e1a07a8c3af8aba49d7b25b9dcc4e693"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMyOC43NjU1OTlwdCcgaGVpZ2h0PScxMjEuMzA3NTUycHQnIHZpZXdCb3g9Jy03MiAtNzIgMjE5LjE3NzA2NiA4MC44NzE3MDEnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFZa0FBb0FBQUFBQjJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVWQxZW1OdFlYQUFBQUU0QUFBQVBnQUFBRXdBN2dEVVoyeDVaZ0FBQVhnQUFBTkFBQUFFR0hEWStKSm9aV0ZrQUFBRXVBQUFBQzhBQUFBMktkV2ovMmhvWldFQUFBVG9BQUFBSHdBQUFDUUhvUUxSYUcxMGVBQUFCUWdBQUFBWUFBQUFHQk1jQW01c2IyTmhBQUFGSUFBQUFBNEFBQUFPQTFvQ09HMWhlSEFBQUFVd0FBQUFGd0FBQUNBQUNBQmFibUZ0WlFBQUJVZ0FBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUdHQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0xbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBycU1LUXhNL3dIOHBraDBraHEvZ09GQWJnZkRMSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQ3lBTkJjREIxQ09pVUdId1kwaGtpSHQvMytnR0lnZEFXTC92L3Avei8vVi8rZURkVUFCQUVjbERia0FBSGphTFpNL2JPUkVGTWI5dmZIT3hMdjJlRzJQN1dTejJiQzdPVHVKTHJ0Uk5tdmZrZHd1aVNDYzdvSU9DblJIUXdFVjk2ZVBoSzVCT2hxS0U0anVHaWpTQUQxSUJBb2trS2hPaUJxSmpnclJnS0RhOEx5SlJ2TDR2WG1qbWQvM3ZiRmdmWFYrSGFYMTJJb3Q2NHJNQjlndHlnNWk2VU9xQVpVVHdBUkxLOTN1U24vVHpuWHVLUmM2TGJVUHJPMWNBU2JqZStONEMvQThKN2hyV1Jhc2svTno4VE45WXgxem9HUXFSMm1SeEJwRCtNankzU0xkS2Nxb0hHZER5R3pNWVpkWGxVWmY1bVdScVg3R0I0K1Nncy90OElicVB1TXBpbkdSOWZINWpScW90eGNiUlBLTE82OEdTTXkxRmZGRUJLWnRRdVBUZTlwRVVOcVFvT01IMzY0MmF6ZE9qcVkrMVZzSys3WnhIZGlDMWc3d3lsK0I5QW5TalRrRElUVFB6WlNNNTlrQXBHZWM2dnVUMWpDajJ3WGdwbjlUdnVmVm9lbmZsTkNvS2FPOVZqcG5mZmQ4WnUvUm1YV1BnNmlERWJNa2FnalZ5eWRJSjJCSW42U1N5U3FTVkE2SjgyV0ZOaVV4WU9Kc25KVnBXYVFhZVUrbG5COHc4QVNyVkNhcGthb25GVDM3dnJheXJRMWFMeDErSEJEQ1dydUYydE1uanh6SmtodFhBWXZUd3dkYU1NYlJuVTd6djlOYWUwZEhXUHJnRTE4Z2tPM2x4MTh1QlRETE5nZlRnNGVzUm4zdzVnQWZ6bjV3TlV1d1RBSjJZT29ncjY3K1BIbkhkUnpwRVFsM2RiN2d1eVRXbHh1L3d6VFlDNjlGdG8wd2FpRDg1VmtjeHc0WjFvcnJ5Rjh3YUsrekhnL1orMy9vTyt1bVpUbHNQbTlpOUF2NzZkTCtwSmppa3I1ZzBqbTlraW9DOCtlOUxPZmtGRHVWQUgwTkpiWm56emNjRUp6d2FqTkVLSStPYjcwY0lnbkwxWVhCbVdvUGRVako0Y0duVEJ0NjdZUk9vWTFyOTZVTFNxN3RidzlzRjJGamZHaG9iL2JiYWRmUjBzYWw5UUtYM3NQdm51RnUwMlBBVGtXTnNOS0RuTmx6Q0tOVFVvMHFEYUhxVWQxZUMrZSt2MysrUlQvU3J4VW5SUFZTK0tveVkrOUdjK2NZZW9LU1FZdXlmOUhsbytwL1BoSUc3bWQ1VnBUY0hiMUtJKzRhd3dyZ2ordjhobHJod1Zidk5ZR05lRk9ZMk5mUnlsb3RDTnRCNHkwdk12N2JETEM0NFBYZldML0ZKY21tZ050cCtsRXJyYnVManp5eklHeDhOUHQ2MHR2ZmFJMEl2VUd2Si9LZ1cxZk1VOFRUKzUvZGYvR2l3Vi92dnJEYkRJWTIxcTVXSlRMWEM0VEY1dlFwNUZKRHdMTCtCOVdtaFhSNDJtTmdaR0JnQUdLSHErK1d4dlBiZkdWZ1ptRUFnY2VPR3hvUjlIOWRGbXVteTBBdUJ3TVRTQlFBU2hzTFJRQjQybU5nWkdCZ1p2alB3TURBVXN5US9EK2N4Wm9CS0lJQzJBQlU1Z042QUFOVUFBQUIxUUNzQTNnQWVBUnpBR01EVEFCc0Fyd0Fld0FBQUFBQUtBQ2VBU1lCbWdJTUFBQjQybU5nWkdCZ1lHT0laQURSREZBU0NRQUFDYm9BWXdCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYURBMm9XQmlaV3BDMkFYWmJDTm5CQUpxZXJZMzkySDhkQTNYSjM3WVFNMVB4VGNyMkNXOUg0bGxiZ0hWMHlaWjU2SWU4dGNzK0NkSjRyeVdaSlhQaktYMG54bXJuamhLL05FOHUvTU5TdCtOOEZkcm9PTmFoZU1qZjdrWExmZTI5aDN3YXVsYnBMZldtL2pZYkJHSFcvS2pGMC9ucDFxZGFOYk5nUWNGNjRNV0NLS25TUW1zZWNrbmFOanpUNGx2WENRWExGRTAvenJ0OUw3dERta240eHNqdHhFRGFNc2V0R3piQlZ0ZXFscC93RElFUy92QUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRNEFBb0FBQUFBQk5BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVjQUFBQmdoY3Q0ZDJOdFlYQUFBQUU4QUFBQU13QUFBRVFEdEFROVoyeDVaZ0FBQVhBQUFBRnJBQUFCbExFcjdQeG9aV0ZrQUFBQzNBQUFBQzhBQUFBMktMK2twMmhvWldFQUFBTU1BQUFBSGdBQUFDUUdXZ0taYUcxMGVBQUFBeXdBQUFBUUFBQUFFQXU4QUxOc2IyTmhBQUFEUEFBQUFBb0FBQUFLQVJ3QWptMWhlSEFBQUFOSUFBQUFHQUFBQUNBQUJ3QXlibUZ0WlFBQUEyQUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQUVMQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lczg0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lOR0JpU1FVbHlXRHBRMFlGN016UEFmeUdkbVlBUUpNeUpVL0FjS0F3QWV6dzQxQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnTWdEUUhFSUxrREpnWE1DLysveC9CK24veFQ5S2ZCTEJhTUFBQStlMEw4UUI0MmxXT3ZVckRZQlNHenpuNXpOZW9hSk8yaVcwaE5VMlRTRnRMVFVoaUZRME80dEtDZzFERTFiWHFvcHMvazROM29ONkFDTTRPdW5nVDNvR0RLTHFLME9pbmd5Q2M0WG5PZWVFOVFCQjh2WkpHVjFDQ05nRHFmQUs1ekYydmhaNGJ1L0V5eGxGc29tR2lwRWZDd2toY2JGY1dNVU1YVzhxU3dpdG1zTHZuVjh5TVFzS21oUzF0RmUzU203V3VLWXdWSmxjYjFaNDJOa0xTcU5yRk5hOVg3OXNKWTRuZHIvYzhyOXZjckswdzlKM3dKQjFnZTNWdXAzTzZNZHZHNW1KamNMUFFTbnhBNkFCSUR0MkNKejVVWlgwUkN4NFBBei95Vk91L1JtNERRNnRnVjJXNm8vSjg4Zko4cWxPaTlQcVhMNHJ6WmZvaGV2Mmg3ZUY3T2VjdzV1UkxsQXdmL2xnVjVPUkJWTUVhQUgzU1BVd0RLR2dsR0ltSkEyNVYzVEJXMEkwTXk3QmJ5SzJjYm5DOFR0L1FuNTBKNXZSVzFxNE16OFpWd2tMNmpPTWFIVlRzN05GaG1qNHhDYkdiUHFHRXhXeHQvNE9OWnRERWdhYmd5M0dYcFkreXdnRytBWEl3U29vQWVOcGpZR1JnWUFEaWU2YXV3Zkg4Tmw4Wm1Ga1lRT0N4NDRaR0JQMy9EYk1xMHg0Z2w0T0JDU1FLQUNpVkN0a0FlTnBqWUdSZ1lHYjR6d0FrNHhtTUdVeVpWUm1BSWlpQUJRQTBIQUg3QUFBQzB3QUFBa2NBTXdOZkFEa0RRd0JIQUFBQUFBQlNBSTRBeWdBQWVOcGpZR1JnWUdCaE1HUmdZZ0FCUmdZMEFBQUZzd0E2ZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktIN2k0T1RpNU9yek5taUFkbWtwYWl5N2lUL2MyQkcvZzhOMXp6ZzJROFNKaG1JUjUwR0ZTZWZQSVkzNVlSSjZJdjRxYzhjdWFFVWs2RTJmRkxuTEtsUC9JWTVhVWtTZmlQeUpuL1BIZU4vWHQzbG12am8yeDNsMXF2ejFaMzFhTlV4dWREK3ZCT3V2UG5UV3FmQ3JUVjIxL3JWV2hjMTJ3cDZIbXhwME9pMGR4Rk1jRWRsd2s4Mnc1aGIybGtzeEpaNE1tLzZZSFNWMW9uTU12UmhvbFQxRkRMemV0NkZXNmlpTGNhWW9QV0t3dVN3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUElBQW9BQUFBQUJEUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFV0MUFXTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUVLQUFBQkVLTnhnUXRvWldGa0FBQUNjQUFBQUM4QUFBQTJLT3lrazJob1pXRUFBQUtnQUFBQUhnQUFBQ1FGdWdLa2FHMTBlQUFBQXNBQUFBQUtBQUFBQ2dhY0FFOXNiMk5oQUFBQ3pBQUFBQWdBQUFBSUFGWUFpRzFoZUhBQUFBTFVBQUFBR0FBQUFDQUFCZ0F6Ym1GdFpRQUFBdXdBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEdUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtZXMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUTBZREJrWnZnUDVETkRwSkhVL0FjS0F3RDJpQTA4ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy84RFNZUC8vLzlmQlBNWkFGRkRCbzE0MmhXT3ZVckRVQmlHdis5TG1vT3hGSm8ySjRKUU1Ebk5RZklqR3ByRHFaQjBWR3pyb2tNSjR1YlBvSnRUQzE2QW01T0xONkRYNHVCbE9EdGJQYjd2OUR5OHd3c0VwNzlmZEV0dnNBMzdBTWhaQjVuRFlwbWpqRldzS2xTbDRzRUFBNDY4VkdWdDlIOGRzL01kNCttYVhDWWl2VnJwU0RDWERBMGp2VnpxYU1qYzlYZDRFV3lTaVJzK2lNWnZ0NndldjhRak9Vc1dvbXExS3JGSVpqS2VabzJZMlBaRU5ObDAvVXJwOFo2K3YxSzdkMGhKbGQ3b3gvT1RGRXdRbmdGSTBUc01ESFFkZm9oK0xDT0hqWXFEVW5ZN0tLTlJ3V3MwTnptKzJPRzhTTWVmNDdTWTcxajVXYy96dklyVmVxdERUejhmUVQrekVLMnNIeEI0YmN6SUpUZkhEZmdEMnQ4c2Z3QUFlTnBqWUdSZ1lBQmlvVTJHZ2ZIOE5sOFptRmtZUU9DeDQ0WkdCUDMvSlhNUTAyb2dsNE9CQ1NRS0FCZUJDbzBBZU5wallHUmdZR2I0endBa2d4ajhHZnlaTWhtQUlpaUFDUUE4Y3dKbEFBQURVZ0FBQXJnQVR3Q1NBQUFBQUFBQUFGWUFpSGphWTJCa1lHQmdaakJpWUdJQUFVWUdOQUFBQmJFQU9uamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU3ArYm00T1RxOFBickFuU29hbWt0ZWdpL25SdlEvQUdEdDg5NTl3QUdTOFNoa21ZQngwbWxUZVBQT2FIUmVTSitLdklHYitzR1pHa00zRlc3Q0tuVFBtUFBHWkpHWGtpL2lOeXhoL3ZmVlBmN3AzMTZ0Z1k2OTJsOXR1VDlXM1ZPTFhSK2JBZXJMUCszRm1qeXFjeWZkWDIxMW9WT3RjRmV4cHFidHpwc0hnVVIzRk1ZTWRGTXMrV1U5aGJLc21jZERabzhtOTZrTlNGeGpuOFlxUlI4aFExOUhMVGlsNmxxeWpDbmFiNEFGVXlMa01BQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9NQUFvQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXRjFBR050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNaWjJ4NVpnQUFBV1FBQUFET0FBQUEzRUtlNFpob1pXRmtBQUFDTkFBQUFDOEFBQUEyS09xa3RtaG9aV0VBQUFKa0FBQUFJQUFBQUNRR21nRjlhRzEwZUFBQUFvUUFBQUFJQUFBQUNBV3JBRWRzYjJOaEFBQUNqQUFBQUFZQUFBQUdBRzRBQUcxaGVIQUFBQUtVQUFBQUZ3QUFBQ0FBQkFCSWJtRnRaUUFBQXF3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRGZBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXVzbzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWTNCalp2Z1A1RE5EcEpIVS9BY0tBd0R6bFExUmVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZodS8vOUR5UCs3d1h3R0FGTUFCcUlBQUFCNDJoV0tQVTdETUJpRy9mcHovQ2tVeDJrZE9WVmJGQkdyN2xpSklBY0JJb0lCcEU2Y29Bc0RONEZUSUhFSEZzN0NZUWhoZkg0RXhOTTQwclA4Rm85Q2dIVmRkWFVxc0FlM01kVSs5UzcxS2U2aEp6cFAzc0tIK0c4NFJNM1VUY01kdW92YVNoM2EzU0JURERnT0NrMEtzUHJ6M1dKdXJqZjZqWUM4M0RWWUZESlVoaHhjbFVsNmVQbG95dXorZGJndGlHY2xWTThxTDBFYWNudUZ3MmpWWEtyQVVLcGh3SjNKNWNrcFQ1SGFDWFAvdGFMVjVkQUR4ditPMk42WW1hMStGcGsxYTdmMFF2d0IyckFjUndBQWVOcGpZR1JnWUFEaXd4WE90dkg4Tmw4Wm1Ga1lRT0N4NDRaR0JQMy9QM01BMHc0Z2w0T0JDU1FLQUM2WUN5TUFlTnBqWUdSZ1lHYjR6OERBd1BTVXdmMy9WT1lBQnFBSUNtQUNBR1BkQkJ3Q3hnQUFBdVVBUndBQUFBQUFiZ0FBZU5wallHUmdZR0JpY0djQTBReFFFZ2tBQUFlTUFFMEFlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVk4QUFvQUFBQUFCOFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXRjAzV050WVhBQUFBRTRBQUFBT0FBQUFFUUFhZ0VKWjJ4NVpnQUFBWEFBQUFOYUFBQUVjR0ljeGExb1pXRmtBQUFFekFBQUFDOEFBQUEyS1FHa3BHaG9aV0VBQUFUOEFBQUFIZ0FBQUNRR2d3R2RhRzEwZUFBQUJSd0FBQUFZQUFBQUdBKzZBTU5zYjJOaEFBQUZOQUFBQUE0QUFBQU9BK1FDbm0xaGVIQUFBQVZFQUFBQUZ3QUFBQ0FBQ0FCaGJtRnRaUUFBQlZ3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBR01BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbW1zODRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWTRoa1p2Z1A1RE5EcEpIVS9BY0tBd0RpSGcwdWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VUY0dFSVpJdi8vQjdOQ0dDTCsvLysvKy8rNi8ydkFhc0VBQU9abEMyMTQyazJUelcvY1ZCVEZmZTZ6MzV2eFBOdmpqajg2R1k4bjdTUjJvalNUa21ROFRkcGtSRnVCcUZTMUZkMEJMYUxRcGl3cTBTNmdHeVJLcGZDeFlBRWJsZ2pCQmdrSlJCR2dTbXo0QjloMWdRUkwyQ0N4Nkk3TzlIcW1DZGdMUC92NjQvek9PVFpnNU9PeEFQMW9uREVNS0JuTHFFT3JjU0JYb1BJc1h5L2lxQmcwaHVoQjh2cFFFWGtJc2lINlJiYUVUQ3F4eHVNaVh1MkFCeTY2aC9OQmtSZFpGOFhRQW5SWUpNTDAxS2U3VlF1ZXU1bGF1eVl3ditIVjhiQ2hSZGlDUmNkZjJ1MDBySk9YaG9VbnRCSUU4NWl3VkkyRVRUUTd3Tmx4Uk5VcUViUXJJWGhjOVNUUVNDbjFsYVBNUkFIVnhqZUphUitkMlJ5ZzNoejlpNFhqTVZtUzNOK2RpdFpMS2pwbzhBYWpPUjdUci9TRGNZSlBoQXFpRGdxMWg1a3hBbU15U29tbFpMbG4rUkRiWU9TWTEwT3hucW11Y29GNzc1bjE2T2xNdUpXdnY5TE1lR0RtM0lKNFg3Q01ZT0dWSTlxZU8yekZrRnVtOXVsWUN5bGFFSktlT3p2ZnF0cDA0OUVma2E0UUNjOVYrekJoUXQyS3cxWTJWWFgrV2tSMjQ3dHk2djRTVXkxWW50OW9reUNQOVo4YS84V2UzRGUyUy8wdVZBODV5eXI2NjkyY28rbGdFRWNjVzE2R0lqMys4Tm8yQmcwR3ltVytEUjR6c0l2Y0JYM3dRdnV6VjUrL1JWUmRXSzdKVnQ1MjVOMjdGUTRvNkxmTkt5eVBudW1mL3ppNURDUkxub0MyWHI4K0NjQThzVXpuUjUvc2ZHVGk2cVVnLy96ZVVpeDlFa21KQXFxd2FJU3QwUnZkOE9ESlU3aDlIVy9WZklaM0o2Z3daWGxjWkk2RSszYU5PUzR6eDZBWTlHaGZYaUM3ek1YaWVjMzY0eWgwc1ZkRHB1bXZvT3lZbW96aXlTaGJ3V1EwSk5GRDl3bG9uS0o4VVloL3Zxd0w2alFBeDdyNU1pTm91emNNbTRNNy90dzV1LzJVVnFUbHpYZTRtYnFTcHRiT2l6dTFPcWhUVVZ4UmJkMmFQcENmeVp3SHQ2M2tTRWpseGVuZHN3bSsrTmFOQXcxN0gwNktOSWkyUHV4ZC9DbjFRUFplV2JtaUI1VDM4TFVidGRnSmFqUnhhZktBSjJrMjEzOGlyZnQ3RmxHb3pOQ2FkSFdPUGRMczBlbHAxaDVrS0xtdi85bkJmK1dROHY5RGwrRno5aTMydEd4R2YzSjFkV29wWFJsSlN5eGJsR1p0YVBsdWllRzZteDExeURIZnRtWktPR2NLNTRSSHhadC9lelcwZkFsSFhyM282TXJhVmtUUGpuNlQydjArVUF3bjJrOFM5emp4WVBIT2hvOExqZm8rQlNOUzFSLzlERC93Mm5aNVhuclJsTlppMHpBZUE5QzdqNGdBQUhqYVkyQmtZR0FBWWxuUEErengvRFpmR1poWkdFRGdzZU9HUmdUOS95VnpPdE1lSUplRGdRa2tDZ0FVK0FxYUFIamFZMkJrWUdCbStNOEFKQU1ZSlArN01hY3pBRVZRQUJzQVRJWURKZ0FBQW5ZQUFBS1NBQ2NDVmdBWkFyb0FRd05RQUJ3Q1VnQWtBQUFBQUFCMEFOUUJPQUhLQWpnQUFIamFZMkJrWUdCZ1kwaGdBTkVNVUJJSkFBQUthUUJxQUhqYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTUuNTY1MDUzLC01OS45MTA2MDQpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOC4xNTEwMywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTUuNTY1MDUzLC01OS45MTA2MDQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU1LjU2NTA1MycgeT0nLTU5LjkxMDYwNCc+VDx0c3BhbiB4PSctNDguMzU5NDEnPlg8L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNy42MzAyMiwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU1LjU2NTA1MywtNTkuOTEwNjA0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy01NS41NjUwNTMnIHk9Jy01OS45MTA2MDQnPlQ8dHNwYW4geD0nLTQ4LjM1OTQxJz5ZPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTMuNDgyNywtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01NS41NjUwNTMsLTU5LjkxMDYwNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTUuNTY1MDUzJyB5PSctNTkuOTEwNjA0Jz7OozwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDkuODc4MDE4JyB5PSctNTguODUzNDU3Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQyLjk1MzQzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01NS41NjUwNTMsLTU5LjkxMDYwNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTUuNTY1MDUzJyB5PSctNTkuOTEwNjA0Jz5VPHRzcGFuIHg9Jy00Ny42NzY2MDUnPkY8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDEuMjcwMDYxJyB5PSctNTguNDE2MjI0Jz4wPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zNi44MDA2OTEnIHk9Jy01OS45MTA2MDQnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDMuNDc0MjYsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01NS41NjUwNTMsLTU5LjkxMDYwNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTUuNTY1MDUzJyB5PSctNTkuOTEwNjA0Jz5VPHRzcGFuIHg9Jy00Ny42NzY2MDUnPkY8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDEuMjcwMDYxJyB5PSctNTguNDE2MjI0Jz4wPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zNi44MDA2OTEnIHk9Jy01OS45MTA2MDQnPlk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEyLjcwNjU3IDBIMzcuODk3ODknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguMTQ3ODksMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNi45NDUxOSw0Ljc4OTYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01NS41NjUwNTMsLTU5LjkxMDYwNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTUuNTY1MDUzJyB5PSctNTkuOTEwNjA0Jz5GPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01MC41MTI0MzYnIHk9Jy01OC45MDg3OTInPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ3LjEyMjMxNScgeT0nLTU4LjkwODc5Mic+LFg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNy45MDk3Vi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMzAuMDM2MDcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01NS41NjUwNTMsLTU5LjkxMDYwNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTUuNTY1MDUzJyB5PSctNTkuOTEwNjA0Jz7OozwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDkuODc4MDE4JyB5PSctNTguODUzNDU3Jz5GPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00NS41NTczNjcnIHk9Jy01Ny4zNTkwNjEnPjA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQxLjY2OTExNicgeT0nLTU4Ljg1MzQ1Nyc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTIuMTg1NzYtNTYuOTA1NUgzOC40MTg3MicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzOC42Njg3MiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTcuMTYzOTYsLTY0LjUwMDY0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTUuNTY1MDUzLC01OS45MTA2MDQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU1LjU2NTA1MycgeT0nLTU5LjkxMDYwNCc+RjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTAuNTEyNDM2JyB5PSctNTguOTA4NzkyJz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00Ny4xMjIzMTUnIHk9Jy01OC45MDg3OTInPixZPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2NS42NDY1NzEsLTU5LjkxMDYwNClzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04LjE1MTAzLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDY1LjY0NjU3MSwtNTkuOTEwNjA0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9JzY1LjY0NjU3MScgeT0nLTU5LjkxMDYwNCc+VDx0c3BhbiB4PSc3Mi44NTIyMTQnPlg8L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNy42MzAyMiwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNjUuNjQ2NTcxLC01OS45MTA2MDQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nNjUuNjQ2NTcxJyB5PSctNTkuOTEwNjA0Jz5UPHRzcGFuIHg9JzcyLjg1MjIxNCc+WTwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEzLjY3NzE1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNjUuNjQ2NTcxLC01OS45MTA2MDQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNjUuNjQ2NTcxJyB5PSctNTkuOTEwNjA0Jz7OoDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc3MS41MjczMzcnIHk9Jy01OC44NTM0NTcnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDIuOTUzNDMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNjUuNjQ2NTcxLC01OS45MTA2MDQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nNjUuNjQ2NTcxJyB5PSctNTkuOTEwNjA0Jz5VPHRzcGFuIHg9JzczLjUzNTAxOSc+RjwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jzc5Ljk0MTU2NCcgeT0nLTU4LjQxNjIyNCc+MDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc4NC40MTA5MzMnIHk9Jy01OS45MTA2MDQnPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDMuNDc0MjYsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDY1LjY0NjU3MSwtNTkuOTEwNjA0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9JzY1LjY0NjU3MScgeT0nLTU5LjkxMDYwNCc+VTx0c3BhbiB4PSc3My41MzUwMTknPkY8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc3OS45NDE1NjQnIHk9Jy01OC40MTYyMjQnPjA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nODQuNDEwOTMzJyB5PSctNTkuOTEwNjA0Jz5ZPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMi43MDY1NyAwSDM3Ljg5Nzg5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM4LjE0Nzg5LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTYuOTQ1MTksNC43ODk2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg2NS42NDY1NzEsLTU5LjkxMDYwNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSc2NS42NDY1NzEnIHk9Jy01OS45MTA2MDQnPkY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNzAuNjk5MTg5JyB5PSctNTguOTA4NzkyJz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc0LjA4OTMxJyB5PSctNTguOTA4NzkyJz4sWDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS03LjkwOTdWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0zMC4wMzYwNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoNjUuNjQ2NTcxLC01OS45MTA2MDQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNjUuNjQ2NTcxJyB5PSctNTkuOTEwNjA0Jz7OoDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc3MS41MjczMzcnIHk9Jy01OC44NTM0NTcnPkY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNzUuODQ3OTg4JyB5PSctNTcuMzU5MDYxJz4wPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc5LjczNjIzOScgeT0nLTU4Ljg1MzQ1Nyc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTIuMTg1NzYtNTYuOTA1NUgzOC40MTg3MicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzOC42Njg3MiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTcuMTYzOTYsLTY0LjUwMDY0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg2NS42NDY1NzEsLTU5LjkxMDYwNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSc2NS42NDY1NzEnIHk9Jy01OS45MTA2MDQnPkY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNzAuNjk5MTg5JyB5PSctNTguOTA4NzkyJz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc0LjA4OTMxJyB5PSctNTguOTA4NzkyJz4sWTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = TX,
    ne = {UF_{0}X},
    sw = TY,
    se = {UF_{0}Y},
    north = {F_{1,X}},
    south = {F_{1,Y}},
    west = {\Sigma _{f}},
    east = {\Sigma _{F_{0}f}},
  }
  \qquad 
  \DiagramSquare {
    nw = TX,
    ne = {UF_{0}X},
    sw = TY,
    se = {UF_{0}Y},
    north = {F_{1,X}},
    south = {F_{1,Y}},
    west = {\Pi _{f}},
    east = {\Pi _{F_{0}f}},
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1216</fr:anchor><fr:addr
type="user">log-000H</fr:addr><fr:route>log-000H.xml</fr:route><fr:title
text="Naming fucntor">Naming fucntor</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with finite limits and <fr:tex
display="inline"><![CDATA[T\colon \mathcal {C}^\mathrm {op}\to \mathsf {Lat}]]></fr:tex> be a <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>-indexed (pre-)lattice such that</fr:p><fr:ul><fr:li>For each object <fr:tex
display="inline"><![CDATA[X \in  \mathcal {C}]]></fr:tex>, the fiber <fr:tex
display="inline"><![CDATA[T(X)]]></fr:tex> is cartesian.</fr:li>
  <fr:li>For each morphism <fr:tex
display="inline"><![CDATA[f\colon X\to Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> admits a left adjoint <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex>.</fr:li>
  <fr:li>Each left adjoint <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> satisfies the <fr:link
type="local"
href="log-000E.xml"
addr="log-000E"
title="Beck-Chevalley condition">Beck-Chevalley</fr:link> condition.</fr:li></fr:ul><fr:p>Then we can define a <fr:em><fr:strong>naming functor</fr:strong></fr:em> <fr:tex
display="inline"><![CDATA[{\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{X}\colon {{\mathcal {C}}_{/{X}}}\to T(X)]]></fr:tex> for each object <fr:tex
display="inline"><![CDATA[X \in  \mathcal {C}]]></fr:tex>.
  Moreover, for each morphism <fr:tex
display="inline"><![CDATA[f\colon X\to Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the following square commutes up to isomorphism.</fr:p>
    
      
      <fr:figure><fr:resource
hash="4c641583e2600d77ef1428a3c5660fa9"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0Mi4wNTY0NzhwdCcgaGVpZ2h0PScxMjMuNTE1OTU1cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTQuNzA0MzE5IDgyLjM0Mzk3Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFQc0FBb0FBQUFBQkhRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVjQUFBQmdoVVFUMkdOdFlYQUFBQUU4QUFBQVBBQUFBRXhBY2VFVloyeDVaZ0FBQVhnQUFBRU1BQUFCSk1HV3UyOW9aV0ZrQUFBQ2hBQUFBQzRBQUFBMktHMmovMmhvWldFQUFBSzBBQUFBSHdBQUFDUUZSd0hrYUcxMGVBQUFBdFFBQUFBWUFBQUFHQXRDQVhCc2IyTmhBQUFDN0FBQUFBNEFBQUFPQVRRQTVHMWhlSEFBQUFMOEFBQUFGd0FBQUNBQUNBQWNibUZ0WlFBQUF4UUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQUQ0QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1mTUE0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lBR0JnWkdCaVNRVWx5V0RwVFVVQkJtWnZnUDVETkRwSkhVL0FjS0F3QU1uQTJxQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1Jnc2dEUVhBd2RRam9sQmt5R2FJVlpCK1A5L29KZ0dqUDMvNXY4Vi81ZmYvd1RXQVFVQVFwWU5ubmphSmN3OVM4TlFHQVhnOTl4YjdqV1I1b1BXRkJUUldKcVNRWWUwTjhGQ3JTN2k0RmdjcEE1YWNXa1FLcTRGOFdNUy80RVcra2M2aVl1L3c5bFpxTVFidzh1Qjk4RGhJZEJ0QnR4eG9sVWkxTHlxRkRhRUZKNStiUVJOZlVuUVE0eTBMT1ZCUis1eW5GeVpzdnlrck9VR1k5dFd6QW5NRWUzVUdYKzgvSndaRHNQRnhOK2NERzhlR3ZlYXBDUHQ5d3Uvb3RXYUo2dENXZ2lTZGc5N1NIYlFERlNjREI3akhBeTM0dXMxY0xzL0FCOGZHaENjQ3UxMHRuOCtaQ1l2dWNmZnMvZXZqaWtNUnBUN3p4a2gxTDdVcGU2MlZuUVFUcWRwbWxHSm9zVmx2dkV6b25teHFiaDExZEtadjQxR25CWVU4ZGZvMzFrQ1kxMXNrSjdCVno3ci9uNHlCYlpPZnpjaE1tSjQybU5nWkdCZ0FHS1B1dDI3NC9sdHZqSXdzekNBd0dQSERZMEkrajhEMDJWbUVKZURnUWxFQVFBeklncHdBQUI0Mm1OZ1pHQmdadmpQd01EQWRKbUJnNEdMeVpZQktJSUMyQUE1cUFJeEFBTFRBQUFCeVFCMEFja0FTQUZMQUlzQlN3QWhBa2NBQ0FBQUFBQUFNQUJnQUhJQWhBQ1NBQUI0Mm1OZ1pHQmdZR09RWmdEUkRGQVNDUUFBQTZ3QUpRQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmtBQW9BQUFBQUE4d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW1LVkFtTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSnFaMng1WmdBQUFXd0FBQUNrQUFBQXFCNnl0ZVJvWldGa0FBQUNFQUFBQUN3QUFBQTJLZTZqMjJob1pXRUFBQUk4QUFBQUh3QUFBQ1FHSFFFZ2FHMTBlQUFBQWx3QUFBQUlBQUFBQ0FkSEFJNXNiMk5oQUFBQ1pBQUFBQVlBQUFBR0FGUUFBRzFoZUhBQUFBSnNBQUFBRndBQUFDQUFCQUEyYm1GdFpRQUFBb1FBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEVkFBQUFCQUFBQUFnQUFNQUFYamFZMkJtWHN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1Skk0czlZZlN3WUdaaTNtNDBCaFJvVFMvLzhaR0FBR3JRNllBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJpLy85RHlMdXZ3UElNQUZJUkJwVUFBSGphTGNsQkNvSkFHSWJoK1NiNEIwc3RkUnlWS0dtaWNWY29wdERDTGxHMFN5THdNQVVkb2FCZGQrb3d1V2oxd3ZNeXNBZGI4aXUrckdRTWRWVW9TV09vU0VVdXpBWXBTS3hSN2lFbzA2YXZ5VXpXb0VpUm1XMVoxU29TdUwzc1JIcjBPUjBERHBsWWI0ZTQ5Z0t5N3l0eXdyaDN5UkhHenRPbXdOTjhoR2xyU2UzeVpyWVFzUzlCbDI0M0g4Q1A4dTRRUXVySmYxaHRsdzhkSHp3OXN4OVZPeFpiZU5wallHUmdZQURpV2hhcDJuaCttNjhNekN3TUlQRFljVU1qTXMwU3luZ0hTSEV3TUlGNEFQUXpDS3Q0Mm1OZ1pHQmcxdnBqeWNEQUVzclF4OURQbE13QUZFRUJUQUJTZ0FOQ0FBUlZBQUFDOGdDT0FBQUFBQUJVQUFCNDJtTmdaR0JnWUdJd1pRRFJERkFTQ1FBQUJjb0FPd0I0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQ1VsWVdCaVpXcEMyQ0RNc1JCZG9nVXFlckk3KzdoZXVnTnArZjl1QU5LZnNoNFRzWnIzTS9KS1VUOWNjRUxiNG1ub2hhSlN6NVlNaUhMWitMTTJTVE9KZmxLWFBET0pmRlUvTy9FSlo4OHRsMTd1L2ZXcTMxbnJIZm5Ob3pyZy9XaDZaeGE2U3JxblhYV0gzdHIxR2xVWm1qQ2NHMVZyU3RkczZXajVjYWRIb3RIc1JmSFJIYWNKUXVNckRsRUo5Qkk2cVMxUWxQOXkzZVN1OWc1eGs5R09pZEpsTkFnVjBIMlZkcUtPbDVxNmwvdjZUQkhBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFUOEFBb0FBQUFBQmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwMldOdFlYQUFBQUU0QUFBQU5RQUFBRHdBYndDdFoyeDVaZ0FBQVhBQUFBSW5BQUFDd042aWpGWm9aV0ZrQUFBRG1BQUFBQzhBQUFBMktRR2t1bWhvWldFQUFBUElBQUFBSGdBQUFDUUdnd0diYUcxMGVBQUFBK2dBQUFBUUFBQUFFQXB1QUZsc2IyTmhBQUFEK0FBQUFBb0FBQUFLQWNBQThtMWhlSEFBQUFRRUFBQUFGd0FBQUNBQUJnQmhibUZ0WlFBQUJCd0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUU4QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1tczA0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBRTVlZaGtadmdQNURORHBKSFUvQWNLQXdEaVhBMDRlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtoakJFL3Y4UDVJY3dSUHovLzMvdC8xVmdWVUFBQUpVTENSWUFBQUI0MmsyUlBXc1VVUlNHNXoxMzV0NloyVHQzZHJMendXWjNaeE4zTTVOZ3N0Rjh6Qm94V1FRaEtFZ1FVZ3FLb2ttVkloWmlJeGdieGQraGpXQWhLaUtDalgvQXpzTEMwa3F3c0RUcm5SMzg0RGJubnZlY3czbmVZOEJvanNmMGlkNGE1d3dEVElSeEY0VUkrVEpFbnVWWmthd1V3MFl4TExLVHlBUXZYNWFQc0lWa3RraDBQR0pybWVnSkJieCtaTmJqOHhsVDlvdm4wZ0ttcG5mbTJXTUdPT0g4alVYcDlrOVlDZmltS1FNNjAwS0tGaGluaTVmbldvNUxCNysreHRJbVlyNFNZSXpnK0J4Um0zcTJ4d1ZyQ21kdUx5YTM4YXBVMWNlRWF1SFMzRWFIR1BrR2pQWjR6UGJvdlhGTjd6OHNoZ1BLdDlERlVIT0V2S2NndUE4ZHAxaE40a2loNGxvclZyZXd2Z3dmdW1BaUpSTXBXOFpFR2hFYm9NZXJTVW1LY2xDRUg4L3FqTG9Od0xNT3J6dEUwaDJNb3Vid0tPanZ1SjNUVXBEa2h3OGNDOUpPVTJ2LzZuNnREdXJhd2dTa2RhZHF5QzlsM3VkN1Zuc3hvakpaVmMrMDhmU2xTa0lKZDhJUGt5dk8wakRlZkRMWWZaZjZJRmZ4eWhkUG1GUEMvM25yb0paNFlZM0kvdFBnYzVySjVUZWs5WUNwS2ttUk1DUEwwTFlZZmUyUjFCNWRLRytzTkRhUHVMN3pQenVTdUJoUi9qOTBuSVE4NDZLbFBSMGd6OVluMlpYS1VycDV6QzIyWkZHYWRTRDV3eEpEcWJOZE1ldVo5NjNwRXM2cjRMem9GTHY3M2EraEZYQjQvUGF1SiszVnpaaTJqNzl3cWQ2RVFzT3hUcld1N1FzZ1hEamFDSENsVWY5TG9SSEpDWTQvSUFqOWpsditTeSthM0Zwb0dzWnZnZWxXSlFCNDJtTmdaR0JnQUdLalA2NlY4ZncyWHhtWVdSaEE0TEhqaGtZRS9mOC9jenJUSGlDWGc0RUpKQW9BTjRFTGJ3QjQybU5nWkdCZ1p2alBBQ1FER0NUL3V6R25Nd0JGVUFBTEFFeUVBeVFBQUFKMkFBQUNWZ0FaQTFBQUhBSlNBQ1FBQUFBQUFHQUE4Z0ZnQUFCNDJtTmdaR0JnWUdGSVlBRFJERkFTQ1FBQUNqTUFhQUI0MmsyT3NXckRNQkNHUDFQSFVLZlFxUjA2RkUwWmhZMzdBSUVNbWJKbUxDU1JDQTVJQ3JKanlCTDZBSDNvWGhRTlBjSHgzWGUvaElDYUd3WDNLbmhOL1Y0bGxVd1BuakhuTFhNbFIyV3UrV0RCRTBYNUxPYVRaZWFTRjc0enozam5sTGtTLzVPNTVvdmZWWERueTJpajJnUmpvejg0MTdmTjFzYWhEMTYxdW5tSXRmVTI3a1pyMVA2cXpOUVAwOUdwVGplNlkwWEFjZWJDaUNYS3p6WmlUR0xQUVhhT25wYUdiWEtEVEVFMlNwd1creit4bG9SUHFWMTZ6VWhxejFXNllaTE1JUDBvYVVXWDdtcTZQOS8wTUxzQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5nQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTno3R050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDZ0FBQUFyS0FDSGFSb1pXRmtBQUFDQkFBQUFDNEFBQUEyS0Jxai8yaG9aV0VBQUFJMEFBQUFId0FBQUNRRWp3RzhhRzEwZUFBQUFsUUFBQUFLQUFBQUNnUkdBR1JzYjJOaEFBQUNZQUFBQUFnQUFBQUlBQ3dBVm0xaGVIQUFBQUpvQUFBQUZ3QUFBQ0FBQlFBWmJtRnRaUUFBQW9BQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRFVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXZNYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWU5Ca1p2Z1A1RE5EcEpIVS9BY0tBd0R2a1EwZWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaRWo1ejhBWXdzekFJTTdBd0NxaXBLYXV4Mml1Wm1adXgyakV6OGpIS000bUpNOG94aGdzbG15b0tjUElLS05tbUNiR3lCUG53Y2prRXMvUC9JMHJLVDVpbGEzVHd0RGtWQjZCeEQvdGxmLytwUWl5TUFBQkk0TWwwRnhOaUxtTVltenNmSXhLcGtCVDFVM1U5Qm5Wek0yTXhNVGxHQmsxd0NhSzhzWjZNUVg3Q0RFek1vcUM3V0dBbXBqMHQzWGhCMThoRmlhd1BRQVZKQ0ZNZU5wallHUmdZQURpVDYvUCs4ZnoyM3hsWUdaaEFJSEhqaHNhRWZSL0JxWUdaaENYZzRFSlJBRUFVZXdLM0FBQWVOcGpZR1JnWUdiNHo4REF3TlRBWU1sZ3lSakNBQlJCQVV3QU8yd0NVQUFDZ0FBQUFZMEFaQUE1QUFBQUFBQUFBQ3dBVm5qYVkyQmtZR0JnWnBCZ0FORU1VQklKQUFBREVBQWZBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWDBBQW9BQUFBQUIwQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFVwMUNXTnRZWEFBQUFFNEFBQUFQZ0FBQUV3QkJ3RE1aMng1WmdBQUFYZ0FBQU1RQUFBRDdCTFZKNXRvWldGa0FBQUVpQUFBQUM0QUFBQTJLVldqLzJob1pXRUFBQVM0QUFBQUhnQUFBQ1FHNmdJTGFHMTBlQUFBQk5nQUFBQVlBQUFBR0JCMkFUTnNiMk5oQUFBRThBQUFBQTRBQUFBT0F6SUNHRzFoZUhBQUFBVUFBQUFBRndBQUFDQUFDQUJtYm1GdFpRQUFCUmdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGNkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtMnNjNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwVFVaMGhqWnZnUDVETkRwSkhVL0FjS0F3RHNFUTFEZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0N5QU5CY0RCMUNPaVVHZklZUWhraUh0LzMrZ0dJZ2RBV0wvdi9SLzNmL1YvK2VEZFVBQkFFcHNEY29BQUhqYVRaTFBqOXRFRk1mOWZXUFB4RC9pY2V6RTNrM1NwTFdEdlNVMFd6YTd0bmE3Skx0TEJTb3RsU3BRcTBKRmthaFV0WUlqY09QUUF5MFNnZ3NIVGtnY3VIT3FRTzJ4RjhRRkJQOEFGODRJaVJ0a2VZNjZiZVhEZU42elIvUDV2SzhCNCtLaFFiWXdETTh3YkVpVkZubUZHWktZc0xoanJyUk5LSHhpalUyaTMvNTlOUkZkRVlnZjY4VXdEQmd2SEI2S2svU0RjY0Fib1NIaklUYmlqbzkxVWhOczVXVVNsMVZVNW1Qa1N2TGpnNnZ6K3ZRVFphTGFzcWpLT2NxOHlOZkJQZng5VHdETjFkMGtRcUF1WC92ZVZlaDBYMThUbjhPTngrK2Q5cjIxa2Rub1NHdmY5RUw2YUlEK0NDUUJ0STVIS3grc0JpNjkvOStmdm1NM2lFeW5wU0Jnd2hIOGdrNmZUaXNoMnNwTmIva09GOFA3V3NFTUg2MUF1MFdyMTMvZXJjK0JWek5ObWVrQlBUUnU4Q1lhWUhvRXhKZWNZVHJEbG1BU3JpZHhjZ1M2V1U1TFJpRXhRWmJtV3pNTXFXSVZQZ29mdk02cHJDYTAvRDJwTnVLa0xUUEpzaFJ0ZjJkMXgxNkl3S3BldXV1UmdLOTYvVHUvWkVCczF6ZlMxcG5kNjdiVTdsNjVlZlh5OXBmeW1hOEZ3WmU5UHF5YjUyNEdOdENOaU5DVUg3OHJIR2hudm1GUDM4TGR4UU5mUDNFaFZhQkV5NEx4OHpEV0Rna25PSElVS0NxS3Q5L2NSazhINWxGWkt0MkFhUG55cDNNM0lzOE5ISzc0RGRPVXRxOUVwdkpyN09vTXU3ckZybDVaWmtjTE9VVEpVcUNSTG9jL3h4TWxqRDRBenp5WEt1Y0JzNitxWktWNXdiYkFMWmx5UXVqKzRpOUZVZGdXM1NKRHkvcjA3RnhUMk53NXBpYmZ5Tld4MjJMbUR6L3pMQVRoS1VIMlBSaDJ3d1BzanJlMGRmdU5KdnhvYzVqUy91SVBaUjFjNEQyWkdZOGFZc2c1aVBLSGVDZGd4Sm9ETGpHM2FpSmMvQTdYYnZwTmk2VUttL0ZOazNyS2E2OHNNMzcrY0oxdTA2L0czdU9NYzFKVldsOTdHaWV4VkR6ZkdlWWlrd3pNNmFobWRXSTRHUm5IdXF5WTBDZU5hUm5MQXQvdUJHYlF0ZmRmWE5zQlJwMWNRQSsxMXFNVDR0aEVYeGhRcEMvcGpoOGZaQ2QzZ1N6bWZqRFFPZ3dIVHFON3ZXN2pxOFdqMTFwN20rMlhSWjROanROSUZxNU5NTTkzdnY3bmlrZ1ZybHp0RmZsem82Y3RyT2FudmpEVEJoamxmNGN6ZkU5NDJtTmdaR0JnQUdLVzVkUFo0L2x0dmpJd3N6Q0F3R1BIRFkwSStqOEQ4MjVtRUplRGdRbEVBUUFJaVFsbUFBQjQybU5nWkdCZ1p2alBBQ1QzTWVqOGQyUGV6UUFVUVFGc0FGODFBL3NBQUFMR0FBQUNWd0JPQXJJQUxBTytBRE1DcndBN0Fqb0FTd0FBQUFBQUhnQ0lBUjRCa0FIMkFBQjQybU5nWkdCZ1lHTklaUURSREZBU0NRQUFDdVlBYndCNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUnNBQW9BQUFBQUJTQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFhOMTcyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ3NaMng1WmdBQUFXUUFBQUd2QUFBQitMMXFqWUpvWldGa0FBQURGQUFBQUM4QUFBQTJLZFdrdW1ob1pXRUFBQU5FQUFBQUh3QUFBQ1FIb1FMT2FHMTBlQUFBQTJRQUFBQU1BQUFBREFzVEFNOXNiMk5oQUFBRGNBQUFBQWdBQUFBSUFJZ0EvRzFoZUhBQUFBTjRBQUFBRndBQUFDQUFCUUJhYm1GdFpRQUFBNUFBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFFWUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtM3NnNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwU01ZSWhrWnZnUDVETkRwSkhVL0FjS0F3RHJOQTFUZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlSLy84RHlZai8vLyt2QlBNWkFGU0xCclY0MmkyUXdXN1RRQkNHOTU5MWRtdkhYaWZyelpvbUpsRVRaQmNKMlZHaE5sSlJRaU5VSVlUVUU0SXpQYmJjdVhCQmdpc0NjZXM1SjE0aGNPQUZLaDRBaVJmZ2lNUXBZVk54bS9sbi90RjhQd003MjZ5OUkxcXhGNHdoR2VKdWJYdFdWcERqWW9aMGhyeENURUlLTzRKTlJVVk9iK3BtaGpueEVoT1JIK1pOMnRTcFFqR1dxZE5MQ0djY1VXTlRJK1JZU0xyODFybzVWUWI5aDR1UFhZSnVaWDIwUHJ4NzVRc2dNcUVFYnN3WDU0cHpyazVPaDUyL3kxWjJvQkxzdnYwVWMzUkZObmp6WmJjTE0vQmNNeisraUNrSXltY2wzcSsvaHdvaUhCQ0gxelVCS0Fyazc5Y3ZROThYRVJFUFI5ZURPQ1MrUDJqL2dtbkhFRkdmUEE4NmFVUC91T3oxZWo0WjQ4UHRVYnhqa08wenNJdk5oditocit3eFl6NmtjQ2FIN2tKUnFDaEdYdHlyVTF2UDhaKytkcVRYOUZMSUJJNi9HT2VGRStjNDJBWXdVWkI4dXI2NjdZUGc2enNkRFMxT25qNTVwR0YxTTlvcFZ6S3JsQ2E3T1A3c2FIV1VXVnBDbWRDYmlCQms3eitZbGw0STNUNWNHRHBhLzF6dStVcDQ3cFlJZTl1LzRVSnpCZUs5Rlo1M0lnYzQzRkpEYi9NZ2YzMEZibFJLc3IyVndXV1FCTjR0emRnL2NiRkJDUUI0Mm1OZ1pHQmdBT0o5dDI0dGp1ZTMrY3JBek1JQUFvOGROelFpNlAvL1dLeVo5Z0s1SEF4TUlGRUFhU2NNYlFCNDJtTmdaR0JnWnZqUHdNREFVc3lRL0QrY3hab0JLSUlDbUFGVTR3TjNBQU5VQUFBRWN3QmpBMHdBYkFBQUFBQUFpQUQ4ZU5wallHUmdZR0JtaUdRQTBReFFFZ2tBQUFscEFHQUFlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ3dOcUZnWW1WcVF0Z0YyV3dqWndRQ2FucTJOL2RoL0hRTjF5ZCsyRUROVDhVM0s5Z2x2UitKWlc0QjFkTW1XZWVpSHZMWExQZ25TZUs4bG1TVno0eWw5SjhacTU0NFN2elJQTHZ6RFVyZmpmQlhhNkRqV29YakkzKzVGeTMzdHZZZDhHcnBXNlMzMXB2NDJHd1JoMXZ5b3hkUDU2ZGFuV2pXellFSEJldURGZ2lpcDBrSnJIbkpKMmpZODArSmIxd2tGeXhSTlA4NjdmUys3UTVwSitNYkk3Y1JBMmpMSHJSczJ3VmJYcXBhZjhBeUJFdjd3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaUU5eUJtTnRZWEFBQUFFOEFBQUFLUUFBQURRQURBQ1daMng1WmdBQUFXZ0FBQUN5QUFBQXVMVzFUNVZvWldGa0FBQUNIQUFBQUM4QUFBQTJLTGFrdVdob1pXRUFBQUpNQUFBQUhnQUFBQ1FGU1A5QWFHMTBlQUFBQW13QUFBQUlBQUFBQ0FVM0FBbHNiMk5oQUFBQ2RBQUFBQVlBQUFBR0FGd0FBRzFoZUhBQUFBSjhBQUFBRndBQUFDQUFCQUE1Ym1GdFpRQUFBcFFBQUFEVEFBQUJQcTgzZGVGd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtbXMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBabkJtbHZxanljREFMTVY4SFZYTi8vOE1EQUQyZnc1RUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ1VnRFFMRUlMNHp2Ly9ROGovKzhCOEJnQlN3UWFmQUFBQWVOcGpZR1RnL1ArY1NabnBNb001QTRNcUd6c0lLcW1wcTlrem1wbWJnUWt4Y1RaK1JqNUdkaloxY3p0R2N6VjJJQk9JNUJpQlBLQThXQW5qSDBZVEJYMnYrS2dNUm1aeEZzbFFsVUQyNEh3NVl5Wm1jUlV1SFFGdVJuWnVWU1ltTzc5NFJRMGpScVkwZDJOWENYNTJmbjVlZnM2RndpWUtzb2FzRllWYThYekp1WG9tekVZc2pKS2E2Z2F1ZkJLTVRKejh3b0d5NWt5TUxrYjJDenlLc3hnWmRWVkZPTGc0MkJnWkdSZ0E1VXdiUEFBQWVOcGpZR1JnWUFEaTVDdDNIc2J6MjN4bFlHWmhBSUhIamhzYUVmVC81OHd5VEplQlhBNEdKcEFvQUdCNURDc0FlTnBqWUdSZ1lKYjZvd2trWlJnNC8vOWdVbVlBaXFBQUpnQlc2UU9MQUFBREhBQUFBaHNBQ1FBQUFBQUFYQUFBZU5wallHUmdZR0Jpc0dBQTBReFFFZ2tBQUFZVkFENEFlTnBOanJGcXd6QVFoajlUeDFBbmtLa2RPaFJOR1lXTjh3Q0ZESm15Wml3a2tRZ09XQTZTWS9CUzhnQjk2RjRVRFQzQjhlbS83NFNBa2g4eUhwV3hqUDFST1lYY25qeGp6bHZpUW81S1hQTEJpaGV5L0ZXU1Q3NFM1eXo0VGp6am5VdmlRdko3NHBJMXY1dSt1OTRHNjlXdU45YTdVeGVtdXRwYkg5cmVxVnBYejJCcm5mV0h3UnAxbkpRWjJ6Q2VPOVhvU2pkczZPbTRjbVBBNHVWbk8wbE1aTWRKWm9HSm1vcDl6QUt0ekoxNE5WclMvOFpXREJldFEzek5pSFdVbVJJYVpTOUlQNHV2YU9LdXB2a0RDVkV4RXdCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01Ni45MTQxNTEsLTU5LjE3NDQ3MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04LjM1ODAyLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ni45MTQxNTEsLTU5LjE3NDQ3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTYuOTE0MTUxJyB5PSctNTkuMTc0NDczJz5DPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01MS42Njg1MjknIHk9Jy01Ny4zNzU2NDYnPi88dHNwYW4geD0nLTQ3LjE1NzY0NCc+WTwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04LjQ4MjMyLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTYuOTE0MTUxLC01OS4xNzQ0NzMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU2LjkxNDE1MScgeT0nLTU5LjE3NDQ3Myc+QzwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTEuNjY4NTI5JyB5PSctNTcuMzc1NjQ2Jz4vWDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC05Ljk2NTNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEyLjEyODU0LC0zMS4wNjM4NyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNTkuMTc0NDczKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01Ni45MTQxNTEnIHk9Jy01OS4xNzQ0NzMnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUyLjI0NzU2NicgeT0nLTYyLjE4MDk5MSc+4oiXPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ1LjM4NjM4LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ni45MTQxNTEsLTU5LjE3NDQ3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTYuOTE0MTUxJyB5PSctNTkuMTc0NDczJz5UPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00OS43MDg1MDgnIHk9Jy01OS4xNzQ0NzMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ1LjgzNDEzNCcgeT0nLTU5LjE3NDQ3Myc+WTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzcuODM2MzI4JyB5PSctNTkuMTc0NDczJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ0Ljg2NTU3LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTYuOTE0MTUxLC01OS4xNzQ0NzMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU2LjkxNDE1MScgeT0nLTU5LjE3NDQ3Myc+VDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDkuNzA4NTA4JyB5PSctNTkuMTc0NDczJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00NS44MzQxMzQnIHk9Jy01OS4xNzQ0NzMnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTM2Ljc5ODU3OCcgeT0nLTU5LjE3NDQ3Myc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTIuOTEzNTYgMEg0MC4zMzA4NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MC41ODA4NCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE4LjYwOTk5LDUuMDYxODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ni45MTQxNTEsLTU5LjE3NDQ3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTYuOTE0MTUxJyB5PSctNTkuMTc0NDczJz5bPHRzcGFuIHg9Jy01My42NjI0NDEnPuKAkzwvdHNwYW4+PHRzcGFuIHg9Jy00OC42OTQ5MzknPl08L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDYuNDM5NDk5JyB5PSctNTYuOTMyODc5Jz5ZPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTguOTA5NzNWLTQ3LjQ5NTc3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDcuNzQ1NzcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0zMC4yMDI3NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNTkuMTc0NDczKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01Ni45MTQxNTEnIHk9Jy01OS4xNzQ0NzMnPlQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTUxLjEzNjE1NCcgeT0nLTU5LjE3NDQ3Myc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDguMDIyODExJyB5PSctNTkuMTc0NDczJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy00My4zNTYyMjYnIHk9Jy01OS4xNzQ0NzMnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEzLjAzNzg2LTU2LjkwNTVIMzkuODEwMDMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDAuMDYwMDMsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE4LjE5Mjk4LC02NC45NjczMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNTkuMTc0NDczKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy01Ni45MTQxNTEnIHk9Jy01OS4xNzQ0NzMnPls8dHNwYW4geD0nLTUzLjY2MjQ0MSc+4oCTPC90c3Bhbj48dHNwYW4geD0nLTQ4LjY5NDkzOSc+XTwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ni40Mzk0OTknIHk9Jy01Ni45MzI4NzknPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = {{{\mathcal {C}}_{/{Y}}}},
    ne = {T(Y)},
    sw = {{{\mathcal {C}}_{/{X}}}},
    se = {T(X)},
    north = {{\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{Y}},
    south = {{\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{X}},
    west = {f^{*}},
    east = {T(f)},
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1217</fr:anchor><fr:addr
type="machine">#303</fr:addr><fr:route>unstable-303.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>For each object <fr:tex
display="inline"><![CDATA[f\colon X\to Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{Y}}}]]></fr:tex>, take <fr:tex
display="inline"><![CDATA[{\mathopen {}[f]\mathclose {}}_{Y} := \Sigma _{f}(1)]]></fr:tex>.
    To extend this assignment to a functor, it suffices to show that whenever there is a morphism <fr:tex
display="inline"><![CDATA[\alpha \colon f\to g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{Y}}}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[{\mathopen {}[f]\mathclose {}}_{Y} \leq  {\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[T(Y)]]></fr:tex>.</fr:p>
  <fr:p>To this end, note that <fr:tex
display="inline"><![CDATA[\alpha ^{*}(1) \leq  \alpha ^{*}g^{*}{\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[T(X)]]></fr:tex> because the unit of the adjunction <fr:tex
display="inline"><![CDATA[\Sigma _{g} \dashv  g^{*}]]></fr:tex> gives <fr:tex
display="inline"><![CDATA[1 \leq  g^{*}{\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex>.
    Since <fr:tex
display="inline"><![CDATA[\alpha ^{*}]]></fr:tex>, as a right adjoint, preserves terminal objects and <fr:tex
display="inline"><![CDATA[f^{*} \cong  \alpha ^{*}g^{*}]]></fr:tex> by the (pseudo)functoriality of <fr:tex
display="inline"><![CDATA[T]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[1 \leq  f^{*}{\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex>.
    Then, the transpose along the adjunction <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex> yields <fr:tex
display="inline"><![CDATA[{\mathopen {}[f]\mathclose {}}_{Y} \leq  {\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex>.</fr:p>
  <fr:p>Now for each <fr:tex
display="inline"><![CDATA[g\colon Z\to Y]]></fr:tex>, form the following pullback:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="4a9867a690f06965f87762f6492d4727"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNy40MDc2NTZwdCcgaGVpZ2h0PScxMTguMjM5NDA3cHQnIHZpZXdCb3g9Jy03MiAtNzIgNzguMjcxNzcxIDc4LjgyNjI3MSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUMwQUFBQTJLRzJrR21ob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0dU51c2VMeC9EWmZHWmhaR0VEZ3NlT0dQZ1Q5bjVIcE1qT0l5OEhBQktJQUZzMEowQUFBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVJQUFvQUFBQUFCZXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjB1bU50WVhBQUFBRTRBQUFBTWdBQUFEd0FnZ0RBWjJ4NVpnQUFBV3dBQUFJN0FBQUN0SWtwajR0b1pXRmtBQUFEcUFBQUFDOEFBQUEyS0dDa0YyaG9aV0VBQUFQWUFBQUFJQUFBQUNRRm1RR2JhRzEwZUFBQUEvZ0FBQUFRQUFBQUVBbW9BTVJzYjJOaEFBQUVDQUFBQUFvQUFBQUtBY0FBMUcxaGVIQUFBQVFVQUFBQUdBQUFBQ0FBQndCWWJtRnRaUUFBQkN3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRS9BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXltS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTVdRek0vd0g4cGtoMGtocS9nT0ZBZFRIRFNzQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS3BqTmsvLzhQNUtlQjZQK3ovODhBcXdJQ0FKbHJDVHdBQUhqYVJaTExidE5BRkliOXovZ1NPNDNIanUxeG02UnBIRHZqb0taSmFScWJSbFhhTk8yaU4wb1hVSW9RckFDSkZSSWJ4RE1naEJBTHR1eDRCZmFWV1BNd0lMRkpHVk1KNXV6T09Zdi9POThvVUk2dkIrUWwrYUhzS2dvb2cyN1lNTm9pbldESVE2NGJmQVVUN05CWUYxazRuQ0NYL1EwZTJvaEZLckpjREdBVGhtSEc5UlJmeG83cTFNenA3ZTRZU0FKQndWWVlZMGxFbC92c3BFazhkczRDbSsvRnQ3YUJtTXU1MDJTc1dtMWFwZHJUWW94UDg2c2pkM2ZUbjFFUk4xc2swZE95U2FBZUI1OS9YdEMyZ1l2TGVpbzZ5ZjhSbHNUYWU3VmRnaUlmVVhyWGE2U0RLNld2ekFvYVNhTC9KWkdKZmQwSStaQm5FbUJIUXZhUlpubFJUWVNTU2k3UUhXU3BoTktONGdRODNDaFdTZlRLZlAxbThFU1ZlVjBPdTlwd0kzODdibkFqekErbmw0Uk9tWHQ0MlIxVmFLMWFDZkJ4UU9FSG03VlpLM0JjaUxTNTExZ3c4SFkrSFR5aUpPZ3RSNTVYYmxvYVFibXh0TjU2UEZSeGNlL1pYWS90VXlUYzRYRGMrZTl2ck55SlZYUkhZcnA3bHFQVFloWEpCdVgwK2hjNUlOK1ZCd1Zaa1cyREIvODB5TVNGT21sTWxzK296OE1iVjBYREtKQ2tVcEZucWVSbXNORVdvOXliUU1RM3B2T01HNWcrWDNtWW50OFhNb3BVRTdac2YvVXNGZUZpYTVPeGRaVlFEY3dYcXhZMUxGTUhITXR2YktVekFvMENSM2RpcG9iQzFUNm9oQ1dtQTlqR2ZxOEQ4blgrd2o3cGpIcjFLQ0tKblpSc1lDd2lYMGJRVEw1bG1aVzZKeitZZXBvd2l4Qkw2OWNiZlhXWTJWVmI3NmJhdTNGMTBhdHdzbDlobG1xeGtxSFNCWG1LUHpEZ1dJd0FlTnBqWUdSZ1lBQmkzUlhYcHNmejIzeGxZR1poQUlISGpodjZFUFIvWGFaalRCZUJYQTRHSnBBb0FFR0JDNEFBZU5wallHUmdZR2I0ejhEQXdIU01RZWYvQmFZc0JxQUlDbUFCQUdVY0JEZ0N4Z0FBQWpvQVN3STZBQ3dDYmdCTkFBQUFBQUJtQU5RQldnQUFlTnBqWUdSZ1lHQmhDR2RnWWdBQlJnWTBBQUFKYVFCZ2VOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5rQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDd0FBQUEyS2U2ajlXaG9aV0VBQUFJOEFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFsd0FBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNaQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUpzQUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9RQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFZBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaVdoWXB6M2grbTY4TXpDd01JUERZY1VNZk1zMFN5bmdIU0hFd01JRjRBTzNOQ0pGNDJtTmdaR0JnMXZwanljREFFc3JReDlEUGxNd0FGRUVCVEFCU2dBTkNBQVJWQUFBQzhnQ09BQUFBQUFCVUFBQjQybU5nWkdCZ1lHSXdaUURSREZBU0NRQUFCY29BT3dCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUNVbFlXQmlaV3BDMkNETXNSQmRvZ1VxZXJJNys3aGV1Z05wK2Y5dUFOS2ZzaDRUc1pyM00vSktVVDljY0VMYjRtbm9oYUpTejVZTWlITForTE0yU1RPSmZsS1hQRE9KZkZVL08vRUpaODh0bDE3dS9mV3EzMW5ySGZuTm96cmcvV2g2WnhhNlNycW5YWFdIM3RyMUdsVVptakNjRzFWclN0ZHM2V2o1Y2FkSG90SHNSZkhSSGFjSlF1TXJEbEVKOUJJNnFTMVFsUDl5M2VTdTlnNXhrOUdPaWRKbE5BZ1YwSDJWZHFLT2w1cTZsL3Y2VEJIQUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVk1BQW9BQUFBQUJtd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUFtTnRZWEFBQUFFNEFBQUFOUUFBQUR3QWd3Q0haMng1WmdBQUFYQUFBQUp5QUFBREtLb3hZRHRvWldGa0FBQUQ1QUFBQUM4QUFBQTJLUUdrOUdob1pXRUFBQVFVQUFBQUhnQUFBQ1FHaGdHY2FHMTBlQUFBQkRRQUFBQVVBQUFBRkEzU0FKNXNiMk5oQUFBRVNBQUFBQXdBQUFBTUFhZ0NlbTFoZUhBQUFBUlVBQUFBR0FBQUFDQUFDQUJoYm1GdFpRQUFCR3dBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGUUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtT3N3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSWhpWnZnUDVETkRwSkhVL0FjS0F3RHV0QTFPZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pKRS9mOFA1RHN5UlB6Ly8vL0EvMVZnVlVBQUFKTFZDUVFBQUFCNDJsV1N6V3NUUVJqRzkzMW5aMlozTTdPYk5QdEJUYkpwVE0xU3NJa203YTRXbWh4VUJFRkZLU0lvS0VvL2hDSlN2L0Npc1hyekwvQXM2bEh4b0NLS0Z3LytDUjcwMEpPQ0lDaDRiT0xzcG43TmFkNW5abDZlMy9PT2h0cmtjSWdiK0VscmFXMU5TeUJPMm41UWRQMU83TE1XOEtnUnpjU0JIeWN0cUhIbStrRWMyS0QwVk81MEllbVFGN0RJWE1tZzYwOTdJT2lWdmtGQjVvb3p4T1NENFJGWkxrb0NraTZmRkNETTdkMzdYMnZYOEVRZVRHZXo3enVrd29FUVFNUGhBQ0pZT25EWG5jd0RPalpMWmN0aFVIOFB4elcxUUNzUGgyUVpYMnRuVkpIRVNST2pMbFFoOGF2Z3Nyb05uRG1nOWlGMEF0L0xMRVpiSG1kYjRJQzZrQjF0dVc5QmR0UkQwb1E2RzNVS1FrZ2JlZkQ5VVo1Z3RRaks5dHBaRTFGWXpaNDNucXdYSm85YWxkMkNvMkJydDAwS3dnaER1bko2SmFjc1Z3MnVLd1I2ZWZRZ090U1FIMjdROGs0UFUzRjBlNklNRDUvWmdTdkFzak51bmRtTWhLNC9mNis1OENwMEFLME1ITUdVWEIvanpzL0ZpN2xBdWpsRTQvY0RoK0ZFSkw1QW1DOFFleVNpeDNXUFpobXBXUktoTXRxdkNtSXJiT2F4S3NSLzQxQ1Q3R0gwTDdRZnVLekJlRWxsMm9Tb01adXA3VkdrZUg3QUtKbW1HRFlxSU5pZEZNTzI1NnE4SnZXYmRGc0tKMGR3MHR0RnJuOXpjbEFxTUpCc2FVRUtvelB2NDhIQlJ5YnM1eTVYY1A4TjI1MWEzMXVBWThYOEh3cUZpR1poOEJZS3JsT3gwanJOWXB6UnFmR01iVzQ0d00vNFJ0dWhhU1owMm5FUDRvN3ZjUnVpR3VzQjFMY3p6ckxCOXFBTFFTM211TEg1N3NtdFN4VkRaL0t3Ym8wTjlwVkF4L25IVjFkTDZpc0MwZmNvRVo2V0NUN1k3SzllY0NtYVA1UVh6Qld4Zis0VVQ5T20xc3RNMFg0QmVJUnZKQUFBZU5wallHUmdZQURpcVZiVG5PUDViYjR5TUxNd2dNQmp4dzE5Q1ByL1ArWjBwcnRBTGdjREUwZ1VBQys5QzJVQWVOcGpZR1JnWUdiNHp3QWtBeGhrL3JzeHB6TUFSVkFBS3dCTXlnTW9BQUFDZGdBQUF3QUFKQU5RQUJ3Q1VnQWtBcm9BT2dBQUFBQUFWQURtQVZRQmxIamFZMkJrWUdCZ1pVaGdZR0lBQVVZR05BQUFDbVVBYW5qYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNTkuNTc4ODEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC01OS41Nzg4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuMzQyMDM1JyB5PSctNTkuNTc4ODEnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzcwODMsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTU5LjU3ODgxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02MS4zNDIwMzUnIHk9Jy01OS41Nzg4MSc+WjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03LjY4NDA1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNTkuNTc4ODEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjM0MjAzNScgeT0nLTU5LjU3ODgxJz5rPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjM3MDc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTU5LjU3ODgxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02MS4zNDIwMzUnIHk9Jy01OS41Nzg4MSc+WDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44OTE2MiwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNTkuNTc4ODEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjM0MjAzNScgeT0nLTU5LjU3ODgxJz5ZPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0IDBINDcuMzE1MjUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuNTY1MjUsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxOC40MjY4Miw0LjU2MTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC01OS41Nzg4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuMzQyMDM1JyB5PSctNTkuNTc4ODEnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU2LjY3NTQ1JyB5PSctNjIuNTg1MzI4Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUyLjUxMDQ4MScgeT0nLTU5LjU3ODgxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00OS4zOTcxMzgnIHk9Jy01OS41Nzg4MSc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDUuMjYwMTg4JyB5PSctNTkuNTc4ODEnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC01OS41Nzg4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuMzQyMDM1JyB5PSctNTkuNTc4ODEnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzI2MzctNTYuOTA1NUg0Ny44MzYwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wODYwNywtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjYuMjU1LC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC01OS41Nzg4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuMzQyMDM1JyB5PSctNTkuNTc4ODEnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = A,
      nw/style = {pullback},
      ne = X,
      sw = Z,
      se = Y,
      north = {f^{*}(g)},
      south = g,
      west = k,
      east = f,
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Then by Beck-Chevalley, we have</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {aligned}       T(f){\mathopen {}[g]\mathclose {}}_{Y} &:= T(f)\Sigma _{g}(1)\\                          &\cong  \Sigma _{f^{*}(g)}k^{*}(1) && \text {right adjoint preserves terminal object}\\                          &\cong  \Sigma _{f^{*}(g)}(1)\\                          &=: {\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{X}f^{*}(g)     \end {aligned}   ]]></fr:tex>
  <fr:p>These isomorphisms assemble into a natural isomorphism <fr:tex
display="inline"><![CDATA[f^{*}{\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{Y} \cong  {\mathopen {}[f^{*}(\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]\mathclose {}}_{X}]]></fr:tex> since any two parallel morphisms in the preorder <fr:tex
display="inline"><![CDATA[T(X)]]></fr:tex> are equal.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1218</fr:anchor><fr:addr
type="user">log-000I</fr:addr><fr:route>log-000I.xml</fr:route><fr:title
text="Comprehension schema">Comprehension schema</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[T\colon \mathcal {C}^\mathrm {op}\to \mathsf {Lat}]]></fr:tex> be a <fr:link
type="local"
href="log-000C.xml"
addr="log-000C"
title="Doctrine">doctrine</fr:link> with the structures listed in <fr:ref
addr="log-000H"
href="log-000H.xml"
taxon="Lemma" />.
  Then <fr:tex
display="inline"><![CDATA[T]]></fr:tex> has <fr:em><fr:strong>comprehension schema</fr:strong></fr:em> if for each object <fr:tex
display="inline"><![CDATA[X \in  \mathcal {C}]]></fr:tex> the naming functor <fr:tex
display="inline"><![CDATA[{\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{X}]]></fr:tex> admits a right adjoint <fr:tex
display="inline"><![CDATA[{\mathopen {}\{X\colon \mathord {\hspace {1pt}\text {--}\hspace {1pt}}\}\mathclose {}}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1219</fr:anchor><fr:addr
type="user">log-000J</fr:addr><fr:route>log-000J.xml</fr:route><fr:title
text="Subobject doctrine of a regular category">Subobject doctrine of a regular category</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>, then the subobject doctrine <fr:tex
display="inline"><![CDATA[\mathsf {Sub}\colon \mathcal {C}^\mathrm {op}\to \mathsf {Lat}]]></fr:tex> has <fr:link
type="local"
href="log-000I.xml"
addr="log-000I"
title="Comprehension schema">comprehension schema</fr:link>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1220</fr:anchor><fr:addr
type="machine">#302</fr:addr><fr:route>unstable-302.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Each fiber <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> has finite limits inherited from <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
    By <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma" />, each <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> has the required left adjoint <fr:tex
display="inline"><![CDATA[\exists _{f}]]></fr:tex>.
    They satisfy the <fr:link
type="local"
href="log-000E.xml"
addr="log-000E"
title="Beck-Chevalley condition">Beck-Chevalley condition</fr:link> because images commute with pullbacks in a regular category.
    Then by construction the <fr:link
type="local"
href="log-000H.xml"
addr="log-000H"
title="Naming fucntor">naming functor</fr:link> <fr:tex
display="inline"><![CDATA[{\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{X}\colon {{\mathcal {C}}_{/{X}}}\to \mathsf {Sub}(X)]]></fr:tex> is just <fr:tex
display="inline"><![CDATA[\mathsf {Img}]]></fr:tex>, which admits the inclusion functor as a right adjoint.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1221</fr:anchor><fr:addr
type="user">log-000P</fr:addr><fr:route>log-000P.xml</fr:route><fr:title
text="Internal language of a category">Internal language of a category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category.
  The <fr:em><fr:strong>internal language</fr:strong></fr:em> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> consists of the signature <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> whose sorts are the objects of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, function symbols are the morphisms of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, and relation symbols are the subobjects in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p><fr:p>We write <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> for the canonical <fr:link
type="local"
href="log-0006.xml"
addr="log-0006"
title="Sigma structure"><fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structure</fr:link> that maps each variable to the appropriate product projection, each function symbol <fr:tex
display="inline"><![CDATA[f\colon A_{1},\ldots ,A_{n}\to B]]></fr:tex> to its underlying morphism <fr:tex
display="inline"><![CDATA[f\colon A_{1} \times  \cdots  \times  A_{n}\to B]]></fr:tex>, and each relation symbol <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1},\ldots ,A_{n}]]></fr:tex> to its underlying subobject <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1} \times  \cdots  \times  A_{n}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1222</fr:anchor><fr:addr
type="user">log-000N</fr:addr><fr:route>log-000N.xml</fr:route><fr:title
text="Deduction system for regular categories">Deduction system for <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular categories</fr:link></fr:title><fr:taxon>Construction</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a regular category.</fr:p><fr:ul><fr:li>Structural rules:
    
    
      
      <fr:figure><fr:resource
hash="fc6ac681ad0f924f2c11bc5ade7bf14e"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzUxNS41NjY2MjVwdCcgaGVpZ2h0PSc0MC4wNDk2MTlwdCcgdmlld0JveD0nLTcyIC03MiAzNDMuNzExMDgzIDI2LjY5OTc0Nic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFXc0FBb0FBQUFBQnFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0Y0SjJOdFlYQUFBQUU4QUFBQU5nQUFBRVFEM1FTbFoyeDVaZ0FBQVhRQUFBTE9BQUFEV0pYS0MxNW9aV0ZrQUFBRVJBQUFBQzhBQUFBMktDU2o1MmhvWldFQUFBUjBBQUFBSUFBQUFDUUZxZ0ZrYUcxMGVBQUFCSlFBQUFBVUFBQUFGQXdrQUtSc2IyTmhBQUFFcUFBQUFBd0FBQUFNQWE0Q2RHMWhlSEFBQUFTMEFBQUFHQUFBQUNBQUNBQlJibUZ0WlFBQUJNd0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm15bVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1WOWxadmdQNURNek1JS0VHUkVxL2dPRkFmdTZEaHNBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnTWdEUUhFSUxrMHBoUE1GLzkveC9NT2c1aS9aLzl4L3FQUGxndEdBQUFEL2NNZ2dBQWVOcEZrczFyMUVBWXh2TytrOHhzc3Rsa1A1S1o3VzZUM1RiZFpObmF0VGJycEdyZDFWYXJMV3FGV2hSRUJhMGdmb0FlQkN1Q0NPTEJvK0JCd2FNSFJmd0hQSHZ3N24raGVOR0xCMXNuOVNCekdPWjk1dkQ4bnVmVlFKTTdmZHlQWDdVam1nYkVCY29jWUpOeE1vUjBqZ3RPV1FqWkVMSmFSQWRTcENNWWdsQnpCeUwxSjVaWkh4aGwxTVZVY3ByQWc2Rmp1TUpaNkxVbFFPUzdQcUNJeW9HZXhQYnBwYURzTHRldHNUUE5DWWt3NmJzY29ONTJXL3FFYXhSc2Y2TUpaUmRlYjM5YXFoM2UxMXJFcVNob1Y2dWxXQzlSSUhkUHcwc1NVTmpxcnM1aU5MV3JkSXhjYVpYaStmdGtuSUdtN0d1Qllya0duN1ZET1l0UTlzV2N6R1RLbVVkWkg1SjRMeEJIWFZsTlJrbWM1Qk5sbnUyQ2hDQjRDMm95NHo3SGpWK2RlaU1jZDlzTWJSZW45eXdOQ2xVbi9rWTlKTTUzQzBWMXJOU3IwNmdFdG9uWTI3T1lza3BwK2x1aFlCTjRzLzNqMFluRGl6cXZPV2c2Y3dSbG96dTl0ZjNiQWh0VnNzVXpvMkZublVBNU1CR1lPeUM0MzV2cVBnT2pDRkRFbkNIY21jSG4rRVZieXhtNHpNUFBqUTRVU0o0N3l3dEtWT1JBRmNJSTVBaHlXYWw1RjNHdVJvb3N5d2NoK1BsYmVLS21VcEFDZnJ4clhsMEtEaUkwTENmMDNBQ0FtODdDNmxZWW8wRjF3MFRMTGhMejFDYUNHL2tJRmRiTU9LR002VkF0VnR2enlReWEzU3JlZjI4UVZrVDg4T2NLQ1k2R045Tk9yMkJGTFlCV3I3TXA5cTJ1VFpCWGRxbGlBTkIwcmxQdTZzZFdyT09YMDA3ZEFwZy9hVlBBOG15anZsZUgyYWpsM1ZpMXJ6djR0a3JRVVJWcXFLVTdiWHlvT3V4ckkwMFRPYnZjaGVHTUt4YmY0MEwraDh2UFpQSXZFN1dRMlQ5cEVDY091RWpUajNMOUVtQll0TnUrZzJqMWs0MzFlTGJzWlpjUExKQVZIbHk0eCswR1E3TnVtQjY4dUhmV3RrNlMvbUQ1OXBoZFFQZmpCKy9HeXBIbHBqaEVzQUQyd1NkajgydVZwM2VpOFlzNnJBMXZuUS9FQ3NFWENhbW9ac3MveVZIVFdqNlhqQkFmYnk3TzZIOEIwRWQzY3dBQWVOcGpZR1JnWUFEaVBXZU5JdVA1YmI0eU1MTXdnTUJqeHczVkNQcS9BbE1YMHhVZ2w0T0JDU1FLQURRQ0N1WUFlTnBqWUdSZ1lHYjR6OERBd0RTUFFmYi9BYVl1QnFBSUNtQUZBR0RzQkJJQ2RnQUFBZlVBTmdLQUFCMENtd0FlQXA0QU13QUFBQUFBWmdESUFVZ0JySGphWTJCa1lHQmdaUWhnWUdJQUFVWUdOQUFBQ05VQVduamFUWTZ4YXNNd0VJWS9VOGRRcDlDcEhUb1VUUm1GamZzQWdReVpzbVlzSkpFSURrZ0tzbVBJRXZvQWZlaGVGQTA5d2ZIZGQ3K0VnSm9iQmZjcWVFMzlYaVdWVEErZU1lY3RjeVZIWmE3NVlNRVRSZmtzNXBObDVwSVh2alBQZU9lVXVSTC9rN25taTk5VmNPZkxhS1BhQkdPalB6alh0ODNXeHFFUFhyVzZlWWkxOVRidVJtdlUvcXJNMUEvVDBhbE9ON3BqUmNCeDVzS0lKY3JQTm1KTVlzOUJkbzZlbG9adGNvTk1RVFpLbkJiN1A3R1doRStwWFhyTlNHclBWYnBoa3N3Zy9TaHBSWmZ1YXJvLzMvUXd1d0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTkFBQW9BQUFBQUE3Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJnaUlsaHdHTnRZWEFBQUFGQUFBQUFNUUFBQUR6QVZTRDFaMng1WmdBQUFYUUFBQUJ3QUFBQWdGbTJ2WUpvWldGa0FBQUI1QUFBQUM4QUFBQTJLTGFqOVdob1pXRUFBQUlVQUFBQUhnQUFBQ1FGaWYrRWFHMTBlQUFBQWpRQUFBQU1BQUFBREFhcUFMQnNiMk5oQUFBQ1FBQUFBQWdBQUFBSUFCb0FRRzFoZUhBQUFBSklBQUFBRndBQUFDQUFCUUFWYm1GdFpRQUFBbUFBQUFEVEFBQUJQcTgzZGVGd2IzTjBBQUFETkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtc21DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBR2pBSUxOa0ZKY2xnNlVySG1Rd0N6MVI1T0JnVm1LK1RwSURVTEYvLzhNREFENkdBOG5BQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZTklBMEc1Qm1CTXJXUEVqNC94L0lCOVAvVytVWGdWVUJBUUMwOUFvbEFBQUFlTnBqWUdTby9NL0lzSVRwUHdNM0E0T3dvQmlia3BxNW9KcVprZGhpUm5aWmRrWVF3WFQ3anhlZm1CZ2Y4ellneVFBRWpBem1ESXhNNWt6SEdJU0JIRVVrVGV5Q2ltWmlJbXhNSXY5ODRkb1pHVGZ6aVlveSt2Kzd4aWNtd2NOVXl5TWh4dmZ2R2tnR2FCUUFHRDRVUW5qYVkyQmtZR0FBNHVsUEgyNk81N2Y1eXNETXdnQUNqeDAzMUNEby80ek1Na3ovZ1Z3T0JpYVFLQUJaZEF1REFIamFZMkJrWUdDVytxTUpKR1VZekJtc21jd1pnQ0lvZ0JrQU54MENFZ0FBQXh3QUFBRWNBSGtDY2dBM0FBQUFBQUFhQUVCNDJtTmdaR0JnWUdZUVlRRFJERkFTQ1FBQUFxd0FHd0I0MmsyT3NXckRNQkNHUDFQSFVDZVFxUjA2RkUwWmhZM3pBSVVNbWJKbUxDU1JDQTVZRHBKajhGTHlBSDNvWGhRTlBjSHg2Yi92aElDU0h6SWVsYkdNL1ZFNWhkeWVQR1BPVytKQ2prcGM4c0dLRjdMOFZaSlB2aExuTFBoT1BPT2RTK0pDOG52aWtqVy9tNzY3M2dicjFhNDMxcnRURjZhNjJsc2YydDZwV2xmUFlHdWQ5WWZCR25XY2xCbmJNSjQ3MWVoS04yem82Ymh5WThEaTVXYzdTVXhreDBsbWdZbWFpbjNNQXEzTW5YZzFXdEwveGxZTUY2MURmTTJJZFpTWkVocGxMMGcvaTY5bzRxNm0rUU1KVVRFVEFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBFQUFvQUFBQUFCRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWdBQUFCZ2hqYVdCMk50WVhBQUFBRThBQUFBT3dBQUFFeEE4ZVh2WjJ4NVpnQUFBWGdBQUFEbUFBQUE3Sms4SG9ob1pXRmtBQUFDWUFBQUFDMEFBQUEyS0wrajlXaG9aV0VBQUFLUUFBQUFIUUFBQUNRR1BnSmJhRzEwZUFBQUFyQUFBQUFVQUFBQUZBcGhBT0ZzYjJOaEFBQUN4QUFBQUF3QUFBQU1BR1lBbW0xaGVIQUFBQUxRQUFBQUdBQUFBQ0FBQ0FBZmJtRnRaUUFBQXVnQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRHVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWttR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqRUR2QU9DbkZaZWxBeVdnbE5tYUcvMEErTXdNalNKZ1JvZncvVUJnQTFPY05UM2phWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdzZ0RRWEF3ZFFqb2tobWlHV2ViSVMyLy8vUURFNCsvK3kvMHYvRk56OUI5WUJCUUJWV0EzOUFIamFKWXl4U3NOUUdJWFArYTlKYXNBaGFwSkxiR25qeGNaUVZHaElTeFhkZEhOUjl5SUZSWHdDMzZGdjBhR2JjM2R4OGdFNk9iZzQrUWhONHhXSGJ6aUhqdy9FU3cwNkN2QUFtcUFJTFhTbTA4bWt4Z2J5MVkyOUVkZkE3Ti9aQ1V4WldHYldVRmdoVjY4NS9weDlRTzVrZ1pZZHNUbW1aN3B1SExqUkdjUE1lR1hSSDJUQm9OdGpLY05XMHJoOGZqSUJWZnNxdloxZjYxRWlrb3kwTEw0Zjc4bHRYWDN0UlIybE9ydE4wYzJ3YmZ1Q2szcXREdVFUUHJhQVRVWlo2ZzU1d2I3SGxPOGNVMWVubWh3N3ZqNWEvOGloZkZUbnZvZ3ZiMzdqb1ZyYXhDK2NrQ3RnQUFCNDJtTmdaR0JnQU9MczNCMkw0L2x0dmpJd3N6Q0F3R1BIRFRVSStqOERzeW96aU12QndBU2lBQ2cxQ2JBQUFBQjQybU5nWkdCZ1p2alBBQ1JER2NTQnBDb0RVQVFGc0FJQUxFWUJvUUFBQUFLQUFBQUJIQUI1QVJ3QUZ3SlVBQ0lEVlFBdkFBQUFBQUFTQUNRQVZBQjJlTnBqWUdSZ1lHQmxrR05nWWdBQlJnWTBBQUFEOHdBb2VOcEZqREZ2d2pBUWhiK0lCSWwwNkZKMVlBQVB6RmFpTUhkaFlHSmxZZ0Zzb2d4eGtCTWlJYUdPL2QwOWpDVnVlUHJ1dlhjSDVQeVM4SnlFejZEUFNjbGtlM0hHQjErUnA3SXRJK2ZNV1RFaFNXZmlMUGlKbkVweWlKenh6U1h5VlB4SDVKdzFmNXV1dmQ0RzY5V3VNOWE3Yyt2TFltOTkzM1JPbGJvSSs5WTY2NCtETmVwMFYyWnMrckZ1VmFVTFhiR2hvK1hLalFHTFI3RVR4d1IybkNYemxCVHNnOVBUU09xa1ZhTEZmZWRieVYzb0hNTW5JNTBUZDFIREtGZTlhQzF0UlJVdU5kVS9ZejB2RHdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTguODExODUnIHk9Jy01Ni4xNTk0NzMnPs6TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0yLjU4NTE4MScgeT0nLTU2LjE1OTQ3Myc+fDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScuMTgyMjI4JyB5PSctNTYuMTU5NDczJz7PlTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc5LjQ2Njc5MicgeT0nLTU2LjE1OTQ3Myc+7oGgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzE4LjMyMjQxOScgeT0nLTU2LjE1OTQ3Myc+z5U8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNjAuMzgxNDM0JyB5PSctNjMuNjMxNDIzJz7OkzwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc2Ni42MDgxMDMnIHk9Jy02My42MzE0MjMnPnw8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNjkuMzc1NTEyJyB5PSctNjMuNjMxNDIzJz7PlTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc3OC42NjAwNzYnIHk9Jy02My42MzE0MjMnPu6BoDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc4Ny41MTU3MDMnIHk9Jy02My42MzE0MjMnPs+IPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzExNC4yODgwMzcnIHk9Jy02My42MzE0MjMnPs6TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzEyMC41MTQ3MDcnIHk9Jy02My42MzE0MjMnPnw8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTIzLjI4MjExNScgeT0nLTYzLjYzMTQyMyc+z4g8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTMyLjg5NjQ3MScgeT0nLTYzLjYzMTQyMyc+7oGgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzE0MS43NTIwOTgnIHk9Jy02My42MzE0MjMnPs+HPC90ZXh0Pgo8cmVjdCB4PSc2MC4zODE0MzQnIHk9Jy01OC44NDkzODMnIGhlaWdodD0nLjM5ODQ4NCcgd2lkdGg9Jzg3LjYwNDE2MycvPgo8dGV4dCBjbGFzcz0nZjInIHg9Jzg3LjQ5OTYyJyB5PSctNDguODg2ODY1Jz7OkzwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc5My43MjYyODknIHk9Jy00OC44ODY4NjUnPnw8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nOTYuNDkzNjk3JyB5PSctNDguODg2ODY1Jz7PlTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PScxMDUuNzc4MjYyJyB5PSctNDguODg2ODY1Jz7ugaA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTE0LjYzMzg4OScgeT0nLTQ4Ljg4Njg2NSc+z4c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTk1LjE2OTg2MicgeT0nLTYzLjYzMTQyMyc+4oiGPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzIwMy40NzIwODcnIHk9Jy02My42MzE0MjMnPnw8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMjA2LjIzOTQ5NicgeT0nLTYzLjYzMTQyMyc+z5U8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjE1LjUyNDA2JyB5PSctNjMuNjMxNDIzJz7ugaA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMjI0LjM3OTY4NycgeT0nLTYzLjYzMTQyMyc+z4g8L3RleHQ+CjxyZWN0IHg9JzE4NC43MjI4NzgnIHk9Jy01OC44NDkzODMnIGhlaWdodD0nLjM5ODQ4NCcgd2lkdGg9JzU2Ljk1MDgwMicvPgo8dGV4dCBjbGFzcz0nZjInIHg9JzE4NC43MjI4NzgnIHk9Jy00OC44ODY4NjUnPs6TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzE5MC45NDk1NDcnIHk9Jy00OC44ODY4NjUnPnw8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTkzLjcxNjk1NScgeT0nLTQ4Ljg4Njg2NSc+z5U8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMjAwLjIzNDE4NycgeT0nLTQ4Ljg4Njg2NSc+WzwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScyMDMuMDAxNTk2JyB5PSctNDguODg2ODY1Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzIwOC45NTE1NDMnIHk9Jy00OC44ODY4NjUnPl08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjE0LjQ4NjI4NCcgeT0nLTQ4Ljg4Njg2NSc+7oGgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzIyMy4zNDE5MTEnIHk9Jy00OC44ODY4NjUnPs+IPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzIzMC4xODg5MzUnIHk9Jy00OC44ODY4NjUnPls8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMjMyLjk1NjM0MycgeT0nLTQ4Ljg4Njg2NSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScyMzguOTA2MjknIHk9Jy00OC44ODY4NjUnPl08L3RleHQ+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {mathpartir}
  \RequirePackage {amsmath}

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
          \begin {mathpar}
            
      \Gamma |\varphi  \vdash  \varphi \and \inferrule {\Gamma |\varphi  \vdash  \psi  \\ \Gamma |\psi  \vdash  \chi 
      }{\Gamma |\varphi  \vdash  \chi 
      }\and \inferrule {\Delta |\varphi  \vdash  \psi 
      }{\Gamma |\varphi {\mathopen {}[f]\mathclose {}} \vdash  \psi {\mathopen {}[f]\mathclose {}}
      }
    
          \end {mathpar}
        ]]></fr:resource-source></fr:resource></fr:figure>
    
  
    where <fr:tex
display="inline"><![CDATA[f\colon \Gamma \to \Delta ]]></fr:tex> is a morphism in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:li>
  <fr:li>Finite conjunction:
    
    
      
      <fr:figure><fr:resource
hash="518ad43a9878d6aaca4bbb09feb82363"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzUxNS41NjY2MjVwdCcgaGVpZ2h0PSc0NS4xOTEzNDJwdCcgdmlld0JveD0nLTcyIC03MiAzNDMuNzExMDgzIDMwLjEyNzU2Mic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVTUFBb0FBQUFBQmN3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVnQUFBQmdpV0Y0UldOdFlYQUFBQUU4QUFBQU5BQUFBRHdEOVFRWVoyeDVaZ0FBQVhBQUFBSTNBQUFDakJZV1l5aG9aV0ZrQUFBRHFBQUFBQzhBQUFBMktDU2ovbWhvWldFQUFBUFlBQUFBSHdBQUFDUUZxUUcwYUcxMGVBQUFBL2dBQUFBUUFBQUFFQW92QUc1c2IyTmhBQUFFQ0FBQUFBb0FBQUFLQWFnQTRtMWhlSEFBQUFRVUFBQUFHQUFBQUNBQUJ3QlJibUZ0WlFBQUJDd0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm02bWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFREF4SklLUzVMWjJCalBzNThsWm5oUDVEUHpNQUlFbVpFcVBnUEZBWUFFcHNPbkhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1prWUdJK3dYejEvMytna3VNZytvL1ZIejJ3S2lBQUFMSG1DZzE0MmtXUnowOFRVUkRIZCtadDMrdnV2dTcyeC9adEtleTJzbmEzS1ZDUXJic1ZrRXBScE1SWWswbzBNV0tpbUJCL0hEaDR3SmdZRStQQkl6Y1BIajFvQ1ArRkIvOFdEQmU5ZUJCOEN3ZG5EcE9aNzJReW54a0ZGUGUwalUvZ3U3S29LRUFjSVgwK1R1SklNSnV5Tm9UQkxCQlRocVFVKzJFUXBoWEtLQXZDSUU0OGNFUU5TbkVpeWdJM2Z6Y3FWVy9DcWpQa0ZrNU5yM2F5UlRNNG9qWVM4NmVPVG5FczE2cFFQd2RjUTJ4Tjl5Tld5RTBkWmJPY3dPZVQ0emMzci9aVlVUSlJNK2NKeHRYbTFON0pIeDA0bXNDTTI3M2x4b2hBM3RVUW1OVWhlTm0rMlB3QUdRUEFRTG0yNHAzTzRFZjhvUXhUQmhFbnk1Q2tpM1lraUhEa0JNb2tBcU1XVUluUWc3Z0hxU3hWMmNhQ1ZQVWxXWklXUENpbnVXTTdKWG1GMklIanIrT1BWOTBGaEtwdWVyYmxBZ2pOWE5yWTh3TE1VRFdqb2M0Tm90M2FSckQ4TWtLQmpTZUNVTVpVS0JyRmVqZWNRYTFaeEZmZk1vUVppQWQvSHhGM3hYc1dOVnBaM2E4QjFGcU5iZWZTeHZBQytjUnpoUXdBamVZYithWjZmYURmMklvYUZSMmd1ODRwWUg2dVdwbFZZYzZ2MlRzYi9LbUpYNG9FVFVVYUt0RnBIVi9MSDdhVm5xSTRLWHQ4QmlPWWtDeGxXemp4ZjdqVUo4UHptMHdHWVhJdWRZTFFCQXRwZEJpUEhnSjZCcStYVFVTOUhXNk9ncm04bld4ZFdTSUQ0ZDdmRmJ6S1VLdGtOQnYyZCs5d2ZaMjBPMnN2eG5nV3JjTURlMmR3YlczY1dTU1lCYjd3YnF3N0xMeC82VTg4VUdHNC9QeWU2d3dJN29la0lEK2IvMFZXTkgzdGJ0aERmTHZkbjFIL0FTd2dYblFBZU5wallHUmdZQURpblhhOXl2SDhObDhabUZrWVFPQ3g0NFllQlAxZmdhbUw2U1NReThIQUJCSUZBQ044Q3BBQWVOcGpZR1JnWUdiNHo4REF3RFNQUVpaQmtLbUxBU2lDQWxnQVBLWUNZd0FDZGdBQUFvQUFIUUtiQUI0Q25nQXpBQUFBQUFCaUFPSUJSZ0FBZU5wallHUmdZR0JoQ0dCZ1lnQUJSZ1kwQUFBSXVnQlplTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVBVQUFvQUFBQUFCSFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXdBQUFCZ2lNbGlCR050WVhBQUFBRkFBQUFBT3dBQUFFd2ticjlqWjJ4NVpnQUFBWHdBQUFEdEFBQUJJRVdZKzROb1pXRmtBQUFDYkFBQUFDOEFBQUEyS0xha0ZXaG9aV0VBQUFLY0FBQUFIZ0FBQUNRR05mK0JhRzEwZUFBQUFyd0FBQUFVQUFBQUZBeHdBU0JzYjJOaEFBQUMwQUFBQUF3QUFBQU1BSVFBMUcxaGVIQUFBQUxjQUFBQUZ3QUFBQ0FBQndBV2JtRnRaUUFBQXZRQUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRHlBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXFtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUdqQUFPREE0eVRVbHlXRHBTc2VaREFMUFZIazRHQldZcjVPa2dOUXZuLy93d01BQjZiRDZ0NDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUxJQTBGd01IVUk2Sm9VWkovWUhkZzRULy80RmljUGIvMXJ1MzVZL0tMd0hyZ0FJQXBBUVBxZ0I0Mm1OZ1pLajh6OGl3aE9rL0F6Y0RnN0NnR0p1U21ybWdtcG1SMkdKR2RsbDJSaERCZFB1UEY1K1lHQi96TmlESkFBU01ET2IvbnpLVk1LVXhpQUE1d21MS2JPeHNhdXJjakd6cWF1cHE1c0pteG1hTXVmODVtSmlFbVhuWlAzN2s0UlptWXVUNHp5N0F3K1QvZDcrQUVETWpCeitUL04rSFVpek1RaXdDVExhaVRCQXpMUmtZbVI0enJXVVFCbktnN2xCa1V6TXhFMWMwRXhOaFUyZUVPT2pmWXg0SkNSNm1GRjVSVVY2bTVyK0wrTVNBdkRpNFd4bWg3Z09hWmM1MERHeVdJcEtuMkFYQmhqR0ovUE5GYUdIY3pDY3F5dWovN3hyWXJGb2VDVEcrZjlkQU1rQ2pBQmt0TGpvQUFBQjQybU5nWkdCZ0FPS1hteFFjNC9sdHZqSXdzekNBd0dQSERUMEkrajhqc3d6VGZ5Q1hnNEVKSkFvQUxjY0tqd0I0Mm1OZ1pHQmdsdnFqQ1NSbEdNd1p6SmdlTXdCRlVBQXJBRU42QXJzQUFBTWNBQUFCSEFCNUFxb0FOd01jQURrQ2NnQTNBQUFBQUFBYUFFUUFhZ0NRZU5wallHUmdZR0JsRUdVQTBReFFFZ2tBQUFMN0FCNEFlTnBOanJGcXd6QVFoajlUeDFBbmtLa2RPaFJOR1lXTjh3Q0ZESm15Wml3a2tRZ09XQTZTWS9CUzhnQjk2RjRVRFQzQjhlbS83NFNBa2g4eUhwV3hqUDFST1lYY25qeGp6bHZpUW81S1hQTEJpaGV5L0ZXU1Q3NFM1eXo0VGp6am5VdmlRdko3NHBJMXY1dSt1OTRHNjlXdU45YTdVeGVtdXRwYkg5cmVxVnBYejJCcm5mV0h3UnAxbkpRWjJ6Q2VPOVhvU2pkczZPbTRjbVBBNHVWbk8wbE1aTWRKWm9HSm1vcDl6QUt0ekoxNE5WclMvOFpXREJldFEzek5pSFdVbVJJYVpTOUlQNHV2YU9LdXB2a0RDVkV4RXdCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaGRoNExHTnRZWEFBQUFFOEFBQUFNUUFBQUR3Ryt2MUVaMng1WmdBQUFYQUFBQUNzQUFBQXVCeUdQbHBvWldGa0FBQUNIQUFBQUMwQUFBQTJLSHFreldob1pXRUFBQUpNQUFBQUhnQUFBQ1FHQlFJZ2FHMTBlQUFBQW13QUFBQU1BQUFBREFmd0FGeHNiMk5oQUFBQ2VBQUFBQWdBQUFBSUFDd0FYRzFoZUhBQUFBS0FBQUFBR0FBQUFDQUFCZ0FmYm1GdFpRQUFBcGdBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtMnNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdJTkdCaVNRVWx5V0RwUzBaWjdNelBBZnlHZG1ZQVFKTXlKVS9BY0tBd0FKSXczM0FIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXl0b3lULzcvSDhnSDAvK1AvTWtIcXdJQ0FKazBDVHdBQUFCNDJtTmdZckJpYUdkNnlGakp3TTBnenNEQXFNaW1abUltcm1nbUpzTEdqc1JtMnY5M0xvK1lHRGRUR3Jlb0tQZmZXZHhpWWp4TXlieWlvb3orak95eTdJd2c0aGljeFFBMGlFR0pnWUVwaEdrSGd5eVFJNjZzeDhpdXJNWW1Mc2dtWnMwb3FxN01ibXBzWktZdWFLYW16V2pLWkM0cnhlR2FuYWtzeU1nczc2WVl2TnhYd2xLS2lVbktVb0pweDdQMFJFWkdJWW0vRDZYRkZKaVpGVVJrbUNSa1JPVVpHQUJsNkJzbmVOcGpZR1JnWUFEaSt6Yzc5c2J6MjN4bFlHWmhBSUhIamh0NmtHbW1oMHc3Z0JRSEF4T0lCd0JRY1FzTkFBQUFlTnBqWUdSZ1lHYjR6d0FrWlJpVUdCaVlIaklBUlZBQU13QTFrQUlzQUFBQ2dBQUFBeHdBT2dKVUFDSUFBQUFBQUN3QVhIamFZMkJrWUdCZ1pwQmpZR0lBQVVZR05BQUFBNzBBSm5qYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTM4LjQ2OTk1JyB5PSctNTUuMDY0MTA5Jz7OkzwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzIuMjQzMjgxJyB5PSctNTUuMDY0MTA5Jz58PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0yOS40NzU4NzInIHk9Jy01NS4wNjQxMDknPs+VPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0yMC4xOTEzMDgnIHk9Jy01NS4wNjQxMDknPu6BoDx0c3BhbiB4PSctMTEuMzM1NjgnPu6AvjwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzIwLjg3MzI5OCcgeT0nLTU1LjA2NDEwOSc+zpM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjcuMDk5OTY3JyB5PSctNTUuMDY0MTA5Jz58PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzI5Ljg2NzM3NScgeT0nLTU1LjA2NDEwOSc+z5U8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMzguNTk4NDczJyB5PSctNTUuMDY0MTA5Jz7iiKc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNDcuNDU0MTIxJyB5PSctNTUuMDY0MTA5Jz7PiDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc1Ny4wNjg0NzcnIHk9Jy01NS4wNjQxMDknPu6BoDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc2NS45MjQxMDUnIHk9Jy01NS4wNjQxMDknPs+VPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzk2LjkwMTU1MicgeT0nLTU1LjA2NDEwOSc+zpM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTAzLjEyODIyMScgeT0nLTU1LjA2NDEwOSc+fDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScxMDUuODk1NjI5JyB5PSctNTUuMDY0MTA5Jz7PlTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PScxMTQuNjI2NzI3JyB5PSctNTUuMDY0MTA5Jz7iiKc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTIzLjQ4MjM3NicgeT0nLTU1LjA2NDEwOSc+z4g8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTMzLjA5NjczMicgeT0nLTU1LjA2NDEwOSc+7oGgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzE0MS45NTIzNTknIHk9Jy01NS4wNjQxMDknPs+IPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzE3NC40NTUxMjYnIHk9Jy02My42MzE0MjMnPs6TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzE4MC42ODE3OTUnIHk9Jy02My42MzE0MjMnPnw8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTgzLjQ0OTIwNCcgeT0nLTYzLjYzMTQyMyc+z4c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTkyLjQ1MDA4NCcgeT0nLTYzLjYzMTQyMyc+7oGgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzIwMS4zMDU3MTEnIHk9Jy02My42MzE0MjMnPs+VPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzIyNy43NDgyNTQnIHk9Jy02My42MzE0MjMnPs6TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzIzMy45NzQ5MjMnIHk9Jy02My42MzE0MjMnPnw8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMjM2Ljc0MjMzMicgeT0nLTYzLjYzMTQyMyc+z4c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjQ1Ljc0MzIxMicgeT0nLTYzLjYzMTQyMyc+7oGgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzI1NC41OTg4MzknIHk9Jy02My42MzE0MjMnPs+IPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzE5Mi4zMDgzMTInIHk9Jy00NS40NTkwMyc+zpM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTk4LjUzNDk4MScgeT0nLTQ1LjQ1OTAzJz58PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzIwMS4zMDIzOScgeT0nLTQ1LjQ1OTAzJz7PhzwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PScyMTAuMzAzMjcnIHk9Jy00NS40NTkwMyc+7oGgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzIxOS4xNTg4OTgnIHk9Jy00NS40NTkwMyc+z5U8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjI3Ljg4OTk5NicgeT0nLTQ1LjQ1OTAzJz7iiKc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMjM2Ljc0NTY0NCcgeT0nLTQ1LjQ1OTAzJz7PiDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScxNzMuMjU5NjEzJyB5PSctNTUuMDY0MTA5Jz49PHRzcGFuIHg9JzE3Ny43OTQ4NjcnPj08L3RzcGFuPjx0c3BhbiB4PScxODIuMzMwMDMnPj08L3RzcGFuPjx0c3BhbiB4PScxODYuODY1MTkzJz49PC90c3Bhbj48dHNwYW4geD0nMTkxLjQwMDM1Nic+PTwvdHNwYW4+PHRzcGFuIHg9JzE5NS45MzU1MTgnPj08L3RzcGFuPjx0c3BhbiB4PScyMDAuNDcwNjgxJz49PC90c3Bhbj48dHNwYW4geD0nMjA1LjAwNTg0NCc+PTwvdHNwYW4+PHRzcGFuIHg9JzIwOS41NDEwMDcnPj08L3RzcGFuPjx0c3BhbiB4PScyMTQuMDc2MTcnPj08L3RzcGFuPjx0c3BhbiB4PScyMTguNjExMzMzJz49PC90c3Bhbj48dHNwYW4geD0nMjIzLjE0NjQ5Nic+PTwvdHNwYW4+PHRzcGFuIHg9JzIyNy42ODE2NTknPj08L3RzcGFuPjx0c3BhbiB4PScyMzIuMjE2ODIyJz49PC90c3Bhbj48dHNwYW4geD0nMjM2Ljc1MTk4NSc+PTwvdHNwYW4+PHRzcGFuIHg9JzI0MS4yODcxNDgnPj08L3RzcGFuPjx0c3BhbiB4PScyNDUuODIyMzExJz49PC90c3Bhbj48dHNwYW4geD0nMjUwLjM1NzQ3NCc+PTwvdHNwYW4+PHRzcGFuIHg9JzI1NC44OTI1NzYnPj08L3RzcGFuPjwvdGV4dD4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {mathpartir}
  \RequirePackage {amsmath}

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
          \begin {mathpar}
            
      \Gamma |\varphi  \vdash  \top \and \Gamma |\varphi  \wedge  \psi  \vdash  \varphi \and \Gamma |\varphi  \wedge  \psi  \vdash  \psi \and \mprset {fraction={===}}
      \inferrule {
        \Gamma |\chi  \vdash  \varphi  \\ \Gamma |\chi  \vdash  \psi 
      }{
        \Gamma |\chi  \vdash  \varphi  \wedge  \psi 
      }
    
          \end {mathpar}
        ]]></fr:resource-source></fr:resource></fr:figure></fr:li>
  <fr:li>Existential quantification:
    
    
      
      <fr:figure><fr:resource
hash="78ba7ffae5d6b3df6452473a2eb487de"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzUxNS41NjY2MjVwdCcgaGVpZ2h0PSc0NS4xOTEzNDJwdCcgdmlld0JveD0nLTcyIC03MiAzNDMuNzExMDgzIDMwLjEyNzU2Mic+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9BQUFvQUFBQUFBL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjB5Mk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUM1WjJ4NVpnQUFBV1FBQUFERUFBQUF6SmhxOTUxb1pXRmtBQUFDS0FBQUFDOEFBQUEyS0dDa00yaG9aV0VBQUFKWUFBQUFJQUFBQUNRRnVBR1phRzEwZUFBQUFuZ0FBQUFJQUFBQUNBVUFBRXRzYjJOaEFBQUNnQUFBQUFZQUFBQUdBR1lBQUcxaGVIQUFBQUtJQUFBQUZ3QUFBQ0FBQkFCQ2JtRnRaUUFBQXFBQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRGNBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWFtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTWFReE0vd0g4cGtoMGtocS9nT0ZBZHcwRFR3QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZocC8vOUR5UCt6d1h3R0FGV2dCc0lBQUFCNDJrWEpzVTdDUUJnSDhQdmZOZGVDU2I4Qzlob3h0dEtyMyttZ1JHcEtRa3hCM2F3TFUrUEV6c000T2JEeUxyNkFEOE1LNHNUNit3bUk1akNXYS9rckZrSkFFYlFmd3MvWjFTaE5ZclJ2TXRTWUs2dTVTc29hMDZOUFRCTENzdU5xeW1PRWtsQldSanRzWjVFWERUc3ZqN2N6b0loWmdUSWlLa2JxNm9FK1VqbWdKY1doZWJWM3o0QTF4NDlTb240LzdRYkQxWC9qZS8vejNsczhuYjhwdHVtMUxMUTc2MGg0VGJ6WnRTcjMwWDVlT3I0cFRvVUx2di95OGdCQ2lEOTBpeHFHZU5wallHUmdZQUJpNlhzUzYrUDViYjR5TUxNd2dNQmp4dzJ6RWZSL2ZhWmpUQmVCWEE0R0pwQW9BQzJYQ3hvQWVOcGpZR1JnWUdiNHo4REF3SFNNd2Z2L0JhWXNCcUFJQ21BQ0FHZmpCRlVDeGdBQUFqb0FTd0FBQUFBQVpnQUFlTnBqWUdSZ1lHQmljR1FBMFF4UUVna0FBQWIyQUVjQWVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVU1BQW9BQUFBQUJkd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGdGNEkyTnRZWEFBQUFFOEFBQUFNd0FBQUVRRDNBU2xaMng1WmdBQUFYQUFBQUkyQUFBQ2xQM2s3NkZvWldGa0FBQURxQUFBQUM4QUFBQTJLQ1NrSjJob1pXRUFBQVBZQUFBQUlBQUFBQ1FGcXdGamFHMTBlQUFBQS9nQUFBQVFBQUFBRUFta0FJZHNiMk5oQUFBRUNBQUFBQW9BQUFBS0FiQUE1bTFoZUhBQUFBUVVBQUFBR0FBQUFDQUFCd0JSYm1GdFpRQUFCQ3dBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJteW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcW1NVjlsWnZnUDVETXpNSUtFR1JFcS9nT0ZBZnBHRGhjQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUlMazBwaFBNRi85L3gvQitqLzdqOVVmUGJCYU1BQUFEL1FNZ1FCNDJrV1J2Mi9UVUJESDM5MnpuMlBIc1ozVVA5S21kdEs2OGFzcTFhUjFlQTZsSkcxVG9pYWlCS2xVSUNHS2hJcFU4VU9pUXlYS2dwQ1lHQ3N4d000QXF2b1BNRE93ODNld01FT3gyd0hkZFBlNTRmdTVJMERFZVl4WDhTZFpJd1NvQ1V3eFFKbU5lQmVTWmRkem1SSkEyb1YwSW1SdDRTVTk2SUtYelEwSXM1MUlwREVvVEdFbUpzSmxIRjUxRGRuMGpOV0ZoZ0FJSGRNQjlFTExsM2lrYi9kOXl4eFV0Y25idFJtQk1PdVlMa0MxWWRhbEdWTXU2TTV1RFN3VFB2MzkxcCs0c1ZUZndMblFiMVFxcFVncU1hQXZ0K0VEOVJrY3o0OWFHTTVka0thY2szb3A2aHpSYVFWSUZwOEU1NHY0SG4rUWNlN2lpang0RER4cWkxVGttWlZjam1keGdmR0k5MEQwSU1jWnpUMmluSVk4aGpRZkJPRGt2V2Q3RTZsSWhBZS92dFFlOS8wVmhDbk5DR3pUQjNCVlkzVjBIRVFvTTBsV1VkT0xWTDIxajJDR0RrSlpxYVV1WllvaVFhVllhWFQ0SXFyekZUejZLbE9saUhqNjV4SDExNE9uU1hPaG9JVjFnUHBDYzk5YkdvMW42RWU5VkpZQldMTGN0T2FsemFGMmN5OXBWaldBenBiT0FLM1dWUFdLQksyd2JoK005Q2NHZnE1UU5ESjlnaVE1YitCcitFNWkwaVBFeTkzRmhZeXJ1Sm1MWTd1ZStDK1gxeXkvdkVuMnpQUVN0U051Z0lrc09STTdEd0dEb3Q1d0RFUXQ1cnM3VWN1eTA3MXJxM1RvK3ZjUFhYMUtRYlVxcXphY0hON1J0UzBhdHdmUEovVUNtbWVuOXNGd2JWRHpybE1zZ0w3eWRySXpMcjk3RVU0L2tHRGNmWGJQOTRZVVR6Z3RhNkJidittNnFnM3U4aDdpbS8yTlJla2ZuU3BiTVFBQWVOcGpZR1JnWUFEaWoxT0xYc2J6MjN4bFlHWmhBSUhIamh0bUkrai9Da3hkVEZlQVhBNEdKcEFvQUZ5Z0MvTUFlTnBqWUdSZ1lHYjR6OERBd0RTUFFlNy9BYVl1QnFBSUNtQUJBR0VDQkJJQ2RnQUFBZlVBTmdLYkFCNENuZ0F6QUFBQUFBQm1BT1lCU2dBQWVOcGpZR1JnWUdCaENHQmdZZ0FCUmdZMEFBQUl1Z0JaZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk9RQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUV3QUFBQmdpTWxoM21OdFlYQUFBQUZBQUFBQVBnQUFBRXppUFVOWloyeDVaZ0FBQVlBQUFBRWxBQUFCaU9LWjU4OW9aV0ZrQUFBQ3FBQUFBQzhBQUFBMktMYWtNMmhvWldFQUFBTFlBQUFBSGdBQUFDUUZ4ditCYUcxMGVBQUFBdmdBQUFBV0FBQUFGZ3ZGQVNCc2IyTmhBQUFERUFBQUFBNEFBQUFPQVZZQTdHMWhlSEFBQUFNZ0FBQUFGd0FBQUNBQUNBQWZibUZ0WlFBQUF6Z0FBQURUQUFBQlBxODNkZUZ3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1DbVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FHakFBT0RBNHlUVWx5V0RwU3NlWkRJTFBWSGs0R0JXWXI1T2tnTlF2bi8vd3dNQUJDTkQ0VjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lMSUEwRndNSFVJNkpvVWFKV1VuOVFlTC8vMEF4Q0R2aC8vLy9yWGYvMzcwanZ3U3NBd29BZFdvT3NnQUFlTnBka01GS3cwQVFobWNtSlJ0SU5pYmRaRjJsUmFxd2dSNVZFbnZ3QlFUdFczanJ6WXVJVUJDZndEZFFuMERCcXpmcEUvVGl5WU1QMEx2WmRXT2lxSE9ZNFdlWWIrWWZRRGkzQ1Bka0lRUVFxZlMzZFpYcWNsZmVJUnN5YkJLOWZoekZVc2Jlazh2Z0FtRmlMU0V0WU9pRW15bEd2dDR2MTBmcHYxcEtBdVRLekxtVUhDL01EYzl6ampOei9hWG5pdE50ZmJYQnNWMmwvNVM0MlZQWmR6cWpVOGljRUhMSFo3NHVRdlFMWGVoS2xIc2x6bXhBSkR6T1Zxc29GSVNCWlVsRTAvbzU2WHNZck5GVy9iYlo4L3E5aEE1emFtK3ZBS21pRnhCT2pINFpacW03Ti9NcE04Yy8xaEVmNHp6SHFWbkdVa1YwR1NrWm0yWFQ2ZjdnV0pPTzFhRytYOUFnNlFEWklFQnpFaWtWNFFNR0E5WTRibGc0YnZsamgzU29Ud1gyUGdVQUFBQjQybU5nWkdCZ0FHS1RoVGJhOGZ3Mlh4bVlXUmhBNExIamh0a0krajhqc3d6VGZ5Q1hnNEVKSkFvQURoUUo3UUI0Mm1OZ1pHQmdsdnFqQ1NSbEdNd1p6SmhLR0lBaUtJQVZBRHM5QWt3QUFBTWNBQUFCSEFCNUFqZ0FPUUtxQURjQ2NnQTNBRGtBQUFBQUFBQUFHZ0JPQUhnQW5nREVBQUI0Mm1OZ1pHQmdZR09RWXdEUkRGQVNDUUFBQS9jQUtBQjQyazJPc1dyRE1CQ0dQMVBIVUNlUXFSMDZGRTBaaFkzekFJVU1tYkptTENTUkNBNVlEcEpqOEZMeUFIM29YaFFOUGNIeDZiL3ZoSUNTSHpJZWxiR00vVkU1aGR5ZVBHUE9XK0pDamtwYzhzR0tGN0w4VlpKUHZoTG5MUGhPUE9PZFMrSkM4bnZpa2pXL203NjczZ2JyMWE0MzFydFRGNmE2MmxzZjJ0NnBXbGZQWUd1ZDlZZkJHbldjbEJuYk1KNDcxZWhLTjJ6bzZiaHlZOERpNVdjN1NVeGt4MGxtZ1ltYWluM01BcTNNblhnMVd0TC94bFlNRjYxRGZNMklkWlNaRWhwbEwwZy9pNjlvNHE2bStRTUpVVEVUQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU29BQW9BQUFBQUJXQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFZ0FBQUJnaGdPV0EyTnRZWEFBQUFFOEFBQUFSUUFBQUZ4QlQrWWdaMng1WmdBQUFZUUFBQUdyQUFBQjhGTWhYSkZvWldGa0FBQURNQUFBQUM0QUFBQTJLTCtrTTJob1pXRUFBQU5nQUFBQUhRQUFBQ1FHUGdKZWFHMTBlQUFBQTRBQUFBQWdBQUFBSUJDWEFiaHNiMk5oQUFBRG9BQUFBQklBQUFBU0Frd0J3RzFoZUhBQUFBTzBBQUFBR0FBQUFDQUFDd0FmYm1GdFpRQUFBOHdBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFFbkFBQUFBd0FBQUFnQUFNQUFIamFZMkJta21DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpFRHZBT0NuRlplbEFTUTBsTm1hRy8wQStNd01qU0pnUm9mdy9VQmdBelVZTkdIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzhnRFFmQXdkUWpvMUJrOEdXSVpvaGxubXlFdHYvLzBCeERXVCsvNXYvai8xZitYL0ZuK0o3akdEZFNBQUFPUzhSaWdBQUFIamFUWkhCYWhOUkZJYlBmMjR5VTJlUzFvbTVkNGFZbUU0R1p6cUlMVTJhR1ZLcEMxRVJzUWltZ2hzTjdkU0krQVI1QU9tbVR5QzRLRjBJTGx4MzUwSjA0d080Y3RHTkt4ZXVYR1VTYjZjaUhqaUhjK0RuKzM4NEJOcWZFM1lFa1V0VXJuZkNhQlZwbUtRMzBWM0NJbHlqMW9iQ1VHWHJjUk5vaHV0amhjcXplK0Rib3lYeDI5b2JQWG0vZGV2b2NmYThjbkYzZWpDWnpmYWRFdWtDRFRRM1B1ZENHZVlpT24xTmpUYkNOWVJwMGxYdUZXQ2xJTXJxMC9zOGZGQVRnQ3g4NkM5eEwzOTk5R3U3VnVMQ2g1ZzI2WUJQTVNHN29QcEd1Skc0ZnFMcWh2bmZ6aC96dHhXbGJCN2JVdHI1RzF1cENtZFZLZkVRWnN2RTJmanlieXV5VG5UV3NzNnFMd1JPVCtwRytmQXd5K1pVb25qNjZFemp6b21PenpXWG5LRGYwMzJzRllLbUZJc1BjY0hwRVBFT24xQkxIMjZ3Q2pNSURkY3gxQTNJS0REN3ZXNFNPVWw0RFgxT1c0MkZPNjllQmc1RSs2NC9mTGZ0RFJyTWpZSEhKejllN0FJMUx6KzlySmFGV0s0MzJXdkt0dVl6cmMxbjRpcC9KNHVxUkJlZ0l0OUlvVjlsd3NkbmpPRGxteDR3S2x2ZTlkbFBYdUd2K1piRmJQRW5hMkdjZjlPSVA2YzdXU01BZU5wallHUmdZQURpNS94NkcrUDViYjR5TUxNd2dNQmp4dzJ6RWZSL0JtWlZaaENYZzRFSlJBRUFIaXNKa0FBQWVOcGpZR1JnWUdiNHp3QWtReG5FZ2FRcUExQUVCWEFBQUN4SkFhUUFBQUFDZ0FBQUFZMEFaQUdOQURrREhBQTZBUndBZVFFY0FCY0NWQUFpQTFVQUx3QUFBQUFBTEFCV0FJSUFsQUNtQU5ZQStBQUFlTnBqWUdSZ1lPQmdrR05nWWdBQlJnWTBBQUFFUkFBcmVOcEZqREZ2d2pBUWhiK0lCSWwwNkZKMVlBQVB6RmFpTUhkaFlHSmxZZ0Zzb2d4eGtCTWlJYUdPL2QwOWpDVnVlUHJ1dlhjSDVQeVM4SnlFejZEUFNjbGtlM0hHQjErUnA3SXRJK2ZNV1RFaFNXZmlMUGlKbkVweWlKenh6U1h5VlB4SDVKdzFmNXV1dmQ0RzY5V3VNOWE3Yyt2TFltOTkzM1JPbGJvSSs5WTY2NCtETmVwMFYyWnMrckZ1VmFVTFhiR2hvK1hLalFHTFI3RVR4d1IybkNYemxCVHNnOVBUU09xa1ZhTEZmZWRieVYzb0hNTW5JNTBUZDFIREtGZTlhQzF0UlJVdU5kVS9ZejB2RHdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8dGV4dCBjbGFzcz0nZjMnIHg9JzE2Ljc4NjUyMycgeT0nLTU1LjA2NDEwOSc+zpM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjMuMDEzMTkyJyB5PSctNTUuMDY0MTA5Jz58PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzI1Ljc4MDYnIHk9Jy01NS4wNjQxMDknPs+IPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzM0Ljg0MTQ4OScgeT0nLTU1LjA2NDEwOSc+4oinPHRzcGFuIHg9JzQzLjY5NzEzOCc+4oiDPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNDkuMjMxOTU1JyB5PSctNTMuNTY5NzI4Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzU0LjM5NjY2OScgeT0nLTU1LjA2NDEwOSc+z5U8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nNjMuNjgxMjM0JyB5PSctNTUuMDY0MTA5Jz7ugaHugaA8dHNwYW4geD0nNzguNjI1MTU2Jz7iiIM8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc4NC4xNTk5NzMnIHk9Jy01My41Njk3MjgnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nODkuMzI0Njg3JyB5PSctNTUuMDY0MTA5Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzkzLjE5OTA2MScgeT0nLTU1LjA2NDEwOSc+z4g8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTAwLjA0NjA4NCcgeT0nLTU1LjA2NDEwOSc+WzwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScxMDIuODEzNDkzJyB5PSctNTUuMDY0MTA5Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzEwOC43NjM0NCcgeT0nLTU1LjA2NDEwOSc+XTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PScxMTMuNzQ0NzE0JyB5PSctNTUuMDY0MTA5Jz7iiKc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTIyLjYwMDM2MycgeT0nLTU1LjA2NDEwOSc+z5U8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTI5LjExNzU5NScgeT0nLTU1LjA2NDEwOSc+KTx0c3BhbiB4PScxNzcuMDY2NTI2JyB5PSctNjMuNjMxNDIzJz7iiIY8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PScxODUuMzY4NzUyJyB5PSctNjMuNjMxNDIzJz58PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzE4OC4xMzYxNicgeT0nLTYzLjYzMTQyMyc+z5U8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTk3LjQyMDcyNScgeT0nLTYzLjYzMTQyMyc+7oGgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzIwNi4yNzYzNTInIHk9Jy02My42MzE0MjMnPs+IPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzIxMy4xMjMzNzYnIHk9Jy02My42MzE0MjMnPls8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMjE1Ljg5MDc4NCcgeT0nLTYzLjYzMTQyMyc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScyMjEuODQwNzMxJyB5PSctNjMuNjMxNDIzJz5dPHRzcGFuIHg9JzE3OC40OTY5MjMnIHk9Jy00NS40NTkwMyc+zpM8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PScxODQuNzIzNTkyJyB5PSctNDUuNDU5MDMnPnziiIM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTkzLjAyNTgxNycgeT0nLTQzLjk2NDY0OSc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScxOTguMTkwNTMyJyB5PSctNDUuNDU5MDMnPs+VPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzIwNy40NzUwOTYnIHk9Jy00NS40NTkwMyc+7oGgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzIxNi4zMzA3MjQnIHk9Jy00NS40NTkwMyc+z4g8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTc1Ljg3MTAxMycgeT0nLTU1LjA2NDEwOSc+PTx0c3BhbiB4PScxODAuNTU4MTYzJz49PC90c3Bhbj48dHNwYW4geD0nMTg1LjI0NTI2OCc+PTwvdHNwYW4+PHRzcGFuIHg9JzE4OS45MzIzNzMnPj08L3RzcGFuPjx0c3BhbiB4PScxOTQuNjE5NDc3Jz49PC90c3Bhbj48dHNwYW4geD0nMTk5LjMwNjU4Mic+PTwvdHNwYW4+PHRzcGFuIHg9JzIwMy45OTM2ODcnPj08L3RzcGFuPjx0c3BhbiB4PScyMDguNjgwNzkyJz49PC90c3Bhbj48dHNwYW4geD0nMjEzLjM2Nzg5Nic+PTwvdHNwYW4+PHRzcGFuIHg9JzIxOC4wNTQ4OTUnPj08L3RzcGFuPjwvdGV4dD4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {mathpartir}
  \RequirePackage {amsmath}

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
          \begin {mathpar}
            
      \Gamma |\psi  \wedge  \exists _{f}\varphi  \dashv \vdash  \exists _{f}(\psi {\mathopen {}[f]\mathclose {}} \wedge  \varphi )\and \mprset {fraction={===}}
      \inferrule {\Delta |\varphi  \vdash  \psi {\mathopen {}[f]\mathclose {}}
      }{\Gamma |\exists _{f}\varphi  \vdash  \psi 
      }
    
          \end {mathpar}
        ]]></fr:resource-source></fr:resource></fr:figure></fr:li>
  <fr:li>Equality:
    
    
      
      <fr:figure><fr:resource
hash="f37198f8669f1f5a97cc71bf5402197f"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzUxNS41NjY2MjVwdCcgaGVpZ2h0PScxNC45NDM5NnB0JyB2aWV3Qm94PSctNzIgLTcyIDM0My43MTEwODMgOS45NjI2NCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFQVUFBb0FBQUFBQkhRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUV3QUFBQmdpTWxpQkdOdFlYQUFBQUZBQUFBQU93QUFBRXdrYnI5aloyeDVaZ0FBQVh3QUFBRHRBQUFCSUVXWSs0Tm9aV0ZrQUFBQ2JBQUFBQzhBQUFBMktMYWtNV2hvWldFQUFBS2NBQUFBSGdBQUFDUUdOZitCYUcxMGVBQUFBcndBQUFBVUFBQUFGQXh3QVNCc2IyTmhBQUFDMEFBQUFBd0FBQUFNQUlRQTFHMWhlSEFBQUFMY0FBQUFGd0FBQUNBQUJ3QVdibUZ0WlFBQUF2UUFBQURUQUFBQlBxODNkZUZ3YjNOMEFBQUR5QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FHakFBT0RBNHlUVWx5V0RwU3NlWkRBTFBWSGs0R0JXWXI1T2tnTlF2bi8vd3dNQUI2YkQ2dDQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lMSUEwRndNSFVJNkpvVVpKL1lIZGc0VC8vNEZpY1BiLzFydTM1WS9LTHdIcmdBSUFwQVFQcWdCNDJtTmdaS2o4ejhpd2hPay9BemNEZzdDZ0dKdVNtcm1nbXBtUjJHSkdkbGwyUmhEQmRQdVBGNStZR0Ivek5pREpBQVNNRE9iL256S1ZNS1V4aUFBNXdtTEtiT3hzYXVyY2pHenFhdXBxNXNKbXhtYU11Zjg1bUppRW1YblpQMzdrNFJabVl1VDR6eTdBdytUL2Q3K0FFRE1qQnorVC9OK0hVaXpNUWl3Q1RMYWlUQkF6TFJrWW1SNHpyV1VRQm5LZzdsQmtVek14RTFjMEV4TmhVMmVFT09qZll4NEpDUjZtRkY1UlVWNm01citMK01TQXZEaTRXeG1oN2dPYVpjNTBER3lXSXBLbjJBWEJoakdKL1BORmFHSGN6Q2NxeXVqLzd4cllyRm9lQ1RHK2Y5ZEFNa0NqQUJrdExqb0FBQUI0Mm1OZ1pHQmdBT0tYbXhRNDQvbHR2akl3c3pDQXdHUEhEYk1ROUg5R1pobW0vMEF1QndNVFNCUUFKdU1LY3dCNDJtTmdaR0JnbHZxakNTUmxHTXdaekpnZU13QkZVQUFyQUVONkFyc0FBQU1jQUFBQkhBQjVBcW9BTndNY0FEa0NjZ0EzQUFBQUFBQWFBRVFBYWdDUWVOcGpZR1JnWUdCbEVHVUEwUXhRRWdrQUFBTDdBQjRBZU5wTmpyRnF3ekFRaGo5VHgxQW5rS2tkT2hSTkdZV044d0NGREpteVppd2trUWdPV0E2U1kvQlM4Z0I5NkY0VURUM0I4ZW0vNzRTQWtoOHlIcFd4alAxUk9ZWGNuanhqemx2aVFvNUtYUExCaWhleS9GV1NUNzRTNXl6NFRqempuVXZpUXZKNzRwSTF2NXUrdTk0RzY5V3VOOWE3VXhlbXV0cGJIOXJlcVZwWHoyQnJuZldId1JwMW5KUVoyekNlTzlYb1NqZHM2T200Y21QQTR1Vm5PMGxNWk1kSlpvR0ptb3A5ekFLdHpKMTROVnJTLzhaV0RCZXRRM3pOaUhXVW1SSWFaUzlJUDR1dmFPS3VwdmtEQ1ZFeEV3QjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVA0QUFvQUFBQUFCS0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hkVjNZR050WVhBQUFBRThBQUFBUUFBQUFGUUF1QVNxWjJ4NVpnQUFBWHdBQUFFUUFBQUJSUFBnNUdsb1pXRmtBQUFDakFBQUFDMEFBQUEyS0h1a01XaG9aV0VBQUFLOEFBQUFIZ0FBQUNRRitnSWphRzEwZUFBQUF0d0FBQUFZQUFBQUdBdEVBVVZzYjJOaEFBQUM5QUFBQUE0QUFBQU9BU1FBd0cxaGVIQUFBQU1FQUFBQUdBQUFBQ0FBQ1FBZmJtRnRaUUFBQXh3QUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRDdBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWZNRTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFMwWXA3TXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBYlRBNG5BSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdjZ0RRUEF3ZFFqb1hCaXNHV0lab2hsbm55Ly85QVVTVGUvK1Avai81ZjhYLzVueUt3UGpnQUFNd0VFRng0MmsxUHNVckRVQlE5OXoyYkZGS0YyTDZYRUp1bTZZT1VJRG8wSmxLZGRSTkJYUndsb0loZjBObkJwVjlRZE9yZzVwek5xZjVIRjcraU1iNG9GdUdlZTg2RmN3LzNndUVhaEFVVmFNSUcybHMwaUE2eWtWeUxCUVY3Z1M3NjQwZXBxZGY3ZXE0NUNBQXdIT0dKTFdrQ0N3NUFvYUUzblRDVEhjUDhwOWw3K2RLUzBtSzNsaEJXT2JPa2JMRjhVd2c2SjlNM3FXNGZhNlZ6Q1pNSzFPQ0Fua2paaWRDZ3huU2E1eFUyRUs4dWFvOVRBZk5mVDl0V2FhSXgxdzZPRldMK0Z2L2tEUFNSVjZ5QXJ3ZEg3Wk9wSXNPeERYbE1ZcWpNTkJsbFF6dUxkaWxsaDc3WFBIbTRWemJ4NERTOGZEMXp4eDVqM3RobHhlZmREZEcyV3k1M1pKL3pmcWZMM0s3US8zOERRM3N5L25qYVkyQmtZR0FBWWxNMWplSjRmcHV2RE13c0RDRHcySEhETEFUOW40SHBJVE9JeThIQUJLSUFBQmdKYWdBQUFIamFZMkJrWUdCbStNOEFKR1VZeEJrWW1CNHlBRVZRQUJzQU5KWUNKQUFBQW9BQUFBRWNBRmtESEFBNkFSd0FlUUVjQUJjQ1ZBQWlBQUFBQUFBaUFFNEFZQUJ5QUtJQUFIamFZMkJrWUdCZ1k1QmpZR0lBQVVZR05BQUFCQTRBS1hqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVljQUFvQUFBQUFCemdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hkeDRBV050WVhBQUFBRThBQUFBUGdBQUFFd0g4djJoWjJ4NVpnQUFBWHdBQUFNdUFBQUQzSjhVTUMxb1pXRmtBQUFFckFBQUFDOEFBQUEyS0h1a0xtaG9aV0VBQUFUY0FBQUFIUUFBQUNRRitnSW1hRzEwZUFBQUJQd0FBQUFZQUFBQUdBMnVBTUZzYjJOaEFBQUZGQUFBQUE0QUFBQU9BMFFDUW0xaGVIQUFBQVVrQUFBQUdBQUFBQ0FBQ1FCYWJtRnRaUUFBQlR3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBR0VBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWNtZWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMG82TWw5bFp2Z1A1RE16TUlLRUdSRXEvZ09GQWVseERkQUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdzZ0RRWEF3ZFFqb25Ca2FHRW9ZTDU2di8vUURGSGhtSUkrLytCLy8zL2UvNFlnSFZBQVFCdDd3Nk9BQUI0MmoyVHkyL2NSQnpINXp2alIrejEraEhiNDZ6WDltYnR4VTdTZEYvZXRaTVVkc3NpQXBFS2FWTmFvdktRa0hoVVBBNFZpQU9YRnRRYkhGQnZjT1dLY3VVdkFIR0dNd2ZPUGFJZTZUS2JxSGhHdi9Idk45Sm92cC9mZHdnbHZlV1MvazMvSWdNeUpxUkdWWTk1NEhxOHJMZ3lnRnJreGFRS2VGVVAwRlVWandkVllFTFVWK1Z5aHJwa3YrQUR4V3NxbVBITFBnejVpd2RyTXBvTmQ4STA5ZW55OVdia05obWE4a2VuQmd3dG5mM3d1UHNsdlcxRHMvNTl3QzBXcTJBTWRNMVNBU1A0OE9XSFhzOEd0VXhsVmRZdEJkbnZPQ0hpQTVrdW4rQU12NUtaU1BwUVRRVEpzOGxWUll3K2lobktjZUFwUllLNldvMUMxTVRNNTBKV0F0OUVsdGVUQ3Q4MzkvbGlCQXlqZE9qckhxVWQzZW5mZmVrWXlIakswc1MvWWQxS1pOYWlkTFlUWHBQUU1ZcTNyOHdSTzExRXVCKzdZUE13NVlwaSsxcmVUaWVPTlpSUTdXYmRYcEJKeFRxVmNra3VndTJPd3JZT3NwRTFrRERKa2tnS25XaWxJeEE2VHVnM1pKY1FsNm1LNzlXQ2JpVzRlczlVNUxXYktUTUVaUzBDRHl5VWxkRDA1eldKYm9aSHFheHJVbWdHeFFzN3BRRDN5cDBZbHZWZW9VVlNSTlhzVG16WitQSHBIMXhmSDFHNjk1b05abXFEVnRpWFVPNm9IWFJack9DbjBBRGEzVzlacE9LQ2JiSjhRaVA4Ums1RllrSGNLUkhBcWpMZy92K1hXaTFwTGdnTGYzaUt5anNRdnpOTVJTdHlzVGVBY01RRmRCNklIUkZOMGFicHBLcnpBUlJ4S0c1blRTbmNQMm1qcWNwSnc5NWU5R3VkdHFOeDc0Q2lzMkcwSXRlMjNiUTA0alo5em1uZmlHbERsWkUwMXJjV0d3dGZxM2JqcXd5OXdvMjRZM2xqTHZ1WWZqZjE3ZllXMno4MkJBbHY1RGtDOVNEUk8xMnBtNFpkMkR1eHBGT0tnK0hIbi9OTGJkQzk2MEk0VmIyeDY0aU9KU092WmtpS1RnUy82VzFLR3FYU3RuNkpFRXJLNVNiOVNuaXRUK2FFQkxXUWY2NnM1aW9YeHZOWHorQThGNTVTemdHbGhRZ21Da0hvQWtJOXlRc1RGbFhLcytybU82Qkp3OWowVFVyMWZuSHJaajYwdmZyZC9lZlpFWTlQNzNFalZLbTJJV3NlSHQyN2J1aXZzdjdrOE5PV3NVYXRzNSs5dTBkWEQ5dkJGVWJYWUJ4ODNkbzdkaDUrbGtWdlNUaWVmZkptSEJ3eCtxaGdqZzdEL29lOXFPbUhieFJ6U3UrL3Y3Z3MvUWRLc29TdEFBQjQybU5nWkdCZ0FPSlp4ejUweC9QYmZHVmdabUVBZ2NlT0cyWWg2UDhLVEErWjdnSzVIQXhNSUZFQVlCa01Td0I0Mm1OZ1pHQmdadmpQQUNJWnhCbmttUjR5QUVWUUFCc0FOR1VDSndBQUFBSjJBQUFEQUFBa0FkOEFOUUZ5QUJjQ1NRQWVBcDRBTXdBQUFBQUFWQUM0QVFJQmlnSHVBQUI0Mm1OZ1pHQmdZR09JWkdCaUFBRkdCalFBQUFuUkFHUjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPHRleHQgY2xhc3M9J2YxJyB4PScyMy40NjUyMTMnIHk9Jy02NC41MjgwMjQnPng8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMzAuMjY2MDc4JyB5PSctNjQuNTI4MDI0Jz46PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzM2LjM1NDI4NScgeT0nLTY0LjUyODAyNCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc0My44MjYyODQnIHk9Jy02NC41MjgwMjQnPnzugL48dHNwYW4geD0nNTcuMTA5NzczJz7ugaA8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc2NS45NjU0JyB5PSctNjQuNTI4MDI0Jz54PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jzc0LjQyNjY2NScgeT0nLTY0LjUyODAyNCc+PTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc4NC45NDI3NDUnIHk9Jy02NC41MjgwMjQnPng8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTM1Ljc0MTk0NicgeT0nLTY0LjUyODAyNCc+zpM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTQxLjk2ODYxNScgeT0nLTY0LjUyODAyNCc+fDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScxNDQuNzM2MDI0JyB5PSctNjQuNTI4MDI0Jz5zPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzE1Mi4xNzMzNDQnIHk9Jy02NC41MjgwMjQnPj08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTYyLjY4OTQyNCcgeT0nLTY0LjUyODAyNCc+dDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PScxNjguNTAwOTI0JyB5PSctNjQuNTI4MDI0Jz7iiKc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTc3LjM1NjU3MycgeT0nLTY0LjUyODAyNCc+z5U8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTgzLjg3MzgwNScgeT0nLTY0LjUyODAyNCc+WzwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScxODYuNjQxMjEzJyB5PSctNjQuNTI4MDI0Jz5zPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzE5MS4zMTEyMDEnIHk9Jy02NC41MjgwMjQnPl08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMTk2Ljg0NTk0MicgeT0nLTY0LjUyODAyNCc+7oGgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzIwNS43MDE1NjknIHk9Jy02NC41MjgwMjQnPs+VPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzIxMi4yMTg4MDEnIHk9Jy02NC41MjgwMjQnPls8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMjE0Ljk4NjIxJyB5PSctNjQuNTI4MDI0Jz50PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzIxOC41ODM4NDUnIHk9Jy02NC41MjgwMjQnPl08L3RleHQ+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {mathpartir}
  \RequirePackage {amsmath}

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
          \begin {mathpar}
            
      x\colon A|\top  \vdash  x = x\and \Gamma |s = t \wedge  \varphi {\mathopen {}[s]\mathclose {}} \vdash  \varphi {\mathopen {}[t]\mathclose {}}
    
          \end {mathpar}
        ]]></fr:resource-source></fr:resource></fr:figure>
    
  
    where <fr:tex
display="inline"><![CDATA[s,t\colon \Gamma \rightrightarrows \Delta ]]></fr:tex> is an arbitrary parallel pair of morphisms in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1223</fr:anchor><fr:addr
type="user">log-000O</fr:addr><fr:route>log-000O.xml</fr:route><fr:title
text="Soundness of deduction system for regular categories">Soundness of <fr:link
type="local"
href="log-000N.xml"
addr="log-000N"
title="Deduction system for regular categories">deduction system for regular categories</fr:link></fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The deduction system defined in <fr:ref
addr="log-000N"
href="log-000N.xml"
taxon="Construction" /> is sound.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1224</fr:anchor><fr:addr
type="machine">#301</fr:addr><fr:route>unstable-301.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>The first two structural rules are given by reflexivity and transitivity in each preorder <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(\Gamma )]]></fr:tex>.
    The last structural rules is given by the action on morphisms of the functor <fr:tex
display="inline"><![CDATA[f^{*}\colon \mathsf {Sub}(\Delta )\to \mathsf {Sub}(\Gamma )]]></fr:tex>.</fr:p>
  <fr:p>Every finite conjunction rule is given by the universal properties of terminal objects and binary products.</fr:p>
  <fr:p>The first existential quantification rule is given by <fr:link
type="local"
href="log-000D.xml"
addr="log-000D"
title="Frobenius reciprocity">Frobenius reciprocity</fr:link> proven in <fr:ref
addr="ct-000R"
href="ct-000R.xml"
taxon="Lemma" />.
    The second existential quantification rule is given by the transposition across the adjunction <fr:tex
display="inline"><![CDATA[\exists _{f} \dashv  f^{*}]]></fr:tex>.</fr:p>
  <fr:p>The first equality rule says the terminal object in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> is contained in the equalizer of <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A}]]></fr:tex> with itself.
    Since the equalizer of the identity morphism with itself is an isomorphism (i.e., a maximal subobject of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>), the soundness of this rule follows.</fr:p>
  <fr:p>For the second equality rule, consider the following pullbacks.
    The right square is the pullback of <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> along <fr:tex
display="inline"><![CDATA[s]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="49942fd02b02fcb4aee267a66da17504"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMxMS4yMjAwM3B0JyBoZWlnaHQ9JzEyMC4yMDMyMzhwdCcgdmlld0JveD0nLTcyIC03MiAyMDcuNDgwMDIgODAuMTM1NDkyJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1jQUFvQUFBQUFBNEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FuS1VNbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0o2WjJ4NVpnQUFBV3dBQUFCVUFBQUFWQXNvYTM5b1pXRmtBQUFCd0FBQUFDOEFBQUEyS0xha2RHaG9aV0VBQUFId0FBQUFIZ0FBQUNRRnh2OSthRzEwZUFBQUFoQUFBQUFJQUFBQUNBWEdBRGRzYjJOaEFBQUNHQUFBQUFZQUFBQUdBQ29BQUcxaGVIQUFBQUlnQUFBQUZ3QUFBQ0FBQkFBV2JtRnRaUUFBQWpnQUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRERBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWVzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdXBJNnM5UWZUUVlHWmlubTYwQmhSb1RTLy84WkdBQWQ3dzdYQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VycS8vOUR5THUzd1BJTUFGTmhCcVVBQUFBQkFEZi81UUowQW1ZQUZBQUFBUk1XSXdZSEJpWW5Dd0VHSnlZbkpqY1ROak0yQVczL0NBSUNFd01OQi9IeERBc1RBZ0VJL3djUURBSlAvYjhRRWdNQkNBOENILzNoR2dRREVnUVFBajBWQWdBQUFIamFZMkJrWUdBQTRxSlBDcXp4L0RaZkdaaFpHRURnc2VPR2FRajYvMU5tR2FZMElKZURnUWtrQ2dBaUpncDdBSGphWTJCa1lHQ1crcU1KSkdVWXpCbk1tRW9ZZ0NJb2dBa0FPem9DU1FBQUF4d0FBQUtxQURjQUFBQUFBQ29BQUhqYVkyQmtZR0JnWWhCbEFORU1VQklKQUFBQ3FnQWJBSGphVFk2eGFzTXdFSVkvVThkUUo1Q3BIVG9VVFJtRmpmTUFoUXlac21Zc0pKRUlEbGdPa21Qd1V2SUFmZWhlRkEwOXdmSHB2KytFZ0pJZk1oNlZzWXo5VVRtRjNKNDhZODViNGtLT1Nsenl3WW9Yc3Z4VmtrKytFdWNzK0U0ODQ1MUw0a0x5ZStLU05iK2J2cnZlQnV2VnJqZld1MU1YcHJyYVd4L2EzcWxhVjg5Z2E1MzFoOEVhZFp5VUdkc3duanZWNkVvM2JPanB1SEpqd09MbFp6dEpUR1RIU1dhQmlacUtmY3dDcmN5ZGVEVmEwdi9HVmd3WHJVTjh6WWgxbEprU0dtVXZTRCtMcjJqaXJxYjVBd2xSTVJNQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFWTUFBb0FBQUFBQmlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoWHgwazJOdFlYQUFBQUU0QUFBQU5RQUFBRHdBbUFDdVoyeDVaZ0FBQVhBQUFBSjJBQUFDNkU0MlV2Um9aV0ZrQUFBRDZBQUFBQzhBQUFBMktHQ2s1V2hvWldFQUFBUVlBQUFBSHdBQUFDUUZkZ0hzYUcxMGVBQUFCRGdBQUFBVUFBQUFGQXNqQVBWc2IyTmhBQUFFVEFBQUFBd0FBQUFNQVpZQ05tMWhlSEFBQUFSWUFBQUFHQUFBQUNBQUNBQkZibUZ0WlFBQUJIQUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZRQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbUtjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvbU1wUXdNL3dIOHBraDBraHEvZ09GQWNQQkRQOEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtKakdVL1A4UDVDY3lGUC8vLzMvQi93bGdWVUFBQUpuUENVQUFBQUI0MmpXU3kyN1RRQlNHL1k4ZDIzRWJPNzVrSm0wYUo3VVRPODNGVGVQVzVsTFNTOXFVVmtVVVVRbGFBVktGa0dESkVuVlRGb2dYNEJrUVN6WXN1Z2V4NHdWWUlPQVpZQVV0NDZMT21jMmNNNHZ2KzJjRUlnelBmNUZ0ZkJSNndxb2dZSWdCWlFiUlVYSW9HMklGU1EyVU9iTENLd2gxS0JIQ0pNM0toWmdtWVJBR3NzTGJMdEloMGdUdmM5V0tBNnRFbGJ4aDEzMVZsVFJOaG0xV0VyWnV1dHZ0MFQxSUs0YTljOWhjWElqaGxHSTI5bTBQNkxyZW9ocmdOYldMNXQ2dEI2Vklwek1nbTJGRkJpRmFicTBlaTZqMDNCYndjUGZKSGRzYWkvRE92bjJaYkRZazBycnVuL1RTQ0tTbXpnaDhFV0YwL2hzL3lHZkJFeEx1Skdaa2xNa0c1QXcvV09HTndQZUNjSWlZRDVSc1BzUlNCTi9qS3Z3V2Q0YytadXV0SzQ5RWNXMTI1MkJ0SDVCN2tTWVRvNUUzQVVQWjZEYVF0amJ0Y2hVZGQzbW9xNUtyenBGM1p6OHBsN2w3OEd6UDN4QnhjTHZvblg1b3M0SW1hWWFxU09MazMwTXNoLzFqZjNGK3d6RDA0OVpVZEkwREN0dWM5enMrQ1NOK2lLQjRXYVFsaHllZmhVK3o3SlgvdUlQc0tWekVOT0hFWVhTNWc0c1g0WTQ2SXBMZzFMcGg2VDFxbHErMjNIbXpLNUdaQXVzLzM3MFArS3doMWFic3JWbHR1VjVuRUZlZE9MSW1HVWhaTTF1UEYvWkYwaXhSTUx5Y0xrQXBURFNzSmplejg5UEQ2b0Jha2JRVWVYN0Fhcm15RGJYbzlQV2dRdks2cmpXcTVmbWkwY2xoYnRDa01MeEs1dFRoVHEvSWlkQVZCRnRVYUhvUmNzeGNYT29zcHJZdkJ3bUwrU2RMS1ZQaUFTMDVjdmhuUnlaZTV5Yk5xZm04RE5kZ25WRnZGYm10b3lxeGpLYzFWUXRteWR5UmJsb0czcHg5YlM4Uk1oNFVGRUpvdjB3aktZNG1HQ3FpcCtDRjF5YWs5bGJTaWlxRWYyN2JaMzhBQUhqYVkyQmtZR0FBNG9YOG5zN3gvRFpmR1poWkdFRGdzZU9HYVFqNi8xZW1ZMHpIZ1Z3T0JpYVFLQUFoMWd0SUFIamFZMkJrWUdCbStNL0F3TUIwakVHYlFZSEprd0VvZ2dKWUFUNDVBbWdBQXNZQUFBSjZBRDRDQWdCREFpZ0FTUUc1QUNzQUFBQUFBR29Bd2dFc0FYUjQybU5nWkdCZ1lHVndZV0JpQUFGR0JqUUFBQWVwQUU1NDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJLQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFZ0FBQUJnaGhpV01XTnRZWEFBQUFFOEFBQUFRQUFBQUZRRURDTWlaMng1WmdBQUFYd0FBQUVoQUFBQlJMTWZQdTFvWldGa0FBQUNvQUFBQUM0QUFBQTJLTCtrS1dob1pXRUFBQUxRQUFBQUhRQUFBQ1FHUGdKY2FHMTBlQUFBQXZBQUFBQVlBQUFBR0ExOUFSdHNiMk5oQUFBRENBQUFBQTRBQUFBT0FSNEF2bTFoZUhBQUFBTVlBQUFBR0FBQUFDQUFDUUFmYm1GdFpRQUFBekFBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtY21PY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpFRHZBT0NuRlplbEFTVnNsTm1hRy8wQStNd01qU0pnUm9mdy9VQmdBNEljTlczamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ2NnRFFQQXdkUWpvWEJsaUdhSVpaNXNoTGIvLzlBVVNUZS95UC9sLzlmOXFmdzduK3dQamdBQU1teUVFcDQyazJNc1U3Q1VCaUZ6LzlmYWJHRm9jcTl2VUVJMUVhUUdEV2hVZ0pHTjkyTWlib1RRNEl4UGdGUDRNSVRtRGd4dURtek9SaGRmQUFuQnhZbkg0RlNMNW9ZaDNOeVR2TGxBNk9MVzU3U0VDNThnQUtydGhmN1Fhd0tsdjF2ODFOeW4xUEs1WUVycFp2Y3VVcmx1SitYa2s3Skx0dTBxTmUvQlNQQ01BVmxCR0FlaFY0a1RTZ3pHdlg3S1piUW1KMHRHRDhGeHIvTXFoZTJJcE94SVFSbWFJakh4bzluSGVBTG5xQnNqaC91a0IzV0xOK3oxRDdKZW1pM29tWmM5K0xhRnJXNFhTNW1qMjZ1UTQ5RTVUZzRmempSblNKenNhTjU4bmwxU2JTaWsrbWFxZ3BSTFpSWWwyVEYrQm03NlZ4czhBY2M1SUZsVXZYQWF0TWhOVzBLNklWNnBKT3VKdXBsSEwwOS8rSk5ma3NPSEdhSG41M3NJSGszaW05c3RUZllBQUFBZU5wallHUmdZQURpVlN3L3pzZnoyM3hsWUdaaEFJSEhqaHVtSWVqL0RNeXF6Q0F1QndNVGlBSUFPQ0lLSmdBQWVOcGpZR1JnWUdiNHp3QWtReG5FZ2FRcUExQUVCYkFCQUN4SEFhSUFBQUFDZ0FBQUF4d0FPZ0VjQUhrQkhBQVhBbFFBSWdOVkFDOEFBQUFBQUN3QVBnQlFBSUFBb2dBQWVOcGpZR1JnWUdCamtHTmdZZ0FCUmdZMEFBQUVEZ0FwZU5wRmpERnZ3akFRaGIrSUJJbDA2RkoxWUFBUHpGYWlNSGRoWUdKbFlnRnNvZ3h4a0JNaUlhR08vZDA5akNWdWVQcnV2WGNINVB5UzhKeUV6NkRQU2Nsa2UzSEdCMStScDdJdEkrZk1XVEVoU1dmaUxQaUpuRXB5aUp6eHpTWHlWUHhINUp3MWY1dXV2ZDRHNjlXdU05YTdjK3ZMWW05OTMzUk9sYm9JKzlZNjY0K0ROZXAwVjJacytyRnVWYVVMWGJHaG8rWEtqUUdMUjdFVHh3UjJuQ1h6bEJUc2c5UFRTT3FrVmFMRmZlZGJ5VjNvSE1Nbkk1MFRkMUhES0ZlOWFDMXRSUlV1TmRVL1l6MHZEd0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVN3QUFvQUFBQUFCV1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnNTMwMk50WVhBQUFBRThBQUFBTWdBQUFEd0hTUDF3WjJ4NVpnQUFBWEFBQUFIYkFBQUNKTHhnelRob1pXRmtBQUFEVEFBQUFDOEFBQUEyS0JTankyaG9aV0VBQUFOOEFBQUFId0FBQUNRRmt3SERhRzEwZUFBQUE1d0FBQUFRQUFBQUVBaGxBSDlzYjJOaEFBQURyQUFBQUFvQUFBQUtBWFlBcm0xaGVIQUFBQU80QUFBQUdBQUFBQ0FBQndCQmJtRnRaUUFBQTlBQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRXBBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMG9XTTE5bFp2Z1A1RE16TUlLRUdSRXEvZ09GQWQ3SkRkUUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5cFl3WC8zL0g4Z3ZCdEgvKy83b2dWVUJBUUNuV2dtMkFBQjQyaldRelc3VFFCU0Y1OTZaMkxFeGR0ellNOFN4bmNSR0hvaUttK0JnOXdjU1dxUkFwS0swbEFwVWZpUWtGcFdBUmJkc0toQTdOcWhMdG14UjNvSVhnRWRCYkNsRHE5NXpkYVI3VitkOEJNaXQweit3Z0I5a1RBamtvTnNnNG92bHVxYVVneHhEY1ZONG1veWhLdjlMcXAvYWJBSmxGWU52UTVwVm94SytYRjdqVzBPQVFaZ01mTk5EN0podWZuaHZEcER5aENheHYrdnN4elhhUWh6M2cyMEdIVXMrMzVoQTVQWWdoT09vQ1hRU0pGelRHcjZSdFpPUjZ3d1lsTXRwNzZwSW1WeENsckdhRk5jN0dyMjJuZzZkRlFhak5BNVo0SVlxT2hHcXh5UDhTSllKYVZKZDg3MktxNlNpRk41Rmk2eHFwdG9ZUkZFcDQ4S0JvbFNkZm0wejdBYXpwR1lhTExDRnZOTXZBT3YzRHlKd25GZlNDRm1JZW5vUU9RMzQrdmNuTjVlR2lLc1BHMEJ0WTZVVjVBeUt2dDZCSG8wMCtCWllBTzNlWnhycVFOUWdLVTY3K0Y2eHpjbUVFRkdwREdmNEtxNXpCZHIzdURpL0ZVUHRMR1VpbGRrZ2sweWVrNjVHbWJUQlFhMVlsSHN2QU9OTFZ0ZTNFYzFjN3U5bGc0Wlh2Vnk3VFdjOGVuckVyVUJINDByTjhPRGthTWN5SDlCOE5IM2JzdXJvTEw1N2g3TzcwN2JZb0ZnSGEvMURhM1h1Zm5xWGhzOFl6TWR2bmtSaVJ2RkVVdGNFcS9HYmJocm05TEdjSUI2LzNyckIvZ0ZOSDB6cUFIamFZMkJrWUdBQTRvTFhwMVhqK1cyK01qQ3pNSURBWThjTjB4RDBmd1dtS3FZbUlKZURnUWtrQ2dBOXRBcnhBSGphWTJCa1lHQm0rTS9Bd01BMGowR2NRWUdwaWdFb2dnSllBRHduQWx3QUFuWUFBQUhmQURVQmNnQVhBcDRBTXdBQUFBQUFaQUN1QVJJQUFIamFZMkJrWUdCZ1lYQmdZR0lBQVVZR05BQUFCeW9BU1hqYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00My4wMzkyNzEsLTYxLjgwMzUzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTI0Ljc2MzgsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQzLjAzOTI3MSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQzLjAzOTI3MScgeT0nLTYxLjgwMzUzJz5zPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zNS42MDE5NTEnIHk9Jy02MS44MDM1Myc+PTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMjUuMDg1ODcxJyB5PSctNjEuODAzNTMnPnQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTE5LjI3NDM3JyB5PSctNjEuODAzNTMnPuKIpzwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTAuNDE4NzIyJyB5PSctNjEuODAzNTMnPs+VPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zLjkwMTQ5JyB5PSctNjEuODAzNTMnPls8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTEuMTM0MDgxJyB5PSctNjEuODAzNTMnPnM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMy41MzU5MDYnIHk9Jy02MS44MDM1Myc+XTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOTEuMDQ4NzItMTQuMjI2MzZIOTkuNTg0NjNWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzYuOTY1OSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDMuMDM5MjcxLC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDMuMDM5MjcxJyB5PSctNjEuODAzNTMnPs+VPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zNi41MjIwMzknIHk9Jy02MS44MDM1Myc+WzwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMzMuNzU0NjMnIHk9Jy02MS44MDM1Myc+czwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjkuMDg0NjQzJyB5PSctNjEuODAzNTMnPl08L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTY3LjQ0NTcsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQzLjAzOTI3MSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQzLjAzOTI3MScgeT0nLTYxLjgwMzUzJz7PlTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTAuODE1OTIsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00My4wMzkyNzEsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00My4wMzkyNzEnIHk9Jy02MS44MDM1Myc+czwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzUuNjAxOTUxJyB5PSctNjEuODAzNTMnPj08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTI1LjA4NTg3MScgeT0nLTYxLjgwMzUzJz50PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDgyLjIzMzI2LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDMuMDM5MjcxLC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDMuMDM5MjcxJyB5PSctNjEuODAzNTMnPs6TPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE2Ni41NDk4NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQzLjAzOTI3MSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQzLjAzOTI3MScgeT0nLTYxLjgwMzUzJz7iiIY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtMTEuMTA5NzNWLTQ4Ljg0NDk5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsMC4wLC0xMS4zNTk3MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ5LjA5NDk5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNMjkuMzE5MzQgMEg3MS45MTAzNScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3Mi4xNjAzNSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjY5NjAxLDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00My4wMzkyNzEsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00My4wMzkyNzEnIHk9Jy02MS44MDM1Myc+YTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTcuNTcxNDYtNTYuOTA1NUg3Ny4xNzc3MicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxNy44MjE0NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNzcuNDI3NzIsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J004NS4zNTgyNi0xMS4xMDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCw4NS4zNTgyNiwtMTEuMzU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsODUuMzU4MjYsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNOTguMzA2MTcgMEgxNjIuMzkwMTUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTYyLjY0MDE1LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTI4LjgzOTgzLDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00My4wMzkyNzEsLTYxLjgwMzUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00My4wMzkyNzEnIHk9Jy02MS44MDM1Myc+YjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTcwLjcxNjUyLTEwLjU1NDE1Vi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDE3MC43MTY1MiwtMTAuODA0MTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMTcwLjcxNjUyLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPHBhdGggZD0nTTkzLjAzODgtNTMuMjg4ODhIMTYxLjQ5NDMxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE2MS43NDQzMSwtNTMuMjg4ODgpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEyNS42Mjk0LC01MC40NzcwNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQzLjAzOTI3MSwtNjEuODAzNTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQzLjAzOTI3MScgeT0nLTYxLjgwMzUzJz5zPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J005My4wMzg4LTYwLjUyMjEzSDE2MS40OTQzMScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNjEuNzQ0MzEsLTYwLjUyMjEzKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMjYuMDA2MTMsLTY3LjYzOTQ4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDMuMDM5MjcxLC02MS44MDM1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDMuMDM5MjcxJyB5PSctNjEuODAzNTMnPnQ8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram, node distance = 2cm and 3cm]
      \node  [pullback] (1) {$s=t \wedge  \varphi {\mathopen {}[s]\mathclose {}}$};
      \node  [right = of 1,pullback] (2) {$\varphi {\mathopen {}[s]\mathclose {}}$};
      \node  [right = of 2] (3) {$\varphi $};
      \node  [below = of 1] (4) {$s = t$};
      \node  [right = of 4] (5) {$\Gamma $};
      \node  [right = of 5] (6) {$\Delta $};
      \draw  [>->,morphism] (1) to (4);
      \draw  [->,morphism] (1) to node {$a$} (2);
      \draw  [>->,morphism] (4) to (5);
      \draw  [>->,morphism] (2) to (5);
      \draw  [->,morphism] (2) to node {$b$} (3);
      \draw  [>->,morphism] (3) to (6);
      \draw  [->,morphism,offset=-1.5] (5) to node {$s$} (6);
      \draw  [->,morphism,offset=1.5] (5) to node[swap] {$t$} (6);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Since <fr:tex
display="inline"><![CDATA[s]]></fr:tex> and <fr:tex
display="inline"><![CDATA[t]]></fr:tex> are equalized by the morphism <fr:tex
display="inline"><![CDATA[s = t \rightarrowtail  \Gamma ]]></fr:tex>, the outer square of the following diagram commutes.
    Thus, the intersection <fr:tex
display="inline"><![CDATA[s = t \wedge  \varphi {\mathopen {}[s]\mathclose {}}]]></fr:tex> is contained in <fr:tex
display="inline"><![CDATA[\varphi {\mathopen {}[t]\mathclose {}}]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="2d72e04518c8ff61173aeb468f98e1e5"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMS4yNzMyNXB0JyBoZWlnaHQ9JzE3Mi41NzY4ODdwdCcgdmlld0JveD0nLTcyIC03MiAxMzQuMTgyMTY3IDExNS4wNTEyNTgnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTWNBQW9BQUFBQUE0QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncW5LVU1tTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDSjZaMng1WmdBQUFXd0FBQUJVQUFBQVZBc29hMzlvWldGa0FBQUJ3QUFBQUM4QUFBQTJLTGFrWm1ob1pXRUFBQUh3QUFBQUhnQUFBQ1FGeHY5K2FHMTBlQUFBQWhBQUFBQUlBQUFBQ0FYR0FEZHNiMk5oQUFBQ0dBQUFBQVlBQUFBR0FDb0FBRzFoZUhBQUFBSWdBQUFBRndBQUFDQUFCQUFXYm1GdFpRQUFBamdBQUFEVEFBQUJQcTgzZGVGd2IzTjBBQUFEREFBQUFCQUFBQUFnQUFNQUFYamFZMkJtZXN3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCalFBRU9NRVpLY1ZrNkE1dVN1cEk2czlRZlRRWUdaaW5tNjBCaFJvVFMvLzhaR0FBZDd3N1hBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrVXJxLy85RHlMdTN3UElNQUZOaEJxVUFBQUFCQURmLzVRSjBBbVlBRkFBQUFSTVdJd1lIQmlZbkN3RUdKeVluSmpjVE5qTTJBVzMvQ0FJQ0V3TU5CL0h4REFzVEFnRUkvd2NRREFKUC9iOFFFZ01CQ0E4Q0gvM2hHZ1FERWdRUUFqMFZBZ0FBQUhqYVkyQmtZR0FBNHFKUENvcngvRFpmR1poWkdFRGdzZU9HZmdUOS95bXpERk1ha012QndBUVNCUUFsbUFxSkFIamFZMkJrWUdDVytxTUpKR1VZekJuTW1Fb1lnQ0lvZ0FrQU96b0NTUUFBQXh3QUFBS3FBRGNBQUFBQUFDb0FBSGphWTJCa1lHQmdZaEJsQU5FTVVCSUpBQUFDcWdBYkFIamFUWTZ4YXNNd0VJWS9VOGRRSjVDcEhUb1VUUm1GamZNQWhReVpzbVlzSkpFSURsZ09rbVB3VXZJQWZlaGVGQTA5d2ZIcHYrK0VnSklmTWg2VnNZejlVVG1GM0o0OFk4NWI0a0tPU2x6eXdZb1hzdnhWa2srK0V1Y3MrRTQ4NDUxTDRrTHllK0tTTmIrYnZydmVCdXZWcmpmV3UxTVhwcnJhV3gvYTNxbGFWODlnYTUzMWg4RWFkWnlVR2Rzd25qdlY2RW8zYk9qcHVISmp3T0xsWnp0SlRHVEhTV2FCaVpxS2Zjd0NyY3lkZURWYTB2L0dWZ3dYclVOOHpZaDFsSmtTR21VdlNEK0xyMmppcnFiNUF3bFJNUk1BZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFNQUFvQUFBQUFCS0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWdBQUFCZ2hoaVdNV050WVhBQUFBRThBQUFBUUFBQUFGUUVEQ01pWjJ4NVpnQUFBWHdBQUFFaEFBQUJSTE1mUHUxb1pXRmtBQUFDb0FBQUFDNEFBQUEyS0wra0cyaG9aV0VBQUFMUUFBQUFIUUFBQUNRR1BnSmNhRzEwZUFBQUF2QUFBQUFZQUFBQUdBMTlBUnRzYjJOaEFBQURDQUFBQUE0QUFBQU9BUjRBdm0xaGVIQUFBQU1ZQUFBQUdBQUFBQ0FBQ1FBZmJtRnRaUUFBQXpBQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRUFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWNtT2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqRUR2QU9DbkZaZWxBU1ZzbE5tYUcvMEErTXdNalNKZ1JvZncvVUJnQTRJY05XM2phWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdjZ0RRUEF3ZFFqb1hCbGlHYUlaWjVzaExiLy85QVVTVGUveVAvbC85ZjlxZnc3bit3UGpnQUFNbXlFRXA0MmsyTXNVN0NVQmlGei85ZmFiR0ZvY3E5dlVFSTFFYVFHRFdoVWdKR045Mk1pYm9UUTRJeFBnRlA0TUlUbURneHVEbXpPUmhkZkFBbkJ4WW5INEZTTDVvWWgzTnlUdkxsQTZPTFc1N1NFQzU4Z0FLcnRoZjdRYXdLbHYxdjgxTnluMVBLNVlFcnBadmN1VXJsdUorWGtrN0pMdHUwcU5lL0JTUENNQVZsQkdBZWhWNGtUU2d6R3ZYN0taYlFtSjB0R0Q4RnhyL01xaGUySXBPeElRUm1hSWpIeG85bkhlQUxucUJzamgvdWtCM1dMTit6MUQ3SmVtaTNvbVpjOStMYUZyVzRYUzVtajI2dVE0OUU1VGc0ZnpqUm5TSnpzYU41OG5sMVNiU2lrK21hcWdwUkxaUllsMlRGK0JtNzZWeHM4QWNjNUlGbFV2WEFhdE1oTlcwSzZJVjZwSk91SnVwbEhMMDkvK0pOZmtzT0hHYUhuNTNzSUhrM2ltOXN0VGZZQUFBQWVOcGpZR1JnWUFEaVZTdy9Yc2Z6MjN4bFlHWmhBSUhIamh2NkVmUi9CbVpWWmhDWGc0RUpSQUVBTzVRS05BQUFlTnBqWUdSZ1lHYjR6d0FrUXhuRWdhUXFBMUFFQmJBQkFDeEhBYUlBQUFBQ2dBQUFBeHdBT2dFY0FIa0JIQUFYQWxRQUlnTlZBQzhBQUFBQUFDd0FQZ0JRQUlBQW9nQUFlTnBqWUdSZ1lHQmprR05nWWdBQlJnWTBBQUFFRGdBcGVOcEZqREZ2d2pBUWhiK0lCSWwwNkZKMVlBQVB6RmFpTUhkaFlHSmxZZ0Zzb2d4eGtCTWlJYUdPL2QwOWpDVnVlUHJ1dlhjSDVQeVM4SnlFejZEUFNjbGtlM0hHQjErUnA3SXRJK2ZNV1RFaFNXZmlMUGlKbkVweWlKenh6U1h5VlB4SDVKdzFmNXV1dmQ0RzY5V3VNOWE3Yyt2TFltOTkzM1JPbGJvSSs5WTY2NCtETmVwMFYyWnMrckZ1VmFVTFhiR2hvK1hLalFHTFI3RVR4d1IybkNYemxCVHNnOVBUU09xa1ZhTEZmZWRieVYzb0hNTW5JNTBUZDFIREtGZTlhQzF0UlJVdU5kVS9ZejB2RHdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVNzQUFvQUFBQUFCVXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hYeDBsMk50WVhBQUFBRTRBQUFBTWdBQUFEd0FtUUN0WjJ4NVpnQUFBV3dBQUFIZEFBQUNGRk4vUWdSb1pXRmtBQUFEVEFBQUFDOEFBQUEyS0dDazEyaG9aV0VBQUFOOEFBQUFId0FBQUNRRmRnSHJhRzEwZUFBQUE1d0FBQUFRQUFBQUVBajdBS3hzYjJOaEFBQURyQUFBQUFvQUFBQUtBWFFBd20xaGVIQUFBQU80QUFBQUdBQUFBQ0FBQndCQ2JtRnRaUUFBQTlBQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRW9BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtT2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9tTXBRd00vd0g4cGtoMGtocS9nT0ZBY1UxRFFNQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS0pqR1UvUDhQNUNlQzZQOEwvdmVEVlFFQkFKblZDVUFBQUhqYUhaSE5idE5BRklYbmpKMFp4N1NlSkU1bWl0STRyWjNhYVg1TWlWTWJRZVcwVFJwb0JLSUlKSlFLa0xwQWdrZEEzWFNEZUFHZUFiRmt3NEk5RWp0ZWdBVVNQQU9zSUdYQ1BidHo3dUk3OXhKSzhzdGY5QmlmU1ovc0U0SWNBNmtFZFZDclNwVmpoTFFKcWFxTWE0V1JBeDRqU3JPbFBCaFpHb1ZSeUxpMlBXUTVzaFFmQ28xNkZaV2E1RVhoYmdTV1pkbzJnMXV1cCtxdzdCMTN4bzloam9RN085MGFYazlRclNWcUdyZyswUFA4b1JYaWpYUkw1Wk43VDJxeEk5ZEJqNkk2QTZWMjRXQWpNVkR2ZTIzZzZkM25EOXpLMUlDLytQNTFaYXRsMHZhdDRLS2Z4YUJOYTUzb29XUjgrUnMvNkJmaWsxUjNNcFprVWpFQnRzUVBSOW9JQXorTWNpUTY0TXM4eDI2TXdOZFY5SmJ1RG1lcUR0czNuaG5Hd2Vac2Z2QUlZUDNZWmxTMGltVkE4RW12aGF4OTVLNDEwUFgyY3NjeVBXdWJ2bC84bExyTXcvbkxrMkJpWUg2LzVILzYyRkdydG1rTGk1dkd5dDlUN0VVNzU4SHcya1FJNTd4OU5iNnBBVWxYODc2bUY2UkhpR3R3bWYwSFNwU0g1ZG01SmgxbWJzRENWQ1g2SVpsVVBCbklXcFZGZjJhTSt0MDdzbUFWaXd5ZVVOMXhmeCtGMjJjTldoRXZtcFlkYnRMdE02ZGNFWGk3K05iWnBYUTZXT1dVeXAwMUdadEpmRVdoYnZnY3Ivd09wYzEzcGwyeVFQNEI3VjlOM3dBQUFIamFZMkJrWUdBQTR0bUNwWVh4L0RaZkdaaFpHRURnc2VPR2ZnVDkveXZUTWFialFDNEhBeE5JRkFBdkpBdVFBSGphWTJCa1lHQm0rTS9Bd01CMGpFR2JRWUhKa3dFb2dnSllBRDQ0QW1jQUFzWUFBQUo2QUQ0Q0FnQkRBYmtBS3dBQUFBQUFhZ0RDQVFvQUFIamFZMkJrWUdCZ1lYQmtZR0lBQVVZR05BQUFCME1BU25qYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVN3QUFvQUFBQUFCV1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnNTMwMk50WVhBQUFBRThBQUFBTWdBQUFEd0hTUDF3WjJ4NVpnQUFBWEFBQUFIYkFBQUNKTHhnelRob1pXRmtBQUFEVEFBQUFDOEFBQUEyS0JTanZXaG9aV0VBQUFOOEFBQUFId0FBQUNRRmt3SERhRzEwZUFBQUE1d0FBQUFRQUFBQUVBaGxBSDlzYjJOaEFBQURyQUFBQUFvQUFBQUtBWFlBcm0xaGVIQUFBQU80QUFBQUdBQUFBQ0FBQndCQmJtRnRaUUFBQTlBQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRXBBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMG9XTTE5bFp2Z1A1RE16TUlLRUdSRXEvZ09GQWQ3SkRkUUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5cFl3WC8zL0g4Z3ZCdEgvKy83b2dWVUJBUUNuV2dtMkFBQjQyaldRelc3VFFCU0Y1OTZaMkxFeGR0ellNOFN4bmNSR0hvaUttK0JnOXdjU1dxUkFwS0swbEFwVWZpUWtGcFdBUmJkc0toQTdOcWhMdG14UjNvSVhnRWRCYkNsRHE5NXpkYVI3VitkOEJNaXQweit3Z0I5a1RBamtvTnNnNG92bHVxYVVneHhEY1ZONG1veWhLdjlMcXAvYWJBSmxGWU52UTVwVm94SytYRjdqVzBPQVFaZ01mTk5EN0podWZuaHZEcER5aENheHYrdnN4elhhUWh6M2cyMEdIVXMrMzVoQTVQWWdoT09vQ1hRU0pGelRHcjZSdFpPUjZ3d1lsTXRwNzZwSW1WeENsckdhRk5jN0dyMjJuZzZkRlFhak5BNVo0SVlxT2hHcXh5UDhTSllKYVZKZDg3MktxNlNpRk41Rmk2eHFwdG9ZUkZFcDQ4S0JvbFNkZm0wejdBYXpwR1lhTExDRnZOTXZBT3YzRHlKd25GZlNDRm1JZW5vUU9RMzQrdmNuTjVlR2lLc1BHMEJ0WTZVVjVBeUt2dDZCSG8wMCtCWllBTzNlWnhycVFOUWdLVTY3K0Y2eHpjbUVFRkdwREdmNEtxNXpCZHIzdURpL0ZVUHRMR1VpbGRrZ2sweWVrNjVHbWJUQlFhMVlsSHN2QU9OTFZ0ZTNFYzFjN3U5bGc0Wlh2Vnk3VFdjOGVuckVyVUJINDByTjhPRGthTWN5SDlCOE5IM2JzdXJvTEw1N2g3TzcwN2JZb0ZnSGEvMURhM1h1Zm5xWGhzOFl6TWR2bmtSaVJ2RkVVdGNFcS9HYmJocm05TEdjSUI2LzNyckIvZ0ZOSDB6cUFIamFZMkJrWUdBQTRvTFhweDNqK1cyK01qQ3pNSURBWThjTi9RajZ2d0pURlZNVGtNdkJ3QVFTQlFCQkpnci9BSGphWTJCa1lHQm0rTS9Bd01BMGowR2NRWUdwaWdFb2dnSllBRHduQWx3QUFuWUFBQUhmQURVQmNnQVhBcDRBTXdBQUFBQUFaQUN1QVJJQUFIamFZMkJrWUdCZ1lYQmdZR0lBQVVZR05BQUFCeW9BU1hqYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yLjk1MTMwNCwtMjMuMjg0NjYxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTcuODU0MTcsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIuOTUxMzA0LC0yMy4yODQ2NjEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTIuOTUxMzA0JyB5PSctMjMuMjg0NjYxJz7PlTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczLjU2NTkyOCcgeT0nLTIzLjI4NDY2MSc+WzwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc2LjMzMzMzNicgeT0nLTIzLjI4NDY2MSc+dDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc5LjkzMDk3MScgeT0nLTIzLjI4NDY2MSc+XTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy4xMjUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yLjk1MTMwNCwtMjMuMjg0NjYxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yLjk1MTMwNCcgeT0nLTIzLjI4NDY2MSc+zpM8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtMTEuMTA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsMC4wLC0xMS4zNTk3MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy4yNjM4OSwtMzAuNTM2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yLjk1MTMwNCwtMjMuMjg0NjYxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTMuNjM0NjcsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIuOTUxMzA0LC0yMy4yODQ2NjEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTIuOTUxMzA0JyB5PSctMjMuMjg0NjYxJz7PlTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi43Mzg4MywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIuOTUxMzA0LC0yMy4yODQ2NjEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIuOTUxMzA0JyB5PSctMjMuMjg0NjYxJz7iiIY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEyLjQwOTcxIDBINDguNTc5MTMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguODI5MTMsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzMC43NDQ0MiwyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMi45NTEzMDQsLTIzLjI4NDY2MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTEwLjU1NDE1Vi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDU2LjkwNTUsLTEwLjgwNDE1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMzAuMjU4MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIuOTUxMzA0LC0yMy4yODQ2NjEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNy42ODA1NC01Ni45MDU1SDQ3LjY4MzI5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ3LjkzMzI5LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNi40MjE1LC02NC4wMjI4NiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIuOTUxMzA0LC0yMy4yODQ2NjEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIuOTUxMzA0JyB5PSctMjMuMjg0NjYxJz50PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02NS4wMDIwOSwzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMi45NTEzMDQsLTIzLjI4NDY2MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMi45NTEzMDQnIHk9Jy0yMy4yODQ2NjEnPnM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNC40ODYwMTYnIHk9Jy0yMy4yODQ2NjEnPj08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTUuMDAyMDk2JyB5PSctMjMuMjg0NjYxJz50PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzIwLjgxMzU5NicgeT0nLTIzLjI4NDY2MSc+4oinPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzI5LjY2OTI0NScgeT0nLTIzLjI4NDY2MSc+z5U8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMzYuMTg2NDc3JyB5PSctMjMuMjg0NjYxJz5bPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzM4Ljk1Mzg4NScgeT0nLTIzLjI4NDY2MSc+czwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc0My42MjM4NzMnIHk9Jy0yMy4yODQ2NjEnPl08L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00MS43MDU2NiAyOS4xNDg2NUMtNDYuMDkxNjQtMy4xNzU2LTM1LjIyMTEyLTI5LjcxMDExLTguMDc1OTktNTAuNzEwODMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4xMzQ0MywwLjk5MDg4LC0wLjk5MDg4LDAuMTM0NDMsLTQxLjczOTI3LDI4LjkwMDkyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjc5MDksLTAuNjExODgsMC42MTE4OCwwLjc5MDksLTcuODc4MjcsLTUwLjg2MzgpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J00tMTAuOTE4OTYgNDQuMDkzOEMxOC4xMDc0OCA0My41MDAzIDM4LjUyNDI1IDMxLjE0OTYxIDUyLjI4MjQ3IDYuMTUzMjknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC40ODIxOCwtMC44NzYwNCwwLjg3NjA0LDAuNDgyMTgsNTIuNDAzMDIsNS45MzQyOCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjkuNzAxMzQsMzcuMDMxNjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yLjk1MTMwNCwtMjMuMjg0NjYxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yLjk1MTMwNCcgeT0nLTIzLjI4NDY2MSc+YmE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nMy4wLDIuMCcgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CjxwYXRoIGQ9J00tMzEuMzMxMyAzMS4zMjg1N0wtOS4yNTkzNyA5LjI2MzIxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MiwtMC43MDY5OSwwLjcwNjk5LDAuNzA3MiwtOS4wODI1Nyw5LjA4NjQ3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw = {\varphi {\mathopen {}[t]\mathclose {}}},
        nw/style = pullback,
        ne = \varphi ,
        sw = \Gamma ,
        se = \Delta ,
        south = t,
        east/style = {>->},
        west/style = {>->},
      }
      \node  [above left = of nw] (a) {$s = t \wedge  \varphi {\mathopen {}[s]\mathclose {}}$};
      \draw  [>->,morphism,bend right] (a) to (sw);
      \draw  [->,morphism,bend left] (a) to node {$ba$} (ne);
      \draw  [->,exists,morphism] (a) to (nw);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1225</fr:anchor><fr:addr
type="user">log-000Q</fr:addr><fr:route>log-000Q.xml</fr:route><fr:title
text="Functional completeness">Functional completeness</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link> and <fr:tex
display="inline"><![CDATA[R \in  \mathsf {Sub}(A \times  B)]]></fr:tex> be a relation satisfying the following sequents:</fr:p><fr:ul><fr:li><fr:em><fr:strong>Functional</fr:strong></fr:em>: <fr:tex
display="inline"><![CDATA[x\colon A, y\colon B, y'\colon B|R(x,y) \wedge  R(x,y') \vdash  y = y']]></fr:tex></fr:li>
  <fr:li><fr:em><fr:strong>Total</fr:strong></fr:em>: <fr:tex
display="inline"><![CDATA[x\colon A|\top  \vdash  \exists x\colon B.\mkern 5muR]]></fr:tex></fr:li></fr:ul><fr:p>Then there is a unique morphism <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[x\colon A,y\colon B|R \dashv \vdash  f(x) = y]]></fr:tex> is satisfied.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1226</fr:anchor><fr:addr
type="machine">#300</fr:addr><fr:route>unstable-300.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>7</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Suppose that <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket R\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> is <fr:tex
display="inline"><![CDATA[(a, b)\colon R\to A \times  B]]></fr:tex>.
    Then <fr:tex
display="inline"><![CDATA[R(x,y)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R(x,y')]]></fr:tex> may be respectively interpreted (up to isomorphism) as <fr:tex
display="inline"><![CDATA[(a\rho _{1},b\rho _{1},\rho _{2})]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(a\rho _{1},\rho _{2},b\rho _{1})]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\rho _{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\rho _{2}]]></fr:tex> are the product projections out of <fr:tex
display="inline"><![CDATA[R \times  B]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="aa67839b1371d7260a5344648531d7f5"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzU2MC4wNzkyODhwdCcgaGVpZ2h0PScxMTguOTE0MDA3cHQnIHZpZXdCb3g9Jy03MiAtNzIgMzczLjM4NjE5MiA3OS4yNzYwMDUnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHhpaEdOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkVBQUFBUkI1YWpIZG9aV0ZrQUFBQnNBQUFBQ3dBQUFBMktlNmtXV2hvWldFQUFBSGNBQUFBSHdBQUFDUUZCZ0RaYUcxMGVBQUFBZndBQUFBSUFBQUFDQVlZQUY5c2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNJQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVNibUZ0WlFBQUFpUUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm01bUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURacTAvbGd3TXpGck14NEhDakFnVi8vOHpNQUFBK3dNUGZ3QjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBRjhBSndGN0Fqd0FFQUFBQVFNR0l5Y21KemNUUGdFM01oWVhCZ2NCY2RRR0RCWVRBd1NlQXhrZUdTWUJBUVFCM1A1Y0VRY0hEUkFCdXc0Z0FTQWNEQXdBZU5wallHUmdZQUJpdHZlUmxmSDhObDhabUZrWVFPQ3g0NFlKeURSTEtKTU5rT0pnWUFMeEFBNDFDTmw0Mm1OZ1pHQmcxdnBqeWNEQUVzb1F6K0RCV00wQUZFRUJUQUJLS0FMakFBUlZBQUFCd3dCZkFBQUFBQUFpQUFCNDJtTmdaR0JnWUdJUVpBRFJERkFTQ1FBQUFrWUFGd0I0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQ1VsWVdCaVpXcEMyQ0RNc1JCZG9nVXFlckk3KzdoZXVnTnArZjl1QU5LZnNoNFRzWnIzTS9KS1VUOWNjRUxiNG1ub2hhSlN6NVlNaUhMWitMTTJTVE9KZmxLWFBET0pmRlUvTy9FSlo4OHRsMTd1L2ZXcTMxbnJIZm5Ob3pyZy9XaDZaeGE2U3JxblhYV0gzdHIxR2xVWm1qQ2NHMVZyU3RkczZXajVjYWRIb3RIc1JmSFJIYWNKUXVNckRsRUo5Qkk2cVMxUWxQOXkzZVN1OWc1eGs5R09pZEpsTkFnVjBIMlZkcUtPbDVxNmwvdjZUQkhBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT3dBQW9BQUFBQUJCZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFV4MUFtTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ0ZaMng1WmdBQUFXUUFBQUQwQUFBQTlOdSsrWkpvWldGa0FBQUNXQUFBQUMwQUFBQTJLT3VreUdob1pXRUFBQUtJQUFBQUhnQUFBQ1FGdWdLeWFHMTBlQUFBQXFnQUFBQUtBQUFBQ2dabkFKSnNiMk5oQUFBQ3RBQUFBQWdBQUFBSUFESUFlbTFoZUhBQUFBSzhBQUFBRndBQUFDQUFCUUF0Ym1GdFpRQUFBdFFBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEb0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtZXMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUTBaREJpWnZnUDVETkRwSkhVL0FjS0F3RDJ4QTArZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhHLy84RFNjUC8vLzlmQVBNWkFGRllCbzRBQVFDU0FBQUNOd0tyQUI0QUFBRVJCaFk3QVJVbUp5TUdCelV6TWpZbkVRNEJKeU0xTXhZL0FUWTNOaFlCbUFRaVRqTXNPdEU2TEROT0lRTXVWQk1TRWhJK0J6ODVHQTRDaS8zTkZ4UXRBd0VCQXkwVUZ3SUFFZ3dCTFFJS0Fnb3VBUWtBQUFFQVhRQUFBbHNDcWdBckFBQWxCeUUxTkQ4Q1BnRTNMZ0VuSWdZSEhnRVhEZ0VqQmlZblBnRTNNaFlYRGdFSEJnOEJKVFkzUGdFM0Fsc2kvaVFEQ2ZvOVRRRUNhRTAwVWhZWUlRRUJKaFVPTEFJQ2hHcHdtd01DYUVndk5Xa0JBaW9LRFE4Q3hzWWZCUUlKMURGcVAweFRBU29qQWg4YklCMEJHU2ROWlFKcFkxQnBMaUFuVGdFQkJBdEJFZ0FBZU5wallHUmdZQURpUmFjZHJPUDViYjR5TUxNd2dNQmp4dzBUa0dubUlLYlZRSXFEZ1FuRUF3QVp3d2xsQUFBQWVOcGpZR1JnWUdiNHp3QWtneGhpR1dLWm9obUFJaWlBQ1FBOTBRSnpBQUFEVWdBQUFyZ0FrZ0JkQUFBQUFBQUFBRElBZW5qYVkyQmtZR0JnWnRCaEFORU1VQklKQUFBRkJBQXpBSGphUFl3eHE4SXdGSVcvWWhYdEd4d0VoemRJOEFlRVNwK2JtNE9UcThQYnJBblNvYW1rdGVnaS9uUnZRL0FHRHQ4OTU5d0FHUzhTaGttWUJ4MG1sVGVQUE9hSFJlU0orS3ZJR2Irc0daR2tNM0ZXN0NLblRQbVBQR1pKR1hraS9pTnl4aC92ZlZQZjdwMzE2dGdZNjkybDl0dVQ5VzNWT0xYUitiQWVyTFArM0ZtanlxY3lmZFgyMTFvVk90Y0ZleHBxYnR6cHNIZ1VSM0ZNWU1kRk1zK1dVOWhiS3NtY2REWm84bTk2a05TRnhqbjhZcVJSOGhRMTlITFRpbDZscXlqQ25hYjRBRlV5TGtNQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFaNEFBb0FBQUFBQjhRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY2QzNjJOdFlYQUFBQUU4QUFBQVFBQUFBRXdIdS8yZloyeDVaZ0FBQVh3QUFBT01BQUFFYkVGdHE2Vm9aV0ZrQUFBRkNBQUFBQzhBQUFBMktHQ2tDV2hvWldFQUFBVTRBQUFBSHdBQUFDUUZod0hoYUcxMGVBQUFCVmdBQUFBY0FBQUFIQS9qQVloc2IyTmhBQUFGZEFBQUFCQUFBQUFRQXdJRU9tMWhlSEFBQUFXRUFBQUFHQUFBQUNBQUNnQllibUZ0WlFBQUJad0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUdiQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1jbVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBycU1COWtadmdQNURNek1JS0VHUkVxL2dPRkFlUG9EYVVBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1Jnc2dEUVhBd2RRam9sQmh5R0pvWkw1NFAvL1FERWRoa1NHQ2hENy85WC9DLy8zL0hFRjY0QUNBR0w4RGxWNDJsV1N6Vy9qVkJURjMzbDI3TVJwWWp1T24rTko2amorVE5NbWFacU1YZG8wYWRPbWFEcURPaFV3bzdiQXFFSWpoQVN6UVdMQkNHa0VDelpzRVlnOUVrczJMTmlEMkNEVzdKRGdieGhXMFBDY2pwQ3d2YnIzV3ZmK3pqa0U1SVBGRG5sT1BpU01rRlNXNUI1R1NlckFsRlJJY2hRbjZRUy9yUlNOUnRPOUZRUmlXQWpWb2dCcDJOVHlNdERhYWdHVHdjUGJwUzNRa3B3YlBDTDhvV1N5ZUU3djRFZlNKZnVFWUlJdFpxbTBETFBLckFtbVNKcGdWbFhpMjZRb0xvUHY1SHV5MTRHUUpuRVVSNUxNeXc3NDhqVEJkN25WZWhVVms4a0YxWEQ5ZkY1VUZBbUdYaytzbWU3YzZSdytoRGhWalpPTGNEUVlvbW9PcldQZjhJQU54eHZsSTN6R0RFMi8vOG9iWnEvTUdxRHp1QzZCVWlWMzRBNEYxTHRPRzNqejN1TXpvM0lzd0x2Ky9kZVZNQkJwZTlkLzFrMTdvTTE4NDRicGNQRVgvcUEvRTQ4a25FbklMbVBXVWlWK2ZqVGxoY2ozb25pQ0lXL0lXWCtDMnozNEhrZmhVNXdkNVdOcjF0NStTeEFPV2lmbkI2OEJVcmVuU0ZRTkNqcWd5a2NiQWRMMjNLaXRZdDBaVDhwNTBjbXYwVyt2LzJRYzV0WHpkKy83UndMT1R6WHZoKzg3VmtrUkZUVXZpOExLUHhjWXg1dFAvVkgvU0ZYTFQ5dDJiNGNmU0FiY2c5ZnhFM2xBeUpRbXkwc3lWWDB1NytpRjJOWU5CQy95V3BKR2ZVUkxJTFpzTEUyUy8zUHBCUnl6R0I5b2NsTVhmbG1HYjhkblZWRXVjRU5hSmJWN3NyR3Y2cnVSeDZVTWpVaW8yaFhkdkxXamhTcXd0M0Zhb1hwQmdsdlNOdTY2eDFWak4yalBLSHdyRktqVzVJUHg0UDNQZDF3dGJPNlBGWm5TZ2pYVTFINE9iZGZwQUY3SGJkSkFiUlVVU3RIZi9XSnFUbktZSjBabUpSdFV0TDRJTDNiYllkVHdhQ0RGUlVXZ2RKenBzTG5vMHduUDRtbm0yazNZT0VheTVMaEpHUDhrbnpQMmtFWlozbVV1bFBRL25hb3ErSjhTc3hJZTNzenFUQWI2MGxYanE3TjBCa1JWWlJWVWJ4dERlVzNQYk5ZTFczdHMyMjZVQURzb0NyWTdOcUFYSmRTS3VqL3RKQkJMTlFlVWJhVnVzUTRyMWd1V3Npb0NuMXgvZlBVRUdMVDlGblJMN01xMkFyUnIwY3VkSGtwVmUwZHRQcmhrSjVoTU5hNU5lY0RNWGc2RHNGUUtkOTllMDZlNW5MZmk1UjU5UFM0cmFFbzhyOE5GdU9TdWtYVkNMSU5EY3BDbG01a0VTeUR1YU1veVloNzBaVGk0K1JaTHI1d3ZUK2VYVkpocHhyMkxVU0xiRGRHc2wwejhiYzhEMjZWMGMzL2VNR3VzQU1hK3diTW5Id0dYWisrY0dwVkRnZmJMajkrelEyajZMd2lUenFmUjl1YjZtblAzSWxCOW4vd0xiamVaajNqYVkyQmtZR0FBNHZrdWJRL2orVzIrTWpDek1JREFZOGNORXhEMGYxV21ZMHpIZ1Z3T0JpYVFLQUJDalF0NkFIamFZMkJrWUdCbStNL0F3TUIwak1HQVFaZ3BsQUVvZ2dMWUFUNkJBbTRBQXNZQUFBRmJBSE1DZWdBK0FnSUFRd0tYQURFQ1VRQXdBbDRBTXdBQUFBQUFLZ0NVQU93QmNBSHNBalo0Mm1OZ1pHQmdZR2NJWjJCaUFBRkdCalFBQUFtNkFHTjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUM0QUFBQTJLRzJrSG1ob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0dU51c2Z6eC9EWmZHWmhaR0VEZ3NlT0dDUWo2UHlQVFpXWVFsNE9CQ1VRQkFCWFJDY3dBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOQUFBb0FBQUFBQTZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdpT1J6RzJOdFlYQUFBQUZBQUFBQUtRQUFBRFFBREFFcVoyeDVaZ0FBQVd3QUFBQjRBQUFBZUpNU1BKRm9aV0ZrQUFBQjVBQUFBQzBBQUFBMktMV2tGV2hvWldFQUFBSVVBQUFBSGdBQUFDUUdOZi9kYUcxMGVBQUFBalFBQUFBR0FBQUFCZ093QUFCc2IyTmhBQUFDUEFBQUFBWUFBQUFHQUR3QUFHMWhlSEFBQUFKRUFBQUFGd0FBQUNBQUJBQWtibUZ0WlFBQUFsd0FBQURUQUFBQlBxODNkZUZ3YjNOMEFBQURNQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1sbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFVEF4SklLUzVMQjBwZVo3ak9MUFZIazRHQldZcjVPbENZRWFIaS8zOEdCZ0RyblE3dkFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hDQytOZi8vNGVRLzdYQWZBWUFYdVVITXdBQUFBQUJBSlFBQ1FLR0FmZ0FJZ0FBQVRjMkZ4WVhCZzhDSHdFV0J3WUhKaThCQnc0Qkl5WW5KajhCSnlZM05qY3lGd0dPeXc0S0V3RUNBeHE3cFRJRUFRRVRDd1hVeXdrSUJoRURBeEROelJBREF4RUdCQUVkeWhFQkFoTUtBeHE3cFRJSUF4TUNBZ1RVeXdvRkFoTUhEYzdPRFFjVEFnSUFBSGphWTJCa1lHQUE0cFhwakkvaitXMitNakN6TUlEQVk4Y05FNUJwWmhuR0gwQ0tnNEVKeEFNQUcxb0pod0FBQUhqYVkyQmtZR0NXK3FNSkpHVVlwakJNWTJwakFJcWdBRVlBVE1vREZ3QUFBeHdBQUFDVUFBQUFBQUFBQUR3QUFIamFZMkJrWUdCZ1lsQm1BTkVNVUJJSkFBQUVDQUFwQUhqYVRZNnhhc013RUlZL1U4ZFFKNUNwSFRvVVRSbUZqZk1BaFF5WnNtWXNKSkVJRGxnT2ttUHdVdklBZmVoZUZBMDl3ZkhwdisrRWdKSWZNaDZWc1l6OVVUbUYzSjQ4WTg1YjRrS09TbHp5d1lvWHN2eFZraysrRXVjcytFNDg0NTFMNGtMeWUrS1NOYitidnJ2ZUJ1dlZyamZXdTFNWHBycmFXeC9hM3FsYVY4OWdhNTMxaDhFYWRaeVVHZHN3bmp2VjZFbzNiT2pwdUhKandPTGxaenRKVEdUSFNXYUJpWnFLZmN3Q3JjeWRlRFZhMHYvR1Znd1hyVU44elloMWxKa1NHbVV2U0QrTHIyamlycWI1QXdsUk1STUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVRzQUFvQUFBQUFCYndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDFHR050WVhBQUFBRTRBQUFBTWdBQUFEd0FkUUNQWjJ4NVpnQUFBV3dBQUFJWkFBQUNmSnJkaG10b1pXRmtBQUFEaUFBQUFDOEFBQUEyS0tDazRXaG9aV0VBQUFPNEFBQUFIZ0FBQUNRR0xBSVFhRzEwZUFBQUE5Z0FBQUFRQUFBQUVBdUhBSGxzYjJOaEFBQUQ2QUFBQUFvQUFBQUtBWklBc0cxaGVIQUFBQVAwQUFBQUdBQUFBQ0FBQ0FCZGJtRnRaUUFBQkF3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRTRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzZzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkFoaVp2Z1A1RE5EcEpIVS9BY0tBd0Q0c2cxa2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS09qRUUvZjhQNUR1QzZQOEgvbThFcXdJQ0FKSWJDUDRBQUhqYVZaRlBheE5CR01ibmZXZDNKbjkyZDlhZHphNmgyV2lhUDZ1Uk50S2t1eWJDaXNha1ltbW9sa2pCZ2lCb2JoNjByZEJUbEI0dEhnVEJreGR2ZmdBdm5qejVCVHg2RUE4ZVBBbGVtemdKRk9xY1poN2VnZC83ZXdpU3luU0tQL0E3YVpBVlFtS0k0aFhQbDY3WGpEeldBQjdXd2xia2UxSGNnQkpucnVkSHZnVXFuOFhOQk9JbS9RU1BtR3N5U0x5bEhCajY3amlsZzVtVkxacm1rK25BTEVpVGdxbVB0ZzB3MG92SnU5K2xmYnhuUTFvY2p6MUJBdzZVQXFZRUJ6RDh4NzFEdDJJRENvdk40b3hnVVA0S2Q0azZsRnlhSGxPR24wbVIxTWtWUlNwYjVaQXB0bElSY2hid0l2aE1BT01sTnVlVk03aW9GcFpyak5PVE8xVUR6UTlIQzJFZ0JHenZQS1RqcmZVdHdEVjdZMi95cG1CWm5lTDd0dzkyRVphN2grZWsvdVRWemo3aTVWdGYraHFBdFludE0wZ0xIUEJPNS9aSVpBYnQ5UnRXb3MwMkFBazkrclJmdVlrZzhzY2Y2Zk5CZFpOT2Zqb3NRd2lTK3ZRWDFSVzNUZTRUQW5PV0JGWnJEYWdKc0VBcWJsZGg1WmpYVkphajJQZm1iODZVZVNYNUdxamhPYnZhTUhML3ErU1VBVjk5Z0hIM1dXOG9pd3RhSzlkZVRVVG1kYjVITmE2QmMxWkdxaHFtZzJjRkhhTXVuWXVhbm1WcFhPb2RkQ2xVMjJicTVRdlYya3lBZmxTb0JaWU41ZEVCYXYwMTNKdjhoYXAzZmxqb090eEFRR2Z5amNkWC9YeG5NUitVSUl3TmlwZzI2ODRGSFRONjFydHU1NWRsYUFZSlR2NDRKdE5POXl1TEp3cGgyTjFvTmY4QkF3dGlId0FBQUhqYVkyQmtZR0FBNGwxbVFZN3gvRFpmR1poWkdFRGdzZU9HQ1FqNi8zTm1OcWE3UUM0SEF4TklGQUFqdndyTUFIamFZMkJrWUdCbStNOEFKRGtaVkJpWW1Oa1lnQ0lvZ0FVQUkrRUJSQUFBQW5ZQUFBTUFBQ1FEQ0FBckF3a0FLZ0FBQUFBQVZBQ3dBVDRBQUhqYVkyQmtZR0JnWVloaFlHWUFBVVlHTkFBQUNmMEFabmphVFk2eGFzTXdFSVkvVThkUXA5Q3BIVG9VVFJtRmpmc0FnUXlac21Zc0pKRUlEa2dLc21QSUV2b0FmZWhlRkEwOXdmSGRkNytFZ0pvYkJmY3FlRTM5WGlXVlRBK2VNZWN0Y3lWSFphNzVZTUVUUmZrczVwTmw1cElYdmpQUGVPZVV1UkwvazdubWk5OVZjT2ZMYUtQYUJHT2pQempYdDgzV3hxRVBYclc2ZVlpMTlUYnVSbXZVL3FyTTFBL1QwYWxPTjdwalJjQng1c0tJSmNyUE5tSk1ZczlCZG82ZWxvWnRjb05NUVRaS25CYjdQN0dXaEUrcFhYck5TR3JQVmJwaGtzd2cvU2hwUlpmdWFyby8zL1F3dXdBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjAuMTc1MzA0LC02Mi4yODc4Mjkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTMuOTg5NTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIwLjE3NTMwNCwtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMC4xNzUzMDQnIHk9Jy02Mi4yODc4MjknPlI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTEwLjMxOTk0MScgeT0nLTYyLjI4NzgyOSc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLS4zNTczMjcnIHk9Jy02Mi4yODc4MjknPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTI0LjA1ODk0LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjAuMTc1MzA0LC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIwLjE3NTMwNCcgeT0nLTYyLjI4NzgyOSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTAuNDg5NDM5JyB5PSctNjIuMjg3ODI5Jz7DlzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctLjUyNjgyNScgeT0nLTYyLjI4NzgyOSc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc5Ljc0MzY0OScgeT0nLTYyLjI4NzgyOSc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTkuNzA2MjYyJyB5PSctNjIuMjg3ODI5Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTkuNDQzMDRWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsMC4wLC05LjY5MzA0KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00OS4wMDUxNiwtMjkuNzAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMC4xNzUzMDQsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMjAuMTc1MzA0JyB5PSctNjIuMjg3ODI5Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xNy4wNjE5NjEnIHk9Jy02Mi4yODc4MjknPmHPgTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctOC42MDcwMzEnIHk9Jy02MS4yOTE1NjUnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQuNzE4NzgnIHk9Jy02Mi4yODc4MjknPiw8dHNwYW4geD0nLS45OTIwMDMnPmLPgTwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzYuNjQ1MDIxJyB5PSctNjEuMjkxNTY1Jz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzEwLjUzMzI3MicgeT0nLTYyLjI4NzgyOSc+LDx0c3BhbiB4PScxNC4yNjAwNDknPs+BPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMTguMzkzNTM1JyB5PSctNjEuMjkxNTY1Jz4yPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzIyLjI4MTc4NicgeT0nLTYyLjI4NzgyOSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4MS41MjMyLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMC4xNzUzMDQsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjAuMTc1MzA0JyB5PSctNjIuMjg3ODI5Jz5SPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDcxLjQ1Mzc4LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjAuMTc1MzA0LC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIwLjE3NTMwNCcgeT0nLTYyLjI4NzgyOSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTAuNDg5NDM5JyB5PSctNjIuMjg3ODI5Jz7DlzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctLjUyNjgyNScgeT0nLTYyLjI4NzgyOSc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTguNTQ1MDkgMEg3Ni40Njc2NScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3Ni43MTc2NSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQzLjczMDQ1LDQuMTcyOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIwLjE3NTMwNCwtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMC4xNzUzMDQnIHk9Jy02Mi4yODc4MjknPs+BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xNi4wNDE4MTgnIHk9Jy02MS4yOTE1NjUnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTg1LjM1ODI2LTguNjA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwxLjAsLTEuMCwwLjAsODUuMzU4MjYsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsODUuMzU4MjYsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OC42MjIxNSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMC4xNzUzMDQsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMjAuMTc1MzA0JyB5PSctNjIuMjg3ODI5Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xNy4wNjE5NjEnIHk9Jy02Mi4yODc4MjknPmEsPHRzcGFuIHg9Jy05LjAxMzc0Jz5iPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTUuNTEwMjAyJyB5PSctNjIuMjg3ODI5Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00yOC42MTQ0OS01Ni45MDU1SDY2LjM5ODI0JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDY2LjY0ODI0LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzOC4zNDAyNCwtNjQuOTY3MzIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMC4xNzUzMDQsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMjAuMTc1MzA0JyB5PSctNjIuMjg3ODI5Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xNy4wNjE5NjEnIHk9Jy02Mi4yODc4MjknPngsPHRzcGFuIHg9Jy04LjgxNzM4Mic+eTwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00LjUyNjcxMycgeT0nLTYyLjI4NzgyOSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTYzLjk2NzY1NiwtNjIuMjg3ODI5KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEzLjk4OTU1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDE2My45Njc2NTYsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScxNjMuOTY3NjU2JyB5PSctNjIuMjg3ODI5Jz5SPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzE3My44MjMwMTknIHk9Jy02Mi4yODc4MjknPsOXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzE4My43ODU2MzMnIHk9Jy02Mi4yODc4MjknPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTI0LjA1ODk0LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxNjMuOTY3NjU2LC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nMTYzLjk2NzY1NicgeT0nLTYyLjI4NzgyOSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PScxNzMuNjUzNTIxJyB5PSctNjIuMjg3ODI5Jz7DlzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PScxODMuNjE2MTM1JyB5PSctNjIuMjg3ODI5Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzE5My44ODY2MDknIHk9Jy02Mi4yODc4MjknPsOXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzIwMy44NDkyMjInIHk9Jy02Mi4yODc4MjknPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOS40NDMwNFYtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwwLjAsLTkuNjkzMDQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ5LjAwNTE2LC0yOS43MDI3NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTYzLjk2NzY1NiwtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9JzE2My45Njc2NTYnIHk9Jy02Mi4yODc4MjknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTY3LjA4MDk5OScgeT0nLTYyLjI4NzgyOSc+Yc+BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzE3NS41MzU5MjknIHk9Jy02MS4yOTE1NjUnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMTc5LjQyNDE4JyB5PSctNjIuMjg3ODI5Jz4sPHRzcGFuIHg9JzE4My4xNTA5NTcnPs+BPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMTg3LjI4NDQ0MycgeT0nLTYxLjI5MTU2NSc+MjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScxOTEuMTcyNjk1JyB5PSctNjIuMjg3ODI5Jz4sPHRzcGFuIHg9JzE5NC44OTk0NzEnPmLPgTwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzIwMi41MzY0OTUnIHk9Jy02MS4yOTE1NjUnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMjA2LjQyNDc0NicgeT0nLTYyLjI4NzgyOSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDkuOTc1OTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTYzLjk2NzY1NiwtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzE2My45Njc2NTYnIHk9Jy02Mi4yODc4MjknPlI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoOTkuOTA2NTQsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDE2My45Njc2NTYsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PScxNjMuOTY3NjU2JyB5PSctNjIuMjg3ODI5Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzE3My42NTM1MjEnIHk9Jy02Mi4yODc4MjknPsOXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzE4My42MTYxMzUnIHk9Jy02Mi4yODc4MjknPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTE4LjU0NTA5IDBIMTA0LjkyMDQxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwNS4xNzA0MSwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU3Ljk1NjgzLDQuMTcyOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoMTYzLjk2NzY1NiwtNjIuMjg3ODI5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9JzE2My45Njc2NTYnIHk9Jy02Mi4yODc4MjknPs+BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzE2OC4xMDExNDInIHk9Jy02MS4yOTE1NjUnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTExMy44MTEwMi04LjYwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDExMy44MTEwMiwtOC44NTk3MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwxMTMuODExMDIsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMTcuMDc0OSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDE2My45Njc2NTYsLTYyLjI4NzgyOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PScxNjMuOTY3NjU2JyB5PSctNjIuMjg3ODI5Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzE2Ny4wODA5OTknIHk9Jy02Mi4yODc4MjknPmEsPHRzcGFuIHg9JzE3NS4xMjkyMic+YjwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzE3OC42MzI3NTgnIHk9Jy02Mi4yODc4MjknPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTI4LjYxNDQ5LTU2LjkwNTVIOTQuODUxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDk1LjEwMSwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTEuMjE0MTksLTY1LjUxMjg4KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgxNjMuOTY3NjU2LC02Mi4yODc4Mjkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMTYzLjk2NzY1NicgeT0nLTYyLjI4NzgyOSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PScxNjcuMDgwOTk5JyB5PSctNjIuMjg3ODI5Jz54LDx0c3BhbiB4PScxNzUuMzI1NTc4Jz55PC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTc5LjYxNjI0NycgeT0nLTY1LjI5NDM0Nic+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzE4Mi4zMTEwMjInIHk9Jy02Mi4yODc4MjknPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      width = 3cm,
      nw = {R \times  B},
      nw/style = pullback,
      ne = R,
      sw = {A \times  B \times  B},
      se = {A \times  B},
      north = {\rho _{1}},
      south = {(x, y)},
      west = {(a\rho _{1},b\rho _{1},\rho _{2})},
      west/style = {>->},
      east = {(a,b)},
      east/style = {>->}
    }
    \qquad 
    \DiagramSquare {
      width = 4cm,
      nw = {R \times  B},
      nw/style = pullback,
      ne = R,
      sw = {A \times  B \times  B},
      se = {A \times  B},
      north = {\rho _{1}},
      south = {(x, y')},
      west = {(a\rho _{1},\rho _{2},b\rho _{1})},
      west/style = {>->},
      east = {(a,b)},
      east/style = {>->}
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Now, suppose that <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket R(x,y) \wedge  R(x,y')\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> is (up to isomorphism) either composite of the following square.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="fe58a2d661a9c0368f8a7b4471979bc9"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMxMC43NzkyNThwdCcgaGVpZ2h0PScxMjIuODM2ODQycHQnIHZpZXdCb3g9Jy03MiAtNzIgMjA3LjE4NjE3MiA4MS44OTEyMjgnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHhpaEdOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkVBQUFBUkI1YWpIZG9aV0ZrQUFBQnNBQUFBQ3dBQUFBMktlNmtkV2hvWldFQUFBSGNBQUFBSHdBQUFDUUZCZ0RaYUcxMGVBQUFBZndBQUFBSUFBQUFDQVlZQUY5c2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNJQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVNibUZ0WlFBQUFpUUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm01bUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURacTAvbGd3TXpGck14NEhDakFnVi8vOHpNQUFBK3dNUGZ3QjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBRjhBSndGN0Fqd0FFQUFBQVFNR0l5Y21KemNUUGdFM01oWVhCZ2NCY2RRR0RCWVRBd1NlQXhrZUdTWUJBUVFCM1A1Y0VRY0hEUkFCdXc0Z0FTQWNEQXdBZU5wallHUmdZQUJpdHZlUmp2SDhObDhabUZrWVFPQ3g0NFo1eURSTEtKTU5rT0pnWUFMeEFBZFJDTDE0Mm1OZ1pHQmcxdnBqeWNEQUVzb1F6K0RCV00wQUZFRUJUQUJLS0FMakFBUlZBQUFCd3dCZkFBQUFBQUFpQUFCNDJtTmdaR0JnWUdJUVpBRFJERkFTQ1FBQUFrWUFGd0I0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQ1VsWVdCaVpXcEMyQ0RNc1JCZG9nVXFlckk3KzdoZXVnTnArZjl1QU5LZnNoNFRzWnIzTS9KS1VUOWNjRUxiNG1ub2hhSlN6NVlNaUhMWitMTTJTVE9KZmxLWFBET0pmRlUvTy9FSlo4OHRsMTd1L2ZXcTMxbnJIZm5Ob3pyZy9XaDZaeGE2U3JxblhYV0gzdHIxR2xVWm1qQ2NHMVZyU3RkczZXajVjYWRIb3RIc1JmSFJIYWNKUXVNckRsRUo5Qkk2cVMxUWxQOXkzZVN1OWc1eGs5R09pZEpsTkFnVjBIMlZkcUtPbDVxNmwvdjZUQkhBQUFBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVpjQUFvQUFBQUFCM0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hjZDM3bU50WVhBQUFBRThBQUFBUUFBQUFFd0VnZ1FUWjJ4NVpnQUFBWHdBQUFOdkFBQUVHRzVuYk9Cb1pXRmtBQUFFN0FBQUFDOEFBQUEyS0dDa0xtaG9aV0VBQUFVY0FBQUFJQUFBQUNRRnJRSENhRzEwZUFBQUJUd0FBQUFjQUFBQUhBLzRBWHRzYjJOaEFBQUZXQUFBQUJBQUFBQVFBdGdFQkcxaGVIQUFBQVZvQUFBQUdBQUFBQ0FBQ3dCTWJtRnRaUUFBQllBQUFBRE5BQUFCT1BOZktxTndiM04wQUFBR1VBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbThtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHJxTUI5a1p2Z1A1RE16TUlLRUdSRXEvZ09GQWVUL0RhZ0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdzZ0RRWEF3ZFFqb2xCaHlHSmVUUHp3Zi8vZ1dJNkRJbk1tMERzLzFmL0wvd1Q5TWNWckFNS0FHNHlEcEo0MmoyU3pXL2JaQnpIbjkvakozNUpFOXVKNDhmSm5EaXRYOU0zTjAxU3V5M0ZhWnNYc2JSYnUzVlMxMndNTnFrZ0JPSXdKQTZNUXlVMHNkc2tMbHk0Y0VEaXlJVUQ5MGtJaERodzRvYkUvb0NldGhNMFBFNGtiTW15ZnM4ai9UN2ZGd1RvazhrMmVvVStSUlNoV09DRkVEcFJiSUhPSzhBTGZoREZDZnlabTlPcTlmbHJya3M4eVZQbU9PRGJkVlVVQUJaYUN3REordWxHdmdVNEwyVFczMEhzd1NpWnZNTFg0UVZhUmJzSVFRSXRhaWhZQnIxRWpRUzZFTldCR2lXZWJlUDlRQWEyaysxSlh3dTRPQXI4d09jRk5yYUFMWThqK0NGVE0wdFExS2tnS2RxOEk0b2ttK1ZCSzVpUnNWK3dyaS8xVG9GMEZXMDA5anJyYlNqcGJXUG9hRGJBaW1WM1JCKytwSnBhT0w1eFh3OWxXZ1U4Q0V3ZU1NNW05dWJiSEppclZnUGc3Y1B6VzFweHlJRjk5ZGZ2T2M4bHVQR0djN0VhaDREclluV21xVGQ1RFgvam41R05JcWFKUzhtb01YV0o0ZnRkTnZBZDJ3OFNhTE1ESVQxUFlDTUV4MlpTMkMybUhlU2hzZC9ZZk1CeGV3dWpzNzA3QVB4cW1PV3g0a29GQUVYb3I3Z1FOd1phdVFiTDFrNGlpOFFTRi9IM1Z5OHBFM055OXNHeDArZmc3RWkxZi9weHljaG5TVllSQmNMbC9oM0RUdEI4NG5UVytvb2lQMmxVd20yRU9OU2FiT0puK0E5VVJRRWFNZUtwb2ZyVTlKU1lZOVpyTTlkYlZQQlRIYlFPclM0dzVOa2xqdGN0YURNZEhUL2dIZDdmU01Cb3BRSGlaOXlvRVN5U20ycng3bmx5b0E1SURiNHR4SnF4Tng2KyswdkZORlNKVjB5YS9RWTJ3K010Ulc0VkdQZG81K0VGTHBmRGRtTUZiMVdYRnZQTlpkenZuaHJtU2ZoaFQ4MXRBV3g0VjVjU3p1R253OE9LM2lNSGx6d0FKb1I5WHF3MXlhNWFmS3QvZFNtcmIvYTU1NC90YlZXR1hOSE1nNWlwUFdMNUFMSW5EbjdNT3NmRWV4SHJXRHhybVpCR2xLcGorbVVXVkR3TFp0cXl3RTdIVHZxYjlqeTJNUHhxQjdJL0p3cVNBQmxYcTZrVnhTQWl6ZVlMR1EzQTBUaUM5YXpXZUJROUtIS2lKREhDMnBvK0NrL3Uycy9IdDgzRFlvb3M4Y0orbyt0MjNlVGExbnQxdjRCSnlYeWFDRFd2UDFxb2Rra25uT014U09UR0N2VWc4L2xYYWJmYUV3OG5qTDJNbGhFeXRCUUZqUCtqVXRMc1dMVmlPcVVNWVlyTk5CazBmbWg5ZlRTNGg3bDlWVHNjZHlLaFVpVzZtZGZobjhyQXJjeGozTndkVlBVeWxZRFM3K0RpNDg4QTd0MTYvMGdyOWppOEpwOS9WUEZBTGZ3R1hyVDBoYi9aWEY2MERzYXU0ampvUDY3UG1MQUFlTnBqWUdSZ1lBQmk3d1cvMXNmejIzeGxZR1poQUlISGpodm1JZWoveWt6SG1DNEJ1UndNVENCUkFGSUtDK2tBZU5wallHUmdZR2I0ejhEQXdIU01RZW4vRjZZT0JxQUlDbUFIQUdsbkJITUN4Z0FBQVZzQWN3SjZBRDRDQWdCREFwY0FNZ0ptQUNJQ1hnQXpBQUFBQUFBcUFKUUE3QUZrQWNJQ0RIamFZMkJrWUdCZ1ovQm1ZR1lBQVVZR05BQUFDS1VBV0hqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvQ0N4ZFdGZ1ltWHFBdGhGR1d3akowUkNxanIyZC9kaFBQUU5WK2QrMkVETkR3WDNLNWdsdlY5SkplN0JGVlBtbVNmaTNqTFhMSGpuaWFKOGx1U1ZqOHlsTkorWksxNzR5anlSL0R0enpZcmZUWENYNjJDajJnVmpvejg1MTYzM052WmQ4R3FwbStTMzF0dDRHS3hSeDVzeVk5ZVBaNmRhM2VpV0RRSEhoU3NEbG9oaUo0bEo3RGxKNStoWXMwOUpMeHdrVnl6Uk5QLzZyZlErYlE3cEp5T2JJemRSd3lpTFh2UXNXMFdiWG1yYVA4dWhML2NBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPd0FBb0FBQUFBQkJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVXgxQW1OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDRloyeDVaZ0FBQVdRQUFBRDBBQUFBOU51KytaSm9aV0ZrQUFBQ1dBQUFBQzBBQUFBMktPdWs1R2hvWldFQUFBS0lBQUFBSGdBQUFDUUZ1Z0t5YUcxMGVBQUFBcWdBQUFBS0FBQUFDZ1puQUpKc2IyTmhBQUFDdEFBQUFBZ0FBQUFJQURJQWVtMWhlSEFBQUFLOEFBQUFGd0FBQUNBQUJRQXRibUZ0WlFBQUF0UUFBQURLQUFBQk11c0lrZVp3YjNOMEFBQURvQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1lczA0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBRMFpEQmladmdQNURORHBKSFUvQWNLQXdEMnhBMCtlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aEcvLzhEU2NQLy8vOWZBUE1aQUZGWUJvNEFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FBQUVBWFFBQUFsc0NxZ0FyQUFBbEJ5RTFORDhDUGdFM0xnRW5JZ1lISGdFWERnRWpCaVluUGdFM01oWVhEZ0VIQmc4QkpUWTNQZ0UzQWxzaS9pUURDZm85VFFFQ2FFMDBVaFlZSVFFQkpoVU9MQUlDaEdwd213TUNhRWd2TldrQkFpb0tEUThDeHNZZkJRSUoxREZxUDB4VEFTb2pBaDhiSUIwQkdTZE5aUUpwWTFCcExpQW5UZ0VCQkF0QkVnQUFlTnBqWUdSZ1lBRGlSYWNkbU9QNWJiNHlNTE13Z01Canh3M3prR25tSUtiVlFJcURnUW5FQXdBUzN3bEpBQUFBZU5wallHUmdZR2I0endBa2d4aGlHV0tab2htQUlpaUFDUUE5MFFKekFBQURVZ0FBQXJnQWtnQmRBQUFBQUFBQUFESUFlbmphWTJCa1lHQmdadEJoQU5FTVVCSUpBQUFGQkFBekFIamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU3ArYm00T1RxOFBickFuU29hbWt0ZWdpL25SdlEvQUdEdDg5NTl3QUdTOFNoa21ZQngwbWxUZVBQT2FIUmVTSitLdklHYitzR1pHa00zRlc3Q0tuVFBtUFBHWkpHWGtpL2lOeXhoL3ZmVlBmN3AzMTZ0Z1k2OTJsOXR1VDlXM1ZPTFhSK2JBZXJMUCszRm1qeXFjeWZkWDIxMW9WT3RjRmV4cHFidHpwc0hnVVIzRk1ZTWRGTXMrV1U5aGJLc21jZERabzhtOTZrTlNGeGpuOFlxUlI4aFExOUhMVGlsNmxxeWpDbmFiNEFGVXlMa01BQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS1Nxa2RXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9KZGIvVXQ0L2x0dmpJd3N6Q0F3R1BIRGZPUWFlYUpURFpBaW9PQkNjUURBQ0c5Q1hnQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzRBQUFBMktHMmtPbWhvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTR1TnVNZGZqK1cyK01qQ3pNSURBWThjTjh4RDBmMGFteTh3Z0xnY0RFNGdDQURuQkNxOEFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9jQUFvQUFBQUFCQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXdBQUFCZ2lTU1VSV050WVhBQUFBRkFBQUFBTVFBQUFEeERpTi9rWjJ4NVpnQUFBWFFBQUFESkFBQUF6SjQ2cUJCb1pXRmtBQUFDUUFBQUFDOEFBQUEyS0xha2hHaG9aV0VBQUFKd0FBQUFIZ0FBQUNRRjJQOS9hRzEwZUFBQUFwQUFBQUFNQUFBQURBamlBTXRzYjJOaEFBQUNuQUFBQUFnQUFBQUlBRHdBWm0xaGVIQUFBQUtrQUFBQUZ3QUFBQ0FBQlFBa2JtRnRaUUFBQXJ3QUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRGtBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbStzWTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU1tSUhhQWNWS0t5OUtCa3RlVjFKbWwvbWd5TURCTE1WOEhDak1pbFAvL3o4QUFBRFpNRDNwNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWU5JQTBHNUJtQk1wZVYxTC8veC9JQjlQL3RlN2VCcXNDQWdDalFBbUpBQUFBZU5vZGpqRk93MEFRUmVmUGJIWTNkaHpXR2JDbFNBaUpTT3N5VXBDOEZlSUl1VVU2T3M1QVNjVVZPQVVGUFZaUzVRSVVIQ0FkVFdRV3lpYzkvZmNKOUVwVGZzWVAzUkloOVczVDJndStRZU9zaTJ1NE9WYXhpdy9vWXVyVHBzWExNQzhVTE12M3Q0MEJ0SndjaDZtM3RValk3NE5JYlEydVAydXdGditPRjJVMng2R1lzTHJxY0toY1pzb3BTdU0zUC9HT0xqTm9zN0xPeHE2RTdYSXVhWC9YNDNIMHpDcVZPNTFtcFRMODZNS010K2VQc0JENGZQTDh0VFN5TUlIdnIvNG1md0Vrb2lKM0FBQUFlTnBqWUdSZ1lBQml4bmVxcytQNWJiNHlNTE13Z01Canh3M3pFUFQvcDh3eVRHbEFMZ2NERTBnVUFDaWlDckVBZU5wallHUmdZSmI2b3dra1pSak1HY3lZMmhpQUlpaUFHUUE4a1FKY0FBQURIQUFBQXh3QWxBS3FBRGNBQUFBQUFEd0FabmphWTJCa1lHQmdabEJtQU5FTVVCSUpBQUFFSXdBcUFIamFUWTZ4YXNNd0VJWS9VOGRRSjVDcEhUb1VUUm1GamZNQWhReVpzbVlzSkpFSURsZ09rbVB3VXZJQWZlaGVGQTA5d2ZIcHYrK0VnSklmTWg2VnNZejlVVG1GM0o0OFk4NWI0a0tPU2x6eXdZb1hzdnhWa2srK0V1Y3MrRTQ4NDUxTDRrTHllK0tTTmIrYnZydmVCdXZWcmpmV3UxTVhwcnJhV3gvYTNxbGFWODlnYTUzMWg4RWFkWnlVR2Rzd25qdlY2RW8zYk9qcHVISmp3T0xsWnp0SlRHVEhTV2FCaVpxS2Zjd0NyY3lkZURWYTB2L0dWZ3dYclVOOHpZaDFsSmtTR21VdlNEK0xyMmppcnFiNUF3bFJNUk1BZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMktCcWtPV2hvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaVQ2L1AzWTdudC9uS3dNekNBQUtQSFRmTVE5RC9HWmdhbUVGY0RnWW1FQVVBYm5vTG9RQUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFiSUFBb0FBQUFBQ0NRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVWQweDJOdFlYQUFBQUU0QUFBQVFRQUFBRXdCRVFDNloyeDVaZ0FBQVh3QUFBUFhBQUFFeENPdTNvSm9aV0ZrQUFBRlZBQUFBQzhBQUFBMktLQ2tSR2hvWldFQUFBV0VBQUFBSFFBQUFDUUdKZ0lSYUcxMGVBQUFCYVFBQUFBY0FBQUFIQkRpQVExc2IyTmhBQUFGd0FBQUFCQUFBQUFRQXU0RVJHMWhlSEFBQUFYUUFBQUFHQUFBQUNBQUN3QmRibUZ0WlFBQUJlZ0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUd2QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm15bVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBycU1GUXlNL3dIOHBraDBraHEvZ09GQWM3NkRQNEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQ3lBTkJjREIxQ09pVUdId1lraGlLSHkvMytnbUE2REk1QmQ4Zi8vLzZ2L0QvN2Y5TDhYckFNS0FFaDBEY0lBQUFCNDJsV1R6Vy9qUkJqRzU1MnhaNXJFWC9ISHVLay8wbncwYnROdGtpYXUzWVFsaGJacGdkTFM3YXBMRVNzaGdaWktTSEJnZDR2WVUwSFZubmJGQVFtSkV4ZHUvQUVJaVJNU0s0NTc0Y2dCY2VEQUNRVGNtakRPYXFYRnNtVDc5WXo5UEwvM2VSR2drOGtBUFVidkl3ZWhsT3FnUWRSSWg1REdqTlphRUNjcGZ5elZhSjBEMGVlYUlGbDJLUWhLRy9CNm5GOEZCV3R6SjMxVDBtSCtTaGtrSkE2TTZwTUovaFgvZ3Rxb0s3NElTZHJscm1YelhzSnBHMWpVaU9MRTVVbmFoZ3FqTm5jVFZ3TlJ6OG85OGRzZStSWnVVVnVsTU9RckRpanluZk1aR2RTQ0ZaTWNHMDhPVk45U0Nhank2WWtDU3E0Ni9QS1B5aG0rWVVCT3Z6em5PZ2tZRUFKNFJtY0FpdnZ1Nk1LdUc0QjFqV2JsdkU2aDloTWNaVG9KV3A1Y0VvcS9SeUZxb25XaDFJcHJFUlhhS2lFNEdyQVFYRUdEc2dxZDZyVXljVWtqcWpVb0kwL3ZpVmpRKy9xaEZ3VzZEaWMzM3libjEvZXVBOTQxOXUrT1AvYzFiUkIrOWNWYmR6QzB0aTdLbHZ6Qmc1dG5HSGRlK21GSEF0QU9jYitJaWM4QVh4dThjcXJuRC9wN205cFF5aHlBQlNQeTRVNTlHNE5ldXZ5R2ZIU3djRWpHdjVrMG4vRnRUbjRuc3RCdG9EY1JncW1XSWF3MTJ0REltbWNKM2JhUTVWRGVFNVNUMU9YVFowWUZlUUY1QThUaXFYYmhNTEgvMTVKbkNMaGlBNXh2M1I0ZFc2RW54VTUvYmFqblB5dU5pTVFrTUdldFJMU0d5c0MxWUtBMExYTkprZ3MwaDFkRzk3WUlMUFRWbVU4L0VWM0xBTWdQL1VhZ0dWQTd2WWVsblYxOGQvdzNMUEQ1WTMvTFpBb0diSTUvWnVsemJtbFFMUVVWaUZLRllKeFRtK2FpalBOeWdiOW9sRnBXcEFaRFBQN1RWS24wYkgrdDhDbENPTjdhajNzSVVEajVCL3Z3Q0owSU1oa0VXM2hNazU3TEhac0pSNndGVVhhcE5pSkJyY3R0eW5nWm5nQnNpUXlLZHdKakZLY1p1SVM3V1p1NXlHY0wxc1FnQ01SWkl1QkdUWlhtK2tjZXFFd09DOGJTWml2Tlk4L3YxZ2NZeXJOS3liY013NnIybE1EREMwWHZXb0FMVElhd1lDNXV6bTQ2dWVSSzhBS0JlbVQ1dktqYlhTNDdzUFpnelRHOFJkSi9UUkhXN0ZXNzJKYWdIZWJMRmFsU25hdUEwUXlrUE1ZdzZMeDNteTk3Z05jUEZRRE03SzVWN0VnUXJ0b3BnVEFxKytDbzlyeVV3MWhheWkraktZOFcvQXMvb3BlenBJaFFad1B0VGkxRlllWTZPNFhwTEFEQzhSTUVHdFNpRmt3UmlFa1FpTElzQ1JRYkpIRzdyZ04vdmVQZVArcGNYYkJ6UWtuazZsMjF2bTZIZm03NWFtY1ArMldOUUpGNUtTZVVaVkVwbVBQcjBjcU1Hb1BYNkQxUFdvNW1taDZCKytPUDN6akRzUHBxV1l5Q0cvZ2swQUhxM3RMKzRncEF1bDI5ZFZoZW5NMEQ5SGNWQ3Rqb3pNMEtKSjJhN3BjdlJrR01wVzM5dTZPVWd5Y21BdjBIQTBpcHN3QjQybU5nWkdCZ0FPSlpzaDJhOGZ3Mlh4bVlXUmhBNExIamhua0krcjhlTXh2VFhTQ1hnNEVKSkFvQUZvY0tGQUI0Mm1OZ1pHQmdadmpQQUNRNUdlU0FKQnNEVUFRRnNBTUFJekFCUHdBQUFBSjJBQUFCSEFCWUF3QUFKQU1JQUNzRENRQXFBa2tBSGdIMkFCNEFBQUFBQUNnQWZBRFlBV1lCN2dKaWVOcGpZR1JnWUdCbmlHRmdaZ0FCUmdZMEFBQUtUZ0JwZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMC4wMjQzNTYsLTU5LjEyOTA4MSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zNy44Mjc1MSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMzAuMDI0MzU2LC01OS4xMjkwODEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMwLjAyNDM1NicgeT0nLTU5LjEyOTA4MSc+UjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMjIuMzgyODU5JyB5PSctNTkuMTI5MDgxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xOC41MDg0ODUnIHk9Jy01OS4xMjkwODEnPngsPHRzcGFuIHg9Jy04LjM4Njc0NSc+eTwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0zLjE0NDgwMicgeT0nLTU5LjEyOTA4MSc+KTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PScyLjk0MzQzOCcgeT0nLTU5LjEyOTA4MSc+4oinPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzExLjc5OTA4NicgeT0nLTU5LjEyOTA4MSc+UjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PScxOS40NDA1ODMnIHk9Jy01OS4xMjkwODEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjMuMzE0OTU3JyB5PSctNTkuMTI5MDgxJz54LDx0c3BhbiB4PSczMy40MzY2OTcnPnk8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSczOC42Nzg2NCcgeT0nLTYyLjc0NDQ0NSc+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzQxLjQ3MzcxNicgeT0nLTU5LjEyOTA4MSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTMuOTg5NTUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zMC4wMjQzNTYsLTU5LjEyOTA4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzAuMDI0MzU2JyB5PSctNTkuMTI5MDgxJz5SPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0yMC4xNjg5OTMnIHk9Jy01OS4xMjkwODEnPsOXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xMC4yMDYzOCcgeT0nLTU5LjEyOTA4MSc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC04LjkwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMi43Nzk4NSwtMzAuNTM2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zMC4wMjQzNTYsLTU5LjEyOTA4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzAuMDI0MzU2JyB5PSctNTkuMTI5MDgxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0yNi45MTEwMTMnIHk9Jy01OS4xMjkwODEnPs6zPHRzcGFuIHg9Jy0yMi4yOTcyMjgnPiw8L3RzcGFuPjx0c3BhbiB4PSctMTguNTcwNDUxJz7OsjwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0xMy42OTQ2JyB5PSctNTkuMTI5MDgxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDk5LjgyMTQ3LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zMC4wMjQzNTYsLTU5LjEyOTA4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzAuMDI0MzU2JyB5PSctNTkuMTI5MDgxJz5SPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0yMC4xNjg5OTMnIHk9Jy01OS4xMjkwODEnPsOXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0xMC4yMDYzOCcgeT0nLTU5LjEyOTA4MSc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OS43NTIwOCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTMwLjAyNDM1NiwtNTkuMTI5MDgxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zMC4wMjQzNTYnIHk9Jy01OS4xMjkwODEnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIwLjMzODQ5MScgeT0nLTU5LjEyOTA4MSc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTEwLjM3NTg3OCcgeT0nLTU5LjEyOTA4MSc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctLjEwNTQwMycgeT0nLTU5LjEyOTA4MSc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nOS44NTcyMScgeT0nLTU5LjEyOTA4MSc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNDIuMzgzMDYgMEg5NC43NjU5MycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg5NS4wMTU5MywwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU2LjM2MTYzLDQuNTYxODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zMC4wMjQzNTYsLTU5LjEyOTA4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMzAuMDI0MzU2JyB5PSctNTkuMTI5MDgxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0yNi45MTEwMTMnIHk9Jy01OS4xMjkwODEnPs6zPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0yMi4yOTcyMjgnIHk9Jy02Mi4xMzU1OTgnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTkuNjAyNDUzJyB5PSctNTkuMTI5MDgxJz4sPHRzcGFuIHg9Jy0xNS44NzU2NzYnPs6yPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTEwLjk5OTgyNScgeT0nLTYyLjEzNTU5OCc+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy04LjMwNTA1MScgeT0nLTU5LjEyOTA4MSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTEzLjgxMTAyLTcuMjQzMDRWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMTEzLjgxMTAyLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTE3LjA3NDksLTI5LjcwMjc0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMzAuMDI0MzU2LC01OS4xMjkwODEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTMwLjAyNDM1NicgeT0nLTU5LjEyOTA4MSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMjYuOTExMDEzJyB5PSctNTkuMTI5MDgxJz5hz4E8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTE4LjQ1NjA4MycgeT0nLTU4LjEzMjgxNyc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTQuNTY3ODMyJyB5PSctNTkuMTI5MDgxJz4sPHRzcGFuIHg9Jy0xMC44NDEwNTUnPs+BPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTYuNzA3NTY5JyB5PSctNTguMTMyODE3Jz4yPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0yLjgxOTMxOCcgeT0nLTU5LjEyOTA4MSc+LDx0c3BhbiB4PScuOTA3NDU5Jz5iz4E8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSc4LjU0NDQ4MycgeT0nLTU4LjEzMjgxNyc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PScxMi40MzI3MzQnIHk9Jy01OS4xMjkwODEnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTE4LjU0NTA5LTU2LjkwNTVIODQuNjk2NTMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODQuOTQ2NTMsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI5LjAwMDE3LC02NC45NjczMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTMwLjAyNDM1NiwtNTkuMTI5MDgxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0zMC4wMjQzNTYnIHk9Jy01OS4xMjkwODEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTI2LjkxMTAxMycgeT0nLTU5LjEyOTA4MSc+Yc+BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0xOC40NTYwODMnIHk9Jy01OC4xMzI4MTcnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE0LjU2NzgzMicgeT0nLTU5LjEyOTA4MSc+LDx0c3BhbiB4PSctMTAuODQxMDU1Jz5iz4E8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMy4yMDQwMzEnIHk9Jy01OC4xMzI4MTcnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLjY4NDIyJyB5PSctNTkuMTI5MDgxJz4sPHRzcGFuIHg9JzQuNDEwOTk3Jz7PgTwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9JzguNTQ0NDgzJyB5PSctNTguMTMyODE3Jz4yPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9JzEyLjQzMjczNCcgeT0nLTU5LjEyOTA4MSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      width = 4cm,
      nw = {R(x,y) \wedge  R(x,y')},
      nw/style = pullback,
      ne = {R \times  B},
      sw = {R \times  B},
      se = {A \times  B \times  B},
      north = {(\gamma ',\beta ')},
      south = {(a\rho _{1},b\rho _{1},\rho _{2})},
      west = {(\gamma ,\beta )},
      east = {(a\rho _{1},\rho _{2},b\rho _{1})}
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>The first sequent demands that <fr:tex
display="inline"><![CDATA[\gamma  = \gamma ']]></fr:tex> and that <fr:tex
display="inline"><![CDATA[\beta  = \beta ']]></fr:tex>.
    Suppose that <fr:tex
display="inline"><![CDATA[au = av]]></fr:tex>.
    Then <fr:tex
display="inline"><![CDATA[(a\rho _{1},\rho _{2},b\rho _{1})(u,bv) = (au,bv,bu) = (a\rho _{1},b\rho _{1},\rho _{2})(v,bu)]]></fr:tex>.
    Thus, <fr:tex
display="inline"><![CDATA[u = v]]></fr:tex>.</fr:p>
  <fr:p>Note that <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket x\colon A.\exists y\colon B.\mkern 5muR\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> is the image of <fr:tex
display="inline"><![CDATA[a]]></fr:tex>.
    This is an isomorphism by the second sequent.
    Thus, <fr:tex
display="inline"><![CDATA[a]]></fr:tex> is a cover.</fr:p>
  <fr:p>Since <fr:tex
display="inline"><![CDATA[a]]></fr:tex> is a monic cover, it is an isomorphism.
    Thus, we can define <fr:tex
display="inline"><![CDATA[f := ba^{-1}]]></fr:tex>.
    Note that <fr:tex
display="inline"><![CDATA[(a,b)]]></fr:tex> is an equalizer of <fr:tex
display="inline"><![CDATA[f\pi _{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\pi _{2}]]></fr:tex>.
    Thus, the required sequent is satisfied.
    Suppose that <fr:tex
display="inline"><![CDATA[g\colon A\to B]]></fr:tex> also satisfies the required sequent.
    Then <fr:tex
display="inline"><![CDATA[(a,b)]]></fr:tex> is an equalizer of <fr:tex
display="inline"><![CDATA[g\pi _{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\pi _{2}]]></fr:tex>.
    Since <fr:tex
display="inline"><![CDATA[(\mathsf {id},f)]]></fr:tex> factors through <fr:tex
display="inline"><![CDATA[(a,b)]]></fr:tex> via <fr:tex
display="inline"><![CDATA[a^{-1}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[g\pi _{1}(\mathsf {id},f) = \pi _{2}(\mathsf {id},f)]]></fr:tex>.
    Then it follows that <fr:tex
display="inline"><![CDATA[f = g]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Backlinks">Backlinks</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1445</fr:anchor><fr:addr
type="user">log-000W</fr:addr><fr:route>log-000W.xml</fr:route><fr:title
text="Covers in the internal language of a category"><fr:link
type="local"
href="ct-000M.xml"
addr="ct-000M"
title="Extremal epimorphism">Covers</fr:link> in the <fr:link
type="local"
href="log-000P.xml"
addr="log-000P"
title="Internal language of a category">internal language</fr:link> of a category</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>.
  <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> is a cover iff <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> satisfies <fr:tex
display="inline"><![CDATA[y\colon B|\top  \vdash  \exists x\colon A.\mkern 5muf(x) = y]]></fr:tex> in its internal language.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>992</fr:anchor><fr:addr
type="machine">#295</fr:addr><fr:route>unstable-295.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Suppose that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is a cover.
    Let <fr:tex
display="inline"><![CDATA[e = (b,a)\colon E\to B \times  A]]></fr:tex> be the interpretation of <fr:tex
display="inline"><![CDATA[f(x) = y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
    Note that <fr:tex
display="inline"><![CDATA[a]]></fr:tex> is an isomorphism since the following is also an equalizer diagram.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="9927b7cfeb51e0dda956286a03f34140"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5NC41OTM0OTRwdCcgaGVpZ2h0PSc0Mi4xNjY3NDVwdCcgdmlld0JveD0nLTcyIC03MiAxMjkuNzI4OTk2IDI4LjExMTE2Myc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT3dBQW9BQUFBQUJCZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFV4MUFtTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ0ZaMng1WmdBQUFXUUFBQUQwQUFBQTlOdSsrWkpvWldGa0FBQUNXQUFBQUMwQUFBQTJLT3VrcW1ob1pXRUFBQUtJQUFBQUhnQUFBQ1FGdWdLeWFHMTBlQUFBQXFnQUFBQUtBQUFBQ2dabkFKSnNiMk5oQUFBQ3RBQUFBQWdBQUFBSUFESUFlbTFoZUhBQUFBSzhBQUFBRndBQUFDQUFCUUF0Ym1GdFpRQUFBdFFBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEb0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtZXMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUTBaREJpWnZnUDVETkRwSkhVL0FjS0F3RDJ4QTArZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhHLy84RFNjUC8vLzlmQVBNWkFGRllCbzRBQVFDU0FBQUNOd0tyQUI0QUFBRVJCaFk3QVJVbUp5TUdCelV6TWpZbkVRNEJKeU0xTXhZL0FUWTNOaFlCbUFRaVRqTXNPdEU2TEROT0lRTXVWQk1TRWhJK0J6ODVHQTRDaS8zTkZ4UXRBd0VCQXkwVUZ3SUFFZ3dCTFFJS0Fnb3VBUWtBQUFFQVhRQUFBbHNDcWdBckFBQWxCeUUxTkQ4Q1BnRTNMZ0VuSWdZSEhnRVhEZ0VqQmlZblBnRTNNaFlYRGdFSEJnOEJKVFkzUGdFM0Fsc2kvaVFEQ2ZvOVRRRUNhRTAwVWhZWUlRRUJKaFVPTEFJQ2hHcHdtd01DYUVndk5Xa0JBaW9LRFE4Q3hzWWZCUUlKMURGcVAweFRBU29qQWg4YklCMEJHU2ROWlFKcFkxQnBMaUFuVGdFQkJBdEJFZ0FBZU5wallHUmdZQURpUmFjZHl1UDViYjR5TUxNd2dNQmp4dzJOeURSekVOTnFJTVhCd0FUaUFRQWhKUW1EQUFBQWVOcGpZR1JnWUdiNHp3QWtneGhpR1dLWm9obUFJaWlBQ1FBOTBRSnpBQUFEVWdBQUFyZ0FrZ0JkQUFBQUFBQUFBRElBZW5qYVkyQmtZR0JnWnRCaEFORU1VQklKQUFBRkJBQXpBSGphUFl3eHE4SXdGSVcvWWhYdEd4d0VoemRJOEFlRVNwK2JtNE9UcThQYnJBblNvYW1rdGVnaS9uUnZRL0FHRHQ4OTU5d0FHUzhTaGttWUJ4MG1sVGVQUE9hSFJlU0orS3ZJR2Irc0daR2tNM0ZXN0NLblRQbVBQR1pKR1hraS9pTnl4aC92ZlZQZjdwMzE2dGdZNjkybDl0dVQ5VzNWT0xYUitiQWVyTFArM0ZtanlxY3lmZFgyMTFvVk90Y0ZleHBxYnR6cHNIZ1VSM0ZNWU1kRk1zK1dVOWhiS3NtY2REWm84bTk2a05TRnhqbjhZcVJSOGhRMTlITFRpbDZscXlqQ25hYjRBRlV5TGtNQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPSUFBb0FBQUFBQS9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxNG1OdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDVVoyeDVaZ0FBQVdRQUFBREpBQUFBekRWbVdmaG9aV0ZrQUFBQ01BQUFBQzhBQUFBMktXR2syMmhvWldFQUFBSmdBQUFBSHdBQUFDUUhNZ09HYUcxMGVBQUFBb0FBQUFBSUFBQUFDQWQ1QUdsc2IyTmhBQUFDaUFBQUFBWUFBQUFHQUdZQUFHMWhlSEFBQUFLUUFBQUFGZ0FBQUNBQUJRQStibUZ0WlFBQUFxZ0FBQUROQUFBQk9QTmJLcDl3YjNOMEFBQURlQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm0zc000Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmtadmdQNURORHBKSFUvQWNLQXdEcHNnMHZlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aU8vLzlEeVA4SHdId0dBRktYQnAwQUFBQjQyaFhKUVdyQ1FCUUc0UGUvR2VhcE0wWmo2a1JiQ0tnUWQycXJKRlFraUJSQnZJRTM2S0liQlEvaHNtZnBDYm9SZWdkM0xucUpxblg3ZmNUMGZyMnFJNS9vbFdaRWlCS01NeDk3R2FLR3RGOGc5bGsrUkVkTWpZMGt5R01mQjdobk4rMm5XVjRnUjRFWEw2ckR2M3UwUmpZQ0h1ZUwxVnNEaUZ4cHFxdmg1U2ZTYXUwTU9DMVpBVUt6bXd5MFpVand2RWp3S2ZXdTI1elI0KysvUTFpRmNVK3NBSVY2c3d4SXVOeUE5Y2VETFRjcVlPWCtVVU5KaGR1TTNvQ1gxcm50NVl1SWJ0RjNHOWtBQUFCNDJtTmdaR0JnQU9JYi9qNzc0L2x0dmpJd3N6Q0F3R1BIRFkwSSt2OS81dU5NZDRGY0RnWW1rQ2dBU2kwTU5nQjQybU5nWkdCZ1p2alB3TURBb3NxUXlSREhmSndCS0lJQ21BQkN4d0xCQUFOVUFBQUVKUUJwQUFBQUFBQm1BQUI0Mm1OZ1pHQmdZR0t3QldJUVlHUkFBd0FHcVFCRUFBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzODtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTlFBQW9BQUFBQUE3d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFlwMEwyTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWdBQzhaMng1WmdBQUFXd0FBQUNNQUFBQWpDd1Z1S2RvWldGa0FBQUIrQUFBQUM4QUFBQTJKK3Frdkdob1pXRUFBQUlvQUFBQUh3QUFBQ1FGREFHamFHMTBlQUFBQWtnQUFBQU1BQUFBREFXRUFISnNiMk5oQUFBQ1ZBQUFBQWdBQUFBSUFESUFSbTFoZUhBQUFBSmNBQUFBR0FBQUFDQUFCZ0FkYm1GdFpRQUFBblFBQUFET0FBQUJPQWQxS3Ixd2IzTjBBQUFEUkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdk1ZNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUk1ZY2hrNXY0UDVETnpNNktwK1E4VUJnRDlQUTJvZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpCay92OFA1SVBwLzNQL3p3U3JBZ0lBbU5FSk5nQUFBQUFDQUNYLzlnSGFBc2NBRUFBYkFBQUJFU00xRGdFSExnRW5QZ0UzTmhZWEVRTTFKaU1tQmdjZUFUYzJBZHBaSGxRd1VXY0NBbWxTR0ZneUF5ZytPR0lEQWxjNFN3TEgvVGsxR2lRQkE0WmtaWVlEQVJVaUFTejl1Tm8wQVUxZldGSUJBd0FBQWdCTkFBQUF0QUsrQUFNQUJ3QUFFeFVqTlJjUkl4RzBaMTlXQXI1blovZitPUUhIQUFBQWVOcGpZR1JnWUFEaXMwelQyK1A1YmI0eU1MTXdnTUJqeHcyTkNQci9ONllBcHVOQUxnY0RFMGdVQURhVUMxb0FlTnBqWUdSZ1lPYit6OERBd0JUQW9Ncmd6M2lMQVNpQ0FwZ0JRZ1lDdEFBQ1VBQUFBakVBSlFFREFFMEFBQUFBQURJQVJuamFZMkJrWUdCZ1pwQmhZR0lBQVVZR05BQUFBNHNBSkhqYVRZdzliOEl3RUlhZnFBbFN3OENDT2pDMEhqcGJRV0ZnWW1GZ1ltVmlBZXlpREhHUUhTSWhWUjM1M1QyTUI4N1M2WGsvemtESkh4bVB5WmpFL1ppY1F0U1RDOFpNRTQ5RWZTVXVtZkhORzFuK0xzNG5xOFM1SlB2RUJSLzhKQjZKLzV1NFpNRjkzYldYYTIrOTJuYkdlbmRxUTFqdXJBOU41OVJjVjFGdnJMUCswRnVqampkbGhpWU01MWJWdXRJMWF6cGFMbHpwc1hnVVczRk1aTWRKc2lCdnlTNDZnVVpTSjYwNW11b2wzMGp1WXVjUWZ6TFNPWEtUYlJqa0tzZytTMXRSeDB0Ti9RL3FiVEE3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUmtBQW9BQUFBQUJSUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGNkMzVtTnRZWEFBQUFFOEFBQUFNd0FBQUVRQWVnUldaMng1WmdBQUFYQUFBQUdUQUFBQjFPaC9UYkZvWldGa0FBQURCQUFBQUM4QUFBQTJLR0NqLzJob1pXRUFBQU0wQUFBQUlBQUFBQ1FGeEFHYmFHMTBlQUFBQTFRQUFBQVFBQUFBRUFrSEFPeHNiMk5oQUFBRFpBQUFBQW9BQUFBS0FSUUFrRzFoZUhBQUFBTndBQUFBRndBQUFDQUFCZ0JDYm1GdFpRQUFBNGdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFV0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtY21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwcnFNQjlnWnZnUDVETXpNSUtFR1JFcS9nT0ZBZUpYRGFBQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUlMa2RCalNtQS84LzQ5Zy9iLzZmODRmWjdCYU1BQUE5Q3dMelFCNDJrV1FzVzdUVUJTRzczL3QzaHNuanEvcnhOY2tOSFljTzlldEttSVNON2FVSXJ0QXUxQWt4QlIxNnM0S1lrU0lCMkNCb1NPOFJtZGVnSTBISVN2aFdneWM3ZGNubmZQOWg0QzgzVy9JanJ3bmtwQ0tNNzdBV1ZtRjhKa0E0eW9ycXhxLzdON2dLSnFPMDlTY1czUFJNOENLeU8xd0lGN0ZRTDNjcnZzcjBENC9XTjRTUFNEWCs1eStvVC9KaFE1R3U4Z0JuNm1zUmlFRHliaU1VS014RXFiS29LaWhUeFFyR1RoSVZLYktTdVZ3cUVCUlNwYmgrOFkxM2JIMWRIbThBVkpmR1JDUkVDS05qY2xDdkF6cFFMd1d2aU9mSlNkUGdFUnE3b1pDZUY3WTdZeHZXNHl2ZjM2OE9MdzRHejQzVkJKT2FjcXlua1ZoWHZ0M3U2MHg0OWplUE16VVBQMlBNRktQUHB1ekR2NTFXZXgzOUF2dVNha0RieDNYamJhdkVzVTR5OUdXMHY1QlhNcEEweXpSZndzUnlMWXgwM1ZhakxvNURNUFVHRDY0SERmZXE1TURwOHRBVDJXOER2RkpITUV3ZzlISExxWHdYUXVZZUgzZjdta0xHKzkrWDEyWkU1RTkvcmFsUVdHRHdyTE9oMU1mc0h4aGViU0s4dVptWW5lSEkyQXduNTQzSDNLdC9CZGNuRHM3QUhqYVkyQmtZR0FBNG9MakljTHgvRFpmR1poWkdFRGdzZU9HUmdUOVg1L3BHTk5GSUplRGdRa2tDZ0FrUWdyRUFIamFZMkJrWUdCbStNL0F3TUIwakVIdi93V215UXhBRVJUQUFnQm9WUVJqQXNZQUFBRmJBSE1DT2dCTEFxd0FMZ0FBQUFBQUtnQ1FBT29BQUhqYVkyQmtZR0JnWVhCa0FORU1VQklKQUFBSExBQkpBSGphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9DQ3hkV0ZnWW1YcUF0aEZHV3dqSjBSQ3FqcjJkL2RoUFBRTlYrZCsyRURORHdYM0s1Z2x2VjlKSmU3QkZWUG1tU2ZpM2pMWExIam5pYUo4bHVTVmo4eWxOSitaSzE3NHlqeVIvRHR6ellyZlRYQ1g2MkNqMmdWam96ODUxNjMzTnZaZDhHcXBtK1MzMXR0NEdLeFJ4NXN5WTllUFo2ZGEzZWlXRFFISGhTc0Rsb2hpSjRsSjdEbEo1K2hZczA5Skx4d2tWeXpSTlAvNnJmUStiUTdwSnlPYkl6ZFJ3eWlMWHZRc1cwV2JYbXJhUDh1aEwvY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDMEFBQUEyS0cya0FHaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHVOdXNkN3gvRFpmR1poWkdFRGdzZU9HUmdUOW41SHBNak9JeThIQUJLSUFIVE1KNmdBQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTThBQW9BQUFBQUE2UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJnaU9SekcyTnRZWEFBQUFGQUFBQUFLUUFBQURRQURBRXFaMng1WmdBQUFXd0FBQUI0QUFBQWVKTVNQSkZvWldGa0FBQUI1QUFBQUN3QUFBQTJLTFdqOTJob1pXRUFBQUlRQUFBQUhnQUFBQ1FHTmYvZGFHMTBlQUFBQWpBQUFBQUdBQUFBQmdPd0FBQnNiMk5oQUFBQ09BQUFBQVlBQUFBR0FEd0FBRzFoZUhBQUFBSkFBQUFBRndBQUFDQUFCQUFrYm1GdFpRQUFBbGdBQUFEVEFBQUJQcTgzZGVGd2IzTjBBQUFETEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtbG1HY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRVRBeEpJS1M1TEIwcGVaN2pPTFBWSGs0R0JXWXI1T2xDWUVhSGkvMzhHQmdEcm5RN3ZBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4Q0MrTmYvLzRlUS83WEFmQVlBWHVVSE13QUFBQUFCQUpRQUNRS0dBZmdBSWdBQUFUYzJGeFlYQmc4Q0h3RVdCd1lISmk4QkJ3NEJJeVluSmo4Qkp5WTNOamN5RndHT3l3NEtFd0VDQXhxN3BUSUVBUUVUQ3dYVXl3a0lCaEVEQXhETnpSQURBeEVHQkFFZHloRUJBaE1LQXhxN3BUSUlBeE1DQWdUVXl3b0ZBaE1IRGM3T0RRY1RBZ0lBQUhqYVkyQmtZR0FBNHBYcFRQTHgvRFpmR1poWkdFRGdzZU9HUm1TYVdZYnhCNURpWUdBQzhRRDMyUWltZU5wallHUmdZSmI2b3dra1pSaW1NRXhqYW1NQWlxQUFSZ0JNeWdNWEFBQURIQUFBQUpRQUFBQUFBQUFBUEFBQWVOcGpZR1JnWUdCaVVHWUEwUXhRRWdrQUFBUUlBQ2tBZU5wTmpyRnF3ekFRaGo5VHgxQW5rS2tkT2hSTkdZV044d0NGREpteVppd2trUWdPV0E2U1kvQlM4Z0I5NkY0VURUM0I4ZW0vNzRTQWtoOHlIcFd4alAxUk9ZWGNuanhqemx2aVFvNUtYUExCaWhleS9GV1NUNzRTNXl6NFRqempuVXZpUXZKNzRwSTF2NXUrdTk0RzY5V3VOOWE3VXhlbXV0cGJIOXJlcVZwWHoyQnJuZldId1JwMW5KUVoyekNlTzlYb1NqZHM2T200Y21QQTR1Vm5PMGxNWk1kSlpvR0ptb3A5ekFLdHpKMTROVnJTLzhaV0RCZXRRM3pOaUhXVW1SSWFaUzlJUDR1dmFPS3VwdmtEQ1ZFeEV3QjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUU1BQW9BQUFBQUJKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MCsyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUZMQUFBQllEbVNzVEpvWldGa0FBQUNzQUFBQUM4QUFBQTJLS0NrMldob1pXRUFBQUxnQUFBQUhnQUFBQ1FHTEFJT2FHMTBlQUFBQXdBQUFBQU1BQUFBREFoK0FFOXNiMk5oQUFBRERBQUFBQWdBQUFBSUFGUUFzRzFoZUhBQUFBTVVBQUFBRmdBQUFDQUFCd0E2Ym1GdFpRQUFBeXdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFQUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RHlLUTFIZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpXUE1VL0NRQUNGNzkzQkhXRGJRMXZhR0FGVFFacG9GRU5KS3d3TUttZzBFcFRFTUpDWW1DaWJnMEZjR1JoMU1qRnhjbkh6QjdnNE9ma25ISXlqdndHd05mRk5MMS9lOEQxQ1NYNDZwVi8wa3hSSmlSQWZubDh5TGQwd1hjL2tSUWluNEpROXkvVDhJbXpCRGRQeUxBMEJEN0ZiZysreVY1eHpRK1dvbVdzcEtOSCtNQmFGT3FPWFdWeE1wazAxcmFzTWFyVFhVYURFbDJxUFAvYUFuaVFSbCtPaEtWbEdnREhRbUJTQVlsM1VSMFkrQ1NvMUh1S0U1TWg5NEpnRVlXUjFPbWFjdnBFc1dTR2JnYWxlemprOGNMT3pTR2tRV1ZoY2dndWIvL25xb1p4WGNISUZMdGgvWjhIQWZiNWJjREpTb3RNOVk4UDJRUnQwTjNsNFBibFBhMW8xKy9SdzJxZFkzeDR0NnRITDIrNkEwbzI5OTBZRTBGcTBNa3RaV29BZVZmZDdNdEdzSEd4cHRVajRBRHJxN0txUjM2R1E4K01YZHROY2JySEo5eHhQa0YrenZUdURBSGphWTJCa1lHQUE0alk5dHB2eC9EWmZHWmhaR0VEZ3NlT0dSZ1Q5L3k4ekc5TmRJSmVEZ1Fra0NnQWtEd3JVQUhqYVkyQmtZR0JtK004QUpEa1lWQmlZbU5rWWdDSW9nQmtBSThjQlFnQUFBbllBQUFNQUFDUURDQUFyQUFBQUFBQlVBTEI0Mm1OZ1pHQmdZR2F3QkdJUVlHUkFBd0FHZHdCQ0FBQjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTYuODQ0Mzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuOTc0NTU4LC01Ni44NDQzOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjMuOTc0NTU4JyB5PSctNTYuODQ0MzknPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDMuMDAxMDIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjk3NDU1OCcgeT0nLTU2Ljg0NDM5Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01My43MDQwODMnIHk9Jy01Ni44NDQzOSc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQzLjc0MTQ3JyB5PSctNTYuODQ0MzknPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA5Ljc2NzYxLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTU2Ljg0NDM5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My45NzQ1NTgnIHk9Jy01Ni44NDQzOSc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTAuNTA1NTQgMEgzNy45NDU0OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMC43NTU1NCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDM4LjE5NTQ4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTAuNjA1NzMsNC41NjE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjk3NDU1OCwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTYzLjk3NDU1OCcgeT0nLTU2Ljg0NDM5Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02MC44NjEyMTUnIHk9Jy01Ni44NDQzOSc+Zjx0c3BhbiB4PSctNTYuNjIzNTc5Jz4sPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUyLjg5NjgwMicgeT0nLTU2Ljg0NDM5Jz5pZDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDcuMzAzMTM5JyB5PSctNTUuODQyNTc3Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00MS42NDM3MjgnIHk9Jy01Ni44NDQzOSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNzUuMzY1NTIgMy42MTY2MkgxMDQuNzEyMDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA0Ljk2MjA3LDMuNjE2NjIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDgzLjY1NzE4LDcuNzg5NTQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTU2Ljg0NDM5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02My45NzQ1NTgnIHk9Jy01Ni44NDQzOSc+Zjx0c3BhbiB4PSctNTkuMzA3OTczJz7PgDwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy01NC42NDkxMjknIHk9Jy01NS44NDgxMjYnPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTc1LjM2NTUyLTMuNjE2NjJIMTA0LjcxMjA3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwNC45NjIwNywtMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODUuOTk5MjIsLTkuNDQyMzIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My45NzQ1NTgsLTU2Ljg0NDM5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02My45NzQ1NTgnIHk9Jy01Ni44NDQzOSc+z4A8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTU5LjMxNTcxMycgeT0nLTU1Ljg0ODEyNic+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$A$};
      \node  (2) [right = of 1] {$B \times  A$};
      \node  (3) [right = of 2] {$B$};
      \draw  [>->,morphism] (1) to node {$(f,\mathsf {id}_{A})$} (2);
      \draw  [->,morphism,offset=-1.5] (2) to node {$f\pi _{2}$} (3);
      \draw  [->,morphism,offset=1.5] (2) to node [swap] {$\pi _{1}$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By <fr:ref
addr="log-0008"
href="log-0008.xml"
taxon="Definition" />, <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket y\colon B.\exists x\colon A.\mkern 5muf(x) = y\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> is the <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">image</fr:link> of the following composite.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="91178b569ec537fc20ab4245e0e7042d"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5NC45MzU5NXB0JyBoZWlnaHQ9JzEwOC4yNzMwODZwdCcgdmlld0JveD0nLTcyIC03MiAxMjkuOTU3MyA3Mi4xODIwNTcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0cya0ttaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHVOdU1kL2orVzIrTWpDek1JREFZOGNOMHhEMGYwYW15OHdnTGdjREU0Z0NBRDJ4Q3I4QUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1jQUFvQUFBQUFBNFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVeDFHMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNFWjJ4NVpnQUFBV1FBQUFCa0FBQUFaREZ1QXJKb1pXRmtBQUFCeUFBQUFDMEFBQUEyS091azFHaG9aV0VBQUFINEFBQUFIZ0FBQUNRRnl3TFdhRzEwZUFBQUFoZ0FBQUFJQUFBQUNBWUtBSkpzYjJOaEFBQUNJQUFBQUFZQUFBQUdBRElBQUcxaGVIQUFBQUlvQUFBQUZ3QUFBQ0FBQkFBZ2JtRnRaUUFBQWtBQUFBREtBQUFCTXVzSWtlWndiM04wQUFBRERBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVptV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9hTWhneU0vd0g4cGtoMGtocS9nT0ZBYU4zREZnQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpRy8vOUR5UDhYd0h3R0FGRkhCbzBBQUFBQUFRQ1NBQUFDTndLckFCNEFBQUVSQmhZN0FSVW1KeU1HQnpVek1qWW5FUTRCSnlNMU14WS9BVFkzTmhZQm1BUWlUak1zT3RFNkxETk9JUU11VkJNU0VoSStCejg1R0E0Q2kvM05GeFF0QXdFQkF5MFVGd0lBRWd3QkxRSUtBZ291QVFrQWVOcGpZR1JnWUFEaUgrekd2UEg4Tmw4Wm1Ga1lRT0N4NDRacHlEUnpFTk5xSU1YQndBVGlBUUQ5MGdqSUFBQUFlTnBqWUdSZ1lHYjR6d0FrZ3hnbU1UUXltVE1BUlZBQUV3QkMzQUtvQUFBRFVnQUFBcmdBa2dBQUFBQUFNZ0FBZU5wallHUmdZR0Jpa0djQTBReFFFZ2tBQUFPa0FDVUFlTm85akRHcndqQVVoYjlpRmUwYkhBU0hOMGp3QjRSS241dWJnNU9ydzl1c0NkS2hxYVMxNkNMK2RHOUQ4QVlPM3ozbjNBQVpMeEtHU1pnSEhTYVZONDg4NW9kRjVJbjRxOGdadjZ3WmthUXpjVmJzSXFkTStZODhaa2taZVNMK0kzTEdIKzk5VTkvdW5mWHEyQmpyM2FYMjI1UDFiZFU0dGRINXNCNnNzLzdjV2FQS3B6SjkxZmJYV2hVNjF3VjdHbXB1M09td2VCUkhjVXhneDBVeXo1WlQyRnNxeVp4ME5tanliM3FRMUlYR09meGlwRkh5RkRYMGN0T0tYcVdyS01LZHB2Z0FWVEl1UXdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktLYWtIMmhvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaW85Yk52Zkg4Tmw4Wm1Ga1lRT0N4NDRacENQcS9Qak1QMDNFZ2w0T0JDU1FLQUN4S0NvUUFlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU2dBQW9BQUFBQUJWQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGYxNERHTnRZWEFBQUFFOEFBQUFNd0FBQUVRQWVRU01aMng1WmdBQUFYQUFBQUhQQUFBQ0VONUQ5cTlvWldGa0FBQURRQUFBQUM4QUFBQTJLR0NrNVdob1pXRUFBQU53QUFBQUlBQUFBQ1FGd3dIa2FHMTBlQUFBQTVBQUFBQVFBQUFBRUFtZkFMWnNiMk5oQUFBRG9BQUFBQW9BQUFBS0FXQUFybTFoZUhBQUFBT3NBQUFBR0FBQUFDQUFCd0E0Ym1GdFpRQUFBOFFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFbEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtU21lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwb21NUjlnWnZnUDVETXpNSUtFR1JFcS9nT0ZBZmF2RGZ3QUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ01nRFFIRUlMa2toaFNtUS84LzQ5Zy9aLy9mKzRmWjdCYU1BQUEvS3NNQWdCNDJpV1F2MjdUVUJURzczZnRYTWVPWTZlcC84UVZNWW1kMmc0cGNSUmp1eUtwblJZSFVKZFdhcVVxSGJxek1LQnVsUkR3Q3J3QUl5L0FBRE1TN3dGaVlBY1dCT1dtM2M1M3ZqUDh6bzlROHVqNk43N1NMOFFqR1NFUUN1U1paVE1kVEJvakRFcStDSHd2Q0Fza3ZKRFdmWUYwRE4rVE5QQXIwN0NnUGJZUG90MExRZGp2SDY3MlR3RjJmNnd3cWcva0RVQ1hxcDBCOG1pNTJlbGk1TTRMclM2NjlTRjkvKytiNVFFbnEyZkhmaVZnZGRUeVBuNjRaemNWVWRIcmtpaW9mODh4RHlkWC9vTzQwblh0S25MR0R3bWhaTWw1LytBekNkYTh1YzlKWFNSV2lTelBYSmpHTFhqS1U1NGxVOHUybU1Ta01MSFdPZWZZQVkvcyswSUdSUmEzOXRxTG1kSnNUTGVLeS9NTDhhblpPVG5ObndEKzdzN2s5YlE3My9aU0ViRnZKVm96L1JHWmJsRlF0ZFphTktBeWJkaUtSUHI4K0VWbDZPbGsxTmt6TmRFQnEybEc3dllFUTFKNkJHUjgvWXUreGFjYnMxeVhINlFsdUVBLzRBd3gxbEs1VEx2UGhmTTJ2UDNGdHZnc3NTQzhxVkdVRzY0N0VJeE90VlcyajRZMVRXR2dJNnVmdW5pajM0RWcyczRyaFZLWUxSbm90cHVtMmdBY0ZaYy9sMHV4cTRlVGQyZlVUbFQrcml6UGpKNEp5S1l1dDJsK055NVhYVlV4SEdCenV6Y3JYOGFFa1A5alEweU9BSGphWTJCa1lHQUE0bWJ1djZueC9EWmZHWmhaR0VEZ3NlT0dhUWo2LzFlbVkwekhnVndPQmlhUUtBQkFaQXY4QUhqYVkyQmtZR0JtK00vQXdNQjBqRUdQUVpKcE1nTlFCQVd3QUFCRGFBS3RBc1lBQUFJQ0FFTUNLd0JGQXF3QUxnQUFBQUFBV0FDdUFRZ0FBSGphWTJCa1lHQmdZVEJuWUdJQUFVWUdOQUFBQmtrQVFIamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b0NDeGRXRmdZbVhxQXRoRkdXd2pKMFJDcWpyMmQvZGhQUFFOVitkKzJFRE5Ed1gzSzVnbHZWOUpKZTdCRlZQbW1TZmkzakxYTEhqbmlhSjhsdVNWajh5bE5KK1pLMTc0eWp5Ui9EdHp6WXJmVFhDWDYyQ2oyZ1Zqb3o4NTE2MzNOdlpkOEdxcG0rUzMxdHQ0R0t4Ung1c3lZOWVQWjZkYTNlaVdEUUhIaFNzRGxvaGlKNGxKN0RsSjUraFlzMDlKTHh3a1Z5elJOUC82cmZRK2JRN3BKeU9iSXpkUnd5aUxYdlFzVzBXYlhtcmFQOHVoTC9jQUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOQUFBb0FBQUFBQTZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdpT1J6RzJOdFlYQUFBQUZBQUFBQUtRQUFBRFFBREFFcVoyeDVaZ0FBQVd3QUFBQjRBQUFBZUpNU1BKRm9aV0ZrQUFBQjVBQUFBQzBBQUFBMktMV2tJV2hvWldFQUFBSVVBQUFBSGdBQUFDUUdOZi9kYUcxMGVBQUFBalFBQUFBR0FBQUFCZ093QUFCc2IyTmhBQUFDUEFBQUFBWUFBQUFHQUR3QUFHMWhlSEFBQUFKRUFBQUFGd0FBQUNBQUJBQWtibUZ0WlFBQUFsd0FBQURUQUFBQlBxODNkZUZ3YjNOMEFBQURNQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1sbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFVEF4SklLUzVMQjBwZVo3ak9MUFZIazRHQldZcjVPbENZRWFIaS8zOEdCZ0RyblE3dkFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hDQytOZi8vNGVRLzdYQWZBWUFYdVVITXdBQUFBQUJBSlFBQ1FLR0FmZ0FJZ0FBQVRjMkZ4WVhCZzhDSHdFV0J3WUhKaThCQnc0Qkl5WW5KajhCSnlZM05qY3lGd0dPeXc0S0V3RUNBeHE3cFRJRUFRRVRDd1hVeXdrSUJoRURBeEROelJBREF4RUdCQUVkeWhFQkFoTUtBeHE3cFRJSUF4TUNBZ1RVeXdvRkFoTUhEYzdPRFFjVEFnSUFBSGphWTJCa1lHQUE0cFhwaktmaitXMitNakN6TUlEQVk4Y04wNUJwWmhuR0gwQ0tnNEVKeEFNQUdHWUpld0FBQUhqYVkyQmtZR0NXK3FNSkpHVVlwakJNWTJwakFJcWdBRVlBVE1vREZ3QUFBeHdBQUFDVUFBQUFBQUFBQUR3QUFIamFZMkJrWUdCZ1lsQm1BTkVNVUJJSkFBQUVDQUFwQUhqYVRZNnhhc013RUlZL1U4ZFFKNUNwSFRvVVRSbUZqZk1BaFF5WnNtWXNKSkVJRGxnT2ttUHdVdklBZmVoZUZBMDl3ZkhwdisrRWdKSWZNaDZWc1l6OVVUbUYzSjQ4WTg1YjRrS09TbHp5d1lvWHN2eFZraysrRXVjcytFNDg0NTFMNGtMeWUrS1NOYitidnJ2ZUJ1dlZyamZXdTFNWHBycmFXeC9hM3FsYVY4OWdhNTMxaDhFYWRaeVVHZHN3bmp2VjZFbzNiT2pwdUhKandPTGxaenRKVEdUSFNXYUJpWnFLZmN3Q3JjeWRlRFZhMHYvR1Znd1hyVU44elloMWxKa1NHbVV2U0QrTHIyamlycWI1QXdsUk1STUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVUwQUFvQUFBQUFCaHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDAwbU50WVhBQUFBRTRBQUFBTlFBQUFFUUFXZ0QyWjJ4NVpnQUFBWEFBQUFKWkFBQUMwS3lRZGhob1pXRmtBQUFEekFBQUFDOEFBQUEyS0txbEEyaG9aV0VBQUFQOEFBQUFIZ0FBQUNRR05nSFRhRzEwZUFBQUJCd0FBQUFVQUFBQUZBMDBBSmxzYjJOaEFBQUVNQUFBQUF3QUFBQU1BWFlDR0cxaGVIQUFBQVE4QUFBQUdBQUFBQ0FBQ1FCTWJtRnRaUUFBQkZRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRktBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVdzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWlBCa1p2Z1A1RE5EcEpIVS9BY0tBd0RoaEEwZWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VTY0dGd1pQUC8vQjdJY0lhei9CLzd2Kzc4YnJCWU1BT0VXQzBvQUFBQjQyajJTejBzVVVRREgzL2U5bWZmYzNabDVxN003b3puT3NxM09pS2JHL25qYmJyUlNxWVdTV0VKNGtJb2doYUFPWVhyTWc1UkpIU0lJT25YcFZwZE9FWFRxMUQvUU1TRTZSWVJIVDd2Ykd5bmY2ZkY5Ny9ENThQMFNTb2E3WGZxRGZpZFRwRXhJSGFwZTludzM1MVdVeDZjZzRpaXVLdDlUOVNrVUJjOTV2dklkNkR5Skt5M1VLK3dqN3ZDY3pkSHlKdkt3ekkzdEhoTjJ4cTJ5bE9oMEYrM0F0UmxzYzMzRmdwVTYyWHI5dTdoSnIyZVJrdTF0VDdJaEFjWkFlNlFBTEg5dGRpYzNuQVdWRGsvaXRPUW9mY1Uxb2c4ajQ5MDI0L1F6Q2NrWU9hTkozV29wNXBxdEdDTHZRSVR3dVFRWFJYN0U2eVp3S29wTEVSZnMvNTNwRDVXM3p3ZmpJU214c25xYmJTOHZMSU5leWw1NTJIa1pPRTR6ZlBQcTVnYkY1TVdkZ212ZWY3YTZTZW5weTEvbURNQlpvbzFleWdJQmVyVTV2eTdUaTQyRkMwN0xTQXpnWXBZOW1CdWVvWkFEN1hkc2EzRmtpWFYrOXZFMElTQ3g1czdTVDJTZWtCSGhvUFFQc081T1l4SkhBc3FUeUVYVHRLWWlvWGtsS3ZwWmViN2dVYTFhVi9FeHVsK2UxdjJvY2dIMDJ3M0R5cmIvREVrTmJUN1JnQ01ObWFWbW44VnlBV0RRODZzdnRNSzVXek0xbS9rNGEvU3psS1p2cmMwbUx1KzNsQ3lQSVU5eHNHK1pMT1JhSWFSaHI3Q0ZvUTJSY2o4RVJ0b05UclJxUUhiZ0VCTU5GNWtEajZVTk1TN2NRWFIrYVRsTU91cHV4dURhc2RUdG9xMjdHZFhDVFBBQzFORklqc2ZqcXJnYUNkNUNBWFhmODNNOGpqZ2VQVFZZY0twSWJiSDNPR1ZDOWpVTHhoNURWQXhnODkxZEhUbHVzMER2dGZmN0phVUo1ZkZVOGdFZHpaaDZIa2toU1pyU2kwR2VrTDgxbEc5NUFBQUFlTnBqWUdSZ1lBRGl5YnR5M3NmejIzeGxZR1poQUlISGpodW1JZWovZjVrRm1PNEN1UndNVENCUkFGaUREQjBBZU5wallHUmdZR2I0endBa09SaVUveDlsRm1BQWlxQUFWZ0JLV1FNUEFBQUNkZ0FBQXdBQUpBTUlBQ3NDOUFBbkFjSUFJd0FBQUFBQVZBQ3dBU0lCYUhqYVkyQmtZR0JnWmZCbVlHWUFBVVlHTkFBQUNHOEFWbmphVFk2eGFzTXdFSVkvVThkUXA5Q3BIVG9VVFJtRmpmc0FnUXlac21Zc0pKRUlEa2dLc21QSUV2b0FmZWhlRkEwOXdmSGRkNytFZ0pvYkJmY3FlRTM5WGlXVlRBK2VNZWN0Y3lWSFphNzVZTUVUUmZrczVwTmw1cElYdmpQUGVPZVV1UkwvazdubWk5OVZjT2ZMYUtQYUJHT2pQempYdDgzV3hxRVBYclc2ZVlpMTlUYnVSbXZVL3FyTTFBL1QwYWxPTjdwalJjQng1c0tJSmNyUE5tSk1ZczlCZG82ZWxvWnRjb05NUVRaS25CYjdQN0dXaEUrcFhYck5TR3JQVmJwaGtzd2cvU2hwUlpmdWFyby8zL1F3dXdBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zczg7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuOTc5MTYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkU8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDMuMDAxMDIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUzLjQ3NTc4MycgeT0nLTYyLjY0NzU2NCc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQzLjUxMzE3JyB5PSctNjIuNjQ3NTY0Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwOS43Njc2MSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjc0NjI1NycgeT0nLTYyLjY0NzU2NCc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1NC4zMTUyMywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkk8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjczNDcgMEgzNy45NDU0OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMC45ODQ3LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguMTk1NDgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMS41OTMwMywyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02Mi42NDc1NjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYzLjc0NjI1NycgeT0nLTYyLjY0NzU2NCc+ZTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNzUuMzY1NTIgMEgxMDQuNzEyMDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA0Ljk2MjA3LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODUuOTk5MjIsMy44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPs+APC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy01OS4wODc0MTMnIHk9Jy02MS42NTEzJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002LjQwNDU0LTYuNDA5NzNMNDcuMDkyMzktNDcuMDk2NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzEsLTAuNzA3MDksMC43MDcwOSwwLjcwNzEsNDcuMDA0MDEsLTQ3LjAwODIyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPHBhdGggZD0nTTY1LjYwNjktNDguMjA4NzZMMTA3LjA1MTQ1LTYuNzYzMjgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNzA3MDksLTAuNzA3MSwwLjcwNzEsLTAuNzA3MDksNjUuNzgzNjgsLTQ4LjAzMTk4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzA5LDAuNzA3MSwtMC43MDcxLDAuNzA3MDksMTA3LjIyODIzLC02LjU4NjUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4Ljk5MjAzLC0zNi4xNDg4OCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjIuNjQ3NTY0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02My43NDYyNTcnIHk9Jy02Mi42NDc1NjQnPkltZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTEuOTk1OTE4JyB5PSctNjIuNjQ3NTY0Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00OC44ODI1NzUnIHk9Jy02Mi42NDc1NjQnPmI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ1LjM3OTAzNycgeT0nLTYyLjY0NzU2NCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$E$};
      \node  (2) [right = of 1] {$B \times  A$};
      \node  (3) [right = of 2] {$B$};
      \node  (4) [below = of 2] {$I$};
      \draw  [>->,morphism] (1) to node {$e$} (2);
      \draw  [->,morphism] (2) to node {$\pi _{1}$} (3);
      \draw  [cover,morphism] (1) to (4);
      \draw  [>->,morphism] (4) to node[swap] {$\mathsf {Img}(b)$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>By assumption, <fr:tex
display="inline"><![CDATA[fa = b]]></fr:tex>.
    Thus, the image of <fr:tex
display="inline"><![CDATA[b]]></fr:tex> coincides with that of <fr:tex
display="inline"><![CDATA[fa]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="ac18ba5c17d57f35668c8be429afad85"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5NC45MzU5NXB0JyBoZWlnaHQ9JzExMS41NzMxOTFwdCcgdmlld0JveD0nLTcyIC03MiAxMjkuOTU3MyA3NC4zODIxMjcnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3M4O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRWUFBb0FBQUFBQk13QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVzkwbkdOdFlYQUFBQUU0QUFBQU13QUFBRVFBZXdFZ1oyeDVaZ0FBQVd3QUFBRk1BQUFCalBOd0pKTm9aV0ZrQUFBQ3VBQUFBQzhBQUFBMktLYWo5V2hvWldFQUFBTG9BQUFBSGdBQUFDUUdOd0oxYUcxMGVBQUFBd2dBQUFBUUFBQUFFQWo5QU5ac2IyTmhBQUFER0FBQUFBb0FBQUFLQU5RQWlHMWhlSEFBQUFNa0FBQUFHQUFBQUNBQUNBQk5ibUZ0WlFBQUF6d0FBQURPQUFBQk9BZDFLcjF3YjNOMEFBQUVEQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1zbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwNk11UXljLzhIOHBtNUdkSFUvQWNLQXdERDd3ejdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1UThHZElaY3YvL1I3RCs3L2cvKy84MHNGb3dBQURzaHd1VkFIamFWVkRMVHNKUUVKMlpXMW9nV0FTbEZkdFVhV01MaUJCNXRNQlZFaGNTSXlwcTRrSWtTR1RqanhnK0RSTVNFcUlmNHRhRjRNV05ta2xPem1ObWNRWVFSZ0F3cFFrd2dJMkVrNWcrMCtTcklUUUl4MXFXS0k3dlVBSU9IUURVUFVkV2RDMmxvaUo3c21KaFVQRjFUWXlLdHV1NWZsQkV6dy9jV2dzRFgyOGgwMWFPNDY0MmRYRXA2eGFXUmU2SklSYXJjbE9TVEh5NjJHK0VHQlhpajhaUjNxMUtOSjZOR1JvNUpZRlMycUhoWmJGeC9MQzBPV0V0N3dqMGU2UG1tc3BvOERJZ3FSQmZMK0s4TFNFTDV3NVBoMFM3dE9NbWlDSmh6YnJpM1M3ZjVOc1J6Mm9hQjNXUk1sdUxMajZ3eUN2VkgzaGxwcWxrc3RsTVZnMlJMQ29Ed3Awb0hzTTMyQk5DL01Ndm9ldXBxS2YrMFVyS0YxMUV4Y0JDRnIxbnFwUTg0Mlg4SmJmdDNubFRUdDZjOURtV0ZuUE1wdTJRelZpLzl2bVh6anJYeE9wYmhrOXNDTi9yckQzcmVOcGpZR1JnWUFCaW85Yk5EK1A1YmI0eU1MTXdnTUJqeHcyTkNQcS9Qak1QMDNFZ2w0T0JDU1FLQURhZ0NxNEFlTnBqWUdSZ1lPYit6d0FrNHhua0dBU1plUmlBSWlpQUJRQXV2d0cwQUFBQ1VBQUFBUzRBWXdJZ0FCNERYd0JWQUFBQUFBQU9BSWdBeGdBQWVOcGpZR1JnWUdCaDhHRmdaZ0FCUmdZMEFBQUliUUJXZU5wTmpEMXZ3akFRaHArb0NWTER3SUk2TUxRZU9sdEJZV0JpWVdCaVpXSUI3S0lNY1pBZElpRlZIZm5kUFl3SHp0THBlVC9PUU1rZkdZL0ptTVQ5bUp4QzFKTUx4a3dUajBSOUpTNlo4YzBiV2Y0dXppZXJ4TGtrKzhRRkgvd2tIb24vbTdoa3dYM2R0WmRyYjczYWRzWjZkMnBEV082c0QwM24xRnhYVVcrc3MvN1FXNk9PTjJXR0pnem5WdFc2MGpWck9sb3VYT214ZUJSYmNVeGt4MG15SUcvSkxqcUJSbEluclRtYTZpWGZTTzVpNXhCL010STVjcE50R09RcXlENUxXMUhIUzAzOUQrcHRNRHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFONEFBb0FBQUFBQStRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVU4wTDJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQzZBQUFBd0VwN2JsWm9aV0ZrQUFBQ0lBQUFBQzBBQUFBMktHMmtBR2hvWldFQUFBSlFBQUFBSHdBQUFDUUV5Z0lmYUcxMGVBQUFBbkFBQUFBS0FBQUFDZ1RrQUhSc2IyTmhBQUFDZkFBQUFBZ0FBQUFJQURBQVlHMWhlSEFBQUFLRUFBQUFGd0FBQUNBQUJRQWNibUZ0WlFBQUFwd0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURhQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1VbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBwcU1HZ3lNL3dIOHBraDBraHEvZ09GQWF0R0RHSUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkNqNXo4all3TXpBSU1YQXdDZ3VKc0xPeHMvSXhzNG1CbVR5TTZxcEE2RzVtajJqR1dNT0x6dTdveFc3SlROaldCb1hPMityS1IrM0toT1RMcDhaTXdNamt3Q2JTWTVBNGJIZW43R2NBa3lNU2JXS0NyWEpSYzJxVFVBakdUeUE1b2RBekJjR21pb3V4aTdDeHM3SHFHWnVZczlveDJpdXg2aXVabXBtSHROaUJqSlFVOGtzVDVxUm1UOGtocEc1MEkyVGtZMlpBV0phMUVLSHhHUW1MbVlXUVovM0M0ODh0ZUppNDJSaVlHQUFBTjdJSUhRQUFIamFZMkJrWUdBQTR1TnVzZDd4L0RaZkdaaFpHRURnc2VPR1JnVDluNUhwTWpPSXk4SEFCS0lBSFRNSjZnQUFBSGphWTJCa1lHQm0rTS9Bd01CMG1jR0R3Wk94Z1FFb2dnS1lBRWwwQXU0QUF0TUFBQUhKQUhRQVNBQUFBQUFBQUFBd0FHQjQybU5nWkdCZ1lHYVFaZ0RSREZBU0NRQUFBMXNBSWdCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVE1BQW9BQUFBQUJZZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFh4MHFtTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWZRQzdaMng1WmdBQUFXd0FBQUgrQUFBQ1VFcE9qTEJvWldGa0FBQURiQUFBQUM4QUFBQTJLR0NqLzJob1pXRUFBQU9jQUFBQUlBQUFBQ1FGcXdHYmFHMTBlQUFBQTd3QUFBQVFBQUFBRUFsOEFNeHNiMk5oQUFBRHpBQUFBQW9BQUFBS0FaSUF3bTFoZUhBQUFBUFlBQUFBR0FBQUFDQUFCd0JDYm1GdFpRQUFBL0FBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFd0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtaW1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb21NcVF4TS93SDhwa2gwa2hxL2dPRkFjK2NEUllBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLSmpHay9mOFA1Q2VDNlA4TC9zOEZxd0lDQUpnL0NUSUFBSGphUlpFL2I5TlFGTVY5M25OdHh4Uy9KSTZmYWRNNnFaLzduSmJHcFRqWXFGUk9rN2FSK2srMEFxbEt4WitKQWI1Q0Z6WTJKZ1pXTmtZV0J2WktiRWg4QWlUNERHVWo0YmtNM0x2ZGM0ZmZPVWNqV2pHOUl2dTQxTHJhdHFhaHdGM3VNK0xBYTNDL1FCOVpDOXh2R0taYUdUc3dFOFJaWG00QW1tZXhqS1ZocW5PQXZFQ2U0ZFBNWXJPQnVzZk5DblBid3JKMDJ6YmcxcHFaUDZ3Ris2czdaOUQ3ekQwNFgrNXRwR2g0cVQ4U2JnaXNCV0hQa25qRDNXcnQ1UGlKbHpoOEFXUXZiaG9neEo0WnRGT0taamZvQUUrUFhweTY5UkZGT1BueGJYWTUwa25uZ1hqZHpST1FscldncVNIYXp2UTNmcEt2V3FobHloTXR5Ymh2TUJnbHZ1eXJneFNoakF1a1NqQkx2Y0M5QkNKVVZ0U1g4ZzVuNUE4Nzk1OVJPbGc2R0E4ZUEwWTNzUTNDb2tvTllPYnVXb1M4cytmZVdzVHRZS3R3TEQyd1Zzakh5Uyt1ekR3YXZ6d1J1eFRqaDlYd3krZFYvNmF0Mjh3eWRUcjc1eHhiOFowTDBWdmZaY3k1Nk13bG13cFFPNXl1azFmayszVUR0TVJVaWY3ajR6NDNUTjVTdmZTcE1HVG1wOWV3cVdySmdWRHBaN2xjaDBNWTBvd2JNVDVzVnZYcWZHV3cwZGtFSWs5U3NCWmpMRnFpaXdrN0NvakxUcG5uOEtGWTJRSUVWM28xWUt4ZUQyeHIvbmtwNDkzazhxQzIzV3ZzVUNtQ05vbU0rRWFGUUQvMDNsK2QwZERFMmJnWnkrWG92NFE1Mlgycmh4WlU5SDhCbG5kVG1BQUFlTnBqWUdSZ1lBRGlOVXdQMk9QNWJiNHlNTE13Z01Canh3Mk5DUHEvUHRNeHBvdEFMZ2NERTBnVUFDSjFDcnNBZU5wallHUmdZR2I0ejhEQXdIU013ZTcvQmFZc0JxQUlDbUFCQUdhNkJFb0N4Z0FBQW5vQVBnSUNBRU1DT2dCTEFBQUFBQUJxQU1JQktBQUFlTnBqWUdSZ1lHQmhjR1JnWWdBQlJnWTBBQUFIUXdCS2VOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVMEFBb0FBQUFBQmh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwMG1OdFlYQUFBQUU0QUFBQU5RQUFBRVFBV2dEMloyeDVaZ0FBQVhBQUFBSlpBQUFDMEt5UWRoaG9aV0ZrQUFBRHpBQUFBQzhBQUFBMktLcWsyV2hvWldFQUFBUDhBQUFBSGdBQUFDUUdOZ0hUYUcxMGVBQUFCQndBQUFBVUFBQUFGQTAwQUpsc2IyTmhBQUFFTUFBQUFBd0FBQUFNQVhZQ0dHMWhlSEFBQUFROEFBQUFHQUFBQUNBQUNRQk1ibUZ0WlFBQUJGUUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZLQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1Xc0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpQQmtadmdQNURORHBKSFUvQWNLQXdEaGhBMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQXlBTkFjUWd1U2NHRndaUFAvL0I3SWNJYXovQi83dis3OGJyQllNQU9FV0Mwb0FBQUI0MmoyU3owc1VVUURIMy9lOW1mZmMzWmw1cTdNN296bk9zcTNPaUtiRy9uamJiclJTcVlXU1dFSjRrSW9naGFBT1lYck1nNVJKSFNJSU9uWHBWcGRPRVhUcTFEL1FNU0U2UllSSFQ3dmJHeW5mNmZGOTcvRDU4UDBTU29hN1hmcURmaWRUcEV4SUhhcGU5bnczNTFXVXg2Y2c0aWl1S3Q5VDlTa1VCYzk1dnZJZDZEeUpLeTNVSyt3ajd2Q2N6ZEh5SnZLd3pJM3RIaE4yeHEyeWxPaDBGKzNBdFJsc2MzM0ZncFU2MlhyOXU3aEpyMmVSa3UxdFQ3SWhBY1pBZTZRQUxIOXRkaWMzbkFXVkRrL2l0T1FvZmNVMW9nOGo0OTAyNC9RekNja1lPYU5KM1dvcDVwcXRHQ0x2UUlUd3VRUVhSWDdFNnlad0tvcExFUmZzLzUzcEQ1VzN6d2ZqSVNteHNucWJiUzh2TElOZXlsNTUySGtaT0U0emZQUHE1Z2JGNU1XZGdtdmVmN2E2U2VucHkxL21ETUJab28xZXlnSUJlclU1dnk3VGk0MkZDMDdMU0F6Z1lwWTltQnVlb1pBRDdYZHNhM0ZraVhWKzl2RTBJU0N4NXM3U1QyU2VrQkhob1BRUHNPNU9ZeEpIQXNxVHlFWFR0S1lpb1hrbEt2cFplYjdnVWExYVYvRXh1bCtlMXYyb2NnSDAydzNEeXJiL0RFa05iVDdSZ0NNTm1hVm1uOFZ5QVdEUTg2c3Z0TUs1V3pNMW0vazRhL1N6bEtadnJjMG1MdSszbEN5UElVOXhzRytaTE9SYUlhUmhyN0NGb1EyUmNqOEVSdG9OVHJScVFIYmdFQk1ORjVrRGo2VU5NUzdjUVhSK2FUbE1PdXB1eHVEYXNkVHRvcTI3R2RYQ1RQQUMxTkZJanNmanFyZ2FDZDVDQVhYZjgzTThqamdlUFRWWWNLcEliYkgzT0dWQzlqVUx4aDVEVkF4Zzg5MWRIVGx1czBEdnRmZjdKYVVKNWZGVThnRWR6Wmg2SGtraFNaclNpMEdla0w4MWxHOTVBQUFBZU5wallHUmdZQURpeWJ0eW5lUDViYjR5TUxNd2dNQmp4dzJOQ1ByL1gyWUJwcnRBTGdjREUwZ1VBRGdGQzBnQWVOcGpZR1JnWUdiNHp3QWtPUmlVL3g5bEZtQUFpcUFBVmdCS1dRTVBBQUFDZGdBQUF3QUFKQU1JQUNzQzlBQW5BY0lBSXdBQUFBQUFWQUN3QVNJQmFIamFZMkJrWUdCZ1pmQm1ZR1lBQVVZR05BQUFDRzhBVm5qYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjk3OTE2LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5FPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUzLjE1NTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYzLjc0NjI1NywtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02My43NDYyNTcnIHk9Jy02MC40NDc1MDEnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTA5Ljc2NzYxLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU0LjMxNTIzLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYzLjc0NjI1NycgeT0nLTYwLjQ0NzUwMSc+STwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC41MzQ3IDBINDguMDk5OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMzQ5OTYsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNi4zOTg1LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5hPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J002NS4yMTEwNCAwSDEwMS40Mzk5NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxMDEuMzE0OTQsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdtaXRlcic+CiA8cGF0aCBkPSdNMy4zOTcxMyAwTC4yNSAxLjg3NDk0VjBWLTEuODc0OTRaJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoODIuODY5NSw0LjE3MjkxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjMuNzQ2MjU3LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYzLjc0NjI1NycgeT0nLTYwLjQ0NzUwMSc+ZjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNi40MDQ1NC02LjQwOTczTDQ3LjA5MjM5LTQ3LjA5NjYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxLC0wLjcwNzA5LDAuNzA3MDksMC43MDcxLDQ3LjAwNDAxLC00Ny4wMDgyMiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lam9pbj0nbWl0ZXInPgogPHBhdGggZD0nTTMuMzk3MTMgMEwuMjUgMS44NzQ5NFYwVi0xLjg3NDk0WicgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgo8L2c+CjxwYXRoIGQ9J002NS42MDY5LTQ4LjIwODc2TDEwNy4wNTE0NS02Ljc2MzI4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjcwNzA5LC0wLjcwNzEsMC43MDcxLC0wLjcwNzA5LDY1Ljc4MzY4LC00OC4wMzE5OCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcwOSwwLjcwNzEsLTAuNzA3MSwwLjcwNzA5LDEwNy4yMjgyMywtNi41ODY1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OC45OTIwMywtMzYuMTQ4ODgpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02My43NDYyNTcsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNjMuNzQ2MjU3JyB5PSctNjAuNDQ3NTAxJz5JbWc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUxLjk5NTkxOCcgeT0nLTYwLjQ0NzUwMSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDguODgyNTc1JyB5PSctNjAuNDQ3NTAxJz5iPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy00NS4zNzkwMzcnIHk9Jy02MC40NDc1MDEnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$E$};
      \node  (2) [right = of 1] {$A$};
      \node  (3) [right = of 2] {$B$};
      \node  (4) [below = of 2] {$I$};
      \draw  [->,morphism] (1) to node {$a$} (2);
      \draw  [cover,morphism] (2) to node {$f$} (3);
      \draw  [cover,morphism] (1) to (4);
      \draw  [>->,morphism] (4) to node[swap] {$\mathsf {Img}(b)$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Since <fr:tex
display="inline"><![CDATA[a]]></fr:tex> is an isomorphism, it follows that the image of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is isomorphic to <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex>.
    Thus, <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex> is an isomorphism.</fr:p>
  <fr:p>Assume the converse.
    Then the identity morphism factors through <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex>, i.e., <fr:tex
display="inline"><![CDATA[\mathsf {Img}(b)]]></fr:tex> is an isomorphism.
    Thus, it follows that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is a cover.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1446</fr:anchor><fr:addr
type="user">log-000U</fr:addr><fr:route>log-000U.xml</fr:route><fr:title
text="Composite morphisms in the internal language of a category">Composite morphisms in the <fr:link
type="local"
href="log-000P.xml"
addr="log-000P"
title="Internal language of a category">internal language</fr:link> of a category</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>.
  <fr:tex
display="inline"><![CDATA[f\colon A\to C]]></fr:tex> is the composite of <fr:tex
display="inline"><![CDATA[g\colon A\to B]]></fr:tex> and <fr:tex
display="inline"><![CDATA[h\colon B\to C]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> satisfies <fr:tex
display="inline"><![CDATA[x\colon A|\top  \vdash  f(x) = h(g(x))]]></fr:tex> in its <fr:link
type="local"
href="log-000P.xml"
addr="log-000P"
title="Internal language of a category">internal language</fr:link>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1006</fr:anchor><fr:addr
type="machine">#297</fr:addr><fr:route>unstable-297.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Suppose that <fr:tex
display="inline"><![CDATA[f = hg]]></fr:tex>.
    Then <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket h(g(x))\rrbracket \mathclose {}}_{\mathcal {C}} = {\mathopen {}\llbracket h\rrbracket \mathclose {}}_{\mathcal {C}} \circ  {\mathopen {}\llbracket g\rrbracket \mathclose {}}_{\mathcal {C}} \circ  \mathsf {id}_{A} = hg]]></fr:tex> and <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket f(x)\rrbracket \mathclose {}}_{\mathcal {C}} = {\mathopen {}\llbracket f\rrbracket \mathclose {}}_{\mathcal {C}} \circ  \mathsf {id}_{A} = f]]></fr:tex>.
    Thus, the equalizer of <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket f(x)\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket h(g(x))\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> is the terminal object, and the result follows immediately.</fr:p>
  <fr:p>Suppose the converse.
    Then the identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A}]]></fr:tex> equalizes <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket f(x)\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket h(g(x))\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex>.
    Thus, it follows that <fr:tex
display="inline"><![CDATA[f = hg]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1447</fr:anchor><fr:addr
type="user">log-000V</fr:addr><fr:route>log-000V.xml</fr:route><fr:title
text="Monomorphisms in the internal language of a category">Monomorphisms in the <fr:link
type="local"
href="log-000P.xml"
addr="log-000P"
title="Internal language of a category">internal language</fr:link> of a category</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>.
  <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> is a monomorphism iff <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> satisfies <fr:tex
display="inline"><![CDATA[x,x'\colon A|f(x) = f(x') \vdash  x = x']]></fr:tex> in its <fr:link
type="local"
href="log-000P.xml"
addr="log-000P"
title="Internal language of a category">internal language</fr:link>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1003</fr:anchor><fr:addr
type="machine">#296</fr:addr><fr:route>unstable-296.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>8</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Suppose that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is monic.
    Let <fr:tex
display="inline"><![CDATA[e\colon E\rightarrowtail A \times  A]]></fr:tex> be the equalizer of <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket f(x)\rrbracket \mathclose {}}_{\mathcal {C}} = f\pi _{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket f(x')\rrbracket \mathclose {}}_{\mathcal {C}} = f\pi _{2}]]></fr:tex>.
    Then it follows that <fr:tex
display="inline"><![CDATA[f\pi _{1}e = f\pi _{2}e]]></fr:tex>.
    Since <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is monic, <fr:tex
display="inline"><![CDATA[\pi _{1}e = \pi _{2}e]]></fr:tex>.
    Then it follows that <fr:tex
display="inline"><![CDATA[e]]></fr:tex> factors through <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket x = x'\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="2401cd6b79c0d16c06449d0fe4dd9e3c"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5NC40OTc1MDlwdCcgaGVpZ2h0PScxMTMuNjc3NzYzcHQnIHZpZXdCb3g9Jy03MiAtNzIgMTI5LjY2NTAwNiA3NS43ODUxNzYnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1JQUFvQUFBQUFBMndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVVBQUFCZ3AyQ1hOV050WVhBQUFBRThBQUFBS2dBQUFEUUFEQ0paWjJ4NVpnQUFBV2dBQUFCTUFBQUFURU4yaUt0b1pXRmtBQUFCdEFBQUFDOEFBQUEyS1IyazJXaG9aV0VBQUFIa0FBQUFIZ0FBQUNRR3dRTUNhRzEwZUFBQUFnUUFBQUFJQUFBQUNBYVVBRHhzYjJOaEFBQUNEQUFBQUFZQUFBQUdBQ1lBQUcxaGVIQUFBQUlVQUFBQUZnQUFBQ0FBQlFBVWJtRnRaUUFBQWl3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBQytBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTltS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhvQUFIR0NPbHVDeWRnVTBKQ0prWi9nUDV6QXlNSUdGR2hOTC9RR0VBeGowTXlnQUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdVZ0RRTEVBTDVTbXovLzBQSXU3L0I4Z3dBVUt3R2hBQUFBQUlBUFAvOUE0TUMzUUFQQUJJQUFBa0JGaU1VSnlFR05TSTNBVFlYTWhZSEFTRUNBUUY1Q1FJWi9POFpBZ29CZVE0U0R3dzkvdE1DV2dMRC9WWVBEUU1ERFE4Q3JoWURDbHI5M25qYVkyQmtZR0FBNG83cUJlSHgvRFpmR1poWkdFRGdzZU9HUmdUOS95OXpNOU5kSUplRGdRa2tDZ0E4N3d1NEFIamFZMkJrWUdCbStNOEFKQTh5MkREWU1UY3pBRVZRQUJNQVJqSUN5d0FBQXRNQUFBUEJBRHdBQUFBQUFDWUFBSGphWTJCa1lHQmdZaEFHWWhCZ1pFQURBQUtQQUJvQUFIamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU2grNHVEazR1VHE4elpvZ0hacEtXb3N1NGsvM05nUnY0UERkYzg0TmtQRWlZWmlFZWRCaFVubnp5R04rV0VTZWlMK0tuUEhMbWhGSk9oTm54UzV5eXBUL3lHT1dsSkVuNGo4aVovengzamYxN2Q1WnI0Nk5zZDVkYXI4OVdkOVdqVk1iblEvcndUcnJ6NTAxcW53cTAxZHRmNjFWb1hOZHNLZWg1c2FkRG90SGNSVEhCSFpjSlBOc09ZVzlwWkxNU1dlREp2K21CMGxkYUp6REwwWWFKVTlSUXk4M3JlaFZ1b29pM0dtS0QxaXNMa3NBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT3dBQW9BQUFBQUJCZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFV4MUFtTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ0ZaMng1WmdBQUFXUUFBQUQwQUFBQTlOdSsrWkpvWldGa0FBQUNXQUFBQUMwQUFBQTJLT3VrcW1ob1pXRUFBQUtJQUFBQUhnQUFBQ1FGdWdLeWFHMTBlQUFBQXFnQUFBQUtBQUFBQ2dabkFKSnNiMk5oQUFBQ3RBQUFBQWdBQUFBSUFESUFlbTFoZUhBQUFBSzhBQUFBRndBQUFDQUFCUUF0Ym1GdFpRQUFBdFFBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEb0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtZXMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUTBaREJpWnZnUDVETkRwSkhVL0FjS0F3RDJ4QTArZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhHLy84RFNjUC8vLzlmQVBNWkFGRllCbzRBQVFDU0FBQUNOd0tyQUI0QUFBRVJCaFk3QVJVbUp5TUdCelV6TWpZbkVRNEJKeU0xTXhZL0FUWTNOaFlCbUFRaVRqTXNPdEU2TEROT0lRTXVWQk1TRWhJK0J6ODVHQTRDaS8zTkZ4UXRBd0VCQXkwVUZ3SUFFZ3dCTFFJS0Fnb3VBUWtBQUFFQVhRQUFBbHNDcWdBckFBQWxCeUUxTkQ4Q1BnRTNMZ0VuSWdZSEhnRVhEZ0VqQmlZblBnRTNNaFlYRGdFSEJnOEJKVFkzUGdFM0Fsc2kvaVFEQ2ZvOVRRRUNhRTAwVWhZWUlRRUJKaFVPTEFJQ2hHcHdtd01DYUVndk5Xa0JBaW9LRFE4Q3hzWWZCUUlKMURGcVAweFRBU29qQWg4YklCMEJHU2ROWlFKcFkxQnBMaUFuVGdFQkJBdEJFZ0FBZU5wallHUmdZQURpUmFjZHl1UDViYjR5TUxNd2dNQmp4dzJOeURSekVOTnFJTVhCd0FUaUFRQWhKUW1EQUFBQWVOcGpZR1JnWUdiNHp3QWtneGhpR1dLWm9obUFJaWlBQ1FBOTBRSnpBQUFEVWdBQUFyZ0FrZ0JkQUFBQUFBQUFBRElBZW5qYVkyQmtZR0JnWnRCaEFORU1VQklKQUFBRkJBQXpBSGphUFl3eHE4SXdGSVcvWWhYdEd4d0VoemRJOEFlRVNwK2JtNE9UcThQYnJBblNvYW1rdGVnaS9uUnZRL0FHRHQ4OTU5d0FHUzhTaGttWUJ4MG1sVGVQUE9hSFJlU0orS3ZJR2Irc0daR2tNM0ZXN0NLblRQbVBQR1pKR1hraS9pTnl4aC92ZlZQZjdwMzE2dGdZNjkybDl0dVQ5VzNWT0xYUitiQWVyTFArM0ZtanlxY3lmZFgyMTFvVk90Y0ZleHBxYnR6cHNIZ1VSM0ZNWU1kRk1zK1dVOWhiS3NtY2REWm84bTk2a05TRnhqbjhZcVJSOGhRMTlITFRpbDZscXlqQ25hYjRBRlV5TGtNQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRSUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoZ0I0TG1OdFlYQUFBQUU4QUFBQU1RQUFBRHdITFAxbloyeDVaZ0FBQVhBQUFBRStBQUFCWU5DWDN5aG9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktHQ2p1R2hvWldFQUFBTGdBQUFBSUFBQUFDUUZ3d0hqYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWVkQUhOc2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZZQXNHMWhlSEFBQUFNVUFBQUFHQUFBQUNBQUJnQTRibUZ0WlFBQUF5d0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUQvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm02bVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBxbU1oOWdadmdQNURNek1JS0VHUkVxL2dPRkFRTjFEaUVBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeXFZeUgvai9IOGdIMC8vbi9IRUNxd0lDQUtNbENaRUFBQUI0MmlXUHNVNkRVQUJGMzMybGowQXBJUEtnTklLdFdHaFRVNW9TZUNhMTBLR05icHBvWW5Ud0V4eE1aNlArZ2ovZ2R6ajdLdzd1NnVKUXFXN241QTczWGtMSmN2Mk5IN3lSaU9TRWlKQVpDSkE2SlhLUkIrQzJBU2FQa0ZVbThuVGl1QTZUbVJ5bnpzYkZDR0ZVS1h1Zks2RElFM05temFkcXN6RnBGNnZyRyttRXQ4NHZ4REVRSGg2TUh5ZitVVzh2azVDRVRxbzNzNDgrRDRxQ2FuVnozb0RHOUlIWmwranQyZDNDTnJMeHNEWGp1dVNCMVhWYkJKMmFMYXNkQWpKYWY5Rm52RzZXUXRhcjhxeEVBUkZHMVlZRVVWeHhBYmViTzI2Vnh2OWZYS2RpbVVYeFg0eWkzQXFDL1pyZFdyUkw2M1JRMTFVR09uUzZXWUFuWXdjMXlmVWVWRXJCVFFYd3JTYlhHb0NuWWZXNVhFcStFWTlmTHFtYmF0VmRSWm5hSFE0bzNGQXNLbmFUOHNyWFZOc0R0bnVkYVhtZkVFSitBVFBlTUVzQUFIamFZMkJrWUdBQTR1a0N6bzd4L0RaZkdaaFpHRURnc2VPR1JnVDkveXZUTWNZalFDNEhBeE5JRkFBYTVnc0pBSGphWTJCa1lHQm0rTS9Bd01CMGpFR1BRWkpwTWdOUUJBVXdBd0JEWndLc0FzWUFBQUlyQUVVQ3JBQXVBQUFBQUFCV0FMQjQybU5nWkdCZ1lHWXdaMkJpQUFGR0JqUUFBQVl1QUQ5NDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU04QUFvQUFBQUFBNlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ2lPUnpHMk50WVhBQUFBRkFBQUFBS1FBQUFEUUFEQUVxWjJ4NVpnQUFBV3dBQUFCNEFBQUFlSk1TUEpGb1pXRmtBQUFCNUFBQUFDd0FBQUEyS0xXajkyaG9aV0VBQUFJUUFBQUFIZ0FBQUNRR05mL2RhRzEwZUFBQUFqQUFBQUFHQUFBQUJnT3dBQUJzYjJOaEFBQUNPQUFBQUFZQUFBQUdBRHdBQUcxaGVIQUFBQUpBQUFBQUZ3QUFBQ0FBQkFBa2JtRnRaUUFBQWxnQUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRExBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWxtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVUQXhKSUtTNUxCMHBlWjdqT0xQVkhrNEdCV1lyNU9sQ1lFYUhpLzM4R0JnRHJuUTd2QUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeENDK05mLy80ZVEvN1hBZkFZQVh1VUhNd0FBQUFBQkFKUUFDUUtHQWZnQUlnQUFBVGMyRnhZWEJnOENId0VXQndZSEppOEJCdzRCSXlZbkpqOEJKeVkzTmpjeUZ3R095dzRLRXdFQ0F4cTdwVElFQVFFVEN3WFV5d2tJQmhFREF4RE56UkFEQXhFR0JBRWR5aEVCQWhNS0F4cTdwVElJQXhNQ0FnVFV5d29GQWhNSERjN09EUWNUQWdJQUFIamFZMkJrWUdBQTRwWHBUUEx4L0RaZkdaaFpHRURnc2VPR1JtU2FXWWJ4QjVEaVlHQUM4UUQzMlFpbWVOcGpZR1JnWUpiNm93a2taUmltTUV4amFtTUFpcUFBUmdCTXlnTVhBQUFESEFBQUFKUUFBQUFBQUFBQVBBQUFlTnBqWUdSZ1lHQmlVR1lBMFF4UUVna0FBQVFJQUNrQWVOcE5qckZxd3pBUWhqOVR4MUFua0trZE9oUk5HWVdOOHdDRkRKbXlaaXdra1FnT1dBNlNZL0JTOGdCOTZGNFVEVDNCOGVtLzc0U0FraDh5SHBXeGpQMVJPWVhjbmp4anpsdmlRbzVLWFBMQmloZXkvRldTVDc0UzV5ejRUanpqblV2aVF2Sjc0cEkxdjV1K3U5NEc2OVd1TjlhN1V4ZW11dHBiSDlyZXFWcFh6MkJybmZXSHdScDFuSlFaMnpDZU85WG9TamRzNk9tNGNtUEE0dVZuTzBsTVpNZEpab0dKbW9wOXpBS3R6SjE0TlZyUy84WldEQmV0UTN6TmlIV1VtUklhWlM5SVA0dXZhT0t1cHZrRENWRXhFd0I0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVEwQUFvQUFBQUFCTVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDArR050WVhBQUFBRTRBQUFBTVFBQUFEd0FXd0NhWjJ4NVpnQUFBV3dBQUFGc0FBQUJqQ2RCaWYxb1pXRmtBQUFDMkFBQUFDOEFBQUEyS0txazJXaG9aV0VBQUFNSUFBQUFIUUFBQUNRR053SG9hRzEwZUFBQUF5Z0FBQUFNQUFBQURBaHFBRXRzYjJOaEFBQUROQUFBQUFnQUFBQUlBRlFBeG0xaGVIQUFBQU04QUFBQUdBQUFBQ0FBQmdCTWJtRnRaUUFBQTFRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRUtBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbU9zYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCbFp2Z1A1RE5EcEpIVS9BY0tBd0R3VWcxRWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS09qSzQvdjhQNUlQcC93Zis3d1dyQWdJQWtJQUk3d0FBQUhqYUpZOHhUOXRBQUlYdjNkbDNjV0w3M0p3NUYrb0VoUVJiQWtFa096a3JyWENFMUN3ZE9qQ2dEbFhWaFNBeFYrM0tnTVRNeUgvbzBnbnhEL2dEakNBeElvUVltWkxncUc5Nit0NGIzaU9VOUJZTCtrRHZTSjlraEJRd1JhWWpGZXJjYU42SFNKTjBZQ0p0aWo0NmdvYzZNcEdQaWk5eFhxTEkyUldPZU9oeGxIcG5CYTc5NjdSbXcydW9BWFBFZlBIVmk1WEg0Tm5IMzF5NHprWjUrZFQ1VFE4RE9ISjJxaVZyQ1RBR1dwTUNjS1BwNUN6c0JhRFM1MHRjbHh6ZEd4eVFTaURwWXNZQ2VrMitFTElwZkhRNy9QOHdOY1l1bHI1anRFU1lqT25RSktLYmNJbThpbzJPQkUrR2c4S2tKa203VElMblVUYXVmcHBzSGZUMmgrVUdzK2VXOUQrMjdYTUwyQnpKZ05wTmw0VXhZTkg5N3hmcnl0NzcrWG5vc1FpZnJQZk1vU3d1cDVPcTZ2LzlZMlMyaFJXS2wzdlhabTBPcURadHZ4T2VzT0xxa2FQK3hWWmR4V3ZsRUFoV1g3RXpVbWk4YUZhM3hMWlFIekIvYlBJNmRuMXowckQ0R3pmTk84UjQybU5nWkdCZ0FPSlZSc0d6NC9sdHZqSXdzekNBd0dQSERZMEkrdjlmWmdHbXUwQXVCd01UU0JRQUxvOExGUUI0Mm1OZ1pHQmdadmpQQUNJWlZQNC9ZUlpnQUlxZ0FHWUFUREVESlFBQUFBSjJBQUFEQUFBa0F2UUFKd0FBQUFBQVZBREdlTnBqWUdSZ1lHQm04R1pnWWdBQlJnWTBBQUFJSWdCVGVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5MTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03LjA1MzM1MywtNTkuMDQ0NDUyKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEzLjYxMTA4LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC03LjA1MzM1MywtNTkuMDQ0NDUyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy03LjA1MzM1MycgeT0nLTU5LjA0NDQ1Mic+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PScyLjYzMjUxMicgeT0nLTU5LjA0NDQ1Mic+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTIuNTk1MTI1JyB5PSctNTkuMDQ0NDUyJz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUzLjE1NTUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTcuMDUzMzUzLC01OS4wNDQ0NTIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTcuMDUzMzUzJyB5PSctNTkuMDQ0NDUyJz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02MC42NTU1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC03LjA1MzM1MywtNTkuMDQ0NDUyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy03LjA1MzM1MycgeT0nLTU5LjA0NDQ1Mic+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNjAuODg0NjYsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC03LjA1MzM1MywtNTkuMDQ0NDUyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy03LjA1MzM1MycgeT0nLTU5LjA0NDQ1Mic+RTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTguMTY2NjMgMy42MTY2Mkg0OC4wOTk5NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4zNDk5NiwzLjYxNjYyKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyOS4wOTM3Miw3LjQyODQ0KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNy4wNTMzNTMsLTU5LjA0NDQ1MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNy4wNTMzNTMnIHk9Jy01OS4wNDQ0NTInPs+APC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0yLjM5NDUwOScgeT0nLTU4LjA0ODE4OCc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTguMTY2NjMtMy42MTY2Mkg0OC4wOTk5NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4zNDk5NiwtMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjkuMDkzNzIsLTkuNDQyMzIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC03LjA1MzM1MywtNTkuMDQ0NDUyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy03LjA1MzM1MycgeT0nLTU5LjA0NDQ1Mic+z4A8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTIuMzk0NTA5JyB5PSctNTguMDQ4MTg4Jz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDYuMzk5OTYgMEgtMTguNjY2NjMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsLTQ2LjE0OTk2LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE4LjQxNjYzLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTM2LjY2ODAzLDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC03LjA1MzM1MywtNTkuMDQ0NDUyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy03LjA1MzM1MycgeT0nLTU5LjA0NDQ1Mic+4oiGPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDcuMTEwMDItNDcuMTA3TC03LjU5MjQtNy41OTY1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMC43MDcxNSwtMC43MDcwMywwLjcwNzAzLC0wLjcwNzE1LC00Ni45MzMyMywtNDYuOTMwMjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTUsMC43MDcwMywtMC43MDcwMywwLjcwNzE1LC03LjQxNTYyLC03LjQxOTgpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yNC42ODg0LC0zMy43Nzg0NiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTcuMDUzMzUzLC01OS4wNDQ0NTIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTcuMDUzMzUzJyB5PSctNTkuMDQ0NDUyJz5lPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzMuMCwyLjAnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNLTU2LjkwNTUtNDguNjYyNDZWLTYuOTA5NzMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwtNTYuOTA1NSwtNi42NTk3MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$A \times  A$};
      \node  (2) [right = of 1] {$A$};
      \node  (3) [left = of 1] {$A$};
      \node  (4) [below = of 3] {$E$};
      \draw  [->,morphism,offset=-1.5] (1) to node {$\pi _{1}$} (2);
      \draw  [->,morphism,offset=1.5] (1) to node[swap] {$\pi _{2}$} (2);
      \draw  [>->,morphism] (3) to node {$\Delta $} (1);
      \draw  [>->,morphism] (4) to node[swap] {$e$} (1);
      \draw  [->,morphism,exists] (4) to (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Assume the converse.
    Suppose that <fr:tex
display="inline"><![CDATA[fu = fv]]></fr:tex> for some parallel pair of morphisms <fr:tex
display="inline"><![CDATA[u,v\colon C\rightrightarrows A]]></fr:tex>.
    Then it follows that <fr:tex
display="inline"><![CDATA[(u,v)]]></fr:tex> factors through <fr:tex
display="inline"><![CDATA[e]]></fr:tex>.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="4ba2b50d858cf45d1a327497867a03df"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIwMC44NjM0MTJwdCcgaGVpZ2h0PScxMTYuOTc3ODUzcHQnIHZpZXdCb3g9Jy03MiAtNzIgMTMzLjkwODk0MSA3Ny45ODUyMzUnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU40QUFvQUFBQUFBK1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVTjBMMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDNkFBQUF3RXA3Ymxab1pXRmtBQUFDSUFBQUFDNEFBQUEyS0cya1BtaG9aV0VBQUFKUUFBQUFId0FBQUNRRXlnSWZhRzEwZUFBQUFuQUFBQUFLQUFBQUNnVGtBSFJzYjJOaEFBQUNmQUFBQUFnQUFBQUlBREFBWUcxaGVIQUFBQUtFQUFBQUZ3QUFBQ0FBQlFBY2JtRnRaUUFBQXB3QUFBREtBQUFCTXUwS2tlcHdiM04wQUFBRGFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVVtU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHBxTUdneU0vd0g4cGtoMGtocS9nT0ZBYXRHREdJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaQ2o1ejhqWXdNekFJTVhBd0NndUpzTE94cy9JeHM0bUJtVHlNNnFwQTZHNW1qMmpHV01PTHp1N294VzdKVE5qV0JvWE8yK3JLUiszS2hPVExwOFpNd01qa3dDYlNZNUE0YkhlbjdHY0FreU1TYldLQ3JYSlJjMnFUVUFqR1R5QTVvZEF6QmNHbWlvdXhpN0N4czdIcUdadVlzOW94Mml1eDZpdVptcG1IdE5pQmpKUVU4a3NUNXFSbVQ4a2hwRzUwSTJUa1kyWkFXSmExRUtIeEdRbUxtWVdRWi8zQzQ4OHRlSmk0MlJpWUdBQUFON0lJSFFBQUhqYVkyQmtZR0FBNHVOdU1lZmorVzIrTWpDek1JREFZOGNOQ3hEMGYwYW15OHdnTGdjREU0Z0NBRGpGQ3FzQUFIamFZMkJrWUdCbStNL0F3TUIwbWNHRHdaT3hnUUVvZ2dLWUFFbDBBdTRBQXRNQUFBSEpBSFFBU0FBQUFBQUFBQUF3QUdCNDJtTmdaR0JnWUdhUVpnRFJERkFTQ1FBQUExc0FJZ0I0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU93QUFvQUFBQUFCQmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVeDFBbU50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNGWjJ4NVpnQUFBV1FBQUFEMEFBQUE5TnUrK1pKb1pXRmtBQUFDV0FBQUFDMEFBQUEyS091azZHaG9aV0VBQUFLSUFBQUFIZ0FBQUNRRnVnS3lhRzEwZUFBQUFxZ0FBQUFLQUFBQUNnWm5BSkpzYjJOaEFBQUN0QUFBQUFnQUFBQUlBRElBZW0xaGVIQUFBQUs4QUFBQUZ3QUFBQ0FBQlFBdGJtRnRaUUFBQXRRQUFBREtBQUFCTXVzSWtlWndiM04wQUFBRG9BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWVzMDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFEwWkRCaVp2Z1A1RE5EcEpIVS9BY0tBd0QyeEEwK2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoRy8vOERTY1AvLy85ZkFQTVpBRkZZQm80QUFRQ1NBQUFDTndLckFCNEFBQUVSQmhZN0FSVW1KeU1HQnpVek1qWW5FUTRCSnlNMU14WS9BVFkzTmhZQm1BUWlUak1zT3RFNkxETk9JUU11VkJNU0VoSStCejg1R0E0Q2kvM05GeFF0QXdFQkF5MFVGd0lBRWd3QkxRSUtBZ291QVFrQUFBRUFYUUFBQWxzQ3FnQXJBQUFsQnlFMU5EOENQZ0UzTGdFbklnWUhIZ0VYRGdFakJpWW5QZ0UzTWhZWERnRUhCZzhCSlRZM1BnRTNBbHNpL2lRRENmbzlUUUVDYUUwMFVoWVlJUUVCSmhVT0xBSUNoR3B3bXdNQ2FFZ3ZOV2tCQWlvS0RROEN4c1lmQlFJSjFERnFQMHhUQVNvakFoOGJJQjBCR1NkTlpRSnBZMUJwTGlBblRnRUJCQXRCRWdBQWVOcGpZR1JnWUFEaVJhZnRmOGZ6MjN4bFlHWmhBSUhIamhzV0lOUE1RVXlyZ1JRSEF4T0lCd0E4dHdwRUFBQUFlTnBqWUdSZ1lHYjR6d0FrZ3hoaUdXS1pvaG1BSWlpQUNRQTkwUUp6QUFBRFVnQUFBcmdBa2dCZEFBQUFBQUFBQURJQWVuamFZMkJrWUdCZ1p0QmhBTkVNVUJJSkFBQUZCQUF6QUhqYVBZd3hxOEl3RklXL1loWHRHeHdFaHpkSThBZUVTcCtibTRPVHE4UGJyQW5Tb2Fta3RlZ2kvblJ2US9BR0R0ODk1OXdBR1M4U2hrbVlCeDBtbFRlUFBPYUhSZVNKK0t2SUdiK3NHWkdrTTNGVzdDS25UUG1QUEdaSkdYa2kvaU55eGgvdmZWUGY3cDMxNnRnWTY5Mmw5dHVUOVczVk9MWFIrYkFlckxQKzNGbWp5cWN5ZmRYMjExb1ZPdGNGZXhwcWJ0enBzSGdVUjNGTVlNZEZNcytXVTloYktzbWNkRFpvOG05NmtOU0Z4am44WXFSUjhoUTE5SExUaWw2bHF5akNuYWI0QUZVeUxrTUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5BQUFvQUFBQUFBNlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ2lPUnpHMk50WVhBQUFBRkFBQUFBS1FBQUFEUUFEQUVxWjJ4NVpnQUFBV3dBQUFCNEFBQUFlSk1TUEpGb1pXRmtBQUFCNUFBQUFDMEFBQUEyS0xXa05XaG9aV0VBQUFJVUFBQUFIZ0FBQUNRR05mL2RhRzEwZUFBQUFqUUFBQUFHQUFBQUJnT3dBQUJzYjJOaEFBQUNQQUFBQUFZQUFBQUdBRHdBQUcxaGVIQUFBQUpFQUFBQUZ3QUFBQ0FBQkFBa2JtRnRaUUFBQWx3QUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRE1BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWxtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVUQXhKSUtTNUxCMHBlWjdqT0xQVkhrNEdCV1lyNU9sQ1lFYUhpLzM4R0JnRHJuUTd2QUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeENDK05mLy80ZVEvN1hBZkFZQVh1VUhNd0FBQUFBQkFKUUFDUUtHQWZnQUlnQUFBVGMyRnhZWEJnOENId0VXQndZSEppOEJCdzRCSXlZbkpqOEJKeVkzTmpjeUZ3R095dzRLRXdFQ0F4cTdwVElFQVFFVEN3WFV5d2tJQmhFREF4RE56UkFEQXhFR0JBRWR5aEVCQWhNS0F4cTdwVElJQXhNQ0FnVFV5d29GQWhNSERjN09EUWNUQWdJQUFIamFZMkJrWUdBQTRwWHBqSXZqK1cyK01qQ3pNSURBWThjTkM1QnBaaG5HSDBDS2c0RUp4QU1BRTNvSlp3QUFBSGphWTJCa1lHQ1crcU1KSkdVWXBqQk1ZMnBqQUlxZ0FFWUFUTW9ERndBQUF4d0FBQUNVQUFBQUFBQUFBRHdBQUhqYVkyQmtZR0JnWWxCbUFORU1VQklKQUFBRUNBQXBBSGphVFk2eGFzTXdFSVkvVThkUUo1Q3BIVG9VVFJtRmpmTUFoUXlac21Zc0pKRUlEbGdPa21Qd1V2SUFmZWhlRkEwOXdmSHB2KytFZ0pJZk1oNlZzWXo5VVRtRjNKNDhZODViNGtLT1Nsenl3WW9Yc3Z4VmtrKytFdWNzK0U0ODQ1MUw0a0x5ZStLU05iK2J2cnZlQnV2VnJqZld1MU1YcHJyYVd4L2EzcWxhVjg5Z2E1MzFoOEVhZFp5VUdkc3duanZWNkVvM2JPanB1SEpqd09MbFp6dEpUR1RIU1dhQmlacUtmY3dDcmN5ZGVEVmEwdi9HVmd3WHJVTjh6WWgxbEprU0dtVXZTRCtMcjJqaXJxYjVBd2xSTVJNQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFia0FBb0FBQUFBQ0pnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY2Q0RkdOdFlYQUFBQUU4QUFBQVFBQUFBRXdIeFAyWVoyeDVaZ0FBQVh3QUFBUHdBQUFGT0QyelY4NW9aV0ZrQUFBRmJBQUFBQzhBQUFBMktMbWtQV2hvWldFQUFBV2NBQUFBSGdBQUFDUUdVQUluYUcxMGVBQUFCYndBQUFBZ0FBQUFJQk44QWNGc2IyTmhBQUFGM0FBQUFCSUFBQUFTQldZRUhtMWhlSEFBQUFYd0FBQUFHQUFBQUNBQUN3QlpibUZ0WlFBQUJnZ0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUcyQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm15bWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBycU1COWdadmdQNURNek1JS0VHUkVxL2dPRkFmTU5EYzRBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1Jnc2dEUVhBd2RRam9sQmh5R05vWno1d1AvL1FERWRobFNHVWhENy85WC9jLy8zLzNFSDY0QUNBR000RGxkNDJuMlV5NC9iVkJqRmZhNWZTZXpZVHVKSGtrbHN4MDdzaE5BNFQzdG1rckZUT3NOVW5VRXRMVEFxQWtaaWdWUVdMT2lvUzhSanhZWU5MQkFyMkxCbnk3b1NheFpJL0FNczJIZllJSFc0VGxvaEZRbnZQbi8yZDMvbm5Ic3ZBK2JoMVQ1enlUeGlUSVpKUkVFY1lSNG5OZ3hCaFNBR1laeWsrRjJXYWkzSGJYYTdYSy9ZVXlVV3dzelJDaUxRbVhhQWRISzJLRTlCeWlJL09XZm9RNWlqcTcvd054NHpBUlBUcVQ2ZFpXTm1ab2lUbUk3Vzg5RWpMR2lWeExPcGFaa0NYVGljbVhtZGpPQUh0QlQrV0JkQkVFZmFRWFc5TEpXbGFUTzllUHM5N3FaUnYvZEdjZ3o0dXkrUFA1dTJWejF2d1NIeXpabFNYdnpaTit3MEpUS3ZyU1hJZ2pMUStoejU2TTdIaDdxNkdBL3JCNGJDTlNEd2lwN1lMcXVMSlpjQmMzSVZrUS9Kcjh5YVljRG1aQXBFTHdoVENweURtUTVTWkt3dkJMRTFTMEh0eUlrVkNoa0djUkpFVUlpS1dXd0tJWDdZMXppdFdidys2ZThEWFNOZ29UcXFxblk3Ykh1a250cWtwcjZ1R29yNWlqOVlVWHlUOWpWYlZhdFZ1MVJvbnVkdGZQUDA4YTNLZXE3ZllBUGZka2xYQ0tVaUFYZGlmSHQ1eG5vaXp1N3ZoRUd2KzI4TGplRGFWNXhYUU80N21QSFZFL0lGOWYyVVlYcVVkR3JwS2xHbzRhWkZOU0IyWUZwNjdyVVFoRlNsRUk1STd2aGM5T2dyUHd6QytTWUJxbS9qZ3BEL1Jtdjh0QkQwUFU3d1RhR28xRnkvVU9Da2tvQmF0YldRai9YR1FiUS8zcEZSN1ZmUWNGWTFWQ1FCbGx6eDAvNHVVTFk4RUhNV3BTcmhmL3l0MFhWRTY4dDNqSkZpdEVHT3doMEJoSlQ0ZFdkT2lCazFCaUIrWTgrOS9ZSHY5WkNsR2lGRlpXd1pJMzdjdCt6ZEIxRWw0OG15eWVyUHRGNFNINzh3KzdUUU43aTVyT0IvQkJtQ1pWcWJUVGRDbUNlY3hDYng2L0t3dmJpM09tZFI3MUFGN3ZKRkJlMFdrYlc5NjhPZTNrQzlyTEx3REg2SWkydHZqdDd0M2VTd09tbStkZmUvd0hYbjFYT3Y0dnM4djVydTNsZ09KTEZ1ZEVDYXozTmlIY3ArUmdzVkNqWmNPYzlpL2h3c0QycTdFeFdFUWdRcUxjbS9lVUdhRFpveG5TRGEyQXdJNXhtYndpSTdiWVZqeStyZXVxZTNDMXF3b1M0TVNPQXBKNGZqMDJwM3JRMW1Sc1NUVW1rZ3NRMzNXV3gxcWVKbkw4WGdxcG9Mc25TYW5WSlg1R1JiTHg5d09INllHdDFjME5JK2NnK2txYnRWMUVyQzd3Nzl1NXpuVFF4Q2FsTHJUaTNvUHpCdkljMDJma3hNNmdjbVBWa1pEZDRmTEFNQ3ZUeHM2Wlc5UjYvdHdObnUyeEhOOG12OG5OOFdFUE96dGNqb3FVdjhnR3JOcFcvT25kV2hydEJ1dUwxUExITVRlckExaks1V3NlMHVxOWNQbTFuMTlvQlg2QTRsUTdPenNQRzUyZ0xMV1kxUFM0VEEwSXBBdTFvMlpJbWVIaGtYVDQ2T3VMWWFqcjgvSTlaTXBsZE9zYmpVWFFNb0dtcXhTaElueXU2MzVSSU5IN1dldTh3K2lTanlQeTNFckpkNDJtTmdaR0JnQU9JWjZXb3o0L2x0dmpJd3N6Q0F3R1BIRFFzUTlIOTlabm1taTBBdUJ3TVRTQlFBSmxFS2ZBQjQybU5nWkdCZ1p2alBBQ1Q5R1BUK1gyQ1dad0NLb0FBT0FGUXpBMzBBQUFMR0FBQUJXd0J6QWlzQVJRSTZBRXNDc3dBd0Fra0FNQU5PQURBQ3JBQXVBQUFBQUFBcUFJQUE1Z0ZjQWJvQ1FnS2NBQUI0Mm1OZ1pHQmc0R0NJWUdCaUFBRkdCalFBQUFudUFHVjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFWc0FBb0FBQUFBQmtRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxQm1OdFlYQUFBQUU0QUFBQU1nQUFBRHdBV3dDZVoyeDVaZ0FBQVd3QUFBS1ZBQUFEQUZ4VWoxTm9aV0ZrQUFBRUJBQUFBQzhBQUFBMktLcWxBMmhvWldFQUFBUTBBQUFBSGdBQUFDUUdOd0hlYUcxMGVBQUFCRlFBQUFBVUFBQUFGQTVOQUtsc2IyTmhBQUFFYUFBQUFBd0FBQUFNQVdJQ01HMWhlSEFBQUFSMEFBQUFHQUFBQUNBQUNRQk1ibUZ0WlFBQUJJd0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUZZQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c000Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmxadmdQNURORHBKSFUvQWNLQXdEMWFBMVNlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPak80L3Y4UDVEdUM2UDhIL3U4SHF3SUNBSkRFQ1BNQUFIamFQWkxQVHhOQkdJYm5uZG1kb2UxMnQ3QmxGNlFzZ2RJdVA5SkMyckpMTWJZcVVMRkVRSm9RWWhwUkV5RWgwVVJGOE9DaEI0d3gwWU14SVRFZXZIalRpeWRqNHNrVGY0QWVOVEdlaURFY1BSaGFaNGs2YzVtOE00Zm5mYjRobEF5Mld2UWIvVUxHU0k0UUg1NmZzMnd6YnVVOWk0OUJ1R20zNE5tVzU0K2hYL0M0Wlh1MkRwa0hjYjRFUDgvZTRUcVBSemxLVnFZVG1yclZhRk1SalpnRkZoTE4xa0kwWVVZWm91ckdxZ1l0TkZCNi9xTi9tNjdFRURLT0dwYkJlZ1VZQTIwekJLRFo2N083OGNFWXFLSHpJQTRiSE1sOUxCTzVHQmx0SFRGT1B4Q0hqSkJKU1dvV2tpNlhiUDBPT25VSUJ6WTN3RVUvUCtZMUF6Z3Y3U2JUWExCL1p5WWY1Rjg5NlhGN0RRT3I5V3VzVVp1dmdaNkxYYmpiZkpiUTlTbm41ZDdhRmtWMmVyZlBWRzgrcm05VE9qNzNzYUlBK2hJdHRsT1dFS0FYcDZvYlJuaWhPSDlXTHlsQkE1aVlaYmNyZ3pNVVJ2ZlJhN2F6a0ZwaXplOGRQRXdJU0w1MXdDTDBVOEFNcGlNcGpaWlJTTHVTT1FDMkhmaFNiMERZQjBjV2tIa1dydWNIMjdJdDI1ZDFXUGcwNCtHUUNvcVZ4ZGtINDVVZWJrRzVmMzVvelN0a3VCSVNLc3RVaG05TjMzdkJXSzFRdmJOYkd4N2ljem8wdXQvOHJVdG1ZYVF2YlFMVGs2dHJYZlhNOWxXS2daRnN2U3NDVU8zRzJWUWViSy94YUt0YVdHYktZRXBmMUNrakFic3JuY2ZvZTFJbEpDWEJrbi9sK21ZWldSekw5eXdEOFhTWlRuaHBJVjBieU10cno3SUZUMDhVZk0vOXI5M09sZVhmOG5KOW9KOHZLMXJzNkdldklZV3JENlhjVk5HSVViVkRZL0VFb05BejlhZFMvNmtyTXhOUlp1T2swc1ZDMG54cGZUYVl3NXNkejhpTm9KUGk4S3VtTW9kTC9RNTEya1ZVS0hJNkNKbHZFMHJZVEp3b1RRQ3g3bC9JRkUxRURxVkNSWXdLc3dmTkF6a1laSFZ2TTZMd1A0Rm9mVFlBQUFCNDJtTmdaR0JnQUdJakZVdmxlSDZicnd6TUxBd2c4Tmh4d3dJRS9mOGxzd0RUWFNDWGc0RUpKQW9BQWs4S0p3QjQybU5nWkdCZ1p2alBBQ1E1R0ZUK1gyQVdZQUNLb0FCV0FFdFhBeHNBQUFKMkFBQURBQUFrQXdnQUt3TGJBRE1DOUFBbkFBQUFBQUJVQUxBQkRnR0FlTnBqWUdSZ1lHQmw4R1pnWmdBQlJnWTBBQUFJYndCV2VOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5MTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjEwMTcxMSwtNTYuODQ0Mzkpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTMuNjExMDgsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTMuMTAxNzExLC01Ni44NDQzOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMy4xMDE3MTEnIHk9Jy01Ni44NDQzOSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc2LjU4NDE1NCcgeT0nLTU2Ljg0NDM5Jz7DlzwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScxNi41NDY3NjgnIHk9Jy01Ni44NDQzOSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44NjIxLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zLjEwMTcxMSwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTMuMTAxNzExJyB5PSctNTYuODQ0MzknPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYwLjg4NDY2LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zLjEwMTcxMSwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTMuMTAxNzExJyB5PSctNTYuODQ0MzknPkU8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYwLjgzNjc1LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMy4xMDE3MTEsLTU2Ljg0NDM5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0zLjEwMTcxMScgeT0nLTU2Ljg0NDM5Jz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xOC4xNjY2MyAzLjYxNjYySDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LDMuNjE2NjIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI2LjYwNDk4LDcuNzg5NTQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zLjEwMTcxMSwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTMuMTAxNzExJyB5PSctNTYuODQ0MzknPmY8dHNwYW4geD0nMS41NjQ4NzMnPs+APC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNi4yMjM3MTgnIHk9Jy01NS44NDgxMjYnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTE4LjE2NjYzLTMuNjE2NjJINDcuODA2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguMDU2NTYsLTMuNjE2NjIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI2LjYwNDk4LC0xMS4yODk1NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTMuMTAxNzExLC01Ni44NDQzOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMy4xMDE3MTEnIHk9Jy01Ni44NDQzOSc+Zjx0c3BhbiB4PScxLjU2NDg3Myc+z4A8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSc2LjIyMzcxOCcgeT0nLTU1Ljg0ODEyNic+MjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTQ2LjE3MDggMEgtMTguNjY2NjMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsLTQ1LjkyMDgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTguNDE2NjMsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzUuMTY1NzcsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTMuMTAxNzExLC01Ni44NDQzOSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMy4xMDE3MTEnIHk9Jy01Ni44NDQzOSc+ZTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTQ3LjExMDAyLTQ3LjEwN0wtNy41OTI0LTcuNTk2NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTAuNzA3MTUsLTAuNzA3MDMsMC43MDcwMywtMC43MDcxNSwtNDYuOTMzMjMsLTQ2LjkzMDI0KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTTIuMiAyLjU4MDYzQzEuNzk4MDcgMS4wMzIyMyAuOTAyNCAuMzAxMDcgMCAwQy45MDI0LS4zMDEwNyAxLjc5ODA3LTEuMDMyMjMgMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjcwNzE1LDAuNzA3MDMsLTAuNzA3MDMsMC43MDcxNSwtNy40MTU2MiwtNy40MTk4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjQuNjg4NCwtMzYuMDE0NTcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zLjEwMTcxMSwtNTYuODQ0Mzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMuMTAxNzExJyB5PSctNTYuODQ0MzknPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLjAxMTYzMicgeT0nLTU2Ljg0NDM5Jz51LDx0c3BhbiB4PSc4LjQ0ODgwNCc+djwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzEyLjY4NDExMycgeT0nLTU2Ljg0NDM5Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzMuMCwyLjAnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNLTU2LjkwNTUtNDguNjYyNDZWLTYuOTA5NzMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwtNTYuOTA1NSwtNi42NTk3MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTY2LjE0Mjc4LC0yOS4yODYxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMy4xMDE3MTEsLTU2Ljg0NDM5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zLjEwMTcxMScgeT0nLTU2Ljg0NDM5Jz53PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$A \times  A$};
      \node  (2) [right = of 1] {$B$};
      \node  (3) [left = of 1] {$E$};
      \node  (4) [below = of 3] {$C$};
      \draw  [->,morphism,offset=-1.5] (1) to node {$f\pi _{1}$} (2);
      \draw  [->,morphism,offset=1.5] (1) to node[swap] {$f\pi _{2}$} (2);
      \draw  [>->,morphism] (3) to node {$e$} (1);
      \draw  [>->,morphism] (4) to node[swap] {$(u,v)$} (1);
      \draw  [->,morphism,exists] (4) to node {$w$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Thus, <fr:tex
display="inline"><![CDATA[u = \pi _{1}(u,v) = \pi _{1}ew]]></fr:tex> and <fr:tex
display="inline"><![CDATA[v = \pi _{2}(u,v) = \pi _{2}ew]]></fr:tex>.
    By assumption, <fr:tex
display="inline"><![CDATA[\pi _{1}e = \pi _{2}e]]></fr:tex> so <fr:tex
display="inline"><![CDATA[u = v]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1448</fr:anchor><fr:addr
type="user">log-000S</fr:addr><fr:route>log-000S.xml</fr:route><fr:title
text="Identity morphisms in the internal language of a category">Identity morphisms in the <fr:link
type="local"
href="log-000P.xml"
addr="log-000P"
title="Internal language of a category">internal language</fr:link> of a category</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>.
  <fr:tex
display="inline"><![CDATA[f\colon A\to A]]></fr:tex> is the identity morphism iff <fr:tex
display="inline"><![CDATA[x\colon A|\top  \vdash  f(x) = x]]></fr:tex> is <fr:link
type="local"
href="log-000T.xml"
addr="log-000T"
title="Satisfaction">satisfied</fr:link> in the <fr:link
type="local"
href="log-000P.xml"
addr="log-000P"
title="Internal language of a category">internal language</fr:link> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1275</fr:anchor><fr:addr
type="machine">#298</fr:addr><fr:route>unstable-298.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Suppose that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is the identity morphism.
    Then by <fr:ref
addr="log-0007"
href="log-0007.xml"
taxon="Definition" />, <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket f(x)\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A} \circ  {\mathopen {}\llbracket x\rrbracket \mathclose {}}_{\mathcal {C}} = {\mathopen {}\llbracket x\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex>.
    But the equalizer with itself is the terminal object.
    Thus, <fr:tex
display="inline"><![CDATA[\top  \leq  {\mathopen {}\llbracket f(x) = x\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> as required.</fr:p>
  <fr:p>Conversely, suppose that the terminal object of <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> (i.e., the identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A}]]></fr:tex>) factors through <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket f(x) = x\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex>.
    Then it follows that <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A}]]></fr:tex> equalizes <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket f(x)\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket x\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex>.
    Since <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket x\rrbracket \mathclose {}}_{\mathcal {C}} = \mathsf {id}_{A}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket f(x)\rrbracket \mathclose {}}_{\mathcal {C}} = {\mathopen {}\llbracket f\rrbracket \mathclose {}}_{\mathcal {C}} = f]]></fr:tex>, it follows that <fr:tex
display="inline"><![CDATA[f = \mathsf {id}_{A}]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Related">Related</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1449</fr:anchor><fr:addr
type="user">log-0006</fr:addr><fr:route>log-0006.xml</fr:route><fr:title
text="Sigma structure">Sigma structure</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with finite products and <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> be a <fr:link
type="local"
href="log-0001.xml"
addr="log-0001"
title="Signature">signature</fr:link>.
  The category of <fr:em><fr:strong><fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structures</fr:strong></fr:em> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, denoted as <fr:tex
display="inline"><![CDATA[\Sigma \text {-}\mathsf {Str}(\mathcal {C})]]></fr:tex>, consists of the following data:</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
  
  <html:tr>
    
  <html:th>Objects</html:th>

    
  <html:th>Morphisms</html:th>

  </html:tr>

  
  <html:tr>
    
  <html:td>
      A <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structure consists of the following data:
      <fr:ul><fr:li>Each sort <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> is associated with an object <fr:tex
display="inline"><![CDATA[MA]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
          This is extended to any finite string of sorts by the assignment <fr:tex
display="inline"><![CDATA[M(A_{1},\ldots ,A_{n}) \mapsto  MA_{1} \times  \cdots  \times  MA_{n}]]></fr:tex>.
          The empty string is associated with the terminal object <fr:tex
display="inline"><![CDATA[1]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:li>
        <fr:li>Each function symbol <fr:tex
display="inline"><![CDATA[f\colon A_{1},\ldots ,A_{n}\to B]]></fr:tex> is associated with a morphism <fr:tex
display="inline"><![CDATA[Mf\colon M(A_{1},\ldots ,A_{n})\to MB]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:li>
        <fr:li>Each relation symbol <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1},\ldots ,A_{n}]]></fr:tex> is associated with a subobject of <fr:tex
display="inline"><![CDATA[M(A_{1},\ldots ,A_{n})]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:li></fr:ul>
    </html:td>

    
  <html:td>
      Let <fr:tex
display="inline"><![CDATA[M]]></fr:tex> and <fr:tex
display="inline"><![CDATA[N]]></fr:tex> be <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structures.
      A <fr:em><fr:strong>homomorphism</fr:strong></fr:em> <fr:tex
display="inline"><![CDATA[h\colon M\to N]]></fr:tex> consists of an indexed family of morphisms <fr:tex
display="inline"><![CDATA[h_{A}\colon MA\to NA]]></fr:tex> for each sort <fr:tex
display="inline"><![CDATA[A]]></fr:tex>.
      This data is subject to the following conditions:
      <fr:ul><fr:li>For each function symbol <fr:tex
display="inline"><![CDATA[f\colon A_{1},\ldots ,A_{n}\to B]]></fr:tex>, the following square commutes:
          
    
      
      <fr:figure><fr:resource
hash="afca79891410f1ca592bfa4b822463a4"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI1MC41ODkzMnB0JyBoZWlnaHQ9JzExOS42OTY4NjJwdCcgdmlld0JveD0nLTcyIC03MiAxNjcuMDU5NTQ3IDc5Ljc5NzkwOCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU4wQUFvQUFBQUFBOWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ2lNSnk0Mk50WVhBQUFBRkFBQUFBTVFBQUFEd0JDUUQwWjJ4NVpnQUFBWFFBQUFDbEFBQUFxUDdSclZSb1pXRmtBQUFDSEFBQUFDOEFBQUEyS1N1a0xHaG9aV0VBQUFKTUFBQUFIZ0FBQUNRR2NnQTZhRzEwZUFBQUFtd0FBQUFNQUFBQURBaDlBU1pzYjJOaEFBQUNlQUFBQUFnQUFBQUlBQm9BVkcxaGVIQUFBQUtBQUFBQUZ3QUFBQ0FBQlFBamJtRnRaUUFBQXBnQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBRGFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXVzSTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU1tQmlTUVVseVdEcFRjem5DZFdmR1BFUU1Ec3lMek9hQXdJMExGLy84TURBQXJ6QStVQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWU5JQTBHNUJtQk1wdVo3aisveitRRDZiL2UvM1hCcXNDQWdDdlZBbjNBQUFBZU5vVmpVOEtna0FjUm4vZitHZHExQ1RVVVNNd0xYUVpHT2dpeVBQVXRndDRwKzdRcmhzRURxNTAweFZxZW9zSER6NzRDSFNuSjAwNGswTVVyTUNMc3JxZ3JlV0UzU1k2UUZ2dVFVbU9iUHNYYVVDUDc0ZTlXVUM1RHA1QlJ2YStPSUxiVlZtVkhhcXliZG9tUTRmbVZNZVN2VlIvdGN4UThIbjBSTUtNWUJqV1lJbmpqc3F6RnFFSktOWGZUSkZhcy9MQllxNEh2b2daZkRXNFJyclVsejh0V2grNkFBQUFlTnBqWUdSZ1lBRGlQODgyM283bnQvbkt3TXpDQUFLUEhUZE1SOUQvM3pGUFpCSUdjamtZbUVDaUFIakpESTBBZU5wallHUmdZRmI4WXdRa0p6SVVNeFF6M1dFQWlxQUFaZ0Jhb3dPd0FBQURrUUFBQVZzQWN3T1JBTE1BQUFBQUFCb0FWSGphWTJCa1lHQmdabEJpQU5FTVVCSUpBQUFFQ2dBcEFIamFUWXc5YjhJd0VJYWZpQVNKZE9oU2RlZ0FIcGl0b0ZSaVkyRmdZbVhxQXRpZ0RIR1FIU0pGcWpyeXUzdTRIbnJENlhrLzdvQ1NIektlay9FYTkzTnlDbEYvWFBEQ1crS3BxRVhpa2crV1RNanltVGh6Tm9selNiNFNGN3h6U1R3Vi96dHh5U2VQYmRmZTdyMzFhdDhaNjkyNURlUDZZSDFvT3FkV3VvcDZaNTMxeDk0YWRScVZHWm93WEZ0VjYwclhiT2xvdVhHbngrSlI3TVV4a1IxbnlRSWphdzdSQ1RTU09tbXQwRlQvOHAza0xuYU84Wk9SemtrU0pUVElWWkI5bGJhaWpwZWEraGZ6ZVRCUEFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTWNBQW9BQUFBQUE0UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MUcyTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUJrQUFBQVpERnVBckpvWldGa0FBQUJ5QUFBQUMwQUFBQTJLT3VrMW1ob1pXRUFBQUg0QUFBQUhnQUFBQ1FGeXdMV2FHMTBlQUFBQWhnQUFBQUlBQUFBQ0FZS0FKSnNiMk5oQUFBQ0lBQUFBQVlBQUFBR0FESUFBRzFoZUhBQUFBSW9BQUFBRndBQUFDQUFCQUFnYm1GdFpRQUFBa0FBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEREFBQUFCQUFBQUFnQUFNQUFYamFZMkJtWm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd5TS93SDhwa2gwa2hxL2dPRkFhTjNERmdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy85RHlQOFh3SHdHQUZGSEJvMEFBQUFBQVFDU0FBQUNOd0tyQUI0QUFBRVJCaFk3QVJVbUp5TUdCelV6TWpZbkVRNEJKeU0xTXhZL0FUWTNOaFlCbUFRaVRqTXNPdEU2TEROT0lRTXVWQk1TRWhJK0J6ODVHQTRDaS8zTkZ4UXRBd0VCQXkwVUZ3SUFFZ3dCTFFJS0Fnb3VBUWtBZU5wallHUmdZQURpSCt6R25QSDhObDhabUZrWVFPQ3g0NGJweURSekVOTnFJTVhCd0FUaUFRRDlWQWpHQUFBQWVOcGpZR1JnWUdiNHp3QWtneGdtTVRReW1UTUFSVkFBRXdCQzNBS29BQUFEVWdBQUFyZ0FrZ0FBQUFBQU1nQUFlTnBqWUdSZ1lHQmlrR2NBMFF4UUVna0FBQU9rQUNVQWVObzlqREdyd2pBVWhiOWlGZTBiSEFTSE4wandCNFJLbjV1Ymc1T3J3OXVzQ2RLaHFhUzE2Q0wrZEc5RDhBWU8zejNuM0FBWkx4S0dTWmdISFNhVk40ODg1b2RGNUluNHE4Z1p2Nndaa2FRemNWYnNJcWRNK1k4OFpra1plU0wrSTNMR0grOTlVOS91bmZYcTJCanIzYVgyMjVQMWJkVTR0ZEg1c0I2c3MvN2NXYVBLcHpKOTFmYlhXaFU2MXdWN0dtcHUzT213ZUJSSGNVeGd4MFV5ejVaVDJGc3F5WngwTm1qeWIzcVExSVhHT2Z4aXBGSHlGRFgwY3RPS1hxV3JLTUtkcHZnQVZUSXVRd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVJQUFvQUFBQUFCY3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDJIR050WVhBQUFBRTRBQUFBTWdBQUFEd0FyUUJ6WjJ4NVpnQUFBV3dBQUFJOEFBQUNsQ2p4ZUkxb1pXRmtBQUFEcUFBQUFDOEFBQUEyS1hLay9XaG9aV0VBQUFQWUFBQUFId0FBQUNRSE5nTjVhRzEwZUFBQUEvZ0FBQUFRQUFBQUVBOGtBVUZzYjJOaEFBQUVDQUFBQUFvQUFBQUtBYkFBekcxaGVIQUFBQVFVQUFBQUdBQUFBQ0FBQ0FCVWJtRnRaUUFBQkN3QUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRS9BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVBzazRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWk1oalp2Z1A1RE5EcEpIVS9BY0tBd0R6aEExcGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS09qSGsvZjhQNUR1QzZQOEgvazhGcXdJQ0FKVkhDUm9BQUhqYU5aRy9iOU5RRU1mZjNYdjR4Zlp6Yk1lTzNSK3BXemZGYmlvYU4ybHFLeFZ5K2t1QnFGV0hJam9VQm9vNmdLQUxTRXdNU0NDRUdKRGdYMkJqWW1DRHFSSXE0aTlnWVdPQVA0QUZxU25QclhwM3c5MTlsL3ZjbHlDNWYzcEtqL0VuNlpLcmhJQVR3R0xxK1I1UHdJUW96c0gzMGl5QmtDc21LanlBelBmOE1oVGlkQlJIYVpaREJqbTBQVTVEL1AwRVJoWjBCMkJzWlcyd1VRRndSR21aR2Zid3U4UG9wbEFBbzVMT0FXemxjYWZKZEFSZWJxMEY4STViMDJMdkY5VHg2T1MxYllBaXhwRUNVTENxS2dDMyszdUE3TkRWMVlvR1NJVmNNcUJjdzFHRWVoUDd1aENQaHArSURFcWVTcFlmK0lYTWtnN3BFWkk1MlZLVWdCSXRkVkkvRE1CWGVKRUI4UE1tUEZmYXFiTW9PVHBSWEk4VVRpOTZ5b2N2cWUzV0hNZTE0UDJERjhqV0RXc3d1SGNINkk0d2J6MGZycGRkcjVwTmZEdzZmSU9EcmMrVE5udjQ5ZUF0Mjk3KzE2YzNjVlFZREFBVXc1VVVOMWI3ODVvNnE1cTdyYzFjVTVlcHBKUWdGdlRvM2RXNUhFRjRKMGU0djlVZTRQQ1BJMW1BM0Q3OVMrZmdtT3dRMHFQcFVockZaZmt3cU1meTcxbGFwT2ZMUzl0ZVZUR2hxS3BTekRrc1NvdmNNNzRteEdjT3BmRVpyMG5MaFd2WnQ5RFFGTERIcGlLQnFqQkswaEhOQ2JwVHUzeDh2ei9ZeGlyenl4ckRNT3FackZUb0U4SnFiQ1E5Uk5XWlI0bmFIckV2bDNoRFZXdmpIaWdIcnhibVBjT2VBYnpXMUZSRTdWSlNxeVVNNS9LWkZWenRYbG5SODdDbVczVUthNGtwZGQxdHVaV0V3VUpqdEpJOFM2NGphM2tqSGRmL01PbVlsVXBBL2dPdG1tRFhlTnBqWUdSZ1lBRGl1M2Yrc3NmejIzeGxZR1poQUlISGpodW1JK2ovWDVsdk1OMEZjamtZbUVDaUFHZWJEUFFBZU5wallHUmdZR2I0ejhEQXdLTEdFTVBneDN5REFTaUNBbGdBUWFvQ3VBQURWQUFBQkNVQWFRUW1BSHdEaFFCY0FBQUFBQUJtQU13QlNnQUFlTnBqWUdSZ1lHQmhDR1pnWmdBQlJnWTBBQUFKSEFCZGVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnd05xRmdZbVZxUXRnRjJXd2pad1FDYW5xMk4vZGgvSFFOMXlkKzJFRE5UOFUzSzlnbHZSK0paVzRCMWRNbVdlZWlIdkxYTFBnblNlSzhsbVNWejR5bDlKOFpxNTQ0U3Z6UlBMdnpEVXJmamZCWGE2RGpXb1hqSTMrNUZ5MzN0dllkOEdycFc2UzMxcHY0Mkd3UmgxdnlveGRQNTZkYW5Xald6WUVIQmV1REZnaWlwMGtKckhuSkoyalk4MCtKYjF3a0Z5eFJOUDg2N2ZTKzdRNXBKK01iSTdjUkEyakxIclJzMndWYlhxcGFmOEF5QkV2N3dBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVkwQUFvQUFBQUFCOGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXaDFaMk50WVhBQUFBRTRBQUFBUEFBQUFFd0JEZ0VQWjJ4NVpnQUFBWFFBQUFOVUFBQUVkTmhXZnZSb1pXRmtBQUFFeUFBQUFDOEFBQUEyS2lta0syaG9aV0VBQUFUNEFBQUFJQUFBQUNRSHdnTXBhRzEwZUFBQUJSZ0FBQUFZQUFBQUdCSjRBVnRzYjJOaEFBQUZNQUFBQUE0QUFBQU9CQXdDcW0xaGVIQUFBQVZBQUFBQUZ3QUFBQ0FBQ0FCU2JtRnRaUUFBQlZnQUFBRE5BQUFCT1BOZktxTndiM04wQUFBR0tBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUZtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHI2TXVReE0vd0g4cGtoMGtocS9nT0ZBYk0zRE1BQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdDeUFOQmNEQjFDT2ljR1BJWTBoZ3lIdi8zK2dtQytNL1gvTC83bi81L3lmRHRZQkJRQllWQTRVZU5xTjA3K1BHMFVVQi9COWIyWm52RDg4czc4M25IK2R2YzZ1RXdmNzd1eGJrN094enptTFFPNkFDMFZPVkZTUkVJbENSWVZBZ2pSQlFBQkJRUXNWSGY4QUlnMGlFaDBGb3FTaVM0ZWdzODNzSFFTSkFxRnRadWM3MHI3UHZMY2FhRWZyTmYwSUgyakhtZ2FFczZnQmVjRDZJQ0h0d3pDUG8zemtBK090ekFJV0Yya1VDK2dEVitrVTRpbU0vRkd1MWdsTDgzaVFSN0ZmYkEveU9HQlp5bWgwandMM3NvYlUzNTNQTElLTzJLdVJUMWJYelNDQU8vZDB3S0F2U2dCU3YzM0xKQWhsUHJtb3YwT2g1QVIrRXp6NWFXaVRtL0MrS1lJUGF1QTVveXErdXZ3MTVoeVFKaHdvRUZXWnl3RzhEVndzN3dha2luZVd2NFRVcmhJa2hnb29WUWVjRXBCdUJUSGlEQWh0cWVPR3YzeUF6d3FWKzFLOUJwcWlhMWZYSy9JemZxT05pM3NRa0xUU0RFaEJqbmVpVUYwSVo5bGY0UFJ2Sy9qNWJ0NkhWQVVOR0VVQ01nSGt4bjFTc3JqQlZqL2RaWUJoejVERXUzMnJqQ0RZdUt1LzE1eURKejUwYlIzMDF5bFpGTjh2OUJLRVB1bmkwZklIVWRKdHZMbjg3WlNobStkUUlSeXBESjA2Smx3djZtZjI4aEY4SzZ5c1lEb0ZFeXNGOHRSeHVPN2phL2lqdGw4NHBQSUw0SzJpeEVFVVI0eXJEazVoUnM3NnBUUnFmNmRvYVpKbWFUNVNuUlFvUWVGWUJsL3NPZFRaTU9iYm5UMkFkcGdTa0EwcFpidEphajE1VkVkZlhwZWhpSzRrRnlZQVNhUnlweTZsNTlYTjBzWXJSUXlmcmI2NzV1NFBnd09TSnZWTmJMUE1NaERvWWZqNTd5ZEVTVTVlcm1UcCtmWS9FVHlSUG5tZnRrcWduVnFlWC8rQmIrSkQ3YkN3cUdMcnlOa1pLV1R4VGo3S0IzRmROVVk5U2ppY2dkcFIwNmk2b0k1UlplckI3c2lmUXBxY1hjQW9qempNWDZpK2RQbVpvYTFtRDMyN2JKSnFZK0toYXpLSUxUZVpkcDRDVWhaUnBPYWxNemsrSjNWLzB5aVpzZUc1K3NjVVpkdHdBQVJmWERvUCtOWHFZWE1BZW45WTdrM1l1TkpzdWkyY1BlMGh4bHR4MUtQOUM3YTEyYjV5c0IxdUl4NTBJdXZhMjJsRld1Q1hJMXlVcFVsTldlS1UyTXE1cFp4Znd2ZmFpNW8ySS9udThKUlEvR1k5UlpwaVZJeWRtcmYvWlNjU0JVbXp0N3EyeGFSZmIxazZOeTBHZ1d0a0J3c2VuK3hmdWtFZTB6ZkgvNkxic3FBSDNjdUhYY0ZyZ1c2RTFRRG1YMi8xWWllc0F1ejNBZ3NRNWJ6dXQvSGlibk9NMkh2dXYvWGVnT0JrMnF5OWNSeElBWTZyL1FudTVaTTBlTnBqWUdSZ1lBRGlBcTk3bitQNWJiNHlNTE13Z01Canh3M1RFZlIvZlpaK3BvdEFMZ2NERTBnVUFFem1DNmdBZU5wallHUmdZR2I0ejhEQXdCTE5ZUEQvT0VzL0ExQUVCYkFCQUYxbEEvTUN4Z0FBQkZzQVRBT2VBRWNDT2dCTEFxd0FUUUxUQURBQUFBQUFBSVFBNkFGT0FjSUNPZ0FBZU5wallHUmdZR0JqQ0dRQTBReFFFZ2tBQUFqeUFGc0FlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOZ0FBb0FBQUFBQTlRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVU56N0dOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFCOFoyeDVaZ0FBQVdRQUFBQ2dBQUFBcktBQ0hhUm9aV0ZrQUFBQ0JBQUFBQzRBQUFBMktCcWtLMmhvWldFQUFBSTBBQUFBSHdBQUFDUUVqd0c4YUcxMGVBQUFBbFFBQUFBS0FBQUFDZ1JHQUdSc2IyTmhBQUFDWUFBQUFBZ0FBQUFJQUN3QVZtMWhlSEFBQUFKb0FBQUFGd0FBQUNBQUJRQVpibUZ0WlFBQUFvQUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURVQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm12TWM0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVlOQmtadmdQNURORHBKSFUvQWNLQXdEdmtRMGVlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aWEvLzhEU1kzLy8vL2ZCUE1aQUZDYkJvVjQybU5nWkVqNXo4QVl3c3pBSU03QXdDcWlwS2F1eDJpdVptWnV4MmpFejhqSEtNNG1KTThveGhnc2xteW9LY1BJS0tObW1DYkd5QlBud2Nqa0VzL1AvSTByS1Q1aWxhM1R3dERrVkI2QnhEL3RsZi8rcFFpeU1BQUJJNE1sMEZ4TmlMbU1ZbXpzZkl4S3BrQlQxVTNVOUJuVnpNMk14TVRsR0JrMXdDYUs4c1o2TVFYN0NERXpNb3FDN1dHQW1wajB0M1hoQjE4aEZpYXdQUUFWSkNGTWVOcGpZR1JnWUFEaVQ2L1BmWS9udC9uS3dNekNBQUtQSFRkTVI5RC9HWmdhbUVGY0RnWW1FQVVBY2V3THJ3QUFlTnBqWUdSZ1lHYjR6OERBd05UQVlNbGd5UmpDQUJSQkFVd0FPMndDVUFBQ2dBQUFBWTBBWkFBNUFBQUFBQUFBQUN3QVZuamFZMkJrWUdCZ1pwQmdBTkVNVUJJSkFBQURFQUFmQUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTVFBQW9BQUFBQUEzZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MG8yTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUJZQUFBQVdPYStkQlZvWldGa0FBQUJ2QUFBQUMwQUFBQTJLR3lrMUdob1pXRUFBQUhzQUFBQUlBQUFBQ1FGVmdJNWFHMTBlQUFBQWd3QUFBQUlBQUFBQ0FVYUFIQnNiMk5oQUFBQ0ZBQUFBQVlBQUFBR0FDd0FBRzFoZUhBQUFBSWNBQUFBRndBQUFDQUFCQUFiYm1GdFpRQUFBalFBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEQUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtNm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd5TS93SDhwa2gwa2hxL2dPRkFkU0JETjhBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy85RHlQOFh3SHdHQUZGSEJvMEFBQUFBQVFCd0FBQUI1QUtwQUJrQUFBRVJCaFk3QVJVdkFROEJOVE15TmljUkRnRW5OUlkyTnpZV0FWY0RJRWtuWjFCd1JpZEpJQU1zVkJRaGRETVZDd0tML2NrYUZTVURBUUlDSlJVYUFnb1VDUUVrQWhZdUFRb0FlTnBqWUdSZ1lBRGlYck5nOFhoK202OE16Q3dNSVBEWWNjTjBaSnJwTXROS0lNWEJ3QVRpQVFBQXJ3azJBQUFBZU5wallHUmdZR2I0ejhEQXdIU1pvWUFobWZFSkExQUVCVEFCQUZhYUE1UUMwd0FBQWtjQWNBQUFBQUFBTEFBQWVOcGpZR1JnWUdCaWtHSUEwUXhRRWdrQUFBTW5BQ0FBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktIN2k0T1RpNU9yek5taUFkbWtwYWl5N2lUL2MyQkcvZzhOMXp6ZzJROFNKaG1JUjUwR0ZTZWZQSVkzNVlSSjZJdjRxYzhjdWFFVWs2RTJmRkxuTEtsUC9JWTVhVWtTZmlQeUpuL1BIZU4vWHQzbG12am8yeDNsMXF2ejFaMzFhTlV4dWREK3ZCT3V2UG5UV3FmQ3JUVjIxL3JWV2hjMTJ3cDZIbXhwME9pMGR4Rk1jRWRsd2s4Mnc1aGIybGtzeEpaNE1tLzZZSFNWMW9uTU12UmhvbFQxRkRMemV0NkZXNmlpTGNhWW9QV0t3dVN3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVhNQUFvQUFBQUFCdkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVZDB2bU50WVhBQUFBRTRBQUFBUVFBQUFFd0FwQURYWjJ4NVpnQUFBWHdBQUFMY0FBQURrRklGSHcxb1pXRmtBQUFFV0FBQUFDOEFBQUEyS2Nla1FtaG9aV0VBQUFTSUFBQUFIZ0FBQUNRSFZBS1phRzEwZUFBQUJLZ0FBQUFjQUFBQUhCSE5BVlJzYjJOaEFBQUV4QUFBQUJBQUFBQVFBaG9DOEcxaGVIQUFBQVRVQUFBQUdBQUFBQ0FBQ3dCSmJtRnRaUUFBQk93QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRndBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbTZtYWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHJxTVBneE0vd0g4cGtoMGtocS9nT0ZBZFoxRFBVQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdDeUFOQmNEQjFDT2lVR0hRWS9CaWNIdi8zK2dHSWp0eU9ENy8vLy9xLyt2L0QvMGZ3ZFlCeFFBQURvU0RYSUFBQUI0MmoyU3pXdlVRQmpHNTVsSkpwdmR6Y3p1WmpkTHUxOXRkN3ZSZmxodDE2d3R1b0xmV0N6VmdyWlFFQXBhQmZVZ2JRVXY5aUIrWUVWUUVEeDU4ZVpWOEZJOENJckhvbWNGOVNUK0RlbjZKcVdHWkRKNTV5VTh2K2Q1R2RoOGQ0cHRzWnVzd0ZoYmFpajR6WFlIN1pZbDYvdlFDdHJlbGxHWERROUM5dzdCY1BNOWxVclBVVnhxSlE4Z3pWWHYvR1RPME9nYnFjRmdkSUV0MFBPSjNXQUorcC9DUUxNVmpIdWZVQnV0MFIxNDBWcWpQczRhM1M3L3liK3pNVFpPblFqYTQxN1J6WHNUZ1NmSFlQbE52eFVVdmFBOWhuNUw1cjFpVUZTZ2VsU2VJSGtUNGoydXlMd2owZkZHQzBpYksrc0pFMDdLYlFuYjJ1N09PR1hYRVhETTVmazAwdlpBNTlYZi9qVitNUU5iaCt1ZUZoVUxRb0FudEFXa2kxZFAzczgzTXVCYXlhaWMxQkwxTDdnUThRZzIzQTJGNUp1c3lvYllJVkxxdHVxK0pHMzlWUlFVckNxSzVKcTArbVdzMTQzRUJVMi8zcFNXMk4wTGFwaDQ4N1RrVjdURy9PS1NXSitibmdNL25UbTN1djJpck5SVTlmWEx5eXNjKzQ3ZnI3bm1yWTNGTmM3M24vbDR5Z0RVTEovTWNsRzJ3TTlQblYzV3labko2V09xWTBRRWNIRlMzRDdWT01HaGU4SzM0czdNNEt6WS9wMlR5U2lIa1c3WEdPVWYyR242SUFGVkJMR0IvNDExU1hUellBcXlJTDBhdkVKOEdrR1FhRGVJRVNtTG9vc09vbzMwbTFLOGUwU1NCaWZKMS9WN1NSTVpaNnBxUHQ5ZWtsbTk4TVJBYVpqaVVNYjFaY2N4am96SUJ6aGV6ZWdOTjQxWnJDWlU3bUVKT3RldThKdmhqNXpsU0NQT2dGTWlra2lxZkRxOG93eFI0SGZEcjhwMmV3QnVxemlsRXExRGZieWNFYUpDclZZMjNPUm5vcVRJRkJUaW1kdERHVDJnakk1RXJBcDE2UXRmUkdERm5Xa2E4QWtpNG1xT1lSZXNGR2NqNmFTR05qbEFnNjhnNUROaDJxbEUxMzVvb25mWWpYSFNRTW9rb01kR3BWRlJtY2VabFB5MUNwU0h0YURCdTNiTjVoeHA0L0FvbncwL3E0VHcrR0l1L0szc2JDL241WWdncFhjSUJpMitJOXB5d2ovNGxzcVdTT3dPb3lHajkxNzJEM0V1aUNKNDJtTmdaR0JnQUdMTFlzR0Q4ZncyWHhtWVdSaEE0TEhqaHVrSStyOFZpeTdUWFNDWGc0RUpKQW9BR3NZS1VBQjQybU5nWkdCZ1p2alBBQ1FmTXFqODM4Q2l5d0FVUVFIc0FHQWxBL1FBQUFKMkFBQUJIQUJZQVJ3QVdRTUFBQ1FEQ0FBckErRUFMQU0yQUNnQUFBQUFBQ2dBUEFDUUFPd0JZZ0hJZU5wallHUmdZR0JuOEdCZ1pnQUJSZ1kwQUFBSVdnQlZlTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNi43OTQ3MjUsLTYwLjQ0NzUwMSlzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zMi44NjA1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Ljc5NDcyNSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Ljc5NDcyNScgeT0nLTYwLjQ0NzUwMSc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSczLjk1NjYxNycgeT0nLTYwLjQ0NzUwMSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc3LjgzMDk5MScgeT0nLTYwLjQ0NzUwMSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PScxNS4zMDI5OScgeT0nLTU4Ljk1MzEyJz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzE5Ljc3MjM2JyB5PSctNjAuNDQ3NTAxJz4sPHRzcGFuIHg9JzI0LjIwMDE2OCc+LjwvdHNwYW4+PHRzcGFuIHg9JzI4LjYyNzk3Nic+LjwvdHNwYW4+PHRzcGFuIHg9JzMzLjA1NTc4NCc+LjwvdHNwYW4+PHRzcGFuIHg9JzM3LjQ4MzU5Mic+LDwvdHNwYW4+PHRzcGFuIHg9JzQxLjkxMTQnPkE8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc0OS4zODMzOTknIHk9Jy01OC45NTMxMic+bjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSc1NC44MDYzOTEnIHk9Jy02MC40NDc1MDEnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMyLjAyNzE2LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNi43OTQ3MjUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNi43OTQ3MjUnIHk9Jy02MC40NDc1MDEnPk48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMi4yOTYxNjUnIHk9Jy02MC40NDc1MDEnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNi4xNzA1MzgnIHk9Jy02MC40NDc1MDEnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMTMuNjQyNTM3JyB5PSctNTguOTUzMTInPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTguMTExOTA3JyB5PSctNjAuNDQ3NTAxJz4sPHRzcGFuIHg9JzIyLjUzOTcxNSc+LjwvdHNwYW4+PHRzcGFuIHg9JzI2Ljk2NzUyMyc+LjwvdHNwYW4+PHRzcGFuIHg9JzMxLjM5NTMzMSc+LjwvdHNwYW4+PHRzcGFuIHg9JzM1LjgyMzEzOSc+LDwvdHNwYW4+PHRzcGFuIHg9JzQwLjI1MDk0Nyc+QTwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzQ3LjcyMjk0NicgeT0nLTU4Ljk1MzEyJz5uPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzUzLjE0NTkzOScgeT0nLTYwLjQ0NzUwMSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC04LjkwOTczVi00Ny40OTU3NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDcuNzQ1NzcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Mi40MzU5MSwtMzAuMjAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Ljc5NDcyNSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Ljc5NDcyNScgeT0nLTYwLjQ0NzUwMSc+aDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMi4xMzA0NjcnIHk9Jy01OS40NDU2ODgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nMy4wMzA4MTQnIHk9Jy01Ny45NTEyOTInPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nOS4yMzEzNzUnIHk9Jy02MC40NDc1MDEnPsOXPHRzcGFuIHg9JzE3LjI3MjIzNic+wrc8L3RzcGFuPjx0c3BhbiB4PScyMC45OTkwMTInPsK3PC90c3Bhbj48dHNwYW4geD0nMjQuNzI1Nzg5Jz7CtzwvdHNwYW4+PHRzcGFuIHg9JzI4LjkwNjA2OSc+w5c8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSczNi45NDY5MjknIHk9Jy02MC40NDc1MDEnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNDEuNjExMTg3JyB5PSctNTkuNDQ1Njg4Jz5BPHRzcGFuIHk9Jy01OC40NDk0MzknPm48L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3NS45MTkwNCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNi43OTQ3MjUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNi43OTQ3MjUnIHk9Jy02MC40NDc1MDEnPk08dHNwYW4geD0nMy45NTY2MTcnPkI8L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3Ni43NTIzOCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYuNzk0NzI1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYuNzk0NzI1JyB5PSctNjAuNDQ3NTAxJz5OPHRzcGFuIHg9JzIuMjk2MTY1Jz5CPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTM3LjQxNjA1IDBINzAuODYzNScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3MS4xMTM1LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuODU5NTMsNC4xNzI5MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYuNzk0NzI1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYuNzk0NzI1JyB5PSctNjAuNDQ3NTAxJz5NPHRzcGFuIHg9JzEuNTUwMzg3Jz5mPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTg1LjM1ODI2LTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsODUuMzU4MjYsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OC42MjIxNSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Ljc5NDcyNSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Ljc5NDcyNScgeT0nLTYwLjQ0NzUwMSc+aDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMi4xMzA0NjcnIHk9Jy01OS40NDU2ODgnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTM2LjU4MjctNTYuOTA1NUg3MS42OTY4NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3MS45NDY4NCwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguNTA1MzcsLTY0LjU3ODQxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNi43OTQ3MjUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNi43OTQ3MjUnIHk9Jy02MC40NDc1MDEnPk48dHNwYW4geD0nLjI2MzU0MSc+ZjwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \DiagramSquare {
              width = 3cm,
              nw = {M(A_{1},\ldots ,A_{n})},
              ne = MB,
              sw = {N(A_{1},\ldots ,A_{n})},
              se = NB,
              north = Mf,
              south = Nf,
              west = {h_{A_{1}} \times  \cdots  \times  h_{A_{n}}},
              east = {h_{B}},
            }
          ]]></fr:resource-source></fr:resource></fr:figure></fr:li>
        <fr:li>For each relation symbol <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1},\ldots ,A_{n}]]></fr:tex>, there is a morphism <fr:tex
display="inline"><![CDATA[g\colon MR\to NR]]></fr:tex> such that the following diagram commutes:
          
    
      
      <fr:figure><fr:resource
hash="62110a92adaa00deaa43a4497b96dec2"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI0NS41OTU3NjZwdCcgaGVpZ2h0PScxMTAuOTIxNDg0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTYzLjczMDUxMSA3My45NDc2NTYnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOMEFBb0FBQUFBQTlnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdpTUp5NDJOdFlYQUFBQUZBQUFBQU1RQUFBRHdCQ1FEMFoyeDVaZ0FBQVhRQUFBQ2xBQUFBcVA3UnJWUm9aV0ZrQUFBQ0hBQUFBQzhBQUFBMktTdWtQbWhvWldFQUFBSk1BQUFBSGdBQUFDUUdjZ0E2YUcxMGVBQUFBbXdBQUFBTUFBQUFEQWg5QVNac2IyTmhBQUFDZUFBQUFBZ0FBQUFJQUJvQVZHMWhlSEFBQUFLQUFBQUFGd0FBQUNBQUJRQWpibUZ0WlFBQUFwZ0FBQURPQUFBQk9CTi9LcnR3YjNOMEFBQURhQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FNbUJpU1FVbHlXRHBUY3puQ2RXZkdQRVFNRHN5THpPYUF3STBMRi8vOE1EQUFyekErVUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lOSUEwRzVCbUJNcHVaN2orL3orUUQ2Yi9lLzNYQnFzQ0FnQ3ZWQW4zQUFBQWVOb1ZqVThLZ2tBY1JuL2YrR2RxMUNUVVVTTXdMWFFaR09naXlQUFV0Z3Q0cCs3UXJoc0VEcTUwMHhWcWVvc0hEejc0Q0hTbkowMDRrME1Vck1DTHNycWdyZVdFM1NZNlFGdnVRVW1PYlBzWGFVQ1A3NGU5V1VDNURwNUJSdmErT0lMYlZWbVZIYXF5YmRvbVE0Zm1WTWVTdlZSL3RjeFE4SG4wUk1LTVlCaldZSW5qanNxekZxRUpLTlhmVEpGYXMvTEJZcTRIdm9nWmZEVzRScnJVbHo4dFdoKzZBQUFBZU5wallHUmdZQURpUDg4MmJvL250L25Ld016Q0FBS1BIVGNzUU5ELzN6RlBaQklHY2prWW1FQ2lBSFJiREhzQWVOcGpZR1JnWUZiOFl3UWtKeklVTXhRejNXRUFpcUFBWmdCYW93T3dBQUFEa1FBQUFWc0Fjd09SQUxNQUFBQUFBQm9BVkhqYVkyQmtZR0JnWmxCaUFORU1VQklKQUFBRUNnQXBBSGphVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9GUmlZMkZnWW1YcUF0aWdESEdRSFNKRnFqcnl1M3U0SG5yRDZYay83b0NTSHpLZWsvRWE5M055Q2xGL1hQRENXK0twcUVYaWtnK1dUTWp5bVRoek5vbHpTYjRTRjd4elNUd1YvenR4eVNlUGJkZmU3cjMxYXQ4WjY5MjVEZVA2WUgxb09xZFd1b3A2WjUzMXg5NGFkUnFWR1pvd1hGdFY2MHJYYk9sb3VYR254K0pSN01VeGtSMW55UUlqYXc3UkNUU1NPbW10MEZULzhwM2tMbmFPOFpPUnpra1NKVFRJVlpCOWxiYWlqcGVhK2hmemVUQlBBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSWUFBb0FBQUFBQlBnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxL1dOdFlYQUFBQUU0QUFBQU1RQUFBRHdBclFCeFoyeDVaZ0FBQVd3QUFBR1RBQUFCeUxQYVNzQm9aV0ZrQUFBREFBQUFBQzhBQUFBMktXR2xEMmhvWldFQUFBTXdBQUFBSHdBQUFDUUhKUU9FYUcxMGVBQUFBMUFBQUFBTUFBQUFEQXIrQU1Wc2IyTmhBQUFEWEFBQUFBZ0FBQUFJQUdZQTVHMWhlSEFBQUFOa0FBQUFHQUFBQUNBQUJnQlVibUZ0WlFBQUEzd0FBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUVUQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1Yc1U0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpNaGpadmdQNURORHBKSFUvQWNLQXdEb1FRMUtlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPakxrL2Y4UDVJUHAvd2YrVHdHckFnSUFsU1VKR0FBQUFIamFIWTgvYjlOUUZNWGZ1ZS94bnY4ODIvR2YyR2tUUXQwVVc2bG9uS1RGVmhCeVFsUUZJaEJEaHc0VkN4SUxBd3RJekl5SWtZL0J6Q2RnS2VJN3NESHdCUmhwc0xubkx1ZWU0WjRmSS9aNnQrUFg5Sk10MkVQR0VBNXhXc1pKckFwNHlQSWFTVnhXQlZJbFBaSnFpQ3FKRXhkdGVKamxXVm5WcUZCakhpdWUwdS8zNkUzdEVOaGZyYmZuQVJCcTQ0RncvSnNmb2VCUHRRUmxocTBBWDc0N213aWJvTnpaZW9qUHFuT29yMzVoUk4vK2Z2SWRTTjBuRG5CMHVpYWcvTTBWU0x5SmJET3dRRnczUndHdUxOb2pqQ2Ewc2JWK2UvT1ZOUVAyWXZlSEgrT2FYVEMyNU9YOU1zdmQ1Z2xHZWRPMUtsdkZTZE40SG5lbGgzYTdzdlUxVGh1c1NNbEdFK1QvcWNxOGRkTGpia3RhZlU4ZFM4TGZQOGcwbWRveEdnb3JIQzRPTGxYLzVXYjduTG9pY1MxQmFiYjBoTkhtdDNWbmZGNHNpY3p3aEdqN2JON3o3eHBxYkpxRGZnejU2dVAwSkhiOEk5RGppV1VTV2JlS3dhQVFkRndmcmVqUjR0N0tydE9CM1JseHJBdXZ5ZTFvRmdXRndIUzhGeFFmaWlja1puSHZMRXErM0FtOUlCaXlmdzY2T20wQWVOcGpZR1JnWUFEaXk4YnhuK1A1YmI0eU1MTXdnTUJqeHcwTEVQVC9yOHpIbWU0Q3VSd01UQ0JSQUZWWERKQUFlTnBqWUdSZ1lHYjR6OERBd0tMS0VNTVF6WHljQVNpQ0FwZ0JRVjRDc2dBRFZBQUFCQ1VBYVFPRkFGd0FBQUFBQUdZQTVIamFZMkJrWUdCZ1pnaG1ZR0lBQVVZR05BQUFDT29BVzNqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvTURhaFlHSmxha0xZQmRsc0kyY0VBbXA2dGpmM1lmeDBEZGNuZnRoQXpVL0ZOeXZZSmIwZmlXVnVBZFhUSmxubm9oN3kxeXo0SjBuaXZKWmtsYytNcGZTZkdhdWVPRXI4MFR5Nzh3MUszNDN3VjJ1ZzQxcUY0eU4vdVJjdDk3YjJIZkJxNlZ1a3Q5YWIrTmhzRVlkYjhxTVhUK2VuV3AxbzFzMkJCd1hyZ3hZSW9xZEpDYXg1eVNkbzJQTlBpVzljSkJjc1VUVC9PdTMwdnUwT2FTZmpHeU8zRVFOb3l4NjBiTnNGVzE2cVduL0FNZ1JMKzhBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNY0FBb0FBQUFBQTRRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVXgxRzJOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDRVoyeDVaZ0FBQVdRQUFBQmtBQUFBWkRGdUFySm9aV0ZrQUFBQnlBQUFBQzBBQUFBMktPdWs2R2hvWldFQUFBSDRBQUFBSGdBQUFDUUZ5d0xXYUcxMGVBQUFBaGdBQUFBSUFBQUFDQVlLQUpKc2IyTmhBQUFDSUFBQUFBWUFBQUFHQURJQUFHMWhlSEFBQUFJb0FBQUFGd0FBQUNBQUJBQWdibUZ0WlFBQUFrQUFBQURLQUFBQk11c0lrZVp3YjNOMEFBQUREQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1abVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvYU1oZ3lNL3dIOHBraDBraHEvZ09GQWFOM0RGZ0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aUcvLzlEeVA4WHdId0dBRkZIQm8wQUFBQUFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FlTnBqWUdSZ1lBRGlIK3hHVCtQNWJiNHlNTE13Z01Canh3MExrR25tSUtiVlFJcURnUW5FQXdBanlRbXpBQUFBZU5wallHUmdZR2I0endBa2d4Z21NVFF5bVRNQVJWQUFFd0JDM0FLb0FBQURVZ0FBQXJnQWtnQUFBQUFBTWdBQWVOcGpZR1JnWUdCaWtHY0EwUXhRRWdrQUFBT2tBQ1VBZU5vOWpER3J3akFVaGI5aUZlMGJIQVNITjBqd0I0UktuNXViZzVPcnc5dXNDZEtocWFTMTZDTCtkRzlEOEFZTzN6M24zQUFaTHhLR1NaZ0hIU2FWTjQ4ODVvZEY1SW40cThnWnY2d1prYVF6Y1Zic0lxZE0rWTg4WmtrWmVTTCtJM0xHSCs5OVU5L3VuZlhxMkJqcjNhWDIyNVAxYmRVNHRkSDVzQjZzcy83Y1dhUEtweko5MWZiWFdoVTYxd1Y3R21wdTNPbXdlQlJIY1V4Z3gwVXl6NVpUMkZzcXlaeDBObWp5YjNxUTFJWEdPZnhpcEZIeUZEWDBjdE9LWHFXcktNS2RwdmdBVlRJdVF3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmdBQW9BQUFBQUE5UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFVOejdHTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUNnQUFBQXJLQUNIYVJvWldGa0FBQUNCQUFBQUM0QUFBQTJLQnFrUFdob1pXRUFBQUkwQUFBQUh3QUFBQ1FFandHOGFHMTBlQUFBQWxRQUFBQUtBQUFBQ2dSR0FHUnNiMk5oQUFBQ1lBQUFBQWdBQUFBSUFDd0FWbTFoZUhBQUFBSm9BQUFBRndBQUFDQUFCUUFaYm1GdFpRQUFBb0FBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFEVUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtdk1jNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwVFVZTkJrWnZnUDVETkRwSkhVL0FjS0F3RHZrUTBlZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pFajV6OEFZd3N6QUlNN0F3Q3FpcEthdXgyaXVabVp1eDJqRXo4akhLTTRtSk04b3hoZ3NsbXlvS2NQSUtLTm1tQ2JHeUJQbndjamtFcy9QL0kwcktUNWlsYTNUd3REa1ZCNkJ4RC90bGYvK3BRaXlNQUFCSTRNbDBGeE5pTG1NWW16c2ZJeEtwa0JUMVUzVTlCblZ6TTJNeE1UbEdCazF3Q2FLOHNaNk1RWDdDREV6TW9xQzdXR0FtcGowdDNYaEIxOGhGaWF3UFFBVkpDRk1lTnBqWUdSZ1lBRGlUNi9QWFk3bnQvbkt3TXpDQUFLUEhUY3NRTkQvR1pnYW1FRmNEZ1ltRUFVQWJYNExuUUFBZU5wallHUmdZR2I0ejhEQXdOVEFZTWxneVJqQ0FCUkJBVXdBTzJ3Q1VBQUNnQUFBQVkwQVpBQTVBQUFBQUFBQUFDd0FWbmphWTJCa1lHQmdacEJnQU5FTVVCSUpBQUFERUFBZkFIamFSWXd4YjhJd0VJVy9pQVNKZE9oU2RXQUFEOHhXb2pCM1lXQmlaV0lCYktJTWNaQVRJaUdoanYzZFBZd2xibmo2N3IxM0IrVDhrdkNjaE0rZ3owbkpaSHR4eGdkZmthZXlMU1BuekZreElVbG40aXo0aVp4S2NvaWM4YzBsOGxUOFIrU2NOWCticnIzZUJ1dlZyalBXdTNQcnkySnZmZDkwVHBXNkNQdldPdXVQZ3pYcWRGZG1iUHF4YmxXbEMxMnhvYVBseW8wQmkwZXhFOGNFZHB3bDg1UVU3SVBUMDBqcXBGV2l4WDNuVzhsZDZCekRKeU9kRTNkUnd5aFh2V2d0YlVVVkxqWFZQMk05THc4QUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1RQUFvQUFBQUFBM2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVeDBvMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNFWjJ4NVpnQUFBV1FBQUFCWUFBQUFXT2ErZEJWb1pXRmtBQUFCdkFBQUFDMEFBQUEyS0d5azVtaG9aV0VBQUFIc0FBQUFJQUFBQUNRRlZnSTVhRzEwZUFBQUFnd0FBQUFJQUFBQUNBVWFBSEJzYjJOaEFBQUNGQUFBQUFZQUFBQUdBQ3dBQUcxaGVIQUFBQUljQUFBQUZ3QUFBQ0FBQkFBYmJtRnRaUUFBQWpRQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBREFBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9hTWhneU0vd0g4cGtoMGtocS9nT0ZBZFNCRE44QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpRy8vOUR5UDhYd0h3R0FGRkhCbzBBQUFBQUFRQndBQUFCNUFLcEFCa0FBQUVSQmhZN0FSVXZBUThCTlRNeU5pY1JEZ0VuTlJZMk56WVdBVmNESUVrbloxQndSaWRKSUFNc1ZCUWhkRE1WQ3dLTC9ja2FGU1VEQVFJQ0pSVWFBZ29VQ1FFa0FoWXVBUW9BZU5wallHUmdZQURpWHJPZ3ovSDhObDhabUZrWVFPQ3g0NFlGeURUVFphYVZRSXFEZ1FuRUF3QW5GUW9qQUFBQWVOcGpZR1JnWUdiNHo4REF3SFNab1lBaG1mRUpBMUFFQlRBQkFGYWFBNVFDMHdBQUFrY0FjQUFBQUFBQUxBQUFlTnBqWUdSZ1lHQmlrR0lBMFF4UUVna0FBQU1uQUNBQWVObzlqREdyd2pBVWhiOWlGZTBiSEFTSE4wandCNFJLSDdpNE9UaTVPcnpObWlBZG1rcGFpeTdpVC9jMkJHL2c4TjF6emcyUThTSmhtSVI1MEdGU2VmUElZMzVZUko2SXY0cWM4Y3VhRVVrNkUyZkZMbkxLbFAvSVk1YVVrU2ZpUHlKbi9QSGVOL1h0M2xtdmpvMngzbDFxdnoxWjMxYU5VeHVkRCt2Qk91dlBuVFdxZkNyVFYyMS9yVldoYzEyd3A2SG14cDBPaTBkeEZNY0VkbHdrODJ3NWhiMmxrc3hKWjRNbS82WUhTVjFvbk1NdlJob2xUMUZETHpldDZGVzZpaUxjYVlvUFdLd3VTd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVRnQUFvQUFBQUFCZXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZSjA4bU50WVhBQUFBRTRBQUFBTWdBQUFEd0Fod0MvWjJ4NVpnQUFBV3dBQUFJUkFBQUN0UGIwK2pob1pXRmtBQUFEZ0FBQUFDOEFBQUEyS0dDa01XaG9aV0VBQUFPd0FBQUFJQUFBQUNRRjBBSHRhRzEwZUFBQUE5QUFBQUFRQUFBQUVBcC9BS2xzYjJOaEFBQUQ0QUFBQUFvQUFBQUtBY2dBNG0xaGVIQUFBQVBzQUFBQUdBQUFBQ0FBQndCUmJtRnRaUUFBQkFRQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRTFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbW1zODRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWjhoalp2Z1A1RE5EcEpIVS9BY0tBd0RvZmcxa2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS1pqRGsvZjhQNUtlRDZQK3ovazhGcXdJQ0FKbmhDVUFBQUhqYWpkRTliOU5RRkFiZ2U4NTFmQnQvM1RpMjc0WFdOWEUrN0VDRGt6YUpUWlhnMUUyRVZDcmFpb0dxQ0xHeEl5RWtCSUxmZ1BnSlRHek03SWorSXlTV0ZMc0RBd05DNzNxRzl6a3ZRVEs0dW9zOStFNFNzaVFFcUFWTWplSWN4bnRDdWlxVFlpelNMSWNGcUN5Qk9NMnFCQ0J6eU1vRHVvQTBqdUpJWlNxelFNaTk2aFREbC9WWGI0YlBGZWdJVzREVjlPM1FuWGQ4d1dSMlZGd2dMYmg5ZE5HZm1uU3phWHJ3YVVqQjlTYWJ5NWJYc0NHS2cwUGZZUEIyWFF5ZlV2UUcyNkhqNklGV1E5RDltNlBXczdFQzUyY3ZUaHkrb3RBVkRRRU5lLzNyRzlkN0hRWDYwNmc0T00yZzErSW1LVEhrMGRWUGZJZVg1TGlTbFpVRFpDcUhxcXVuVm1YVHNReEtiNWwyRkU5S1RNV0w0dW9IWExHZ2s4QTBjM0tJT3UzcmwyU3BZRkNjK0kvM0gwd01RQmNkdzlTb2YydmVSRnRUUWVwMkorL2ZBMnBhUWlDSy92enNCcTg1cmZxR0p1dE51L1pSUWQ2dE53QXN0aHIwQUwrc0w4TXgxSVlUTTVtcnM2MHd0TnU0dU45RWxDTXBFbVY0MjlCYjNjUGxycmVMdU93TC9lR0hhSXZyNEpnQ1Z5YlhGSTF2TUlVYXBYTlVPai9ERDNKS3lJS20wOGsxd1lJaEpDVXBSMUhObFFyNVgzYkswYUpSL0g3SDBGWHVCRzI5eGpSZEJkZXV4OHNWaytjSGd5ZjBENzAxKzR0dThJcnU3dXdmNzFoczI2M1ZQZCtGNHVzb2tRM1BCemhJWEIwUWVSRTRYYnd6RFdlSXlkRy85YzB4eFhrZWJyOCtjN2xWcmsxK0F5dS9XTnNBQUFCNDJtTmdaR0JnQUdML1d3enk4ZncyWHhtWVdSaEE0TEhqaGdVSStyOHUwekdtNDBBdUJ3TVRTQlFBR2tVS29BQjQybU5nWkdCZ1p2alB3TURBZEpsQmgwR1VhUkVEVUFRRnNBQUFSVWdDd3dMR0FBQUNPZ0FzQXF3QVRRTFRBREFBQUFBQUFHNEE0Z0ZhQUFCNDJtTmdaR0JnWUdFSVlHQmlBQUZHQmpRQUFBaTZBRmw0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWUlBQW9BQUFBQUIxd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVkMHdtTnRZWEFBQUFFNEFBQUFRZ0FBQUZRQW13RkJaMng1WmdBQUFYd0FBQU1WQUFBRDlEbXBVUGxvWldGa0FBQUVsQUFBQUM4QUFBQTJLY2VrVkdob1pXRUFBQVRFQUFBQUhnQUFBQ1FIVkFLWmFHMTBlQUFBQk9RQUFBQWNBQUFBSEJIT0FWTnNiMk5oQUFBRkFBQUFBQkFBQUFBUUFpUURQRzFoZUhBQUFBVVFBQUFBR0FBQUFDQUFDZ0JkYm1GdFpRQUFCU2dBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGL0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtNm1hY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcnFNQVF4TS93SDhwa2gwa2hxL2dPRkFkYnBEUGtBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0J5QU5BOERCMUNPaFVHSFFZL0JrY0dQSWVqL2Y2QW9oT2NMNHYyLyt2L0svMFAvdC8vZkF0WUhCd0N1SWcvVEFBQjQybFdTejR2Y1pCekc4N3p2bXplVHljOUpaaEpuWnpLenU3T2J0TE03WGR6Skp1eHFwOGl3VnBCS0ViYmRvaWRCdDRJOTZTcnN4VldrdGFnVXZQbC9DRjZLdDRySG9uaFVVQThpbmdTdm1maE54Z29OeVp2M044L24rendLbE9QeVFIbXMzRkU2aXBKTEJ6YVNPSjhoVHpVNXVvUTB5NFBIWWlRM0FuQm5aUXpodDd0UjFMMkNtMm56V1pqTVhqbmU5NFNEMWUwaGhFSVBsRnYwUFZMZVVScDBuNDMxT00xMmcwY1lUb2IwWmtIVkRta2ZVemJLa3YzS2ZsWjJsRjNhaVN6ZkRVSy9IVXl6UU81QVMrSWt6Y0lneTNld3BzbDJFR2FoRFpxdnBxY2tiOHEvd1p1eWJVbk1na2tIcHZyZWVVT0ZaZmdwMTdWRitZclY5eTBPU3owNU5tSHE2N092L2xwN245MXdvVHZGZWVEd1NBUG5ZQTFIQTh6d3JjTlAyaHN1bUdQTGFycnBTSXkreDZ0TG51MnlGQlAyclhLVkJ0ekJBRmt0NUgrQlBxUVc3eG1RSFJrTUVYVHFWVWxycE5MUGtxcEhUS0dQR2FxT1RHTEp2LzVVQUp2N3BPLzh3NllLMXpvWXFGOHUzcEF0NTlabkFyMHR3ckxGMnllV0pTNXZ5N3VZRDF6bmM5L0VkWncyYk85ZUQ0NlhSK3hPOFl1bldWTFVMSXpJSk9BUDJNdkZCN2JnSFhaVy9HRHJmaGRndWwzVDlxZ2RyN0sreTNsRVc3Vlc4WkM5VkJIM3FRaWRtdlZDV2ZDNzdLRnl1V0sxTVpJSlQzZ0ZGaTVkV1U4SW91S0tkL0FFckljOGl4TkpLMFBrVkFFS2tBMHVIM0JWTnhxbGZrL0Z5cFpmNDVpQW9STFFmUkZ0UkxaNzN6WGtiNmRBZjh2aFpPRHQyenBqTU1YekUzYTkrTTV1OElDOTdoVy8yM3ByaGJGK1JXQTRTNEpOalMxRmExYnhKMzQwV2owU3UyUVVzdnBmclBJMUx2L2dLckc0eW1zVlRSV2FHZlpJZUZ5RjNCOGdiRHUxYVZNeU1jdkRvQjVyNUU5bDdSV3lhNCs0Umx3ang5dFBSZEpQUjdXdGEzUUhIY0Q1L04zREkzL1FFMmxuZjIvbU5COTBEN25RQkx4bi9JeWlLVlVFZG5SZ2puM3ZvbEFOcWJQSjRkbWNrLzlXNCtPUEtMVzJUZlovMFkrcEpoaWRuREh4NGxWMnV2Z0htOEhxVVgvdWFTWUQ4eFkvYWZsellmZGd2UnV0SWNsTnpwaHVqYjBMS211cVJ2Q0MyNzNrSjFZMFk0dS92U2VaK0MvZmxJbjlGcXNMZGpTL2xrNy9CUU83ak1jQUFBQjQybU5nWkdCZ0FPSXNqUldINC9sdHZqSXdzekNBd0dQSERRc1E5SDhyRmwybXUwQXVCd01UU0JRQU1rMEs0UUI0Mm1OZ1pHQmdadmpQQUNRZk1xajgzOENpeXdBVVFRSHNBR0FsQS9RQUFBSjJBQUFCSEFCWUFSd0FXUU1BQUNRRDRRQXNBellBS0FNSkFDb0FBQUFBQUNnQVBBQ1FBUVlCYkFINmVOcGpZR1JnWUdCbmlHRmdZZ0FCUmdZMEFBQUtOd0JvZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTU4LjUxNDEzOCwtNjMuMzcyNjI4KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTkuMjMwOSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTguNTE0MTM4LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU4LjUxNDEzOCcgeT0nLTYzLjM3MjYyOCc+TTx0c3BhbiB4PSctNDcuNzYyNzk1Jz5SPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTguMzk3NTUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01OC41MTQxMzgsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTguNTE0MTM4JyB5PSctNjMuMzcyNjI4Jz5OPHRzcGFuIHg9Jy00OS40MjMyNDgnPlI8L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03LjQxNjMyLC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU4LjUxNDEzOCwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01OC41MTQxMzgnIHk9Jy02My4zNzI2MjgnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuNDk3NzYsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU4LjUxNDEzOCwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01OC41MTQxMzgnIHk9Jy02My4zNzI2MjgnPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ3Ljc2Mjc5NScgeT0nLTYzLjM3MjYyOCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDMuODg4NDIyJyB5PSctNjMuMzcyNjI4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0zNi40MTY0MjMnIHk9Jy02MS44NzgyNDcnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTMxLjk0NzA1MycgeT0nLTYzLjM3MjYyOCc+LDx0c3BhbiB4PSctMjcuNTE5MjQ1Jz4uPC90c3Bhbj48dHNwYW4geD0nLTIzLjA5MTQzNyc+LjwvdHNwYW4+PHRzcGFuIHg9Jy0xOC42NjM2MjknPi48L3RzcGFuPjx0c3BhbiB4PSctMTQuMjM1ODIxJz4sPC90c3Bhbj48dHNwYW4geD0nLTkuODA4MDEzJz5BPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIuMzM2MDE0JyB5PSctNjEuODc4MjQ3Jz5uPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzMuMDg2OTc4JyB5PSctNjMuMzcyNjI4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUzLjMzMTEsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01OC41MTQxMzgsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTguNTE0MTM4JyB5PSctNjMuMzcyNjI4Jz5OPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00OS40MjMyNDgnIHk9Jy02My4zNzI2MjgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQ1LjU0ODg3NCcgeT0nLTYzLjM3MjYyOCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzguMDc2ODc1JyB5PSctNjEuODc4MjQ3Jz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0zMy42MDc1MDYnIHk9Jy02My4zNzI2MjgnPiw8dHNwYW4geD0nLTI5LjE3OTY5OCc+LjwvdHNwYW4+PHRzcGFuIHg9Jy0yNC43NTE4OSc+LjwvdHNwYW4+PHRzcGFuIHg9Jy0yMC4zMjQwODInPi48L3RzcGFuPjx0c3BhbiB4PSctMTUuODk2Mjc0Jz4sPC90c3Bhbj48dHNwYW4geD0nLTExLjQ2ODQ2Nic+QTwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zLjk5NjQ2NycgeT0nLTYxLjg3ODI0Nyc+bjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxLjQyNjUyNicgeT0nLTYzLjM3MjYyOCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTUuOTg2NDMgMEg0Ny40NDIyMScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxNi4yMzY0MywwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ3LjY5MjIxLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzAuODY0MzIsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU4LjUxNDEzOCwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTg1LjM1ODI2LTguOTA5NzNWLTQ3LjQ5NTc3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsODUuMzU4MjYsLTQ3Ljc0NTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg4OC42MjIxNSwtMzAuMjAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01OC41MTQxMzgsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTguNTE0MTM4JyB5PSctNjMuMzcyNjI4Jz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01My44NDk4OCcgeT0nLTYyLjM3MDgxNSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNDguNjg4NTk5JyB5PSctNjAuODc2NDE5Jz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy00Mi40ODgwMzcnIHk9Jy02My4zNzI2MjgnPsOXPHRzcGFuIHg9Jy0zNC40NDcxNzcnPsK3PC90c3Bhbj48dHNwYW4geD0nLTMwLjcyMDQnPsK3PC90c3Bhbj48dHNwYW4geD0nLTI2Ljk5MzYyMyc+wrc8L3RzcGFuPjx0c3BhbiB4PSctMjIuODEzMzQ0Jz7DlzwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xNC43NzI0ODQnIHk9Jy02My4zNzI2MjgnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTEwLjEwODIyNicgeT0nLTYyLjM3MDgxNSc+QTx0c3BhbiB5PSctNjEuMzc0NTY2Jz5uPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTE1LjE1MzA5LTU2LjkwNTVINDguMjc1NTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsMTUuNDAzMDksLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjUyNTU2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzMC44NjQzMiwtNTkuNzE3MzIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01OC41MTQxMzgsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \DiagramSquare {
              width = 3cm,
              nw = {MR},
              ne = {M(A_{1},\ldots ,A_{n})},
              sw = {NR},
              se = {N(A_{1},\ldots ,A_{n})},
              north/style = {>->},
              south/style = {>->},
              east = {h_{A_{1}} \times  \cdots  \times  h_{A_{n}}},
              west = {g},
            }
          ]]></fr:resource-source></fr:resource></fr:figure></fr:li></fr:ul>
    </html:td>

  </html:tr>

</html:table>
<fr:p>Composition and identities are defined componentwise from those in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>