<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>487</fr:anchor><fr:taxon>Lemma</fr:taxon><fr:addr>ct-0012</fr:addr><fr:route>ct-0012.xml</fr:route><fr:title>Union as a pushout of intersection</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>\mathcal { C }</fr:tex> be a <fr:link
href="ct-000X.xml"
type="local"
addr="ct-000X">coherent category</fr:link> and <fr:tex>A_{1}</fr:tex> and <fr:tex>A_{2}</fr:tex> be subobjects of <fr:tex>A</fr:tex>.
  Then the following square is both a pullback and a pushout in <fr:tex>\mathcal { C }</fr:tex>.
</fr:p>
    
      
      <fr:embedded-tex
hash="4875275966500364a86ee53cf416e07c"><fr:embedded-tex-preamble>
         
   \RequirePackage {tikz}
   \RequirePackage {amsmath}
   \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

   \definecolor {catccolor}{RGB}{255,244,138}
   \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
   \tikzstyle {catc}=[catccolor!60]
   \tikzstyle {catd}=[orange!40]
   \tikzstyle {cate}=[red!40]
   \tikzstyle {catf}=[blue!10]
   \tikzstyle {catg}=[green!25]


   \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
   \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

   \NewDocumentCommand \CreateRect {D&lt;&gt;{} m m}{
     \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

     \path [spath/save = #1north] (#1nw) to (#1ne);
     \path [spath/save = #1west] (#1nw) to (#1sw);
     \path [spath/save = #1east] (#1ne) to (#1se);
     \path [spath/save = #1south] (#1sw) to (#1se);
  }
 
         
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}-&gt;
    },
    cover/.style = {
      -{Triangle[open]}
    },
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {-&gt;},
    square/south/.style = {-&gt;},
    square/west/.style = {-&gt;},
    square/east/.style = {-&gt;},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff
 
      </fr:embedded-tex-preamble><fr:embedded-tex-body>
   \DiagramSquare {
    nw = {A_{1}  \cap  A_{2}},
    ne = {A_{2}},
    sw = {A_{1}},
    se = {A_{1}  \cup  A_{2}},
    north = {i_{2}},
    north/style = {&gt;-&gt;},
    west = {i_{1}},
    west/style = {&gt;-&gt;},
    south = {u_{1}},
    south/style = {&gt;-&gt;},
    east = {u_{2}},
    east/style = {&gt;-&gt;},
  }
</fr:embedded-tex-body></fr:embedded-tex>
    
  <fr:p>
  where the <fr:tex>i</fr:tex>'s and the <fr:tex>u</fr:tex>'s are the product projections and coproduct injections in <fr:tex>\mathsf { Sub } (A)</fr:tex> respectively.
</fr:p>
    
      
      <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>442</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:parent>ct-0012</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    The diagram commutes since <fr:tex>\mathsf { Sub } (A)</fr:tex> is a preorder: any two morphisms <fr:tex>A_{1}  \cap  A_{2}  \rightrightarrows  A_{1}  \cup  A_{2}</fr:tex> in <fr:tex>\mathsf { Sub } (A)</fr:tex> are equal.
    Moreover, this diagram is a pullback in <fr:tex>\mathsf { Sub } (A)</fr:tex> as the pullback of <fr:tex>u_{2}</fr:tex> along <fr:tex>u_{1}</fr:tex> is just the largest subobject contained in both <fr:tex>A_{1}</fr:tex> and <fr:tex>A_{2}</fr:tex>, i.e., the intersection.
    Then since both the inclusion <fr:tex>\mathsf { Sub } (A)  \hookrightarrow   { \mathcal { C } _{/{ A }}}</fr:tex> (as a right adjoint) and the forgetful functor <fr:tex>{ \mathcal { C } _{/{ A }}}   \to   \mathcal { C }</fr:tex> preserve pullbacks, the square is a pullback in <fr:tex>\mathcal { C }</fr:tex>.
  </fr:p>
  <fr:p>
    Note that the forgetful functor <fr:tex>{ \mathcal { C } _{/{ A }}}   \to   \mathcal { C }</fr:tex> preserves arbitrary colimits, but the inclusion functor does not necessarily preserve them, so the same strategy does not work for pushout.
  </fr:p>
  <fr:p>
    Let <fr:tex>f \colon A_{1} \to B</fr:tex> and <fr:tex>g \colon A_{2} \to B</fr:tex> be morphisms in <fr:tex>\mathcal { C }</fr:tex> such that <fr:tex>fi_{1} = gi_{2}</fr:tex>.
    Consider the joint morphisms <fr:tex>(f,u_{1}) \colon A_{1} \rightarrowtail B  \times  (A_{1}  \cup  A_{2})</fr:tex> and <fr:tex>(g,u_{2}) \colon A_{2} \rightarrowtail B  \times  (A_{1}  \cup  A_{2})</fr:tex>, which are monic because <fr:tex>u_{1}</fr:tex> and <fr:tex>u_{2}</fr:tex> are.
    Let <fr:tex>(m,n) \colon U \rightarrowtail B  \times  (A_{1}  \cup  A_{2})</fr:tex> be the union of <fr:tex>(f,u_{1})</fr:tex> and <fr:tex>(g,u_{2})</fr:tex> in <fr:tex>\mathsf { Sub } (B  \times  (A_{1}  \cup  A_{2}))</fr:tex>.
    We show that <fr:tex>n</fr:tex> is an isomorphism.
  </fr:p>
  <fr:p>
    The functor <fr:tex>\exists _{ \pi _{2}} \colon \mathsf { Sub } (B  \times  (A_{1}  \cup  A_{2})) \to \mathsf { Sub } (A_{1}  \cup  A_{2})</fr:tex> constructed in <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma"></fr:ref>, as a left adjoint, preserves arbitrary unions.
    Let us consider the image of <fr:tex>n</fr:tex>:
  </fr:p>
  <fr:tex
display="block">      \begin {align*}        \exists _{ \pi _{2}}(m, n) &amp; \cong   \mathsf { Img } ( \pi _{2}(m,n)) \\                        &amp; \cong   \mathsf { Img } (n) \\                        &amp; \cong   \exists _{ \pi _{2}}((f,u_{1})  \cup  (g,u_{2})) \\                        &amp; \cong   \exists _{ \pi _{2}}(f,u_{1})  \cup   \exists _{ \pi _{2}}(g,u_{2}) \\                        &amp; \cong   \mathsf { Img } ( \pi _{2}(f,u_{1}))  \cup   \mathsf { Img } ( \pi _{2}(g,u_{2})) \\                        &amp; \cong  u_{1}  \cup  u_{2} \\                        &amp; \cong   \mathsf {id} _{ A_{1}  \cup  A_{2} }       \end {align*}   </fr:tex>
  <fr:p>
    Thus, if <fr:tex>n</fr:tex> is monic then <fr:tex>\mathsf { Img } (n)  \cong  n  \cong   \mathsf {id} _{ A_{1}  \cup  A_{2} }</fr:tex>, i.e., <fr:tex>n</fr:tex> is the whole of <fr:tex>A_{1}  \cup  A_{2}</fr:tex>, so it is an isomorphism.
    Let <fr:tex>a , b \colon V \rightrightarrows U</fr:tex> be a pair of morphisms such that <fr:tex>na = nb</fr:tex>.
    To show that <fr:tex>a = b</fr:tex>, it suffices to show <fr:tex>ma = mb</fr:tex> since <fr:tex>n</fr:tex> and <fr:tex>m</fr:tex> are jointly monic.
    To this end, we show that the equalizer of <fr:tex>ma</fr:tex> and <fr:tex>mb</fr:tex> is an isomorphism.
  </fr:p>
  <fr:p>
    The object <fr:tex>U</fr:tex> (when viewed as the maximal subobject in <fr:tex>\mathsf { Sub } (U)</fr:tex>) is the union of the coproduct injections <fr:tex>\ell</fr:tex> and <fr:tex>k</fr:tex>.
  </fr:p>
  
    
      
      <fr:embedded-tex
hash="d609831419307d3fae4638deeea0b8e4"><fr:embedded-tex-preamble>
         
   \RequirePackage {tikz}
   \RequirePackage {amsmath}
   \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

   \definecolor {catccolor}{RGB}{255,244,138}
   \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
   \tikzstyle {catc}=[catccolor!60]
   \tikzstyle {catd}=[orange!40]
   \tikzstyle {cate}=[red!40]
   \tikzstyle {catf}=[blue!10]
   \tikzstyle {catg}=[green!25]


   \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
   \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

   \NewDocumentCommand \CreateRect {D&lt;&gt;{} m m}{
     \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

     \path [spath/save = #1north] (#1nw) to (#1ne);
     \path [spath/save = #1west] (#1nw) to (#1sw);
     \path [spath/save = #1east] (#1ne) to (#1se);
     \path [spath/save = #1south] (#1sw) to (#1se);
  }
 
         
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}-&gt;
    },
    cover/.style = {
      -{Triangle[open]}
    },
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {-&gt;},
    square/south/.style = {-&gt;},
    square/west/.style = {-&gt;},
    square/east/.style = {-&gt;},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff
 
      </fr:embedded-tex-preamble><fr:embedded-tex-body>
     \begin {tikzpicture}[diagram]
       \node  (1) {$A_{1}$};
       \node  [right = of 1] (2) {$U$};
       \node  [right = of 2] (3) {$A_{2}$};
       \node  [below = of 2] (4) {$B  \times  (A_{1}  \cup  A_{2})$};
       \draw  [&gt;-&gt;,morphism] (1) to node {$ \ell $} (2);
       \draw  [&gt;-&gt;,morphism] (3) to node[swap] {$k$} (2);
       \draw  [&gt;-&gt;,morphism] (1) to node[swap] {$(f,u_{1})$} (4);
       \draw  [&gt;-&gt;,morphism] (2) to node[desc] {$(m,n)$} (4);
       \draw  [&gt;-&gt;,morphism] (3) to node {$(g,u_{2})$} (4);
     \end {tikzpicture}
  </fr:embedded-tex-body></fr:embedded-tex>
    
  
  <fr:p>
    The pullback of <fr:tex>\ell   \cup  k</fr:tex> along <fr:tex>a</fr:tex> or <fr:tex>b</fr:tex> are the maximal subobject of <fr:tex>V</fr:tex> since isomorphisms are stable under pullback.
    Thus, we have
  </fr:p>
  <fr:tex
display="block">     V  \cong   a ^{*} ( \ell   \cup  k)  \cong   b ^{*} ( \ell   \cup  k)   </fr:tex>
  <fr:p>
    Since finite unions are stable under pullback in a coherent category, we also have
  </fr:p>
  <fr:tex
display="block">     V  \cong   a ^{*} ( \ell )  \cup   a ^{*} (k)  \cong   b ^{*} ( \ell )  \cup   b ^{*} (k)   </fr:tex>
  <fr:p>
    Now, we can decompose <fr:tex>V</fr:tex> as the union of 4 subobjects using <fr:ref
addr="ct-0011"
href="ct-0011.xml"
taxon="Lemma"></fr:ref>.
  </fr:p>
  <fr:tex
display="block">      \begin {align*}       V  \cong  V  \cap  V &amp; \cong  ( a ^{*} ( \ell )  \cup   a ^{*} (k))  \cap  ( b ^{*} ( \ell )  \cup   b ^{*} (k)) \\                     &amp; \cong  (( a ^{*} ( \ell )  \cup   a ^{*} (k))  \cap   b ^{*} ( \ell ))  \cup  (( a ^{*} ( \ell )  \cup   a ^{*} (k))  \cap   b ^{*} (k)) \\                     &amp; \cong  ( a ^{*} ( \ell )  \cap   b ^{*} ( \ell ))  \cup  ( a ^{*} ( \ell )  \cap   b ^{*} (k))  \cup  ( a ^{*} (k)  \cap   b ^{*} ( \ell ))  \cup  ( a ^{*} (k)  \cap   b ^{*} (k))      \end {align*}   </fr:tex>
  <fr:p>
    Let <fr:tex>e \colon E \rightarrowtail V</fr:tex> be the equalizer of <fr:tex>ma</fr:tex> and <fr:tex>mb</fr:tex>.
    To show that it is an isomorphism, it suffices to show that each of the 4 subobjects is contained in <fr:tex>e</fr:tex>, i.e., each of the 4 subobjects equalizes <fr:tex>ma</fr:tex> and <fr:tex>mb</fr:tex>.
    Let <fr:tex>\ell '</fr:tex>, <fr:tex>\ell ''</fr:tex>, <fr:tex>k'</fr:tex>, and <fr:tex>k''</fr:tex> be given as follows:
  </fr:p>
  
    
      
      <fr:embedded-tex
hash="457df26dd9a9518237ce44b5f088cbd4"><fr:embedded-tex-preamble>
         
   \RequirePackage {tikz}
   \RequirePackage {amsmath}
   \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

   \definecolor {catccolor}{RGB}{255,244,138}
   \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
   \tikzstyle {catc}=[catccolor!60]
   \tikzstyle {catd}=[orange!40]
   \tikzstyle {cate}=[red!40]
   \tikzstyle {catf}=[blue!10]
   \tikzstyle {catg}=[green!25]


   \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
   \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

   \NewDocumentCommand \CreateRect {D&lt;&gt;{} m m}{
     \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

     \path [spath/save = #1north] (#1nw) to (#1ne);
     \path [spath/save = #1west] (#1nw) to (#1sw);
     \path [spath/save = #1east] (#1ne) to (#1se);
     \path [spath/save = #1south] (#1sw) to (#1se);
  }
 
         
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}-&gt;
    },
    cover/.style = {
      -{Triangle[open]}
    },
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {-&gt;},
    square/south/.style = {-&gt;},
    square/west/.style = {-&gt;},
    square/east/.style = {-&gt;},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff
 
      </fr:embedded-tex-preamble><fr:embedded-tex-body>
     \DiagramSquare {
      nw = {A_{1}'},
      nw/style = {pullback},
      ne = {A_{1}},
      sw = V,
      se = U,
      north = { \ell '},
      south = a,
      west = { a ^{*} ( \ell )},
      west/style = {&gt;-&gt;},
      east =  \ell ,
      east/style = {&gt;-&gt;},
    }
     \qquad 
     \DiagramSquare {
      nw = {A_{1}''},
      nw/style = {pullback},
      ne = {A_{1}},
      sw = V,
      se = U,
      north = { \ell ''},
      south = b,
      west = { b ^{*} ( \ell )},
      west/style = {&gt;-&gt;},
      east =  \ell ,
      east/style = {&gt;-&gt;},
    }
     \qquad 
     \DiagramSquare {
      nw = {A_{2}'},
      nw/style = {pullback},
      ne = {A_{2}},
      sw = V,
      se = U,
      north = {k'},
      south = a,
      west = { a ^{*} (k)},
      west/style = {&gt;-&gt;},
      east = k,
      east/style = {&gt;-&gt;},
    }
     \qquad 
     \DiagramSquare {
      nw = {A_{2}''},
      nw/style = {pullback},
      ne = {A_{2}},
      sw = V,
      se = U,
      north = {k''},
      south = b,
      west = { b ^{*} (k)},
      west/style = {&gt;-&gt;},
      east = k,
      east/style = {&gt;-&gt;},
    }
  </fr:embedded-tex-body></fr:embedded-tex>
    
  
  <fr:p>
    First, let us consider the subobject <fr:tex>x :=  a ^{*} ( \ell )  \cap   b ^{*} ( \ell )</fr:tex>.
    Let <fr:tex>\pi _{1}</fr:tex> and <fr:tex>\pi _{2}</fr:tex> be the product projections of <fr:tex>x</fr:tex>.
  </fr:p>
  
    
      
      <fr:embedded-tex
hash="bba6ed9bb700411dcb3a06f976ca35e3"><fr:embedded-tex-preamble>
         
   \RequirePackage {tikz}
   \RequirePackage {amsmath}
   \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

   \definecolor {catccolor}{RGB}{255,244,138}
   \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
   \tikzstyle {catc}=[catccolor!60]
   \tikzstyle {catd}=[orange!40]
   \tikzstyle {cate}=[red!40]
   \tikzstyle {catf}=[blue!10]
   \tikzstyle {catg}=[green!25]


   \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
   \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

   \NewDocumentCommand \CreateRect {D&lt;&gt;{} m m}{
     \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

     \path [spath/save = #1north] (#1nw) to (#1ne);
     \path [spath/save = #1west] (#1nw) to (#1sw);
     \path [spath/save = #1east] (#1ne) to (#1se);
     \path [spath/save = #1south] (#1sw) to (#1se);
  }
 
         
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}-&gt;
    },
    cover/.style = {
      -{Triangle[open]}
    },
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {-&gt;},
    square/south/.style = {-&gt;},
    square/west/.style = {-&gt;},
    square/east/.style = {-&gt;},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff
 
      </fr:embedded-tex-preamble><fr:embedded-tex-body>
     \begin {tikzpicture}[diagram]
       \node  (1) {$A_{1}'$};
       \node  [right = of 1] (2) {$ \underline {A_{1}}$};
       \node  [right = of 2] (3) {$A_{1}''$};
       \node  [below = of 2] (4) {$V$};
       \draw  [&gt;-&gt;,morphism] (2) to node[swap] {$ \pi _{1}$} (1);
       \draw  [&gt;-&gt;,morphism] (2) to node {$ \pi _{2}$} (3);
       \draw  [&gt;-&gt;,morphism] (1) to node[swap] {$ a ^{*} ( \ell )$} (4);
       \draw  [&gt;-&gt;,morphism] (2) to node[desc] {$x$} (4);
       \draw  [&gt;-&gt;,morphism] (3) to node {$ b ^{*} ( \ell )$} (4);
     \end {tikzpicture}
  </fr:embedded-tex-body></fr:embedded-tex>
    
  
  <fr:p>
    Note that
  </fr:p>
  <fr:tex
display="block">      \begin {align*}       u_{1} \ell ' \pi _{1} &amp;= n \ell \ell ' \pi _{1} \\                     &amp;= na a ^{*} ( \ell ) \pi _{1} &amp;&amp;  \text {since $na = nb$} \\                     &amp;= nb a ^{*} ( \ell ) \pi _{1} &amp;&amp;  \text {since $ a ^{*} ( \ell ) \pi _{1} = x =  b ^{*} ( \ell ) \pi _{2}$} \\                     &amp;= nb b ^{*} ( \ell ) \pi _{2} \\                     &amp;= n \ell \ell '' \pi _{2} \\                     &amp;= u_{1} \ell '' \pi _{2}      \end {align*}   </fr:tex>
  <fr:p>
    Since <fr:tex>u_{1}</fr:tex> is monic, <fr:tex>\ell ' \pi _{1} =  \ell '' \pi _{2}</fr:tex>.
    Then
  </fr:p>
  <fr:tex
display="block">      \begin {align*}       max &amp;= ma a ^{*} ( \ell ) \pi _{1} \\            &amp;= m \ell \ell ' \pi _{1} \\            &amp;= m \ell \ell '' \pi _{2} \\            &amp;= mb b ^{*} ( \ell ) \pi _{2} \\            &amp;= mbx      \end {align*}   </fr:tex>
  <fr:p>
    Analogously, the subobject <fr:tex>a ^{*} (k)  \cap   b ^{*} (k)</fr:tex> is also contained in <fr:tex>e</fr:tex>.
    Now, we show that <fr:tex>y :=  a ^{*} ( \ell )  \cap   b ^{*} (k)</fr:tex> is contained in <fr:tex>e</fr:tex>.
    The proof for <fr:tex>a ^{*} (k)  \cap   b ^{*} ( \ell )</fr:tex> is analogous to this one.
  </fr:p>
  <fr:p>
    Let <fr:tex>\nu _{1}</fr:tex> and <fr:tex>\nu _{2}</fr:tex> be the product projections of <fr:tex>y</fr:tex>.
  </fr:p>
  
    
      
      <fr:embedded-tex
hash="a7fa3d01140792f73f96bd484626fe9c"><fr:embedded-tex-preamble>
         
   \RequirePackage {tikz}
   \RequirePackage {amsmath}
   \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

   \definecolor {catccolor}{RGB}{255,244,138}
   \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
   \tikzstyle {catc}=[catccolor!60]
   \tikzstyle {catd}=[orange!40]
   \tikzstyle {cate}=[red!40]
   \tikzstyle {catf}=[blue!10]
   \tikzstyle {catg}=[green!25]


   \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
   \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

   \NewDocumentCommand \CreateRect {D&lt;&gt;{} m m}{
     \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

     \path [spath/save = #1north] (#1nw) to (#1ne);
     \path [spath/save = #1west] (#1nw) to (#1sw);
     \path [spath/save = #1east] (#1ne) to (#1se);
     \path [spath/save = #1south] (#1sw) to (#1se);
  }
 
         
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}-&gt;
    },
    cover/.style = {
      -{Triangle[open]}
    },
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {-&gt;},
    square/south/.style = {-&gt;},
    square/west/.style = {-&gt;},
    square/east/.style = {-&gt;},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff
 
      </fr:embedded-tex-preamble><fr:embedded-tex-body>
     \begin {tikzpicture}[diagram]
       \node  (1) {$A_{1}'$};
       \node  [right = of 1] (2) {$ \underline {A}$};
       \node  [right = of 2] (3) {$A_{2}''$};
       \node  [below = of 2] (4) {$V$};
       \draw  [&gt;-&gt;,morphism] (2) to node[swap] {$ \nu _{1}$} (1);
       \draw  [&gt;-&gt;,morphism] (2) to node {$ \nu _{2}$} (3);
       \draw  [&gt;-&gt;,morphism] (1) to node[swap] {$ a ^{*} ( \ell )$} (4);
       \draw  [&gt;-&gt;,morphism] (2) to node[desc] {$y$} (4);
       \draw  [&gt;-&gt;,morphism] (3) to node {$ b ^{*} (k)$} (4);
     \end {tikzpicture}
  </fr:embedded-tex-body></fr:embedded-tex>
    
  
  <fr:p>
    Then we have
  </fr:p>
  <fr:tex
display="block">      \begin {align*}       u_{1} \ell ' \nu _{1} &amp;= n \ell \ell ' \nu _{1} \\                     &amp;= na a ^{*} ( \ell ) \nu _{1} &amp;&amp;  \text {since $na = nb$} \\                     &amp;= nb a ^{*} ( \ell ) \nu _{1}&amp;&amp;  \text {since $ a ^{*} ( \ell ) \nu _{1} = y =  b ^{*} (k) \nu _{2}$} \\                     &amp;= nb b ^{*} (k) \nu _{2} \\                     &amp;= nkk'' \nu _{2} \\                     &amp;= u_{2}k'' \nu _{2}      \end {align*}   </fr:tex>
  <fr:p>
    Thus, <fr:tex>\ell ' \nu _{1}</fr:tex> and <fr:tex>k'' \nu _{2}</fr:tex> can be factored as follows:
  </fr:p>
  
    
      
      <fr:embedded-tex
hash="8de67d4fff6ecbfc8873f41e7fac29fb"><fr:embedded-tex-preamble>
         
   \RequirePackage {tikz}
   \RequirePackage {amsmath}
   \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

   \definecolor {catccolor}{RGB}{255,244,138}
   \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
   \tikzstyle {catc}=[catccolor!60]
   \tikzstyle {catd}=[orange!40]
   \tikzstyle {cate}=[red!40]
   \tikzstyle {catf}=[blue!10]
   \tikzstyle {catg}=[green!25]


   \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
   \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

   \NewDocumentCommand \CreateRect {D&lt;&gt;{} m m}{
     \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

     \path [spath/save = #1north] (#1nw) to (#1ne);
     \path [spath/save = #1west] (#1nw) to (#1sw);
     \path [spath/save = #1east] (#1ne) to (#1se);
     \path [spath/save = #1south] (#1sw) to (#1se);
  }
 
         
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}-&gt;
    },
    cover/.style = {
      -{Triangle[open]}
    },
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {-&gt;},
    square/south/.style = {-&gt;},
    square/west/.style = {-&gt;},
    square/east/.style = {-&gt;},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff
 
      </fr:embedded-tex-preamble><fr:embedded-tex-body>
     \begin {tikzpicture}[diagram]
       \SpliceDiagramSquare {
        nw = {A_{1}  \cap  A_{2}},
        nw/style = {pullback},
        ne = {A_{2}},
        sw = {A_{1}},
        se = {A_{1}  \cup  A_{2}},
        north = {i_{2}},
        north/style = {&gt;-&gt;},
        west = {i_{1}},
        west/style = {&gt;-&gt;},
        south = {u_{1}},
        south/style = {&gt;-&gt;},
        east = {u_{2}},
        east/style = {&gt;-&gt;},
      }
       \node  [above left = of nw] (a) {$ \underline {A}$};
       \draw  [-&gt;,morphism,bend right] (a) to node[swap] {$ \ell ' \nu _{1}$} (sw);
       \draw  [-&gt;,morphism,exists] (a) to node[desc] {$z$} (nw);
       \draw  [-&gt;,morphism,bend left] (a) to node {$k'' \nu _{2}$} (ne);
     \end {tikzpicture}
  </fr:embedded-tex-body></fr:embedded-tex>
    
  
  <fr:p>
    This yields
  </fr:p>
  <fr:tex
display="block">      \begin {align*}       may &amp;= ma a ^{*} ( \ell ) \nu _{1} \\            &amp;= m \ell \ell ' \nu _{1} \\            &amp;= m \ell  i_{1}z \\            &amp;= fi_{1}z &amp;&amp;  \text {since $fi_{i} = gi_{2}$} \\            &amp;= gi_{2}z \\            &amp;= mki_{2}z \\            &amp;= mkk'' \nu _{2} \\            &amp;= mb b ^{*} (k) \nu _{2} \\            &amp;= mby      \end {align*}   </fr:tex>
  <fr:p>
    We may now conclude that <fr:tex>n</fr:tex> is an isomorphism.
    Then <fr:tex>f</fr:tex> can be factored as <fr:tex>mn ^{-1}  u_{1}</fr:tex> and <fr:tex>g</fr:tex> can be factored as <fr:tex>mn ^{-1}  u_{2}</fr:tex>.
    It remains to show uniqueness.
  </fr:p>
  <fr:p>
    Let any two factors <fr:tex>A_{1}  \cup  A_{2}  \rightrightarrows  B</fr:tex> be given.
    Consider the equalizer <fr:tex>\epsilon</fr:tex> of these two factors.
    By definition, both <fr:tex>u_{1}</fr:tex> and <fr:tex>u_{2}</fr:tex> equalize these two factors, but this means that both <fr:tex>u_{1}</fr:tex> and <fr:tex>u_{2}</fr:tex> are contained in the subobject <fr:tex>\epsilon</fr:tex>.
    Thus, <fr:tex>\epsilon</fr:tex> is an isomorphism, so the two factors are equal.
  </fr:p>
</fr:mainmatter></fr:tree>
    
  </fr:mainmatter><fr:backmatter><fr:contributions></fr:contributions><fr:context></fr:context><fr:related><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>484</fr:anchor><fr:taxon>Lemma</fr:taxon><fr:addr>ct-0011</fr:addr><fr:route>ct-0011.xml</fr:route><fr:title><fr:link
href="ct-000X.xml"
type="local"
addr="ct-000X">Coherent categories</fr:link> admit distributive law</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>\mathcal { C }</fr:tex> be a coherent category.
  Then intersections distribute over unions, i.e., for any three subobjects <fr:tex>A_{1}</fr:tex>, <fr:tex>A_{2}</fr:tex>, and <fr:tex>A_{3}</fr:tex> of <fr:tex>A</fr:tex>, the following holds.
</fr:p><fr:tex
display="block">   A_{1}  \cap  (A_{2}  \cup  A_{3})  \cong  (A_{1}  \cap  A_{2})  \cup  (A_{1}  \cap  A_{3}) </fr:tex>
    
      
      <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>396</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>10</fr:day></fr:date><fr:parent>ct-0011</fr:parent></fr:frontmatter><fr:mainmatter>
  Let <fr:tex>m \colon A_{1} \rightarrowtail A</fr:tex> be a subobject of <fr:tex>\mathcal { C }</fr:tex>.
  Then by <fr:ref
addr="ct-000L"
href="ct-000L.xml"
taxon="Lemma"></fr:ref>, <fr:tex>A_{1}  \cap  ( \mathord { \hspace {1pt} \text {--} \hspace {1pt}} )</fr:tex> can be described as the composite <fr:tex>\mathsf { Sub } (A)  \xrightarrow { m ^{*} }   \mathsf { Sub } (A_{1})  \xrightarrow { \exists _{m} }   \mathsf { Sub } (A)</fr:tex>.
  Thus, we have
</fr:mainmatter></fr:tree>
    
  <fr:tex
display="block">    \begin {align*}     A_{1}  \cap  (A_{2}  \cup  A_{3}) &amp; \cong   \exists _{m} m ^{*} (A_{2}  \cup  A_{3}) &amp;&amp;  \text {$ m ^{*} $ preserves finite unions} \\                              &amp; \cong   \exists _{m}( m ^{*} (A_{2})  \cup   m ^{*} (A_{3})) &amp;&amp;  \text {left adjoint preserves finite unions} \\                              &amp; \cong   \exists _{m} m ^{*} (A_{2})  \cup   \exists _{m} m ^{*} (A_{3}) \\                              &amp; \cong  (A_{1}  \cap  A_{2})  \cup  (A_{1}  \cap  A_{3})    \end {align*} </fr:tex></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>485</fr:anchor><fr:taxon>Definition</fr:taxon><fr:addr>ct-000X</fr:addr><fr:route>ct-000X.xml</fr:route><fr:title>Coherent category</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>7</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
  A <fr:link
href="ct-000O.xml"
type="local"
addr="ct-000O">regular category</fr:link> <fr:tex>\mathcal { C }</fr:tex> is said to be <fr:em><fr:strong>coherent</fr:strong></fr:em> if each <fr:tex>\mathsf { Sub } (B)</fr:tex> has finite <fr:link
href="ct-000F.xml"
type="local"
addr="ct-000F">unions</fr:link> and each <fr:tex>f ^{*} \colon \mathsf { Sub } (A) \to \mathsf { Sub } (B)</fr:tex> preserves them.
  A <fr:em><fr:strong>coherent functor</fr:strong></fr:em> between coherent categories is a <fr:link
href="ct-000O.xml"
type="local"
addr="ct-000O">regular functor</fr:link> which preserves finite unions.
</fr:p></fr:mainmatter></fr:tree><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>486</fr:anchor><fr:taxon>Lemma</fr:taxon><fr:addr>ct-000L</fr:addr><fr:route>ct-000L.xml</fr:route><fr:title>Equivalent condition for the existence of <fr:link
href="ct-000K.xml"
type="local"
addr="ct-000K">images</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex>\mathcal { C }</fr:tex> be a category with pullbacks. Then <fr:tex>\mathcal { C }</fr:tex> has images iff for each morphism <fr:tex>f \colon A \to B</fr:tex>, the pullback functor <fr:tex>f ^{*} \colon \mathsf { Sub } (B) \to \mathsf { Sub } (A)</fr:tex> admits a left adjoint <fr:tex>\exists _{f} \colon \mathsf { Sub } (A) \to \mathsf { Sub } (B)</fr:tex>.</fr:p>
    
      
      <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>303</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:parent>ct-000L</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>By <fr:ref
addr="ct-000J"
href="ct-000J.xml"
taxon="Lemma"></fr:ref>, the pullback functor <fr:tex>f ^{*} \colon { \mathcal { C } _{/{ B }}} \to { \mathcal { C } _{/{ A }}}</fr:tex> admits <fr:tex>\Sigma _{f} \colon { \mathcal { C } _{/{ A }}} \to { \mathcal { C } _{/{ B }}}</fr:tex> as a left adjoint.</fr:p>
  <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>301</fr:anchor><fr:taxon>If</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:parent>ct-000L</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex>g \colon B' \rightarrowtail B</fr:tex> be an arbitrary object in <fr:tex>\mathsf { Sub } (B)</fr:tex>. We need to construct a functor <fr:tex>\mathsf { Img } \colon { \mathcal { C } _{/{ B }}} \to \mathsf { Sub } (B)</fr:tex> so that each morphism <fr:tex>f  \to  g</fr:tex> in <fr:tex>{ \mathcal { C } _{/{ B }}}</fr:tex> corresponds to a unique morphism <fr:tex>\mathsf { Img } (f)  \to  g</fr:tex> in <fr:tex>\mathsf { Sub } (B)</fr:tex>.</fr:p><fr:p>Let <fr:tex>f  \to  g</fr:tex> be an arbitrary morphism in <fr:tex>{ \mathcal { C } _{/{ B }}}</fr:tex>. Then this corresponds to a unique morphism <fr:tex>\mathsf {id} _{ A }   \to   f ^{*} (g)</fr:tex> as follows:</fr:p>
    
      
      <fr:embedded-tex
hash="70bd1ce54a18fe1e0f15c71df204b2e9"><fr:embedded-tex-preamble>
         
   \RequirePackage {tikz}
   \RequirePackage {amsmath}
   \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

   \definecolor {catccolor}{RGB}{255,244,138}
   \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
   \tikzstyle {catc}=[catccolor!60]
   \tikzstyle {catd}=[orange!40]
   \tikzstyle {cate}=[red!40]
   \tikzstyle {catf}=[blue!10]
   \tikzstyle {catg}=[green!25]


   \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
   \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

   \NewDocumentCommand \CreateRect {D&lt;&gt;{} m m}{
     \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

     \path [spath/save = #1north] (#1nw) to (#1ne);
     \path [spath/save = #1west] (#1nw) to (#1sw);
     \path [spath/save = #1east] (#1ne) to (#1se);
     \path [spath/save = #1south] (#1sw) to (#1se);
  }
 
         
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}-&gt;
    },
    cover/.style = {
      -{Triangle[open]}
    },
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {-&gt;},
    square/south/.style = {-&gt;},
    square/west/.style = {-&gt;},
    square/east/.style = {-&gt;},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff
 
      </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzpicture}[diagram]
         \SpliceDiagramSquare {
          ne = B',
          se = B,
          nw = A',
          nw/style = pullback,
          sw = A,
          east = g,
          east/style = {&gt;-&gt;},
          west =  f ^{*} (g),
          west/style = {&gt;-&gt;},
          south = f,
          north =  \varepsilon _{g},
        }
         \node  [above left of = nw] (a) {$A$};
         \draw  [-&gt;,morphism,bend left] (a) to node {} (ne);
         \draw  [double,morphism,bend right] (a) to node {} (sw);
         \draw  [-&gt;,morphism,exists] (a) to node {} (nw);
       \end {tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
    
  <fr:p>This then corresponds to a unique morphism <fr:tex>\exists _{f}( \mathsf {id} _{ A } )  \to  g</fr:tex> under the adjunction <fr:tex>\exists _{f}  \dashv   f ^{*}</fr:tex>. Thus, we define <fr:tex>\mathsf { Img }</fr:tex> by the assignment <fr:tex>f  \mapsto   \exists _{f}( \mathsf {id} _{ A } )</fr:tex>. This assignment can be trivially extended to a functor: since the category <fr:tex>\mathsf { Sub } (B)</fr:tex> is a preorder, every morphism <fr:tex>f  \to  f'</fr:tex> in <fr:tex>{ \mathcal { C } _{/{ B }}}</fr:tex> has to be mapped to the unique morphism <fr:tex>\mathsf { Img } (f)  \to   \mathsf { Img } (f')</fr:tex> in <fr:tex>\mathsf { Sub } (B)</fr:tex>. This morphism must exist. Indeed, it is the lifting of <fr:tex>\mathsf { Img } (f)</fr:tex> against <fr:tex>\varepsilon _{ \mathsf { Img } (f')}</fr:tex> depicted in the following diagram.</fr:p>
    
      
      <fr:embedded-tex
hash="8968e10fd49149481592eb9aa80a5f21"><fr:embedded-tex-preamble>
         
   \RequirePackage {tikz}
   \RequirePackage {amsmath}
   \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

   \definecolor {catccolor}{RGB}{255,244,138}
   \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
   \tikzstyle {catc}=[catccolor!60]
   \tikzstyle {catd}=[orange!40]
   \tikzstyle {cate}=[red!40]
   \tikzstyle {catf}=[blue!10]
   \tikzstyle {catg}=[green!25]


   \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
   \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

   \NewDocumentCommand \CreateRect {D&lt;&gt;{} m m}{
     \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

     \path [spath/save = #1north] (#1nw) to (#1ne);
     \path [spath/save = #1west] (#1nw) to (#1sw);
     \path [spath/save = #1east] (#1ne) to (#1se);
     \path [spath/save = #1south] (#1sw) to (#1se);
  }
 
         
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}-&gt;
    },
    cover/.style = {
      -{Triangle[open]}
    },
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {-&gt;},
    square/south/.style = {-&gt;},
    square/west/.style = {-&gt;},
    square/east/.style = {-&gt;},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff
 
      </fr:embedded-tex-preamble><fr:embedded-tex-body>
       \begin {tikzpicture}[diagram]
         \SpliceDiagramSquare {
          nw = A',
          nw/style = pullback,
          sw = A,
          ne = B',
          se = B,
          north =  \varepsilon _{ \mathsf { Img } (f')},
          east =  \mathsf { Img } (f'),
          east/style = {&gt;-&gt;},
          south =  \mathsf { Img } (f),
          south/style = {&gt;-&gt;},
        }
         \draw  [-&gt;,morphism,exists] (sw) to (ne);
       \end {tikzpicture}
    </fr:embedded-tex-body></fr:embedded-tex>
    
  <fr:p>We can now extract the components of the unit and the counit from this correspondence.</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
      
  <html:tr>
        
  <html:th>Unit (<fr:tex>\vartheta</fr:tex>)</html:th>

        
  <html:th>Counit (<fr:tex>\zeta</fr:tex>)</html:th>

      </html:tr>

      
  <html:tr>
        
  <html:td>
          <fr:p>Let <fr:tex>f \colon A \to B</fr:tex> be an object in <fr:tex>{ \mathcal { C } _{/{ B }}}</fr:tex>. The identity morphism <fr:tex>\mathsf {id} \colon \mathsf { Img } (f) \to \mathsf { Img } (f)</fr:tex> is, by definition, the identity morphism <fr:tex>\mathsf {id} \colon \exists _{f}( \mathsf {id} _{ A } ) \to \mathsf { Img } (f)</fr:tex>, which corresponds to the unit <fr:tex>\eta _{ \mathsf {id} _{ A } } \colon \mathsf {id} _{ A } \to f ^{*} ( \mathsf { Img } (f))</fr:tex> of the adjunction <html:span
style="white-space: nowrap"><fr:tex>\exists _{f}  \dashv   f ^{*}</fr:tex></html:span>.</fr:p>
          <fr:p>Then since <fr:tex>\mathsf { Img } (f)</fr:tex> is monic, <fr:tex>\eta _{ \mathsf {id} _{ A } }</fr:tex> corresponds to a unique morphism <fr:tex>\varepsilon _{ \mathsf { Img } (f)} \eta _{ \mathsf {id} _{ A } } \colon f \to \mathsf { Img } (f)</fr:tex>, where <fr:tex>\varepsilon</fr:tex> is the counit of the adjunction <fr:tex>\Sigma _{f}  \dashv   f ^{*}</fr:tex>. This defines the component of <fr:tex>\vartheta</fr:tex> at <fr:tex>f</fr:tex>. This is precisely the lifting of <fr:tex>f</fr:tex> against <fr:tex>\varepsilon _{ \mathsf { Img } (f)}</fr:tex>.</fr:p>
          
    
      
      <fr:embedded-tex
hash="76186827dc6d280886c759cf567f11eb"><fr:embedded-tex-preamble>
         
   \RequirePackage {tikz}
   \RequirePackage {amsmath}
   \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

   \definecolor {catccolor}{RGB}{255,244,138}
   \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
   \tikzstyle {catc}=[catccolor!60]
   \tikzstyle {catd}=[orange!40]
   \tikzstyle {cate}=[red!40]
   \tikzstyle {catf}=[blue!10]
   \tikzstyle {catg}=[green!25]


   \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
   \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

   \NewDocumentCommand \CreateRect {D&lt;&gt;{} m m}{
     \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

     \path [spath/save = #1north] (#1nw) to (#1ne);
     \path [spath/save = #1west] (#1nw) to (#1sw);
     \path [spath/save = #1east] (#1ne) to (#1se);
     \path [spath/save = #1south] (#1sw) to (#1se);
  }
 
         
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}-&gt;
    },
    cover/.style = {
      -{Triangle[open]}
    },
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {-&gt;},
    square/south/.style = {-&gt;},
    square/west/.style = {-&gt;},
    square/east/.style = {-&gt;},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff
 
      </fr:embedded-tex-preamble><fr:embedded-tex-body>
             \begin {tikzpicture}[diagram]
               \SpliceDiagramSquare {
                nw = A',
                nw/style = pullback,
                sw = A,
                ne = B',
                se = B,
                north =  \varepsilon _{ \mathsf { Img } (f)},
                east =  \mathsf { Img } (f),
                east/style = {&gt;-&gt;},
                south = f,
              }
               \draw  [-&gt;,morphism,exists] (sw) to node[desc] {$ \vartheta _{f}$} (ne);
             \end {tikzpicture}
          </fr:embedded-tex-body></fr:embedded-tex>
    
  
        </html:td>

        
  <html:td>
          <fr:p>Let <fr:tex>f \colon A \rightarrowtail B</fr:tex> be an object in <fr:tex>\mathsf { Sub } (B)</fr:tex>. Then the identity morphism <fr:tex>\mathsf {id} _{f} \colon f \to f</fr:tex> corresponds to a unique morphism <fr:tex>s \colon \mathsf {id} _{ A } \to f ^{*} (f)</fr:tex> by the universal property of pullbacks.</fr:p>
          <fr:p>This morphism corresponds to a unique morphism <fr:tex>\exists _{f}( \mathsf {id} _{ A } )  \to  f</fr:tex> under the adjunction <fr:tex>\exists _{f}  \dashv   f ^{*}</fr:tex>, which we take as the component of <fr:tex>\zeta</fr:tex> at <fr:tex>f</fr:tex>.</fr:p>
        </html:td>

      </html:tr>

    </html:table>
</fr:mainmatter></fr:tree>
  
  <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>302</fr:anchor><fr:taxon>Only if</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>2</fr:day></fr:date><fr:parent>ct-000L</fr:parent></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex>\mathcal { C }</fr:tex> has images, then we may define <fr:tex>\exists _{f} \colon \mathsf { Sub } (A) \to \mathsf { Sub } (B)</fr:tex> as the following composite:</fr:p><fr:tex
display="block">        \mathsf { Sub } (A)  \hookrightarrow   { \mathcal { C } _{/{ A }}}   \xrightarrow { \Sigma _{f} }   { \mathcal { C } _{/{ B }}}   \xrightarrow { \mathsf { Img } }   \mathsf { Sub } (B)     </fr:tex><fr:p>Let <fr:tex>i_{A} \colon \mathsf { Sub } (A) \hookrightarrow { \mathcal { C } _{/{ A }}}</fr:tex> and <fr:tex>i_{B} \colon \mathsf { Sub } (B) \hookrightarrow { \mathcal { C } _{/{ B }}}</fr:tex> be the inclusion functors. Note that</fr:p><fr:tex
display="block">        \mathsf { Img } \Sigma _{f}  \dashv   f ^{*} i_{B}     </fr:tex><fr:p>Since <fr:tex>f ^{*} i_{B}  \cong  i_{A} f ^{*}</fr:tex> by construction, we have</fr:p><fr:tex
display="block">        \mathsf { Img } \Sigma _{f}  \dashv  i_{A} f ^{*}      </fr:tex><fr:p>Let <fr:tex>\eta</fr:tex> and <fr:tex>\varepsilon</fr:tex> be the unit and counit of this adjunction respectively. Since <fr:tex>\mathsf { Sub } (A)</fr:tex> is a full subcategory of <fr:tex>{ \mathcal { C } _{/{ A }}}</fr:tex>, there is a natural isomorphism <fr:tex>\iota \colon \mathsf {id} _{ { \mathcal { C } _{/{ A }}} } \stackrel { \sim }{ \smash { \longrightarrow } \rule {0pt}{0.4ex}} i_{A}</fr:tex>. Then we can define <fr:tex>\eta '</fr:tex> as follows:</fr:p><fr:tex
display="block">        \eta ' :=  \mathsf {id} _{ { \mathcal { C } _{/{ A }}} }   \xrightarrow { \eta }  i_{A} f ^{*} \mathsf { Img } \Sigma _{f}        \xrightarrow { \iota _{ f ^{*} \mathsf { Img } \Sigma _{f}} }   f ^{*} \mathsf { Img } \Sigma _{f}        \xrightarrow { f ^{*} \mathsf { Img } \Sigma _{f}( \iota ) }   f ^{*} \mathsf { Img } \Sigma _{f}i_{A}     </fr:tex><fr:p>Then <fr:tex>\eta '</fr:tex> and <fr:tex>\varepsilon</fr:tex> form the unit and counit of the adjunction <fr:tex>\mathsf { Img } \Sigma _{f}i_{A}  \dashv   f ^{*}</fr:tex>.</fr:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
    
  </fr:mainmatter></fr:tree></fr:related><fr:backlinks><fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>483</fr:anchor><fr:taxon>Corollary</fr:taxon><fr:addr>ct-0015</fr:addr><fr:route>ct-0015.xml</fr:route><fr:title>Disjoint unions are coproducts</fr:title><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>11</fr:day></fr:date></fr:frontmatter><fr:mainmatter><fr:p>
  Let <fr:tex>A_{1}</fr:tex> and <fr:tex>A_{2}</fr:tex> be subobjects of <fr:tex>A</fr:tex> in a <fr:link
href="ct-000X.xml"
type="local"
addr="ct-000X">coherent category</fr:link> such that <fr:tex>A_{1}  \cap  A_{2}  \cong  0</fr:tex>.
  Then <fr:tex>A_{1}  \cup  A_{2}  \cong  A_{1} + A_{2}</fr:tex>.
  Note that every coherent category has a (strict) initial object by <fr:ref
addr="ct-000Z"
href="ct-000Z.xml"
taxon="Lemma"></fr:ref>.
</fr:p>
    
      
      <fr:tree
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"><fr:frontmatter><fr:anchor>447</fr:anchor><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>11</fr:day></fr:date><fr:parent>ct-0015</fr:parent></fr:frontmatter><fr:mainmatter>
  <fr:p>
    By <fr:ref
addr="ct-0012"
href="ct-0012.xml"
taxon="Lemma"></fr:ref> the following diagram is a pushout.
  </fr:p>
  
    
      
      <fr:embedded-tex
hash="51ee634f714f9650d56816d8a6108ce8"><fr:embedded-tex-preamble>
         
   \RequirePackage {tikz}
   \RequirePackage {amsmath}
   \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

   \definecolor {catccolor}{RGB}{255,244,138}
   \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
   \tikzstyle {catc}=[catccolor!60]
   \tikzstyle {catd}=[orange!40]
   \tikzstyle {cate}=[red!40]
   \tikzstyle {catf}=[blue!10]
   \tikzstyle {catg}=[green!25]


   \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
   \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

   \NewDocumentCommand \CreateRect {D&lt;&gt;{} m m}{
     \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

     \path [spath/save = #1north] (#1nw) to (#1ne);
     \path [spath/save = #1west] (#1nw) to (#1sw);
     \path [spath/save = #1east] (#1ne) to (#1se);
     \path [spath/save = #1south] (#1sw) to (#1se);
  }
 
         
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}-&gt;
    },
    cover/.style = {
      -{Triangle[open]}
    },
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {-&gt;},
    square/south/.style = {-&gt;},
    square/west/.style = {-&gt;},
    square/east/.style = {-&gt;},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff
 
      </fr:embedded-tex-preamble><fr:embedded-tex-body>
     \DiagramSquare {
      nw = 0,
      ne = {A_{2}},
      sw = {A_{1}},
      se = {A_{1}  \cup  A_{2}},
      north/style = {&gt;-&gt;,exists},
      west/style = {&gt;-&gt;,exists},
      south/style = {&gt;-&gt;},
      east/style = {&gt;-&gt;},
    }
  </fr:embedded-tex-body></fr:embedded-tex>
    
  
  <fr:p>
    But, pushouts under <fr:tex>0</fr:tex> are coproducts.
  </fr:p>
</fr:mainmatter></fr:tree>
    
  </fr:mainmatter></fr:tree></fr:backlinks><fr:references></fr:references></fr:backmatter></fr:tree>