<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1903</fr:anchor><fr:addr
type="user">ct-0001</fr:addr><fr:route>ct-0001.xml</fr:route><fr:title
text="Reflexive relation">Reflexive relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[(a,b)\colon R\rightarrowtail A \times  A]]></fr:tex> be a relation in a cartesian category.
  The relation <fr:tex
display="inline"><![CDATA[(a,b)]]></fr:tex> is said to be <fr:em><fr:strong>reflexive</fr:strong></fr:em> if it contains the diagonal relation <fr:tex
display="inline"><![CDATA[\Delta \colon A\rightarrowtail A \times  A]]></fr:tex>, i.e., if there is a morphism <fr:tex
display="inline"><![CDATA[\rho \colon A\to R]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[a\rho  = \mathsf {id}_{A}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b\rho  = \mathsf {id}_{A}]]></fr:tex>.</fr:p>
    
      
      <fr:figure><fr:resource
hash="1032c16198458e2da13683f2f38b121a"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEyNy4zOTU2MDFwdCcgaGVpZ2h0PScxMTIuNzM1NTMycHQnIHZpZXdCb3g9Jy03MiAtNzIgODQuOTMwNDAxIDc1LjE1NzAyMSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVQ4QUFvQUFBQUFCYkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hjZDMyR050WVhBQUFBRThBQUFBTlFBQUFFUUFkd1JYWjJ4NVpnQUFBWFFBQUFJaUFBQUNiR2d4UEJwb1pXRmtBQUFEbUFBQUFDOEFBQUEyS0Z5RnEyaG9aV0VBQUFQSUFBQUFId0FBQUNRRmZnSHNhRzEwZUFBQUErZ0FBQUFVQUFBQUZBcjdBU2RzYjJOaEFBQUQvQUFBQUF3QUFBQU1BUllCeW0xaGVIQUFBQVFJQUFBQUdBQUFBQ0FBQ0FCQ2JtRnRaUUFBQkNBQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRThBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbU1tS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHJxTUI5a1p2Z1A1RE16TUlLRUdSRXEvZ09GQWQwQkRaSUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtkQmlTbUEvKy93OW1KWUpZLzYvK1gvakhHYXdXREFEenVBdkxBQUFBZU5vbGtUMXYwMUFVaHU5NzdkaE8ydGhKSFY4M0pIVVNmNllmY2ZOVnV5cVYyN1JKcEphaXRBS3Bhc3FIR0NxRWhGaVFHT2hTaVlHZndDOUFZbVJoWUVkaVFjeHNTUEFieWdRTk4rMjkyemxIZXAvbkhBTHljckpCTHNrcndnaUpaVWtPMFkxaUM0YWtRWkw5SUlvVC9KaWQwY3VWNmkzWEZiMjBwODBJa0RxVm5DSUR0WFlOU0ZySGE5azJhRlpPdFI0VC9paEpKcGQwRDE5SWcyd1RnZ1J0Wm1wVWhWRmdab0l0UkJVd3N5RHhOTWtQVlBCTW5qUDlGb1E0Q3Z6QWwyUmV0c0RENHdnZlV3dWxBdVlNSnFjMXZlb29pcGpKU05EenBjamN5VnQ3Uzd2SEVMYzBmWC9zZFZzZEZJeU9PWFIwRzFpeDdLN2k0eTNUYy9uRHV3K01VR1ZsMEVGUWtrQnBKdFdyZGdTVUdsWWRlSGh3ZHFUUERRWFlWeisvejNxdVNPdTNuWXRHSElKV2xQS04wKzdrRDM3UnI4UW1FWGNTcG1UTXZONFN4L2UzZU1GM2JEOUkwT0VOZWRwUHNCYkNzYmtLbitMdVVJZm1UbjM5a1NEMGF2c252ZnVBMUFnekV0WGNkQjdRNVA2S2k3ZyswT2NYc0d4dEpxb2lXc29pL1hEMW0zR1pleWZQRHAyK2dKTlJ6djc4YWNuTVpzU01wc2lpTVB0dmpNMmdlZTUwVi91YXBwN1hpK0hHbExjejhXakNiekJQbGdreGRjNWp3YnplK1JSWUExOHd4NDNaOU1KYzFKWnVPRTBXUDdIZWpRYW5WTmpKNlFmamJpUVh5NkpSeWhyNFd4eTR4U3FsemUxQjJaaG5hVEQySGhjdlhnT25SMDlIK3R5dVFGZlZzK2RGRDduOE4zalIwaHQvdmJtOGFOMFp1NXJqa1AvNGpWcXNBQUI0Mm1OZ1pHQmdBT0k4M3RVTDQvbHR2akl3c3pDQXdHUDdoWWtJK3I4cTB6R200MEF1QndNVFNCUUFJQW9LZHdCNDJtTmdaR0JnWnZqUHdNREFkSXpCbUVHQnlaTUJLSUlDV0FFKzhRSndBQUxHQUFBQld3QnpBbm9BUGdJQ0FFTUNYZ0F6QUFBQUFBQXFBSlFBN0FFMmVOcGpZR1JnWUdCbGNHUmdZZ0FCUmdZMEFBQUhYZ0JMZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFQUUFBb0FBQUFBQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoWU9XZEdOdFlYQUFBQUU4QUFBQU1nQUFBRHhEOWQ2cFoyeDVaZ0FBQVhBQUFBRURBQUFCREkzeDl3Rm9aV0ZrQUFBQ2RBQUFBQzBBQUFBMktSbUZ3R2hvWldFQUFBS2tBQUFBSGdBQUFDUUd3UU1FYUcxMGVBQUFBc1FBQUFBUUFBQUFFQW9tQVBoc2IyTmhBQUFDMUFBQUFBb0FBQUFLQUxZQVlHMWhlSEFBQUFMZ0FBQUFHQUFBQUNBQUJ3QWNibUZ0WlFBQUF2Z0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQUR4QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm02bVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakVEdkFPQ25GWmVsQVNRMGxObWFHLzBBK00xZ2FRa0RBZjZBd0FOelREUWtBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeW1vcXNmMy9EK1JyZ09qL04rLytCYXNDQWdDS2RBaTdBQUI0MmlYTXNVckRVQmpGOGU5OFYrNGwwZVRHR2hLcWk2azB3VUVIYVc2d3FOVkZIQnhMaDFBSExUZ1ZvZEtsUTBHc2pqNUVYOENYVUh3Qlo5MmNPd3ZHR3VuNUwyZjZFV2c0Qis0RTBUb1J3c0JYVWtNcUdaUlhJMDdLc3JnRmc3NmoxRWxUN1F0MHJtM2xQS2J1Y3AxNXh6V0N3SjVzOUwzQjI5UDNoZVV4cnNiUjVyaDNPNm5mbHlTZGxYNTc0YStWYWhnb1h5b1hjZFpvNFFqWkxwSTROVm4zd2Z5RDJ6Vnpzd0doMjEySXdha0ZLV2loNWRQanl4N2JZbW4xZkRaOS9XcmEwbUlxeDNRd0w4U0VQMGhUaGNoQ3NPVW5rVXhyR1V5NEZ5aEVESXdzcnY3TXFteGo1RmIweXVIdk8rZjhVblMwSTRTaitUa1FkbDU4L2dHOERURlVBSGphWTJCa1lHQUE0dVhhalYvaitXMitNakN6TUlEQVkvdUZpUWo2UHlOek16T0l5OEhBQktJQUtId0p6QUFBQUhqYVkyQmtZR0JtK004QUpBOHkyRERZTVRjekFFVlFBQXNBUmpRQ3pRQUFBdE1BQUFISkFIUUJ5UUJJQThFQVBBQUFBQUFBTUFCZ0FJWUFBSGphWTJCa1lHQmdZWkJtWUdJQUFVWUdOQUFBQTQwQUpIamFQWXd4cThJd0ZJVy9ZaFh0R3h3RWh6ZEk4QWVFU2grNHVEazR1VHE4elpvZ0hacEtXb3N1NGsvM05nUnY0UERkYzg0TmtQRWlZWmlFZWRCaFVubnp5R04rV0VTZWlMK0tuUEhMbWhGSk9oTm54UzV5eXBUL3lHT1dsSkVuNGo4aVovengzamYxN2Q1WnI0Nk5zZDVkYXI4OVdkOVdqVk1iblEvcndUcnJ6NTAxcW53cTAxZHRmNjFWb1hOZHNLZWg1c2FkRG90SGNSVEhCSFpjSlBOc09ZVzlwWkxNU1dlREp2K21CMGxkYUp6REwwWWFKVTlSUXk4M3JlaFZ1b29pM0dtS0QxaXNMa3NBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5BQUFvQUFBQUFBNlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ2lPUnpHMk50WVhBQUFBRkFBQUFBS1FBQUFEUUFEQUVxWjJ4NVpnQUFBV3dBQUFCNEFBQUFlSk1TUEpGb1pXRmtBQUFCNUFBQUFDMEFBQUEyS0xHRnQyaG9aV0VBQUFJVUFBQUFIZ0FBQUNRR05mL2RhRzEwZUFBQUFqUUFBQUFHQUFBQUJnT3dBQUJzYjJOaEFBQUNQQUFBQUFZQUFBQUdBRHdBQUcxaGVIQUFBQUpFQUFBQUZ3QUFBQ0FBQkFBa2JtRnRaUUFBQWx3QUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRE1BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWxtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVUQXhKSUtTNUxCMHBlWjdqT0xQVkhrNEdCV1lyNU9sQ1lFYUhpLzM4R0JnRHJuUTd2QUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeENDK05mLy80ZVEvN1hBZkFZQVh1VUhNd0FBQUFBQkFKUUFDUUtHQWZnQUlnQUFBVGMyRnhZWEJnOENId0VXQndZSEppOEJCdzRCSXlZbkpqOEJKeVkzTmpjeUZ3R095dzRLRXdFQ0F4cTdwVElFQVFFVEN3WFV5d2tJQmhFREF4RE56UkFEQXhFR0JBRWR5aEVCQWhNS0F4cTdwVElJQXhNQ0FnVFV5d29GQWhNSERjN09EUWNUQWdJQUFIamFZMkJrWUdBQTRwWDVkdlBqK1cyK01qQ3pNSURBWS91RmljZzBzd3pqRHlERndjQUU0Z0VBRUN3SkNBQUFBSGphWTJCa1lHQ1crcU1KSkdVWXBqQk1ZMnBqQUlxZ0FFWUFUTW9ERndBQUF4d0FBQUNVQUFBQUFBQUFBRHdBQUhqYVkyQmtZR0JnWWxCbUFORU1VQklKQUFBRUNBQXBBSGphVFk2eGFzTXdFSVkvVThkUUo1Q3BIVG9VVFJtRmpmTUFoUXlac21Zc0pKRUlEbGdPa21Qd1V2SUFmZWhlRkEwOXdmSHB2KytFZ0pJZk1oNlZzWXo5VVRtRjNKNDhZODViNGtLT1Nsenl3WW9Yc3Z4VmtrKytFdWNzK0U0ODQ1MUw0a0x5ZStLU05iK2J2cnZlQnV2VnJqZld1MU1YcHJyYVd4L2EzcWxhVjg5Z2E1MzFoOEVhZFp5VUdkc3duanZWNkVvM2JPanB1SEpqd09MbFp6dEpUR1RIU1dhQmlacUtmY3dDcmN5ZGVEVmEwdi9HVmd3WHJVTjh6WWgxbEprU0dtVXZTRCtMcjJqaXJxYjVBd2xSTVJNQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUlVBQW9BQUFBQUJQd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MURHTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWRRQ05aMng1WmdBQUFXd0FBQUdLQUFBQnhDRTI0eDVvWldGa0FBQUMrQUFBQUM4QUFBQTJLSnVHZzJob1pXRUFBQU1vQUFBQUhnQUFBQ1FHS3dJUmFHMTBlQUFBQTBnQUFBQU1BQUFBREFoL0FFNXNiMk5oQUFBRFZBQUFBQWdBQUFBSUFGUUE0bTFoZUhBQUFBTmNBQUFBR0FBQUFDQUFCZ0JkYm1GdFpRQUFBM1FBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFU0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNvNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaQWhpWnZnUDVETkRwSkhVL0FjS0F3RDBWZzFZZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pJRS9mOFA1SVBwL3dmK2J3Q3JBZ0lBa2ZrSS9BQUFBSGphVlpDL2J0TlFGTWJ2ZDY1OWI1ejRYMzJkYXlKaWl6U3RYU0tWU0xWckswRXlRbEZnZ2dFcEZSSXo5QUZhR0RxbGlMVmk1a2xZZUFCZWdKR0JpWUVKaVpXRUd5WTQwem1menAvdmR4aXhnKzJXdnRGWE5tVW5qRFdvbXhPZHFGaVh0UlpUeUNJdnFqclJkVFBGU0lwWUozWGl3K2c3dVd6UmxQd2pYb3JZRTJqMWNSK3VmYm51MlBCNnF1S08zR3lmZWtQbGNYajIrWE1YcnJQZmZ2Z3hla05uSVp6Zzkxb0hQSlhnSE5RSkpPQW1yNWJ2NG9NUUZQaGlKM2NEZ2ZGblBHTW1pRTIyMzdsTm4xaklYakFHdmp2ZTRqU2ZJZy9nUTJWSTRnQ2lMM1JwM05aTm92L1dVaGdDWS9ZQlRIT2RGMk11TTlUeGYyaXFHaGZDcENPend3eGd2YmhZcmxSMjI2cjZzOU0yNkw0ZkxMa2xMVVMzVkcwUWhRM3RwM04zb3FLN2x0MFREaDB2cnhZY2h6T3Y4L2JhMFB2K1BMTnZobm5xaHhpZlg1SDE2REc5M3Z6Q29iNnpHaTRpNlJJbzJueVJ6ZjFrTU44ZnBDTVVqY3VKSEc4U0hkblV0WHY2WVRpNHB3b3ZiV256TS9LRTllK2ZWRWF6UGVKRGs2NFdUNnJ5RDhBbVFDZ0FBSGphWTJCa1lHQUE0bTN5dDF2aitXMitNakN6TUlEQVkvdUZpUWo2LzNObVZxYTdRQzRIQXhOSUZBQTJRUXI5QUhqYVkyQmtZR0JtK004QUpEa1pWQmhZbUZrWmdDSW9nQmtBSS9jQlJBQUFBbllBQUFNQUFDUURDUUFxQUFBQUFBQlVBT0o0Mm1OZ1pHQmdZR2FJWVdCaUFBRkdCalFBQUFuTEFHUjQyazJPc1dyRE1CQ0dQMVBIVUtmUXFSMDZGRTBaaFkzN0FJRU1tYkptTENTUkNBNUlDckpqeUJMNkFIM29YaFFOUGNIeDNYZS9oSUNhR3dYM0tuaE4vVjRsbFV3UG5qSG5MWE1sUjJXdStXREJFMFg1TE9hVFplYVNGNzR6ejNqbmxMa1MvNU81NW92ZlZYRG55MmlqMmdSam96ODQxN2ZOMXNhaEQxNjF1bm1JdGZVMjdrWnIxUDZxek5RUDA5R3BUamU2WTBYQWNlYkNpQ1hLenpaaVRHTFBRWGFPbnBhR2JYS0RURUUyU3B3Vyt6K3hsb1JQcVYxNnpVaHF6MVc2WVpMTUlQMG9hVVdYN21xNlA5LzBNTHNBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYxLjYxMjIwMSwtNTkuNjcyNjA1KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuODM1MDcsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjYxMjIwMSwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02MS42MTIyMDEnIHk9Jy01OS42NzI2MDUnPlI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDMuMjk0NDIsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjYxMjIwMSwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02MS42MTIyMDEnIHk9Jy01OS42NzI2MDUnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUxLjkyNjMzNicgeT0nLTU5LjY3MjYwNSc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQxLjk2MzcyMicgeT0nLTU5LjY3MjYwNSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjYxMjIwMSwtNTkuNjcyNjA1KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02MS42MTIyMDEnIHk9Jy01OS42NzI2MDUnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEwLjU5MDYgMEgzOC4yMzg4OCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxMC44NDA2LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMzguNDg4ODgsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNC42NDIyMSw0LjU2MTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuNjEyMjAxLC01OS42NzI2MDUpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTYxLjYxMjIwMScgeT0nLTU5LjY3MjYwNSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTguNDk4ODU4JyB5PSctNTkuNjcyNjA1Jz5hLDx0c3BhbiB4PSctNTAuNDUwNjM3Jz5iPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTQ2Ljk0NzA5OScgeT0nLTU5LjY3MjYwNSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC00OC42NjI0NlYtNi45MDk3MycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDAuMCwtNi42NTk3MyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTcuNDEyODcsLTI5LjI4NjEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS42MTIyMDEsLTU5LjY3MjYwNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuNjEyMjAxJyB5PSctNTkuNjcyNjA1Jz7PgTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOS43OTU0OS00Ny4xMDdMNDkuMzEzMS03LjU5NjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjcwNzE1LC0wLjcwNzAzLDAuNzA3MDMsLTAuNzA3MTUsOS45NzIyNywtNDYuOTMwMjQpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTUsMC43MDcwMywtMC43MDcwMywwLjcwNzE1LDQ5LjQ4OTg4LC03LjQxOTgpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMyLjIxNzEsLTM1LjU0NzkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS42MTIyMDEsLTU5LjY3MjYwNSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNjEuNjEyMjAxJyB5PSctNTkuNjcyNjA1Jz7iiIY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
    \node  (1) {$R$};
    \node  [right = of 1] (2) {$A \times  A$};
    \node  [below = of 1] (3) {$A$};
    \draw  [>->,morphism] (1) to node {$(a,b)$} (2);
    \draw  [->,morphism] (3) to node {$\rho $} (1);
    \draw  [>->,morphism] (3) to node[swap] {$\Delta $} (2);
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></fr:figure>
    
  </fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Backlinks">Backlinks</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1904</fr:anchor><fr:addr
type="user">ct-0004</fr:addr><fr:route>ct-0004.xml</fr:route><fr:title
text="Equivalence relation">Equivalence relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[(a,b)\colon R\rightarrowtail A \times  A]]></fr:tex> be a relation in a cartesian category.
  <fr:tex
display="inline"><![CDATA[(a,b)]]></fr:tex> is said to be an <fr:em><fr:strong>equivalence relation</fr:strong></fr:em> if it is <fr:link
type="local"
href="ct-0001.xml"
addr="ct-0001"
title="Reflexive relation">reflexive</fr:link>, <fr:link
type="local"
href="ct-0002.xml"
addr="ct-0002"
title="Symmetric relation">symmetric</fr:link>, and <fr:link
type="local"
href="ct-0003.xml"
addr="ct-0003"
title="Transitive relation">transitive</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>