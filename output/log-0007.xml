<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1744</fr:anchor><fr:addr
type="user">log-0007</fr:addr><fr:route>log-0007.xml</fr:route><fr:title
text="Interpretation of terms">Interpretation of <fr:link
type="local"
href="log-0002.xml"
addr="log-0002"
title="Terms">terms</fr:link></fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>18</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with sufficient structure and <fr:tex
display="inline"><![CDATA[\Gamma  = x_{1}\colon B_{1},\ldots ,x_{m}\colon B_{m}]]></fr:tex> be a context over a signature <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>.
  Given a <fr:link
type="local"
href="log-0006.xml"
addr="log-0006"
title="Sigma structure"><fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structure</fr:link> <fr:tex
display="inline"><![CDATA[M]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the interpretation of a term-in-context <fr:tex
display="inline"><![CDATA[\Gamma .t]]></fr:tex> of sort <fr:tex
display="inline"><![CDATA[B]]></fr:tex> in <fr:tex
display="inline"><![CDATA[M]]></fr:tex> is a morphism <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .t\rrbracket \mathclose {}}_{M}\colon M(B_{1},\ldots ,B_{m})\to MB]]></fr:tex> defined recursively on the structure of <fr:tex
display="inline"><![CDATA[t]]></fr:tex> as follow:</fr:p><fr:ul><fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .x_{i}\rrbracket \mathclose {}}_{M}]]></fr:tex> is the <fr:tex
display="inline"><![CDATA[i]]></fr:tex>-th projection <fr:tex
display="inline"><![CDATA[\pi _{i}\colon M(B_{1},\ldots ,B_{m})\to MB_{i}]]></fr:tex>.</fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[f\colon A_{1},\ldots ,A_{n}\to B]]></fr:tex> is a function symbol and <fr:tex
display="inline"><![CDATA[t_{1},\ldots ,t_{n}]]></fr:tex> are terms of appropriate sorts then <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .f(t_{1},\ldots ,t_{n})\rrbracket \mathclose {}}_{M}]]></fr:tex> is the composite
    <fr:tex
display="block"><![CDATA[       M(B_{1},\ldots ,B_{m}) \xrightarrow {({\mathopen {}\llbracket \Gamma .t_{1}\rrbracket \mathclose {}}_{M},\ldots ,{\mathopen {}\llbracket \Gamma .t_{n}\rrbracket \mathclose {}}_{M})} M(A_{1},\ldots ,A_{n}) \xrightarrow {Mf} MB     ]]></fr:tex></fr:li></fr:ul></fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1745</fr:anchor><fr:addr
type="user">fnd-0005</fr:addr><fr:route>fnd-0005.xml</fr:route><fr:title
text="Semantics">Semantics</fr:title><fr:taxon>Section</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1270</fr:anchor><fr:addr
type="user">log-0006</fr:addr><fr:route>log-0006.xml</fr:route><fr:title
text="Sigma structure">Sigma structure</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with finite products and <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> be a <fr:link
type="local"
href="log-0001.xml"
addr="log-0001"
title="Signature">signature</fr:link>.
  The category of <fr:em><fr:strong><fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structures</fr:strong></fr:em> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, denoted as <fr:tex
display="inline"><![CDATA[\Sigma \text {-}\mathsf {Str}(\mathcal {C})]]></fr:tex>, consists of the following data:</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
  
  <html:tr>
    
  <html:th>Objects</html:th>

    
  <html:th>Morphisms</html:th>

  </html:tr>

  
  <html:tr>
    
  <html:td>
      A <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structure consists of the following data:
      <fr:ul><fr:li>Each sort <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> is associated with an object <fr:tex
display="inline"><![CDATA[MA]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
          This is extended to any finite string of sorts by the assignment <fr:tex
display="inline"><![CDATA[M(A_{1},\ldots ,A_{n}) \mapsto  MA_{1} \times  \cdots  \times  MA_{n}]]></fr:tex>.
          The empty string is associated with the terminal object <fr:tex
display="inline"><![CDATA[1]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:li>
        <fr:li>Each function symbol <fr:tex
display="inline"><![CDATA[f\colon A_{1},\ldots ,A_{n}\to B]]></fr:tex> is associated with a morphism <fr:tex
display="inline"><![CDATA[Mf\colon M(A_{1},\ldots ,A_{n})\to MB]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:li>
        <fr:li>Each relation symbol <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1},\ldots ,A_{n}]]></fr:tex> is associated with a subobject of <fr:tex
display="inline"><![CDATA[M(A_{1},\ldots ,A_{n})]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:li></fr:ul>
    </html:td>

    
  <html:td>
      Let <fr:tex
display="inline"><![CDATA[M]]></fr:tex> and <fr:tex
display="inline"><![CDATA[N]]></fr:tex> be <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structures.
      A <fr:em><fr:strong>homomorphism</fr:strong></fr:em> <fr:tex
display="inline"><![CDATA[h\colon M\to N]]></fr:tex> consists of an indexed family of morphisms <fr:tex
display="inline"><![CDATA[h_{A}\colon MA\to NA]]></fr:tex> for each sort <fr:tex
display="inline"><![CDATA[A]]></fr:tex>.
      This data is subject to the following conditions:
      <fr:ul><fr:li>For each function symbol <fr:tex
display="inline"><![CDATA[f\colon A_{1},\ldots ,A_{n}\to B]]></fr:tex>, the following square commutes:
          
    
      
      <fr:figure><fr:resource
hash="afca79891410f1ca592bfa4b822463a4"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI1MC41ODkzMnB0JyBoZWlnaHQ9JzExOS42OTY4NjJwdCcgdmlld0JveD0nLTcyIC03MiAxNjcuMDU5NTQ3IDc5Ljc5NzkwOCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTVlBQW9BQUFBQUE0UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MUcyTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUJrQUFBQVpERnVBckpvWldGa0FBQUJ5QUFBQUN3QUFBQTJLUmllTW1ob1pXRUFBQUgwQUFBQUhnQUFBQ1FGeXdMV2FHMTBlQUFBQWhRQUFBQUlBQUFBQ0FZS0FKSnNiMk5oQUFBQ0hBQUFBQVlBQUFBR0FESUFBRzFoZUhBQUFBSWtBQUFBRndBQUFDQUFCQUFnYm1GdFpRQUFBandBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEQ0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd5TS93SDhwa2gwa2hxL2dPRkFhTjNERmdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy85RHlQOFh3SHdHQUZGSEJvMEFBQUFBQVFDU0FBQUNOd0tyQUI0QUFBRVJCaFk3QVJVbUp5TUdCelV6TWpZbkVRNEJKeU0xTXhZL0FUWTNOaFlCbUFRaVRqTXNPdEU2TEROT0lRTXVWQk1TRWhJK0J6ODVHQTRDaS8zTkZ4UXRBd0VCQXkwVUZ3SUFFZ3dCTFFJS0Fnb3VBUWtBZU5wallHUmdZQURpNzJzZEF1UDViYjR5TUxNd2dNRGpDRjFYWkpvNWlHazFrT0pnWUFMeEFBWHBDRVI0Mm1OZ1pHQmdadmpQQUNTREdDWXhOREtaTXdCRlVBQVRBRUxjQXFnQUFBTlNBQUFDdUFDU0FBQUFBQUF5QUFCNDJtTmdaR0JnWUdLUVp3RFJERkFTQ1FBQUE2UUFKUUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVSUFBb0FBQUFBQmN3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngySEdOdFlYQUFBQUU0QUFBQU1nQUFBRHdBclFCeloyeDVaZ0FBQVd3QUFBSThBQUFDbENqeGVJMW9aV0ZrQUFBRHFBQUFBQzhBQUFBMktaK2VXV2hvWldFQUFBUFlBQUFBSHdBQUFDUUhOZ041YUcxMGVBQUFBL2dBQUFBUUFBQUFFQThrQVVGc2IyTmhBQUFFQ0FBQUFBb0FBQUFLQWJBQXpHMWhlSEFBQUFRVUFBQUFHQUFBQUNBQUNBQlVibUZ0WlFBQUJDd0FBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUUvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1Qc2s0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpNaGpadmdQNURORHBKSFUvQWNLQXdEemhBMXBlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPakhrL2Y4UDVEdUM2UDhIL2s4RnF3SUNBSlZIQ1JvQUFIamFOWkcvYjlOUUVNZmYzWHY0eGZaemJNZU8zUitwV3pmRmJpb2FOMmxxS3hWeStrdUJxRldISWpvVUJvbzZnS0FMU0V3TVNDQ0VHSkRnWDJCalltQ0RxUklxNGk5Z1lXT0FQNEFGcVNuUHJYcDN3OTE5bC92Y2x5QzVmM3BLai9FbjZaS3JoSUFUd0dMcStSNVB3SVFvenNIMzBpeUJrQ3NtS2p5QXpQZjhNaFRpZEJSSGFaWkRCam0wUFU1RC9QMEVSaFowQjJCc1pXMndVUUZ3UkdtWkdmYnd1OFBvcGxBQW81TE9BV3psY2FmSmRBUmVicTBGOEk1YjAyTHZGOVR4Nk9TMWJZQWl4cEVDVUxDcUtnQzMrM3VBN05EVjFZb0dTSVZjTXFCY3cxR0VlaFA3dWhDUGhwK0lERXFlU3BZZitJWE1rZzdwRVpJNTJWS1VnQkl0ZFZJL0RNQlhlSkVCOFBNbVBGZmFxYk1vT1RwUlhJOFVUaTk2eW9jdnFlM1dITWUxNFAyREY4aldEV3N3dUhjSDZJNHdiejBmcnBkZHI1cE5mRHc2ZklPRHJjK1RObnY0OWVBdDI5NysxNmMzY1ZRWURBQVV3NVVVTjFiNzg1bzZxNXE3cmMxY1U1ZXBwSlFnRnZUbzNkVzVIRUY0SjBlNHY5VWU0UENQSTFtQTNENzlTK2ZnbU93UTBxUHBVaHJGWmZrd3FNZnk3MWxhcE9mTFM5dGVWVEdocUtwU3pEa3NTb3ZjTTc0bXhHY09wZkVacjBuTGhXdlp0OURRRkxESHBpS0JxakJLMGhITkNicFR1M3g4dnovWXhpcnp5eHJETU9xWnJGVG9FOEpxYkNROVJOV1pSNG5hSHJFdmwzaERWV3ZqSGlnSHJ4Ym1QY09lQWJ6VzFGUkU3VkpTcXlVTTUvS1pGVnp0WGxuUjg3Q21XM1VLYTRrcGRkMXR1WldFd1VKanRKSThTNjRqYTNrakhkZi9NT21ZbFVwQS9nT3RtbURYZU5wallHUmdZQURpdTgxYy92SDhObDhabUZrWVFPQnhoSzRyZ3Y3L2xma0cwMTBnbDRPQkNTUUtBQmQ4Q25RQWVOcGpZR1JnWUdiNHo4REF3S0xHRU1QZ3gzeURBU2lDQWxnQVFhb0N1QUFEVkFBQUJDVUFhUVFtQUh3RGhRQmNBQUFBQUFCbUFNd0JTZ0FBZU5wallHUmdZR0JoQ0daZ1pnQUJSZ1kwQUFBSkhBQmRlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ3dOcUZnWW1WcVF0Z0YyV3dqWndRQ2FucTJOL2RoL0hRTjF5ZCsyRUROVDhVM0s5Z2x2UitKWlc0QjFkTW1XZWVpSHZMWExQZ25TZUs4bG1TVno0eWw5SjhacTU0NFN2elJQTHZ6RFVyZmpmQlhhNkRqV29YakkzKzVGeTMzdHZZZDhHcnBXNlMzMXB2NDJHd1JoMXZ5b3hkUDU2ZGFuV2pXellFSEJldURGZ2lpcDBrSnJIbkpKMmpZODArSmIxd2tGeXhSTlA4NjdmUys3UTVwSitNYkk3Y1JBMmpMSHJSczJ3VmJYcXBhZjhBeUJFdjd3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1NQUFvQUFBQUFBM2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVeDBvMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNFWjJ4NVpnQUFBV1FBQUFCWUFBQUFXT2ErZEJWb1pXRmtBQUFCdkFBQUFDd0FBQUEyS0ptZU1HaG9aV0VBQUFIb0FBQUFJQUFBQUNRRlZnSTVhRzEwZUFBQUFnZ0FBQUFJQUFBQUNBVWFBSEJzYjJOaEFBQUNFQUFBQUFZQUFBQUdBQ3dBQUcxaGVIQUFBQUlZQUFBQUZ3QUFBQ0FBQkFBYmJtRnRaUUFBQWpBQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBQy9BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9hTWhneU0vd0g4cGtoMGtocS9nT0ZBZFNCRE44QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpRy8vOUR5UDhYd0h3R0FGRkhCbzBBQUFBQUFRQndBQUFCNUFLcEFCa0FBQUVSQmhZN0FSVXZBUThCTlRNeU5pY1JEZ0VuTlJZMk56WVdBVmNESUVrbloxQndSaWRKSUFNc1ZCUWhkRE1WQ3dLTC9ja2FGU1VEQVFJQ0pSVWFBZ29VQ1FFa0FoWXVBUW9BZU5wallHUmdZQURpbmpzSjhmSDhObDhabUZrWVFPQnhoSzRyTXMxMG1Xa2xrT0pnWUFMeEFBazFDTFI0Mm1OZ1pHQmdadmpQd01EQWRKbWhnQ0daOFFrRFVBUUZNQUVBVnBvRGxBTFRBQUFDUndCd0FBQUFBQUFzQUFCNDJtTmdaR0JnWUdLUVlnRFJERkFTQ1FBQUF5Y0FJQUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOMEFBb0FBQUFBQTlnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdpTUp5NDJOdFlYQUFBQUZBQUFBQU1RQUFBRHdCQ1FEMFoyeDVaZ0FBQVhRQUFBQ2xBQUFBcVA3UnJWUm9aV0ZrQUFBQ0hBQUFBQzhBQUFBMktWaWRpR2hvWldFQUFBSk1BQUFBSGdBQUFDUUdjZ0E2YUcxMGVBQUFBbXdBQUFBTUFBQUFEQWg5QVNac2IyTmhBQUFDZUFBQUFBZ0FBQUFJQUJvQVZHMWhlSEFBQUFLQUFBQUFGd0FBQUNBQUJRQWpibUZ0WlFBQUFwZ0FBQURPQUFBQk9CTi9LcnR3YjNOMEFBQURhQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FNbUJpU1FVbHlXRHBUY3puQ2RXZkdQRVFNRHN5THpPYUF3STBMRi8vOE1EQUFyekErVUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lOSUEwRzVCbUJNcHVaN2orL3orUUQ2Yi9lLzNYQnFzQ0FnQ3ZWQW4zQUFBQWVOb1ZqVThLZ2tBY1JuL2YrR2RxMUNUVVVTTXdMWFFaR09naXlQUFV0Z3Q0cCs3UXJoc0VEcTUwMHhWcWVvc0hEejc0Q0hTbkowMDRrME1Vck1DTHNycWdyZVdFM1NZNlFGdnVRVW1PYlBzWGFVQ1A3NGU5V1VDNURwNUJSdmErT0lMYlZWbVZIYXF5YmRvbVE0Zm1WTWVTdlZSL3RjeFE4SG4wUk1LTVlCaldZSW5qanNxekZxRUpLTlhmVEpGYXMvTEJZcTRIdm9nWmZEVzRScnJVbHo4dFdoKzZBQUFBZU5wallHUmdZQURpUHozN2xlUDViYjR5TUxNd2dNRGpDRjFYQlAzL0hmTkVKbUVnbDRPQkNTUUtBQ21wQ2cwQWVOcGpZR1JnWUZiOFl3UWtKeklVTXhRejNXRUFpcUFBWmdCYW93T3dBQUFEa1FBQUFWc0Fjd09SQUxNQUFBQUFBQm9BVkhqYVkyQmtZR0JnWmxCaUFORU1VQklKQUFBRUNnQXBBSGphVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9GUmlZMkZnWW1YcUF0aWdESEdRSFNKRnFqcnl1M3U0SG5yRDZYay83b0NTSHpLZWsvRWE5M055Q2xGL1hQRENXK0twcUVYaWtnK1dUTWp5bVRoek5vbHpTYjRTRjd4elNUd1YvenR4eVNlUGJkZmU3cjMxYXQ4WjY5MjVEZVA2WUgxb09xZFd1b3A2WjUzMXg5NGFkUnFWR1pvd1hGdFY2MHJYYk9sb3VYR254K0pSN01VeGtSMW55UUlqYXc3UkNUU1NPbW10MEZULzhwM2tMbmFPOFpPUnpra1NKVFRJVlpCOWxiYWlqcGVhK2hmemVUQlBBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFZMEFBb0FBQUFBQjhnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoV2gxWjJOdFlYQUFBQUU0QUFBQVBBQUFBRXdCRGdFUFoyeDVaZ0FBQVhRQUFBTlVBQUFFZE5oV2Z2Um9aV0ZrQUFBRXlBQUFBQzhBQUFBMktsYWRoMmhvWldFQUFBVDRBQUFBSUFBQUFDUUh3Z01wYUcxMGVBQUFCUmdBQUFBWUFBQUFHQko0QVZ0c2IyTmhBQUFGTUFBQUFBNEFBQUFPQkF3Q3FtMWhlSEFBQUFWQUFBQUFGd0FBQUNBQUNBQlNibUZ0WlFBQUJWZ0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUdLQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1GbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjByNk11UXhNL3dIOHBraDBraHEvZ09GQWJNM0RNQUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQ3lBTkJjREIxQ09pY0dQSVkwaGd5SHYvMytnbUMrTS9YL0wvN24vNS95ZkR0WUJCUUJZVkE0VWVOcU4wNytQRzBVVUIvQjliMlpudkQ4OHM3ODNuSCtkdmM2dUV3Zjc3dXhiazdPeHp6bUxRTzZBQzBWT1ZGU1JFSWxDUllWQWdqUkJRQUJCUVFzVkhmOEFJZzBpRWgwRm9xU2lTNGVnczgzc0hRU0pBcUZ0WnVjNzByN1B2TGNhYUVmck5mMElIMmpIbWdhRXM2Z0JlY0Q2SUNIdHd6Q1BvM3prQStPdHpBSVdGMmtVQytnRFYra1U0aW1NL0ZHdTFnbEw4M2lRUjdGZmJBL3lPR0JaeW1oMGp3TDNzb2JVMzUzUExJS08yS3VSVDFiWHpTQ0FPL2Qwd0tBdlNnQlN2MzNMSkFobFBybW92ME9oNUFSK0V6ejVhV2lUbS9DK0tZSVBhdUE1b3lxK3V2dzE1aHlRSmh3b0VGV1p5d0c4RFZ3czd3YWtpbmVXdjRUVXJoSWtoZ29vVlFlY0VwQnVCVEhpREFodHFlT0d2M3lBendxVisxSzlCcHFpYTFmWEsvSXpmcU9OaTNzUWtMVFNERWhCam5laVVGMElaOWxmNFBSdksvajVidDZIVkFVTkdFVUNNZ0hreG4xU3NyakJWai9kWllCaHo1REV1MzJyakNEWXVLdS8xNXlESno1MGJSMzAxeWxaRk44djlCS0VQdW5pMGZJSFVkSnR2TG44N1pTaG0rZFFJUnlwREowNkpsd3Y2bWYyOGhGOEs2eXNZRG9GRXlzRjh0Unh1TzdqYS9panRsODRwUElMNEsyaXhFRVVSNHlyRGs1aFJzNzZwVFJxZjZkb2FaSm1hVDVTblJRb1FlRllCbC9zT2RUWk1PYmJuVDJBZHBnU2tBMHBaYnRKYWoxNVZFZGZYcGVoaUs0a0Z5WUFTYVJ5cHk2bDU5WE4wc1lyUlF5ZnJiNjc1dTRQZ3dPU0p2Vk5iTFBNTWhEb1lmajU3eWRFU1U1ZXJtVHArZlkvRVR5UlBubWZ0a3FnblZxZVgvK0JiK0pEN2JDd3FHTHJ5TmtaS1dUeFRqN0tCM0ZkTlVZOVNqaWNnZHBSMDZpNm9JNVJaZXJCN3NpZlFwcWNYY0FvanpqTVg2aStkUG1ab2ExbUQzMjdiSkpxWStLaGF6S0lMVGVaZHA0Q1VoWlJwT2FsTXprK0ozVi8weWlac2VHNStzY1VaZHR3QUFSZlhEb1ArTlhxWVhNQWVuOVk3azNZdU5Kc3VpMmNQZTBoeGx0eDFLUDlDN2ExMmI1eXNCMXVJeDUwSXV2YTIybEZXdUNYSTF5VXBVbE5XZUtVMk1xNXBaeGZ3dmZhaTVvMkkvbnU4SlJRL0dZOVJacGlWSXlkbXJmL1pTY1NCVW16dDdxMnhhUmZiMWs2TnkwR2dXdGtCd3Nlbit4ZnVrRWUwemZILzZMYnNxQUgzY3VIWGNGcmdXNkUxUURtWDIvMVlpZXNBdXozQWdzUTVienV0L0hpYm5PTTJIdnV2L1hlZ09CazJxeTljUnhJQVk2ci9RbnU1Wk0wZU5wallHUmdZQURpL0E5dnJPUDViYjR5TUxNd2dNRGpDRjFYQlAxZm42V2Y2U0tReThIQUJCSUZBQ3FZQ2ljQWVOcGpZR1JnWUdiNHo4REF3QkxOWVBEL09Fcy9BMUFFQmJBQkFGMWxBL01DeGdBQUJGc0FUQU9lQUVjQ09nQkxBcXdBVFFMVEFEQUFBQUFBQUlRQTZBRk9BY0lDT2dBQWVOcGpZR1JnWUdCakNHUUEwUXhRRWdrQUFBanlBRnNBZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmdBQW9BQUFBQUE5UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFVOejdHTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUNnQUFBQXJLQUNIYVJvWldGa0FBQUNCQUFBQUMwQUFBQTJLRWVkaDJob1pXRUFBQUkwQUFBQUh3QUFBQ1FFandHOGFHMTBlQUFBQWxRQUFBQUtBQUFBQ2dSR0FHUnNiMk5oQUFBQ1lBQUFBQWdBQUFBSUFDd0FWbTFoZUhBQUFBSm9BQUFBRndBQUFDQUFCUUFaYm1GdFpRQUFBb0FBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFEVUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtdk1jNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwVFVZTkJrWnZnUDVETkRwSkhVL0FjS0F3RHZrUTBlZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pFajV6OEFZd3N6QUlNN0F3Q3FpcEthdXgyaXVabVp1eDJqRXo4akhLTTRtSk04b3hoZ3NsbXlvS2NQSUtLTm1tQ2JHeUJQbndjamtFcy9QL0kwcktUNWlsYTNUd3REa1ZCNkJ4RC90bGYvK3BRaXlNQUFCSTRNbDBGeE5pTG1NWW16c2ZJeEtwa0JUMVUzVTlCblZ6TTJNeE1UbEdCazF3Q2FLOHNaNk1RWDdDREV6TW9xQzdXR0FtcGowdDNYaEIxOGhGaWF3UFFBVkpDRk1lTnBqWUdSZ1lBRGlUeFB2Mk1mejIzeGxZR1poQUlISEVicXVDUG8vQTFNRE00akx3Y0FFb2dBaXpBa3ZBQUFBZU5wallHUmdZR2I0ejhEQXdOVEFZTWxneVJqQ0FCUkJBVXdBTzJ3Q1VBQUNnQUFBQVkwQVpBQTVBQUFBQUFBQUFDd0FWbmphWTJCa1lHQmdacEJnQU5FTVVCSUpBQUFERUFBZkFIamFSWXd4YjhJd0VJVy9pQVNKZE9oU2RXQUFEOHhXb2pCM1lXQmlaV0lCYktJTWNaQVRJaUdoanYzZFBZd2xibmo2N3IxM0IrVDhrdkNjaE0rZ3owbkpaSHR4eGdkZmthZXlMU1BuekZreElVbG40aXo0aVp4S2NvaWM4YzBsOGxUOFIrU2NOWCticnIzZUJ1dlZyalBXdTNQcnkySnZmZDkwVHBXNkNQdldPdXVQZ3pYcWRGZG1iUHF4YmxXbEMxMnhvYVBseW8wQmkwZXhFOGNFZHB3bDg1UVU3SVBUMDBqcXBGV2l4WDNuVzhsZDZCekRKeU9kRTNkUnd5aFh2V2d0YlVVVkxqWFZQMk05THc4QUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWE1BQW9BQUFBQUJ2QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVkMHZtTnRZWEFBQUFFNEFBQUFRUUFBQUV3QXBBRFhaMng1WmdBQUFYd0FBQUxjQUFBRGtGSUZIdzFvWldGa0FBQUVXQUFBQUM0QUFBQTJLZlNkbm1ob1pXRUFBQVNJQUFBQUhnQUFBQ1FIVkFLWmFHMTBlQUFBQktnQUFBQWNBQUFBSEJITkFWUnNiMk5oQUFBRXhBQUFBQkFBQUFBUUFob0M4RzFoZUhBQUFBVFVBQUFBR0FBQUFDQUFDd0JKYm1GdFpRQUFCT3dBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGd0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtNm1hY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcnFNUGd4TS93SDhwa2gwa2hxL2dPRkFkWjFEUFVBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0N5QU5CY0RCMUNPaVVHSFFZL0JpY0h2LzMrZ0dJanR5T0Q3Ly8vL3EvK3YvRC8wZndkWUJ4UUFBRG9TRFhJQUFBQjQyajJTeld2VVFCakc1NWxKSnB2ZHpjenVaamRMdTE5dGQ3dlJmbGh0MTZ3dHVvTGZXQ3pWZ3JaUUVBcGFCZlVnYlFVdjlpQitZRVZRRUR4NThlWlY4Rkk4Q0lySG9tY0Y5U1QrRGVuNkpxV0daREo1NXlVOHYrZDVHZGg4ZDRwdHNadXN3RmhiYWlqNHpYWUg3WllsNi92UUN0cmVsbEdYRFE5Qzl3N0JjUE05bFVyUFVWeHFKUThnelZYdi9HVE8wT2dicWNGZ2RJRXQwUE9KM1dBSitwL0NRTE1Wakh1ZlVCdXQwUjE0MFZxalBzNGEzUzcveWIrek1UWk9uUWphNDE3UnpYc1RnU2ZIWVBsTnZ4VVV2YUE5aG41TDVyMWlVRlNnZWxTZUlIa1Q0ajJ1eUx3ajBmRkdDMGliSytzSkUwN0tiUW5iMnU3T09HWFhFWERNNWZrMDB2WkE1OVhmL2pWK01RTmJoK3VlRmhVTFFvQW50QVdraTFkUDNzODNNdUJheWFpYzFCTDFMN2dROFFnMjNBMkY1SnVzeW9iWUlWTHF0dXErSkczOVZSUVVyQ3FLNUpxMCttV3MxNDNFQlUyLzNwU1cyTjBMYXBoNDg3VGtWN1RHL09LU1dKK2JuZ00vblRtM3V2MmlyTlJVOWZYTHl5c2MrNDdmcjdubXJZM0ZOYzczbi9sNHlnRFVMSi9NY2xHMndNOVBuVjNXeVpuSjZXT3FZMFFFY0hGUzNEN1ZPTUdoZThLMzRzN000S3pZL3AyVHlTaUhrVzdYR09VZjJHbjZJQUZWQkxHQi80MTFTWFR6WUFxeUlMMGF2RUo4R2tHUWFEZUlFU21Mb29zT29vMzBtMUs4ZTBTU0JpZkoxL1Y3U1JNWlo2cHFQdDlla2xtOThNUkFhWmppVU1iMVpjY3hqb3pJQnpoZXplZ05ONDFackNaVTdtRUpPdGV1OEp2aGo1emxTQ1BPZ0ZNaWtraXFmRHE4b3d4UjRIZkRyOHAyZXdCdXF6aWxFcTFEZmJ5Y0VhSkNyVlkyM09Sbm9xVElGQlRpbWR0REdUMmdqSTVFckFwMTZRdGZSR0RGbldrYThBa2k0bXFPWVJlc0ZHY2o2YVNHTmpsQWc2OGc1RE5oMnFsRTEzNW9vbmZZalhIU1FNb2tvTWRHcFZGUm1jZVpsUHkxQ3BTSHRhREJ1M2JONWh4cDQvQW9udzAvcTRUdytHSXUvSzNzYkMvbjVZZ2dwWGNJQmkyK0k5cHl3ai80bHNxV1NPd09veUdqOTE3MkQzRXVpQ0o0Mm1OZ1pHQmdBR0pMU1huT2VINmJyd3pNTEF3ZzhEaEMxeFZCLzdkaTBXVzZDK1J5TURDQlJBSExsd2ZRQUFCNDJtTmdaR0JnWnZqUEFDUWZNcWo4MzhDaXl3QVVRUUhzQUdBbEEvUUFBQUoyQUFBQkhBQllBUndBV1FNQUFDUURDQUFyQStFQUxBTTJBQ2dBQUFBQUFDZ0FQQUNRQU93QllnSEllTnBqWUdSZ1lHQm44R0JnWmdBQlJnWTBBQUFJV2dCVmVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Ljc5NDcyNSwtNjAuNDQ3NTAxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMyLjg2MDUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYuNzk0NzI1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYuNzk0NzI1JyB5PSctNjAuNDQ3NTAxJz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzMuOTU2NjE3JyB5PSctNjAuNDQ3NTAxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzcuODMwOTkxJyB5PSctNjAuNDQ3NTAxJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzE1LjMwMjk5JyB5PSctNTguOTUzMTInPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTkuNzcyMzYnIHk9Jy02MC40NDc1MDEnPiw8dHNwYW4geD0nMjQuMjAwMTY4Jz4uPC90c3Bhbj48dHNwYW4geD0nMjguNjI3OTc2Jz4uPC90c3Bhbj48dHNwYW4geD0nMzMuMDU1Nzg0Jz4uPC90c3Bhbj48dHNwYW4geD0nMzcuNDgzNTkyJz4sPC90c3Bhbj48dHNwYW4geD0nNDEuOTExNCc+QTwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzQ5LjM4MzM5OScgeT0nLTU4Ljk1MzEyJz5uPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzU0LjgwNjM5MScgeT0nLTYwLjQ0NzUwMSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzIuMDI3MTYsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Ljc5NDcyNSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Ljc5NDcyNScgeT0nLTYwLjQ0NzUwMSc+TjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScyLjI5NjE2NScgeT0nLTYwLjQ0NzUwMSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc2LjE3MDUzOCcgeT0nLTYwLjQ0NzUwMSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PScxMy42NDI1MzcnIHk9Jy01OC45NTMxMic+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScxOC4xMTE5MDcnIHk9Jy02MC40NDc1MDEnPiw8dHNwYW4geD0nMjIuNTM5NzE1Jz4uPC90c3Bhbj48dHNwYW4geD0nMjYuOTY3NTIzJz4uPC90c3Bhbj48dHNwYW4geD0nMzEuMzk1MzMxJz4uPC90c3Bhbj48dHNwYW4geD0nMzUuODIzMTM5Jz4sPC90c3Bhbj48dHNwYW4geD0nNDAuMjUwOTQ3Jz5BPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNDcuNzIyOTQ2JyB5PSctNTguOTUzMTInPm48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNTMuMTQ1OTM5JyB5PSctNjAuNDQ3NTAxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTguOTA5NzNWLTQ3LjQ5NTc3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00Ny43NDU3NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjQzNTkxLC0zMC4yMDI3NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYuNzk0NzI1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYuNzk0NzI1JyB5PSctNjAuNDQ3NTAxJz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yLjEzMDQ2NycgeT0nLTU5LjQ0NTY4OCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSczLjAzMDgxNCcgeT0nLTU3Ljk1MTI5Mic+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc5LjIzMTM3NScgeT0nLTYwLjQ0NzUwMSc+w5c8dHNwYW4geD0nMTcuMjcyMjM2Jz7CtzwvdHNwYW4+PHRzcGFuIHg9JzIwLjk5OTAxMic+wrc8L3RzcGFuPjx0c3BhbiB4PScyNC43MjU3ODknPsK3PC90c3Bhbj48dHNwYW4geD0nMjguOTA2MDY5Jz7DlzwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzM2Ljk0NjkyOScgeT0nLTYwLjQ0NzUwMSc+aDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc0MS42MTExODcnIHk9Jy01OS40NDU2ODgnPkE8dHNwYW4geT0nLTU4LjQ0OTQzOSc+bjwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDc1LjkxOTA0LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Ljc5NDcyNSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Ljc5NDcyNScgeT0nLTYwLjQ0NzUwMSc+TTx0c3BhbiB4PSczLjk1NjYxNyc+QjwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDc2Ljc1MjM4LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNi43OTQ3MjUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNi43OTQ3MjUnIHk9Jy02MC40NDc1MDEnPk48dHNwYW4geD0nMi4yOTYxNjUnPkI8L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMzcuNDE2MDUgMEg3MC44NjM1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDcxLjExMzUsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ny44NTk1Myw0LjE3MjkxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNi43OTQ3MjUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNi43OTQ3MjUnIHk9Jy02MC40NDc1MDEnPk08dHNwYW4geD0nMS41NTAzODcnPmY8L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNODUuMzU4MjYtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw4NS4zNTgyNiwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4LjYyMjE1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYuNzk0NzI1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYuNzk0NzI1JyB5PSctNjAuNDQ3NTAxJz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yLjEzMDQ2NycgeT0nLTU5LjQ0NTY4OCc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMzYuNTgyNy01Ni45MDU1SDcxLjY5Njg0JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDcxLjk0Njg0LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC41MDUzNywtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Ljc5NDcyNSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Ljc5NDcyNScgeT0nLTYwLjQ0NzUwMSc+Tjx0c3BhbiB4PScuMjYzNTQxJz5mPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \DiagramSquare {
              width = 3cm,
              nw = {M(A_{1},\ldots ,A_{n})},
              ne = MB,
              sw = {N(A_{1},\ldots ,A_{n})},
              se = NB,
              north = Mf,
              south = Nf,
              west = {h_{A_{1}} \times  \cdots  \times  h_{A_{n}}},
              east = {h_{B}},
            }
          ]]></fr:resource-source></fr:resource></fr:figure></fr:li>
        <fr:li>For each relation symbol <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1},\ldots ,A_{n}]]></fr:tex>, there is a morphism <fr:tex
display="inline"><![CDATA[g\colon MR\to NR]]></fr:tex> such that the following diagram commutes:
          
    
      
      <fr:figure><fr:resource
hash="62110a92adaa00deaa43a4497b96dec2"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI0NS41OTU3NjZwdCcgaGVpZ2h0PScxMTAuOTIxNDg0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTYzLjczMDUxMSA3My45NDc2NTYnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1ZQUFvQUFBQUFBNFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVeDFHMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNFWjJ4NVpnQUFBV1FBQUFCa0FBQUFaREZ1QXJKb1pXRmtBQUFCeUFBQUFDd0FBQUEyS1JpZVFHaG9aV0VBQUFIMEFBQUFIZ0FBQUNRRnl3TFdhRzEwZUFBQUFoUUFBQUFJQUFBQUNBWUtBSkpzYjJOaEFBQUNIQUFBQUFZQUFBQUdBRElBQUcxaGVIQUFBQUlrQUFBQUZ3QUFBQ0FBQkFBZ2JtRnRaUUFBQWp3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRENBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVptV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9hTWhneU0vd0g4cGtoMGtocS9nT0ZBYU4zREZnQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpRy8vOUR5UDhYd0h3R0FGRkhCbzBBQUFBQUFRQ1NBQUFDTndLckFCNEFBQUVSQmhZN0FSVW1KeU1HQnpVek1qWW5FUTRCSnlNMU14WS9BVFkzTmhZQm1BUWlUak1zT3RFNkxETk9JUU11VkJNU0VoSStCejg1R0E0Q2kvM05GeFF0QXdFQkF5MFVGd0lBRWd3QkxRSUtBZ291QVFrQWVOcGpZR1JnWUFEaTcyc2RUT1A1YmI0eU1MTXdnTURqQ0YwZlpKbzVpR2sxa09KZ1lBTHhBQUozQ0RaNDJtTmdaR0JnWnZqUEFDU0RHQ1l4TkRLWk13QkZVQUFUQUVMY0FxZ0FBQU5TQUFBQ3VBQ1NBQUFBQUFBeUFBQjQybU5nWkdCZ1lHS1Fad0RSREZBU0NRQUFBNlFBSlFCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRXFmbTV1RGs2dkQyNndKMHFHcHBMWG9JdjUwYjBQd0JnN2ZQZWZjQUJrdkVvWkptQWNkSnBVM2p6em1oMFhraWZpcnlCbS9yQm1ScEROeFZ1d2lwMHo1anp4bVNSbDVJdjRqY3NZZjczMVQzKzZkOWVyWUdPdmRwZmJiay9WdDFUaTEwZm13SHF5ei90eFpvOHFuTW4zVjl0ZGFGVHJYQlhzYWFtN2M2YkI0RkVkeFRHREhSVExQbGxQWVd5ckpuSFEyYVBKdmVwRFVoY1k1L0dLa1VmSVVOZlJ5MDRwZXBhc293cDJtK0FCVk1pNURBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUllBQW9BQUFBQUJQZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MS9XTnRZWEFBQUFFNEFBQUFNUUFBQUR3QXJRQnhaMng1WmdBQUFXd0FBQUdUQUFBQnlMUGFTc0JvWldGa0FBQURBQUFBQUM4QUFBQTJLWTZlWjJob1pXRUFBQU13QUFBQUh3QUFBQ1FISlFPRWFHMTBlQUFBQTFBQUFBQU1BQUFBREFyK0FNVnNiMk5oQUFBRFhBQUFBQWdBQUFBSUFHWUE1RzFoZUhBQUFBTmtBQUFBR0FBQUFDQUFCZ0JVYm1GdFpRQUFBM3dBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFFVEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtWHNVNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaTWhqWnZnUDVETkRwSkhVL0FjS0F3RG9RUTFLZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pMay9mOFA1SVBwL3dmK1R3R3JBZ0lBbFNVSkdBQUFBSGphSFk4L2I5TlFGTVhmdWUveG52ODgyL0dmMkdrVFF0MFVXNmxvbktURlZoQnlRbFFGSWhCRGh3NFZDeElMQXd0SXpJeUlrWS9CekNkZ0tlSTdzREh3QlJocHNMbm5MdWVlNFo0ZkkvWjZ0K1BYOUpNdDJFUEdFQTV4V3NaSnJBcDR5UElhU1Z4V0JWSWxQWkpxaUNxSkV4ZHRlSmpsV1ZuVnFGQmpIaXVlMHUvMzZFM3RFTmhmcmJmbkFSQnE0NEZ3L0pzZm9lQlB0UVJsaHEwQVg3NDdtd2lib056WmVvalBxbk9vcjM1aFJOLytmdklkU04wbkRuQjB1aWFnL00wVlNMeUpiRE93UUZ3M1J3R3VMTm9qakNhMHNiVitlL09WTlFQMll2ZUhIK09hWFRDMjVPWDlNc3ZkNWdsR2VkTzFLbHZGU2RONEhuZWxoM2E3c3ZVMVRodXNTTWxHRStUL3FjcThkZExqYmt0YWZVOGRTOExmUDhnMG1kb3hHZ29ySEM0T0xsWC81V2I3bkxvaWNTMUJhYmIwaE5IbXQzVm5mRjRzaWN6d2hHajdiTjd6N3hwcWJKcURmZ3o1NnVQMEpIYjhJOURqaVdVU1diZUt3YUFRZEZ3ZnJlalI0dDdLcnRPQjNSbHhyQXV2eWUxb0ZnV0Z3SFM4RnhRZmlpY2tabkh2TEVxKzNBbTlJQml5Znc2Nk9tMEFlTnBqWUdSZ1lBRGlTemR6bmVQNWJiNHlNTE13Z01EakNGMGZCUDMvSy9OeHBydEFMZ2NERTBnVUFEUUZDeE1BZU5wallHUmdZR2I0ejhEQXdLTEtFTU1Relh5Y0FTaUNBcGdCUVY0Q3NnQURWQUFBQkNVQWFRT0ZBRndBQUFBQUFHWUE1SGphWTJCa1lHQmdaZ2htWUdJQUFVWUdOQUFBQ09vQVczamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b01EYWhZR0psYWtMWUJkbHNJMmNFQW1wNnRqZjNZZngwRGRjbmZ0aEF6VS9GTnl2WUpiMGZpV1Z1QWRYVEpsbm5vaDd5MXl6NEowbml2SlprbGMrTXBmU2ZHYXVlT0VyODBUeTc4dzFLMzQzd1YydWc0MXFGNHlOL3VSY3Q5N2IySGZCcTZWdWt0OWFiK05oc0VZZGI4cU1YVCtlbldwMW8xczJCQndYcmd4WUlvcWRKQ2F4NXlTZG8yUE5QaVc5Y0pCY3NVVFQvT3UzMHZ1ME9hU2ZqR3lPM0VRTm95eDYwYk5zRlcxNnFXbi9BTWdSTCs4QUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5nQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTno3R050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDZ0FBQUFyS0FDSGFSb1pXRmtBQUFDQkFBQUFDMEFBQUEyS0VlZGxXaG9aV0VBQUFJMEFBQUFId0FBQUNRRWp3RzhhRzEwZUFBQUFsUUFBQUFLQUFBQUNnUkdBR1JzYjJOaEFBQUNZQUFBQUFnQUFBQUlBQ3dBVm0xaGVIQUFBQUpvQUFBQUZ3QUFBQ0FBQlFBWmJtRnRaUUFBQW9BQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRFVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXZNYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWU5Ca1p2Z1A1RE5EcEpIVS9BY0tBd0R2a1EwZWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaRWo1ejhBWXdzekFJTTdBd0NxaXBLYXV4Mml1Wm1adXgyakV6OGpIS000bUpNOG94aGdzbG15b0tjUElLS05tbUNiR3lCUG53Y2prRXMvUC9JMHJLVDVpbGEzVHd0RGtWQjZCeEQvdGxmLytwUWl5TUFBQkk0TWwwRnhOaUxtTVltenNmSXhLcGtCVDFVM1U5Qm5Wek0yTXhNVGxHQmsxd0NhSzhzWjZNUVg3Q0RFek1vcUM3V0dBbXBqMHQzWGhCMThoRmlhd1BRQVZKQ0ZNZU5wallHUmdZQURpVHhQdktNZnoyM3hsWUdaaEFJSEhFYm8rQ1BvL0ExTURNNGpMd2NBRW9nQWZXZ2toQUFBQWVOcGpZR1JnWUdiNHo4REF3TlRBWU1sZ3lSakNBQlJCQVV3QU8yd0NVQUFDZ0FBQUFZMEFaQUE1QUFBQUFBQUFBQ3dBVm5qYVkyQmtZR0JnWnBCZ0FORU1VQklKQUFBREVBQWZBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNTUFBb0FBQUFBQTNnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVXgwbzJOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDRVoyeDVaZ0FBQVdRQUFBQllBQUFBV09hK2RCVm9aV0ZrQUFBQnZBQUFBQ3dBQUFBMktKbWVQbWhvWldFQUFBSG9BQUFBSUFBQUFDUUZWZ0k1YUcxMGVBQUFBZ2dBQUFBSUFBQUFDQVVhQUhCc2IyTmhBQUFDRUFBQUFBWUFBQUFHQUN3QUFHMWhlSEFBQUFJWUFBQUFGd0FBQUNBQUJBQWJibUZ0WlFBQUFqQUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQUMvQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm02bVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvYU1oZ3lNL3dIOHBraDBraHEvZ09GQWRTQkROOEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aUcvLzlEeVA4WHdId0dBRkZIQm8wQUFBQUFBUUJ3QUFBQjVBS3BBQmtBQUFFUkJoWTdBUlV2QVE4Qk5UTXlOaWNSRGdFbk5SWTJOellXQVZjRElFa25aMUJ3UmlkSklBTXNWQlFoZERNVkN3S0wvY2thRlNVREFRSUNKUlVhQWdvVUNRRWtBaFl1QVFvQWVOcGpZR1JnWUFEaW5qc0p6dkg4Tmw4Wm1Ga1lRT0J4aEs0UE1zMTBtV2tsa09KZ1lBTHhBQVhEQ0taNDJtTmdaR0JnWnZqUHdNREFkSm1oZ0NHWjhRa0RVQVFGTUFFQVZwb0RsQUxUQUFBQ1J3QndBQUFBQUFBc0FBQjQybU5nWkdCZ1lHS1FZZ0RSREZBU0NRQUFBeWNBSUFCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjBBQW9BQUFBQUE5Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJnaU1KeTQyTnRZWEFBQUFGQUFBQUFNUUFBQUR3QkNRRDBaMng1WmdBQUFYUUFBQUNsQUFBQXFQN1JyVlJvWldGa0FBQUNIQUFBQUM4QUFBQTJLVmlkbG1ob1pXRUFBQUpNQUFBQUhnQUFBQ1FHY2dBNmFHMTBlQUFBQW13QUFBQU1BQUFBREFoOUFTWnNiMk5oQUFBQ2VBQUFBQWdBQUFBSUFCb0FWRzFoZUhBQUFBS0FBQUFBRndBQUFDQUFCUUFqYm1GdFpRQUFBcGdBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFEYUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTW1CaVNRVWx5V0RwVGN6bkNkV2ZHUEVRTURzeUx6T2FBd0kwTEYvLzhNREFBcnpBK1VBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZTklBMEc1Qm1CTXB1WjdqKy96K1FENmIvZS8zWEJxc0NBZ0N2VkFuM0FBQUFlTm9WalU4S2drQWNSbi9mK0dkcTFDVFVVU013TFhRWkdPZ2l5UFBVdGd0NHArN1FyaHNFRHE1MDB4VnFlb3NIRHo3NENIU25KMDA0azBNVXJNQ0xzcnFncmVXRTNTWTZRRnZ1UVVtT2JQc1hhVUNQNzRlOVdVQzVEcDVCUnZhK09JTGJWVm1WSGFxeWJkb21RNGZtVk1lU3ZWUi90Y3hROEhuMFJNS01ZQmpXWUluampzcXpGcUVKS05YZlRKRmFzL0xCWXE0SHZvZ1pmRFc0UnJyVWx6OHRXaCs2QUFBQWVOcGpZR1JnWUFEaVB6MzcyZVA1YmI0eU1MTXdnTURqQ0YwZkJQMy9IZk5FSm1FZ2w0T0JDU1FLQUNZM0NmOEFlTnBqWUdSZ1lGYjhZd1FrSnpJVU14UXozV0VBaXFBQVpnQmFvd093QUFBRGtRQUFBVnNBY3dPUkFMTUFBQUFBQUJvQVZIamFZMkJrWUdCZ1psQmlBTkVNVUJJSkFBQUVDZ0FwQUhqYVRZdzliOEl3RUlhZmlBU0pkT2hTZGVnQUhwaXRvRlJpWTJGZ1ltWHFBdGlnREhHUUhTSkZxanJ5dTN1NEhuckQ2WGsvN29DU0h6S2VrL0VhOTNOeUNsRi9YUERDVytLcHFFWGlrZytXVE1qeW1UaHpOb2x6U2I0U0Y3eHpTVHdWL3p0eHlTZVBiZGZlN3IzMWF0OFo2OTI1RGVQNllIMW9PcWRXdW9wNlo1MzF4OTRhZFJxVkdab3dYRnRWNjByWGJPbG91WEdueCtKUjdNVXhrUjFueVFJamF3N1JDVFNTT21tdDBGVC84cDNrTG5hTzhaT1J6a2tTSlRUSVZaQjlsYmFpanBlYStoZnplVEJQQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVGdBQW9BQUFBQUJld0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFlKMDhtTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWh3Qy9aMng1WmdBQUFXd0FBQUlSQUFBQ3RQYjAramhvWldGa0FBQURnQUFBQUM4QUFBQTJLSTJkaVdob1pXRUFBQU93QUFBQUlBQUFBQ1FGMEFIdGFHMTBlQUFBQTlBQUFBQVFBQUFBRUFwL0FLbHNiMk5oQUFBRDRBQUFBQW9BQUFBS0FjZ0E0bTFoZUhBQUFBUHNBQUFBR0FBQUFDQUFCd0JSYm1GdFpRQUFCQVFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFMUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtbXM4NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUk1aOGhqWnZnUDVETkRwSkhVL0FjS0F3RG9mZzFrZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLWmpEay9mOFA1S2VENlArei9rOEZxd0lDQUpuaENVQUFBSGphamRFOWI5TlFGQWJnZTg1MWZCdC8zVGkyNzRYV05YRSs3RUNEa3phSlRaWGcxRTJFVkNyYWlvR3FDTEd4SXlFa0JJTGZnUGdKVEd6TTdJaitJeVNXRkxzREF3TkM3M3FHOXprdlFUSzR1b3M5K0U0U3NpUUVxQVZNamVJY3hudEN1aXFUWWl6U0xJY0ZxQ3lCT00ycUJDQnp5TW9EdW9BMGp1SklaU3F6UU1pOTZoVERsL1ZYYjRiUEZlZ0lXNERWOU8zUW5YZDh3V1IyVkZ3Z0xiaDlkTkdmbW5TemFYcndhVWpCOVNhYnk1YlhzQ0dLZzBQZllQQjJYUXlmVXZRRzI2SGo2SUZXUTlEOW02UFdzN0VDNTJjdlRoeStvdEFWRFFFTmUvM3JHOWQ3SFFYNjA2ZzRPTTJnMStJbUtUSGswZFZQZkllWDVMaVNsWlVEWkNxSHFxdW5WbVhUc1F4S2I1bDJGRTlLVE1XTDR1b0hYTEdnazhBMGMzS0lPdTNybDJTcFlGQ2MrSS8zSDB3TVFCY2R3OVNvZjJ2ZVJGdFRRZXAySisvZkEycGFRaUNLL3Z6c0JxODVyZnFHSnV0TnUvWlJRZDZ0TndBc3RocjBBTCtzTDhNeDFJWVRNNW1yczYwd3ROdTR1TjlFbENNcEVtVjQyOUJiM2NQbHJyZUx1T3dML2VHSGFJdnI0SmdDVnliWEZJMXZNSVVhcFhOVU9qL0REM0pLeUlLbTA4azF3WUloSkNVcFIxSE5sUXI1WDNiSzBhSlIvSDdIMEZYdUJHMjl4alJkQmRldXg4c1ZrK2NIZ3lmMEQ3MDErNHR1OElydTd1d2Y3MWhzMjYzVlBkK0Y0dXNva1EzUEJ6aElYQjBRZVJFNFhid3pEV2VJeWRHLzljMHh4WGtlYnI4K2M3bFZyazErQXl1L1dOc0FBQUI0Mm1OZ1pHQmdBR0wvQnQ3OGVINmJyd3pNTEF3ZzhEaEMxd2RCLzlkbE9zWjBITWpsWUdBQ2lRSUE5dVlKSXdCNDJtTmdaR0JnWnZqUHdNREFkSmxCaDBHVWFSRURVQVFGc0FBQVJVZ0N3d0xHQUFBQ09nQXNBcXdBVFFMVEFEQUFBQUFBQUc0QTRnRmFBQUI0Mm1OZ1pHQmdZR0VJWUdCaUFBRkdCalFBQUFpNkFGbDQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFZSUFBb0FBQUFBQjF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVWQwd21OdFlYQUFBQUU0QUFBQVFnQUFBRlFBbXdGQloyeDVaZ0FBQVh3QUFBTVZBQUFEOURtcFVQbG9aV0ZrQUFBRWxBQUFBQzhBQUFBMktmU2RyR2hvWldFQUFBVEVBQUFBSGdBQUFDUUhWQUtaYUcxMGVBQUFCT1FBQUFBY0FBQUFIQkhPQVZOc2IyTmhBQUFGQUFBQUFCQUFBQUFRQWlRRFBHMWhlSEFBQUFVUUFBQUFHQUFBQUNBQUNnQmRibUZ0WlFBQUJTZ0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUYvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm02bWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBycU1BUXhNL3dIOHBraDBraHEvZ09GQWRicERQa0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQnlBTkE4REIxQ09oVUdIUVkvQmtjR1BJZWovZjZBb2hPY0w0djIvK3YvSy8wUC90Ly9mQXRZSEJ3Q3VJZy9UQUFCNDJsV1N6NHZjWkJ6Rzg3enZtemVUeWM5SlpoSm5aekt6dTdPYnRMTTdYZHpKSnV4cXA4aXdWcEJLRWJiZG9pZEJ0NEk5NlNyc3hWV2t0YWdVdlBsL0NGNkt0NHJIb25oVVVBOGluZ1N2bWZoTnhnb055WnYzTjgvbit6d0tsT1B5UUhtczNGRTZpcEpMQnphU09KOGhUelU1dW9RMHk0UEhZaVEzQW5CblpRemh0N3RSMUwyQ20ybnpXWmpNWGpuZTk0U0QxZTBoaEVJUGxGdjBQVkxlVVJwMG40MzFPTTEyZzBjWVRvYjBaa0hWRG1rZlV6YktrdjNLZmxaMmxGM2FpU3pmRFVLL0hVeXpRTzVBUytJa3pjSWd5M2V3cHNsMkVHYWhEWnF2cHFja2I4cS93WnV5YlVuTWdra0hwdnJlZVVPRlpmZ3AxN1ZGK1lyVjl5ME9TejA1Tm1IcTY3T3YvbHA3bjkxd29UdkZlZUR3U0FQbllBMUhBOHp3cmNOUDJoc3VtR1BMYXJycFNJeSt4NnRMbnUyeUZCUDJyWEtWQnR6QkFGa3Q1SCtCUHFRVzd4bVFIUmtNRVhUcVZVbHJwTkxQa3FwSFRLR1BHYXFPVEdMSnYvNVVBSnY3cE8vOHc2WUsxem9ZcUY4dTNwQXQ1OVpuQXIwdHdyTEYyeWVXSlM1dnk3dVlEMXpuYzkvRWRadzJiTzllRDQ2WFIreE84WXVuV1ZMVUxJeklKT0FQMk12RkI3YmdIWFpXL0dEcmZoZGd1bDNUOXFnZHI3Syt5M2xFVzdWVzhaQzlWQkgzcVFpZG12VkNXZkM3N0tGeXVXSzFNWklKVDNnRkZpNWRXVThJb3VLS2QvQUVySWM4aXhOSkswUGtWQUVLa0EwdUgzQlZOeHFsZmsvRnlwWmY0NWlBb1JMUWZSRnRSTFo3M3pYa2I2ZEFmOHZoWk9EdDJ6cGpNTVh6RTNhOStNNXU4SUM5N2hXLzIzcHJoYkYrUldBNFM0Sk5qUzFGYTFieEozNDBXajBTdTJRVXN2cGZyUEkxTHYvZ0tyRzR5bXNWVFJXYUdmWkllRnlGM0I4Z2JEdTFhVk15TWN2RG9CNXI1RTlsN1JXeWE0KzRSbHdqeDl0UFJkSlBSN1d0YTNRSEhjRDUvTjNESTMvUUUybG5mMi9tTkI5MEQ3blFCTHhuL0l5aUtWVUVkblJnam4zdm9sQU5xYlBKNGRtY2svOVc0K09QS0xXMlRmWi8wWStwSmhpZG5ESHg0bFYydXZnSG04SHFVWC91YVNZRDh4WS9hZmx6WWZkZ3ZSdXRJY2xOenBodWpiMExLbXVxUnZDQzI3M2tKMVkwWTR1L3ZTZVorQy9mbEluOUZxc0xkalMvbGs3L0JRTzdqTWNBQUFCNDJtTmdaR0JnQU9MTWM5dUU0L2x0dmpJd3N6Q0F3T01JWFI4RS9kK0tSWmZwTHBETHdjQUVFZ1VBRVBzSlpBQjQybU5nWkdCZ1p2alBBQ1FmTXFqODM4Q2l5d0FVUVFIc0FHQWxBL1FBQUFKMkFBQUJIQUJZQVJ3QVdRTUFBQ1FENFFBc0F6WUFLQU1KQUNvQUFBQUFBQ2dBUEFDUUFRWUJiQUg2ZU5wallHUmdZR0JuaUdGZ1lnQUJSZ1kwQUFBS053Qm9lTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTguNTE0MTM4LC02My4zNzI2Mjgpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOS4yMzA5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01OC41MTQxMzgsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTguNTE0MTM4JyB5PSctNjMuMzcyNjI4Jz5NPHRzcGFuIHg9Jy00Ny43NjI3OTUnPlI8L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOC4zOTc1NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU4LjUxNDEzOCwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01OC41MTQxMzgnIHk9Jy02My4zNzI2MjgnPk48dHNwYW4geD0nLTQ5LjQyMzI0OCc+UjwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTcuNDE2MzIsLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTguNTE0MTM4LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU4LjUxNDEzOCcgeT0nLTYzLjM3MjYyOCc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi40OTc3NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTguNTE0MTM4LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU4LjUxNDEzOCcgeT0nLTYzLjM3MjYyOCc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDcuNzYyNzk1JyB5PSctNjMuMzcyNjI4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00My44ODg0MjInIHk9Jy02My4zNzI2MjgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTM2LjQxNjQyMycgeT0nLTYxLjg3ODI0Nyc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMzEuOTQ3MDUzJyB5PSctNjMuMzcyNjI4Jz4sPHRzcGFuIHg9Jy0yNy41MTkyNDUnPi48L3RzcGFuPjx0c3BhbiB4PSctMjMuMDkxNDM3Jz4uPC90c3Bhbj48dHNwYW4geD0nLTE4LjY2MzYyOSc+LjwvdHNwYW4+PHRzcGFuIHg9Jy0xNC4yMzU4MjEnPiw8L3RzcGFuPjx0c3BhbiB4PSctOS44MDgwMTMnPkE8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMi4zMzYwMTQnIHk9Jy02MS44NzgyNDcnPm48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMy4wODY5NzgnIHk9Jy02My4zNzI2MjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTMuMzMxMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU4LjUxNDEzOCwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01OC41MTQxMzgnIHk9Jy02My4zNzI2MjgnPk48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ5LjQyMzI0OCcgeT0nLTYzLjM3MjYyOCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDUuNTQ4ODc0JyB5PSctNjMuMzcyNjI4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0zOC4wNzY4NzUnIHk9Jy02MS44NzgyNDcnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTMzLjYwNzUwNicgeT0nLTYzLjM3MjYyOCc+LDx0c3BhbiB4PSctMjkuMTc5Njk4Jz4uPC90c3Bhbj48dHNwYW4geD0nLTI0Ljc1MTg5Jz4uPC90c3Bhbj48dHNwYW4geD0nLTIwLjMyNDA4Mic+LjwvdHNwYW4+PHRzcGFuIHg9Jy0xNS44OTYyNzQnPiw8L3RzcGFuPjx0c3BhbiB4PSctMTEuNDY4NDY2Jz5BPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTMuOTk2NDY3JyB5PSctNjEuODc4MjQ3Jz5uPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzEuNDI2NTI2JyB5PSctNjMuMzcyNjI4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xNS45ODY0MyAwSDQ3LjQ0MjIxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDE2LjIzNjQzLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuNjkyMjEsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzMC44NjQzMiwyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTguNTE0MTM4LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNODUuMzU4MjYtOC45MDk3M1YtNDcuNDk1NzcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw4NS4zNTgyNiwtNDcuNzQ1NzcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4LjYyMjE1LC0zMC4yMDI3NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU4LjUxNDEzOCwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01OC41MTQxMzgnIHk9Jy02My4zNzI2MjgnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUzLjg0OTg4JyB5PSctNjIuMzcwODE1Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy00OC42ODg1OTknIHk9Jy02MC44NzY0MTknPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTQyLjQ4ODAzNycgeT0nLTYzLjM3MjYyOCc+w5c8dHNwYW4geD0nLTM0LjQ0NzE3Nyc+wrc8L3RzcGFuPjx0c3BhbiB4PSctMzAuNzIwNCc+wrc8L3RzcGFuPjx0c3BhbiB4PSctMjYuOTkzNjIzJz7CtzwvdHNwYW4+PHRzcGFuIHg9Jy0yMi44MTMzNDQnPsOXPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTE0Ljc3MjQ4NCcgeT0nLTYzLjM3MjYyOCc+aDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTAuMTA4MjI2JyB5PSctNjIuMzcwODE1Jz5BPHRzcGFuIHk9Jy02MS4zNzQ1NjYnPm48L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTUuMTUzMDktNTYuOTA1NUg0OC4yNzU1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxNS40MDMwOSwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguNTI1NTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMwLjg2NDMyLC01OS43MTczMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU4LjUxNDEzOCwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \DiagramSquare {
              width = 3cm,
              nw = {MR},
              ne = {M(A_{1},\ldots ,A_{n})},
              sw = {NR},
              se = {N(A_{1},\ldots ,A_{n})},
              north/style = {>->},
              south/style = {>->},
              east = {h_{A_{1}} \times  \cdots  \times  h_{A_{n}}},
              west = {g},
            }
          ]]></fr:resource-source></fr:resource></fr:figure></fr:li></fr:ul>
    </html:td>

  </html:tr>

</html:table>
<fr:p>Composition and identities are defined componentwise from those in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1271</fr:anchor><fr:addr
type="user">log-0007</fr:addr><fr:route>log-0007.xml</fr:route><fr:title
text="Interpretation of terms">Interpretation of <fr:link
type="local"
href="log-0002.xml"
addr="log-0002"
title="Terms">terms</fr:link></fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>18</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with sufficient structure and <fr:tex
display="inline"><![CDATA[\Gamma  = x_{1}\colon B_{1},\ldots ,x_{m}\colon B_{m}]]></fr:tex> be a context over a signature <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>.
  Given a <fr:link
type="local"
href="log-0006.xml"
addr="log-0006"
title="Sigma structure"><fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structure</fr:link> <fr:tex
display="inline"><![CDATA[M]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the interpretation of a term-in-context <fr:tex
display="inline"><![CDATA[\Gamma .t]]></fr:tex> of sort <fr:tex
display="inline"><![CDATA[B]]></fr:tex> in <fr:tex
display="inline"><![CDATA[M]]></fr:tex> is a morphism <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .t\rrbracket \mathclose {}}_{M}\colon M(B_{1},\ldots ,B_{m})\to MB]]></fr:tex> defined recursively on the structure of <fr:tex
display="inline"><![CDATA[t]]></fr:tex> as follow:</fr:p><fr:ul><fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .x_{i}\rrbracket \mathclose {}}_{M}]]></fr:tex> is the <fr:tex
display="inline"><![CDATA[i]]></fr:tex>-th projection <fr:tex
display="inline"><![CDATA[\pi _{i}\colon M(B_{1},\ldots ,B_{m})\to MB_{i}]]></fr:tex>.</fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[f\colon A_{1},\ldots ,A_{n}\to B]]></fr:tex> is a function symbol and <fr:tex
display="inline"><![CDATA[t_{1},\ldots ,t_{n}]]></fr:tex> are terms of appropriate sorts then <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .f(t_{1},\ldots ,t_{n})\rrbracket \mathclose {}}_{M}]]></fr:tex> is the composite
    <fr:tex
display="block"><![CDATA[       M(B_{1},\ldots ,B_{m}) \xrightarrow {({\mathopen {}\llbracket \Gamma .t_{1}\rrbracket \mathclose {}}_{M},\ldots ,{\mathopen {}\llbracket \Gamma .t_{n}\rrbracket \mathclose {}}_{M})} M(A_{1},\ldots ,A_{n}) \xrightarrow {Mf} MB     ]]></fr:tex></fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1272</fr:anchor><fr:addr
type="user">ct-000F</fr:addr><fr:route>ct-000F.xml</fr:route><fr:title
text="Intersection and union">Intersection and union</fr:title><fr:taxon>Terminology</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>5</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Products and coproducts in <fr:link
type="local"
href="ct-0006.xml"
addr="ct-0006"
title="Subobject"><fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex></fr:link> are called <fr:em><fr:strong>intersections</fr:strong></fr:em> and <fr:em><fr:strong>unions</fr:strong></fr:em> respectively.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1273</fr:anchor><fr:addr
type="user">log-0008</fr:addr><fr:route>log-0008.xml</fr:route><fr:title
text="Interpretation of formulas">Interpretation of <fr:link
type="local"
href="log-0003.xml"
addr="log-0003"
title="Formulas">formulas</fr:link></fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>18</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with sufficient structure and <fr:tex
display="inline"><![CDATA[\Gamma  = x_{1}\colon B_{1},\ldots ,x_{m}\colon B_{m}]]></fr:tex> be a context over a signature <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>.
  Given a <fr:link
type="local"
href="log-0006.xml"
addr="log-0006"
title="Sigma structure"><fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structure</fr:link> <fr:tex
display="inline"><![CDATA[M]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the interpretation of a formula-in-context <fr:tex
display="inline"><![CDATA[\Gamma .\varphi ]]></fr:tex> in <fr:tex
display="inline"><![CDATA[M]]></fr:tex> is a subobject <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi \rrbracket \mathclose {}}_{M} \rightarrowtail  M(B_{1},\ldots ,B_{m})]]></fr:tex> defined recursively on the structure of <fr:tex
display="inline"><![CDATA[\varphi ]]></fr:tex> as follow:</fr:p><fr:ul><fr:li>If <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1},\ldots ,A_{n}]]></fr:tex> is a relation symbol and <fr:tex
display="inline"><![CDATA[t_{1},\ldots ,t_{n}]]></fr:tex> are terms of appropriate sorts, then <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .R(t_{1},\ldots ,t_{n})\rrbracket \mathclose {}}_{M}]]></fr:tex> is the following pullback:
    
    
      
      <fr:figure><fr:resource
hash="6ed2369964bbc52730b95a3062c9c119"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzM3Ny40NTI4MTJwdCcgaGVpZ2h0PScxMTcuMjE4NzJwdCcgdmlld0JveD0nLTcyIC03MiAyNTEuNjM1MjA4IDc4LjE0NTgxMyc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVNFQUFvQUFBQUFCVEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hXaDJVV050WVhBQUFBRTRBQUFBTVFBQUFEd0FvUUNKWjJ4NVpnQUFBV3dBQUFHL0FBQUNBQTlIemVob1pXRmtBQUFETEFBQUFDOEFBQUEyS3ZHZU1taG9aV0VBQUFOY0FBQUFJQUFBQUNRSWlRUWdhRzEwZUFBQUEzd0FBQUFNQUFBQURBdjhBTnBzYjJOaEFBQURpQUFBQUFnQUFBQUlBSUlCQUcxaGVIQUFBQU9RQUFBQUZ3QUFBQ0FBQlFCVWJtRnRaUUFBQTZnQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRWVBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbS9zYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFQwWmNoalp2Z1A1RE5EcEpIVS9BY0tBd0FJU0EycWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUSytqTGsvZjhQNUlQcC8xditUd0dyQWdJQWxwa0pKQUFBQUhqYUZaRE5idE5RRUlYdm1YdDdIVHYrLzdsT1NOSTBwTFZKYU9zMmJXeGFpYVNnQ21pRmtHREJpZzFTTnp3QVcwQkNxb0JGSG9BdEcrQVpZQTFQMGpkZ2hVeTUxb3cwYytZYmFYU0dnYjI1cnRlbTlJTTlaUXpja0dxSVVpVXVDaGhaZmxpbXM3S0tJUE9iV2Q2R0lkTlNwYklnalJaSUY2aWlhcDRWa05sY2J4NW9Ga0hQZFJNYjBoaG5Vbnk5NURERGJUOUVLRmVmQXFqNHpvQ3YvczBUMzdWb2RTbjR1ZW1EMVBIZDF4NGhhSjNlNG05NUVQZmpNUGEvSko1NGoyOTJFbngySTVOa3R4clFSWDNsU1FHQ3RCTVRRbkJYRnorbDQvcGpqL3N1dmFxdk9sc05IUktISUMrMndHK24rR3M3QW9CMFloTXdvL29ubmJ1RzFsMkhnSUNCdmJqK3c2ZjR4WjR4dHVUbHZNeHlGNGFMY1o3bFdWVTJvUnEzTTVWSUQwMG1zdEVMSEtRcWJieEtZeGQ1cVFkVm1UZEtldHlGL2xuMWUrUllFc0dOamN3bTAzWmErcDRWclI5dFBEZDZMeCtjUGFGRXBLNGxhSlF0UGRGcStNRDJKNmZGa3NpTWRvak9Iczg2d1ZiTG1KaG12NmNnTHo3czdTZ24yQVE5M0xWTUltdXQ2UGNMUWRQRjVnbmRPOW8rYVM5Ry9iWS81cmhmZUpxMzQvMDRMQVQySnQyd2VGYzhJckd2T29keCtuMFllV0c0enY0RDNJeEQyd0I0Mm1OZ1pHQmdBR0lSdTJUdGVINmJyd3pNTEF3ZzhEaEMxd2xCLy8vS3FzVzBCOGpsWUdBQ2lRSUE1YjhJeUFCNDJtTmdaR0JnWnZqUHdNREFxc3dROC84bnF4WURVQVFGTUFNQVdLY0Rzd05VQUFBRkl3QitBNFVBWEFBQUFBQUFnZ0VBZU5wallHUmdZR0JtQ0dZQTBReFFFZ2tBQUFqVEFGb0FlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ3dOcUZnWW1WcVF0Z0YyV3dqWndRQ2FucTJOL2RoL0hRTjF5ZCsyRUROVDhVM0s5Z2x2UitKWlc0QjFkTW1XZWVpSHZMWExQZ25TZUs4bG1TVno0eWw5SjhacTU0NFN2elJQTHZ6RFVyZmpmQlhhNkRqV29YakkzKzVGeTMzdHZZZDhHcnBXNlMzMXB2NDJHd1JoMXZ5b3hkUDU2ZGFuV2pXellFSEJldURGZ2lpcDBrSnJIbkpKMmpZODArSmIxd2tGeXhSTlA4NjdmUys3UTVwSitNYkk3Y1JBMmpMSHJSczJ3VmJYcXBhZjhBeUJFdjd3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1ZQUFvQUFBQUFBNFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVeDFHMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNFWjJ4NVpnQUFBV1FBQUFCa0FBQUFaREZ1QXJKb1pXRmtBQUFCeUFBQUFDd0FBQUEyS1JpZUxHaG9aV0VBQUFIMEFBQUFIZ0FBQUNRRnl3TFdhRzEwZUFBQUFoUUFBQUFJQUFBQUNBWUtBSkpzYjJOaEFBQUNIQUFBQUFZQUFBQUdBRElBQUcxaGVIQUFBQUlrQUFBQUZ3QUFBQ0FBQkFBZ2JtRnRaUUFBQWp3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRENBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVptV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9hTWhneU0vd0g4cGtoMGtocS9nT0ZBYU4zREZnQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpRy8vOUR5UDhYd0h3R0FGRkhCbzBBQUFBQUFRQ1NBQUFDTndLckFCNEFBQUVSQmhZN0FSVW1KeU1HQnpVek1qWW5FUTRCSnlNMU14WS9BVFkzTmhZQm1BUWlUak1zT3RFNkxETk9JUU11VkJNU0VoSStCejg1R0E0Q2kvM05GeFF0QXdFQkF5MFVGd0lBRWd3QkxRSUtBZ291QVFrQWVOcGpZR1JnWUFEaTcyc2RZdVA1YmI0eU1MTXdnTURqQ0YwblpKbzVpR2sxa09KZ1lBTHhBQWRqQ0VwNDJtTmdaR0JnWnZqUEFDU0RHQ1l4TkRLWk13QkZVQUFUQUVMY0FxZ0FBQU5TQUFBQ3VBQ1NBQUFBQUFBeUFBQjQybU5nWkdCZ1lHS1Fad0RSREZBU0NRQUFBNlFBSlFCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRXFmbTV1RGs2dkQyNndKMHFHcHBMWG9JdjUwYjBQd0JnN2ZQZWZjQUJrdkVvWkptQWNkSnBVM2p6em1oMFhraWZpcnlCbS9yQm1ScEROeFZ1d2lwMHo1anp4bVNSbDVJdjRqY3NZZjczMVQzKzZkOWVyWUdPdmRwZmJiay9WdDFUaTEwZm13SHF5ei90eFpvOHFuTW4zVjl0ZGFGVHJYQlhzYWFtN2M2YkI0RkVkeFRHREhSVExQbGxQWVd5ckpuSFEyYVBKdmVwRFVoY1k1L0dLa1VmSVVOZlJ5MDRwZXBhc293cDJtK0FCVk1pNURBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpzdG1hcnk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOQUFBb0FBQUFBQThRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdjS3habG1OdFlYQUFBQUZBQUFBQUxnQUFBRFFBRE9DZVoyeDVaZ0FBQVhBQUFBQ09BQUFBcU1EYmszRm9aV0ZrQUFBQ0FBQUFBQzBBQUFBMko0U2RnV2hvWldFQUFBSXdBQUFBSUFBQUFDUUZaUFpNYUcxMGVBQUFBbEFBQUFBS0FBQUFDZ05wQUpCc2IyTmhBQUFDWEFBQUFBZ0FBQUFJQUNvQVZHMWhlSEFBQUFKa0FBQUFHQUFBQUNBQUJnQVpibUZ0WlFBQUFud0FBQUN5QUFBQkxFTnZaWXh3YjNOMEFBQURNQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm0zTTQ0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFBQkpIWktjVms2QTlzRHJ3ZmV6TlZmVEJnWW1LdTV6d0NGR1JFcS92OW5ZQUFBVFl3US93QjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytRKzgvLzhIa2w3Ly84dHZCOHN6QUFCbXBRZUhBQUI0Mm1OZ1lwanduNEZ4THpNRGd6Q0RPQU9EdUtDWnVhS1l1Q2didTdLZ01aaFdWQk1HTWljdzhUSUs4REF4OGNUSGc4aC9IM2g3b3FNL01UL2haV1RrRmVObC9KTUNwaGlaei81SllXQmdZdEFHbWhrR05KTVpiS2F4b0xJd3lDQjFVek56SUJ0TUF5MDVHUjNkQ3pUcUk4aU11RGdReWNqUHczU09lYzRmQjZpeHpITWd4dkl5QUFDVHNoMk5BQUI0Mm1OZ1pHQmdBT0tvVmpieGVINmJyd3pNTEF3ZzhEaEMxd2xCLzJkZzNNc000bkl3TUlFb0FOeFNCOE1BQUFCNDJtTmdaR0JncnY1aXdzREErSkpCbTBHSGNTOERVQVFGTUFFQVhvb0RxZ0ZWQUFBQjZRQ1FBQ3NBQUFBQUFBQUFLZ0JVZU5wallHUmdZR0Jta0dCZ1lnQUJSZ1kwQUFBREp3QWdlTnBkanNFS2drQVFoajlKaXd3NkJuWGFKMWdVZzZBWHNDZndycmlFa0FxdUNIYm8yUnRsVHM1aDV0dC92b0VGWW40RUxCVndXUHRTb2ZCQk9lTEVXWGt2NlZVNTVvWmhSeEFlSlRuelZBNkZYOG9SRndybHZlUWY1Wmc3WHorMjVUQS9kQlJ1OEUzZm1kUW1tdVN1YzBNNXV0cFVzNm1ueGsvdjFtUTJzUm1la1phU2dabkg1bFhnaER3TlBaMzhNTVdTYkp4Y25HNzFTc2tkdFhpVmJJelFKSmRlK2x0OFE3WmVXN0kvUWFRdGZRQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWUVBQW9BQUFBQUI3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFVkMCsyTnRZWEFBQUFFNEFBQUFRZ0FBQUZRQXV3RnZaMng1WmdBQUFYd0FBQU1YQUFBRVVPRTl6K05vWldGa0FBQUVsQUFBQUM4QUFBQTJLbGFkZW1ob1pXRUFBQVRFQUFBQUlBQUFBQ1FIdlFNdmFHMTBlQUFBQk9RQUFBQWNBQUFBSEJKd0FiNXNiMk5oQUFBRkFBQUFBQkFBQUFBUUFzNEQwRzFoZUhBQUFBVVFBQUFBRndBQUFDQUFDUUJ2Ym1GdFpRQUFCU2dBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGK0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtV3NRNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwVFVZU2hoWnZnUDVETkRwSkhVL0FjS0F3RGpIZzB5ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0J5QU5BOERCMUNPaFVHSFFZL0JseUdQb2VUL2Y2QW9oSmNMNHYyLyt2L0svMjMvcC8rZkJOWUhCd0MrdUJBaEFBQjQybjJUUzQ4YlJSREh1NnBudXUwWmU4YWVSL2ZpSGIvRzN2R3VIZXoxWTJmSXJtUHY0a0FDUkVvQ0V1RVc1UkFVQ2NpRmg4UUJDWWdpUlFJSlJlRVRjT0NFeEJkQXlvM1BFQ21SY2tMS0Z5Q25iRXg1TnprUUtUc3ozWnJ1cWk3Vi8xZlZETmlYeTEzMkwvdUdLY1l5S1dRZkptbFdnMUM0SUdUU1NiTVpQQ2pZZmxSdlZOcHRZeU8vNGRvY3hMaGV5a21BNXFnSk1CdGUyU21PQUl2U0hGNWw5QUQ3aXVZbkZOT2ltQTdJT0tHWUkvVUVHcFd3M2FpbzFxNk9vVEdtUWI0WGxrdmpGN3pQTHRGQkxvV3FReHFJQWJpUURDZ1ZyZExNcDB6aWpnMUNyNnhLT3pBQVNkWVo2QmxrZnBiU2Ywc2txUjZuU3Z1cjdYR3FBOUZKaEtIdUdDQzlUdDAxZnp5WTJ4eEx6bTZWMzMxKzJRb0N1SG5IQkF3R1RnN0FOVC8vek9JSVJUbnRtajhZa0NzRmZoTTg5MTVZNE5maEo4c0pmcTZDVjhvaXZISDRqNVlTMEdoSk1JQkl5REp4OENwNDl2Qld3Q084ZWZnNE5Bb1JSNTRuZzJHUVF5a0h2TGVPcUtRQWJzVGtudmNQNytONWgreStTOHZnaU5uMjhpbC9CSCt6THhqYm1KT0lwT053RngyZWRPWTgzWm5RRXVSS2VSK29KcWhXMHRPaldla2F5S055T1ZRMlBVcXpkSHkwUlcrY2RDWnpwSjBYeDQ4RFRqTDRxK2R5REhxblArZzVzaHFZK1RBS3dPb1ZiT0g2dGRnMnBXVUxDTXI1enVLczFGZjJ0ejYwMWo1NTU5eGFaQk14OUczSDR0WEdyb2RlWG9BcWxGdG5OazhETDI2RWlPSFc5T0liamkyajBNeXA5UkRNai82WStxMHh4K21zV2YzNlV1QTZVQ3AzLzl6dTYxSVlBZXozQXdxSjdrSE5iMk4zcDdtSDJOMXZMZERVYTVOaWZ5cjIxcHZOY296ek14NmkzdGFxYnd5MkNuYmowOFV3SENJdU5zTks3V1ZRMDJjdk9lSnZ4UEVpWXllQk93a1lPUjRqZTFHQTcxNEw1dFRIZkFXa1VMUjQxTmp6c0d3SjBIYTVOZHQ4QzNqQlZRcGZoWHh3a3ZiK2U2L1gzSDU3TWZSZUFiblMyMXMraGR2NFBUdkZtTStsb3Z0SzMvLzBaUDd4N1ZqcFVscU9SeXFrMi9Ic2ZZRng3N3d5YzNtcVlzM1Z2Y1diKzJDZXUxWkZ6NzFSejFsSkU3ZXVPV1hQaFYrZlArenVJTDQ3S2twcTQrMDFTbW5jdHpXc2Mrcm1iK011WXYxM3c2SStaLzhCNmY2TWFBQjQybU5nWkdCZ0FPTEVlZTQvNC9sdHZqSXdzekNBd09NSVhTY0UvZCtLcFo5cFA1REx3Y0FFRWdVQUhJMEowd0I0Mm1OZ1pHQmdadmpQd01EQUVzMmcvZjhNU3o4RFVBUUZzQU1BWFZ3RDlBTEdBQUFCV3dCekFWc0FkQVJiQUV3RURRQXdBdE1BTUFHNUFDc0FBQUFBQUNvQVFBREVBV2dCNEFJb2VOcGpZR1JnWUdCbnlHTUEwUXhRRWdrQUFBdmlBSGtBZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRc0FBb0FBQUFBQkx3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY04zeEdOdFlYQUFBQUU4QUFBQU5RQUFBRVFBUmdRbloyeDVaZ0FBQVhRQUFBRlhBQUFCZlA2UDF0NW9aV0ZrQUFBQ3pBQUFBQzBBQUFBMktKcWRnbWhvWldFQUFBTDhBQUFBSGdBQUFDUUYxZ0haYUcxMGVBQUFBeHdBQUFBVUFBQUFGQXRIQVdWc2IyTmhBQUFETUFBQUFBd0FBQUFNQUx3QkhtMWhlSEFBQUFNOEFBQUFGd0FBQUNBQUJ3QWdibUZ0WlFBQUExUUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQUVJQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm04bUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBwcU1FOW1admdQNURNek1JS0VHUkVxL2dPRkFlREJEWG9BQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnTWdEUUhFSUxrTkJrTW1TZi8vdzlrYVVCWS8yLyt2L1NuRUt3V0RBRGxMUXRxQUFBQWVOcGQwTTFLQWxFVUIvQjd6bzE3bVJGbkZHZkdkTUQ4YUdhSXlpQ2RPMnFRdFVnU0NscElSVmxRZ2hGSWFMaFVpRDVXMFJPMGN0a1QrQUlSOUI2MXFVWHJGbElqMGlZT25ITld2Ly9oRUNEZEg0QXJTa2ljRUlnYUdtY3FNTTRNZjFYQmR2enk3RElJYUFVNVh5L3hJb1hkcHN5RGQ2NFNzQkFYRlVFSllJamxXNkhPeThQM2tSUkNPTzJua3YzRzVZMTE3Wk5rMC9kckV6L2lxMUdEYTR3cllIdjVNcXlDbHdYSGRvVlh2eFZqY0M0dExreWdhcTBPdEZPUmdGRXkwUTRHYXljTmxPbFVlT3RyOFB4ZWtwbUVoSXo5dHQvZThJbkUvQmxteGdyb1M2Q0NtMXNXVGxnQnh6V0VKd3pZbzhtcWM3YlRyampWSkYyb2FhbHVUZy9nL2VnMXJsc1VFQzA5anJJbXdTd2FXWkRIYnBFUWZNUWhTWXova3NrQ3o2Ulo5SCtBc09mQnhkNU1SdHJ1OURJcTBNVEc3T0YrVThRS0pxSlppT0h3OC93WVF0T2pqNzhjTFk1aE0yTDVwLzhDNmhvOUZ3QjQybU5nWkdCZ0FHTGYwRWJUZUg2YnJ3ek1MQXdnOERoQzF3bEIvMmRrdXN3TTRuSXdNSUVvQU96MUNEY0FBQUI0Mm1OZ1pHQmdadmpQd01EQWRKbkJFa2pPWmdDS29BQldBRVEyQXJVQUFBTFRBQUFCeVFCMEFja0FTQUpIQUhBQ213QTVBQUFBQUFBd0FHQUFqQUMrZU5wallHUmdZR0Jsa0djQTBReFFFZ2tBQUFQMUFDZ0FlTm85akRHcndqQVVoYjlpRmUwYkhBU0hOMGp3QjRSS0g3aTRPVGk1T3J6Tm1pQWRta3BhaXk3aVQvYzJCRy9nOE4xenpnMlE4U0pobUlSNTBHRlNlZlBJWTM1WVJKNkl2NHFjOGN1YUVVazZFMmZGTG5MS2xQL0lZNWFVa1NmaVB5Sm4vUEhlTi9YdDNsbXZqbzJ4M2wxcXZ6MVozMWFOVXh1ZEQrdkJPdXZQblRXcWZDclRWMjEvclZXaGMxMndwNkhteHAwT2kwZHhGTWNFZGx3azgydzVoYjJsa3N4Slo0TW0vNllIU1Yxb25NTXZSaG9sVDFGREx6ZXQ2Rlc2aWlMY2FZb1BXS3d1U3dBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQWFRQUFvQUFBQUFCK3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVZDB1Mk50WVhBQUFBRTRBQUFBUndBQUFGd0JSQUVpWjJ4NVpnQUFBWUFBQUFPVUFBQUVkTEtnSHFCb1pXRmtBQUFGRkFBQUFDOEFBQUEyS2ZTZG1HaG9aV0VBQUFWRUFBQUFIZ0FBQUNRSFJ3S2VhRzEwZUFBQUJXUUFBQUFnQUFBQUlCTVNBVzFzYjJOaEFBQUZoQUFBQUJJQUFBQVNCRlFER0cxaGVIQUFBQVdZQUFBQUdBQUFBQ0FBREFCZGJtRnRaUUFBQmJBQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBR2hBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVNtS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHJxTUpRd00vd0g4cGtoMGtocS9nT0ZBY3ZlRFBJQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEeUFOQjhEQjFDT2pVR0hRWS9CaWNHWElZaWg1UDkvb0RpSTd3amovNy82LzhyL1EvOTMvTi95ZnpKWU54SUFBRDFYRWxvQWVOcFZrMDlzMjFRY3g5L3Z2ZWYzNGpUMmMrM0VKbitjTkUxclE5WW1yRW50SldpWklLUWRsRlpsVTZFYmt4Q1RvRUppSEdEZHBGNEkwd1JJMjRRRUVoSmNPTUNONnlRdUV3ZWtTUnluSVk1TW1qaHc0SVFFeHlUOGJHMElMUHZwK2ZsbisvdjlmbjZQQU5tZjljazljb2tVQ0ltRkFoUENJQjVBM0pXaTBZSnVGTHYzZUVNc3VjQlVxUW5jeVJkOXYzZ0tYdTFtajBPT21xWDluczBWTEt6VWdCTThnSnpENnk1NWgyVHdleVlzQnQxb3piMEx0ZFVhbnBHYmpEV3NvMlJwTnFNUDZhK2tUZGF3RXFKNHpmV2N2TnVKWE5FR0dRWmhOL0xjS0c1RFhZcTg2MFdlQ2JpZUxIZFFYb2Q5RDIrS3ZDRmc0SzRXSUtkZEhtYzBNT2FjTHRQbGRMWmpWQnlEZ2FFZDdPY2dweThPdnZ5amZvVytZb0d1Sm1OWE1WOENZMEF6U2dMa3ZMZEcxL05MRmxCbGltUTVxd1EwZm9JemlSOUdqczBtVE5BN3BFcWE1QVFxZGJxTlVLQzJlaFVLSnNncWVKaWFrSFdSNm5VU2NWRVFOZ0loMmVNNXc0TE90N2ZLb2E4VTdGKzR5TVpudDg0QzNiUzJENmVmVjB5elgvMzZpOWN2VTJnTnI5Y2M3ZDJiRjY1USt2VHBIemM0Z0xsTGUvT1VWU1RRbC9zdkhxanNUbS9yT1hQQUV3Zmd3SWk5dDdIMFBBVlZuSHpIcnU0czc3THBiN2JJSmh4V1pqTytTbjhnbTNpREFxb1FwUUgrRzZ5RG9vUDFPUkFGNGRiQUxhUlBFeE1vMm9sU2k4akNjMkFBeVVTRWdXQzNQMEZKeXozTWRmeEJWZ1BMNkZlMXo2WVh4Ync2ZDRORCtSamlNUG5iQjRiQlQ2NklqMkJZdGRSTkp3ZTdjSmd4N1kvTG9PellwNWNtRDJ4cENKNHlvRWhFb0pNcTNacGNOVGtyMEtQSmZWTjNpZ0JVTjFOS1pSeWJDN1JpTWVaanFaeWYzS0duRTFJWUNoVFNYbXJPZm1jYU1yTElhNG5iSlBjQnJBZHRDSktHZHBCUlhxVkdPMmc4aWowM3ZaZm9LWW5qRkZwY1R6a2h6U2ovdi9iN0QyMFBYNER4OFAzUm5sTXQ4MjZodHo1UTJVK0xJOFlsQi9zSko4STJGQnE0cHQvUE5SMzdLYTdOQ1oydWpvNkdERE16TXRjK3hBNU5ZR3UzS29Gdld0QTRPS0o4WTVNZVR2K0NaWGRocnpLMFpZNEN0YWUveVBnWnI5aGZMUHAxQ09NY28xUTNtdmFUR3MxcWMrNnpWckhsaElZL29OTS83Y2M1UHVwbHpQRlJ1OERlY0x2YndUN3dabi9ER1hxTnJCRGlNQ2tLK1RqSkFQZFRYcUloMlVyMnU5TVFDV1VNRGFOUjBNRVF3cDlmNG5TaDlNS2lsdFY1eWZUQ2s4ME8vbVR6dkE5S3ZSSHFGVjZoc25IZVZ4WjhOYjN2WnUzamxKN1l0b0NaZXJ0WWFuSG9OR1VONmdteWIwbzVnSEw5UmlJTGNmMEQ1dTZtbFhqYVkyQmtZR0FBNHZ5OVlqZmorVzIrTWpDek1JREE0d2hkSndUOTM0cEZsK2t1a012QndBUVNCUUFUQ0FsckFIamFZMkJrWUdCbStNOEFKQjh5aVAvZndxTExBQlJCQVJ3QVgwOEQ3QUFBQW5ZQUFBRWNBRmdCSEFCWkF3QUFKQU1JQUNzRDRRQXNBd2tBS2dGeUFCY0FBQUFBQUNnQVBBQ1FBT3dCWWdId0Fqb0FBSGphWTJCa1lHRGdZSWhoWUdZQUFVWUdOQUFBQ21rQWFuamFUWTZ4YXNNd0VJWS9VOGRRcDlDcEhUb1VUUm1GamZzQWdReVpzbVlzSkpFSURrZ0tzbVBJRXZvQWZlaGVGQTA5d2ZIZGQ3K0VnSm9iQmZjcWVFMzlYaVdWVEErZU1lY3RjeVZIWmE3NVlNRVRSZmtzNXBObDVwSVh2alBQZU9lVXVSTC9rN25taTk5VmNPZkxhS1BhQkdPalB6alh0ODNXeHFFUFhyVzZlWWkxOVRidVJtdlUvcXJNMUEvVDBhbE9ON3BqUmNCeDVzS0lKY3JQTm1KTVlzOUJkbzZlbG9adGNvTk1RVFpLbkJiN1A3R1doRStwWFhyTlNHclBWYnBoa3N3Zy9TaHBSWmZ1YXJvLzMvUXd1d0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFQVUFBb0FBQUFBQkVRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY04zZm1OdFlYQUFBQUU4QUFBQU1nQUFBRHdIRC8wY1oyeDVaZ0FBQVhBQUFBRDlBQUFCREtLbE81bG9aV0ZrQUFBQ2NBQUFBQzBBQUFBMktFZWRnV2hvWldFQUFBS2dBQUFBSGdBQUFDUUZlQUdGYUcxMGVBQUFBc0FBQUFBUUFBQUFFQWZ1QUw5c2IyTmhBQUFDMEFBQUFBb0FBQUFLQUxJQVZtMWhlSEFBQUFMY0FBQUFGd0FBQUNBQUJnQWZibUZ0WlFBQUF2UUFBQUROQUFBQk9JTGhLcWx3YjNOMEFBQUR4QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1ZbU9jd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBwcU1FOW1admdQNURNek1JS0VHUkVxL2dPRkFjZFREVFFBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeW1veVQvNy9IOGpYQU5IL2IvNHBBS3NDQWdDV3l3a3BBQUI0MmkzTlQwckRRQmlINGU4M1V4T1IycHJReklTWW1wckF4Q0pVR2sxQ0VGMklpb2hkcFlJYkxmMmpJcDdBQTRqbjZFcndCTDJPRzlldVhObHFpTDRIZUY0Q1RYNElmVTRraVpZYXZnbzdTRldTSGlLcW93YXBtUjRFY2pIdXRsM0FWZDA3Z2VyTkdkanhvTTYvVmthRHE3ZURvK25sK0xhNk52eCtlVm9zSmthRmlrQlo0YmIvWEFoTnI4R1BDelhjVXp0UWFSSUp1UUZzbGFLMWVuM084Z3VUQTFiNW9YOXhOSCtlZnZiTUNpcy9oZWtUc1Q2YlViTXdaZENCSGloTkdwclloeFVHZXJ3YkphR1JxRzNFTEcwNnl5ZVBENEVCN3AxdTVxODlPM01ZY3pLYnpUN3VoNEJwejkvWFJZdnpWc05sdG10NVJMLzV4Qy82QUFBQWVOcGpZR1JnWUFEaUs4SnpiT1A1YmI0eU1MTXdnTURqQ0YwbkJQMmZnYW1CR2NUbFlHQUNVUUQ3VXdoTEFBQUFlTnBqWUdSZ1lHYjR6OERBd05UQW9BUWtReGlBSWlpQUJRQTB4QUlEQUFBQ2dBQUFBWTBBWkFHTkFEa0NWQUFpQUFBQUFBQXNBRllBaGdBQWVOcGpZR1JnWUdCaGtHTUEwUXhRRWdrQUFBUEJBQ1lBZU5wRmpERnZ3akFRaGIrSUJJbDA2RkoxWUFBUHpGYWlNSGRoWUdKbFlnRnNvZ3h4a0JNaUlhR08vZDA5akNWdWVQcnV2WGNINVB5UzhKeUV6NkRQU2Nsa2UzSEdCMStScDdJdEkrZk1XVEVoU1dmaUxQaUpuRXB5aUp6eHpTWHlWUHhINUp3MWY1dXV2ZDRHNjlXdU05YTdjK3ZMWW05OTMzUk9sYm9JKzlZNjY0K0ROZXAwVjJacytyRnVWYVVMWGJHaG8rWEtqUUdMUjdFVHh3UjJuQ1h6bEJUc2c5UFRTT3FrVmFMRmZlZGJ5VjNvSE1Nbkk1MFRkMUhES0ZlOWFDMXRSUlV1TmRVL1l6MHZEd0FBQUhqYVkyQm1RQWFNREdnQUFBQ09BQVU9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6c3RtYXJ5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU04QUFvQUFBQUFBOUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2NIQlpGbU50WVhBQUFBRkFBQUFBTGdBQUFEUUFET0NlWjJ4NVpnQUFBWEFBQUFDSUFBQUFxSU9QTy8xb1pXRmtBQUFCK0FBQUFDMEFBQUEySjB5ZGdXaG9aV0VBQUFJb0FBQUFId0FBQUNRRTFmWGphRzEwZUFBQUFrZ0FBQUFLQUFBQUNnTUxBSGRzYjJOaEFBQUNWQUFBQUFnQUFBQUlBQ29BVkcxaGVIQUFBQUpjQUFBQUdBQUFBQ0FBQmdBWmJtRnRaUUFBQW5RQUFBQzJBQUFCTlNDU1NNdHdiM04wQUFBRExBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWJHV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCMXdOdlpyTXYyZ3dNekdiY1Y0SENqQWdWLy84ek1BQUFMandRUXdCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1ErOC8vOEhrbDcvLzh0dkI4c3pBQUJtcFFlSEFBQjQybU5nWWlqL3o4RFl5c3pBSU13Z3pzQWdMbWhtYml3bUxzckdyaXdJcGRXRWdjeHlScTd2M0l5TTNGRlJJUEk3VjExWTJGZm1WMXlNakZ6Q1hJeC9nc0FVSS9PMVAwRU1RTURFSUFrMFV3Vm9KalBZVEdOQlpXR1FRZXFtUU1NRm9iU1krSkx3OEFaR3JxOGdROExEUVNTUWVaMTUzUjhUcUxITTZ5REdjZ0dOQkFBdWd4dzRlTnBqWUdSZ1lBQmkyWmtmQ3VMNWJiNHlNTE13Z01EakNGMG5CUDJmZ2JHVkdjVGxZR0FDVVFBSlFnaWxBQUFBZU5wallHUmdZRGI3b3MzQXdEaVhRWkpCZ3JHVkFTaUNBcGdBUmxRQ3NnQUJWUUFBQVowQWR3QVpBQUFBQUFBQUFDb0FWSGphWTJCa1lHQmdacEJnWUdJQUFVWUdOQUFBQXljQUlIamFiWXd4RDRJd0VJVWZFUWppd3VTZ1N4UDNCbEpYWnlaWE5vY1NHc0pBU1NnaFlYSHhqL3NnMVVWdnVQdnUzWHNISU1VVEFkWUtrR3g5clpDY2VJNXdRT1k1cG5yMm5PS0VDM1lJd2oyVkREZlBJZm51T2NJUkQ4OHhkZWM1eFJVdk4vVjZYSXI4TXlzenVtNndvcEJmcVRUV2pIb3lqYWdYMGN5ZG05dGVLSmxMeFZjVGVtaU1XRkFnLzlrckdMSkRod0VXZ3ByODR5cnBzcHRUODJMUTBGbnpKa2d6czQ2OVpVSkFiWGtKOVFiQnVTNnBBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6c3RtYXJ5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6c3RtYXJ5MTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yNy40NzA3MTUsLTYzLjM3MjYyOClzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00MC4zOTA3MywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjcuNDcwNzE1LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTI3LjQ3MDcxNScgeT0nLTYzLjM3MjYyOCc+7oGKPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0yMy40NTc5NzcnIHk9Jy02My4zNzI2MjgnPs6TPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xNy4yMzEzMDgnIHk9Jy02My4zNzI2MjgnPi5SPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy02LjgyMjQwMicgeT0nLTYzLjM3MjYyOCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMi45NDgwMjgnIHk9Jy02My4zNzI2MjgnPnQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLjY0OTYwNicgeT0nLTYxLjg3ODI0Nyc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc1LjExODk3NicgeT0nLTYzLjM3MjYyOCc+LDx0c3BhbiB4PSc5LjU0Njc4NCc+LjwvdHNwYW4+PHRzcGFuIHg9JzEzLjk3NDU5Mic+LjwvdHNwYW4+PHRzcGFuIHg9JzE4LjQwMjQnPi48L3RzcGFuPjx0c3BhbiB4PScyMi44MzAyMDgnPiw8L3RzcGFuPjx0c3BhbiB4PScyNy4yNTgwMTYnPnQ8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczMC44NTU2NTEnIHk9Jy02MS44NzgyNDcnPm48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMzYuMjc4NjQzJyB5PSctNjMuMzcyNjI4Jz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzQwLjE1MzAxNycgeT0nLTYzLjM3MjYyOCc+7oGLPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzQ0LjE2NTcyMycgeT0nLTYwLjM4Mzg1MSc+TTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzQuMDIxOTYsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yNy40NzA3MTUsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMjcuNDcwNzE1JyB5PSctNjMuMzcyNjI4Jz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xNi43MTkzNzMnIHk9Jy02My4zNzI2MjgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTEyLjg0NDk5OScgeT0nLTYzLjM3MjYyOCc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNS4yODgyNCcgeT0nLTYxLjg3ODI0Nyc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctLjgxODg3MScgeT0nLTYzLjM3MjYyOCc+LDx0c3BhbiB4PSczLjYwODkzNyc+LjwvdHNwYW4+PHRzcGFuIHg9JzguMDM2NzQ1Jz4uPC90c3Bhbj48dHNwYW4geD0nMTIuNDY0NTUzJz4uPC90c3Bhbj48dHNwYW4geD0nMTYuODkyMzYxJz4sPC90c3Bhbj48dHNwYW4geD0nMjEuMzIwMTY5Jz5CPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjguODc2OTI4JyB5PSctNjEuODc4MjQ3Jz5tPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzM2LjQ0NDY2NCcgeT0nLTYzLjM3MjYyOCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC0xMS42MDk3Vi00Ny40OTU3NycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsMS4wLC0xLjAsMC4wLDAuMCwtMTEuODU5NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ3Ljc0NTc3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy4yNjM4OSwtMzAuNDUyNzMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yNy40NzA3MTUsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE2MS40ODU2MywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjcuNDcwNzE1LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTI3LjQ3MDcxNScgeT0nLTYzLjM3MjYyOCc+TTx0c3BhbiB4PSctMTYuNzE5MzczJz5SPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTM3Ljg1NjAyLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjcuNDcwNzE1LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTI3LjQ3MDcxNScgeT0nLTYzLjM3MjYyOCc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMTYuNzE5MzczJyB5PSctNjMuMzcyNjI4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xMi44NDQ5OTknIHk9Jy02My4zNzI2MjgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTUuMzczJyB5PSctNjEuODc4MjQ3Jz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0uOTAzNjMnIHk9Jy02My4zNzI2MjgnPiw8dHNwYW4geD0nMy41MjQxNzgnPi48L3RzcGFuPjx0c3BhbiB4PSc3Ljk1MTk4Nic+LjwvdHNwYW4+PHRzcGFuIHg9JzEyLjM3OTc5NCc+LjwvdHNwYW4+PHRzcGFuIHg9JzE2LjgwNzYwMic+LDwvdHNwYW4+PHRzcGFuIHg9JzIxLjIzNTQxJz5BPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nMjguNzA3NDA5JyB5PSctNjEuODc4MjQ3Jz5uPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzM0LjEzMDQwMScgeT0nLTYzLjM3MjYyOCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNDQuOTQ2MjcgMEgxNTYuNDMwMDgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTU2LjY4MDA4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTAwLjkzODE3LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yNy40NzA3MTUsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xNzAuNzE2NTItOC42MDk3M1YtNDcuNDk1NzcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLDEuMCwtMS4wLDAuMCwxNzAuNzE2NTIsLTguODU5NzMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNMi4yIDIuNTgwNjNDMS43OTgwNyAxLjAzMjIzIC45MDI0IC4zMDEwNyAwIDBDLjkwMjQtLjMwMTA3IDEuNzk4MDctMS4wMzIyMyAyLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMTcwLjcxNjUyLC00Ny43NDU3NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTczLjk4MDQxLC0yOC45NTI3NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTI3LjQ3MDcxNSwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTM4LjU3NzUtNTYuOTA1NUgxMzIuODAwNDgnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMTMzLjA1MDQ4LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0NC41NjU1NSwtNjQuOTY3MzIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yNy40NzA3MTUsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjcuNDcwNzE1JyB5PSctNjMuMzcyNjI4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0yNC4zNTczNzInIHk9Jy02My4zNzI2MjgnPu6BijwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMjEuMDI2MDk2JyB5PSctNjMuMzcyNjI4Jz7OkzwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTYuMTAwMDk3JyB5PSctNjMuMzcyNjI4Jz4udDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMTAuNzI0Mzg0JyB5PSctNjIuMzc2MzY0Jz4xPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy02LjgzNjEzMycgeT0nLTYzLjM3MjYyOCc+7oGLPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0zLjUwNDkwNScgeT0nLTYxLjEzMTAzNCc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczLjkzMjUzNycgeT0nLTYzLjM3MjYyOCc+LDx0c3BhbiB4PSc3LjY1OTMxNCc+LjwvdHNwYW4+PHRzcGFuIHg9JzExLjM4NjA5Jz4uPC90c3Bhbj48dHNwYW4geD0nMTUuMTEyODY3Jz4uPC90c3Bhbj48dHNwYW4geD0nMTguODM5NjAxJz4sPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nMjIuNTY2Mzc4JyB5PSctNjMuMzcyNjI4Jz7ugYo8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nMjUuODk3NjU0JyB5PSctNjMuMzcyNjI4Jz7OkzwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSczMC44MjM2NTQnIHk9Jy02My4zNzI2MjgnPi50PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzM2LjE5OTM2NicgeT0nLTYyLjM3NjM2NCc+bjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc0MS4wODUwMzYnIHk9Jy02My4zNzI2MjgnPu6BizwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSc0NC40MTYyNjUnIHk9Jy02MS4xMzEwMzQnPk08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nNTEuODUzNzA2JyB5PSctNjMuMzcyNjI4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \DiagramSquare {
        width = 6cm,
        nw = {{\mathopen {}\llbracket \Gamma .R(t_{1},\ldots ,t_{n})\rrbracket \mathclose {}}_{M}},
        nw/style = {pullback},
        ne = MR,
        sw = {M(B_{1},\ldots ,B_{m})},
        se = {M(A_{1},\ldots ,A_{n})},
        west/style = {>->},
        east/style = {>->},
        south = {({\mathopen {}\llbracket \Gamma .t_{1}\rrbracket \mathclose {}}_{M},\ldots ,{\mathopen {}\llbracket \Gamma .t_{n}\rrbracket \mathclose {}}_{M})},
      }
    ]]></fr:resource-source></fr:resource></fr:figure></fr:li>
  <fr:li>If <fr:tex
display="inline"><![CDATA[s]]></fr:tex> and <fr:tex
display="inline"><![CDATA[t]]></fr:tex> are terms of the same sort <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .s=t\rrbracket \mathclose {}}_{M}]]></fr:tex> is the following equalizer:
    
    
      
      <fr:figure><fr:resource
hash="ed5b657b8e31b55f3106c22aefbf15bd"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMxNy4yMTQzMDZwdCcgaGVpZ2h0PSc0OS4yODU5MjhwdCcgdmlld0JveD0nLTcyIC03MiAyMTEuNDc2MjA0IDMyLjg1NzI4NSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU93QUFvQUFBQUFCQ2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hXaDJiV050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNnWjJ4NVpnQUFBV1FBQUFEeUFBQUJCSkRUM1NCb1pXRmtBQUFDV0FBQUFDOEFBQUEyS3ZHZU5HaG9aV0VBQUFLSUFBQUFJQUFBQUNRSXF3UWZhRzEwZUFBQUFxZ0FBQUFJQUFBQUNBaDNBSDVzYjJOaEFBQUNzQUFBQUFZQUFBQUdBSUlBQUcxaGVIQUFBQUs0QUFBQUZ3QUFBQ0FBQkFCVGJtRnRaUUFBQXRBQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRG9BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXNXYWN3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHI2TXZneU0vd0g4cGtoMGtocS9nT0ZBYjRERE1jQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpKy8vOUR5UDlid0h3R0FGT1RCcWtBQUFCNDJoV0tNVTdEUUJSRVBYK1h2empZNjdXOTloSkJGSWtJR3dHU0pjQTJpa1FxcW5UY2dZWUQwRUtCRkFtS0hJQ1dCdTRBMThrbGtJR2xtcG4zSmtEdzhEdHNIZE5uY0JNRUVJckxLYnF5MEdpZ3F2cWljMmRkbjRQcmc2cmVnV0xYbFk0Yjhtb0J0MENmOTIzVmdLdldQOCs5eStHNUwxYXhtbFVzMzFjQ1lYWnFNbVM4ZmtsUjJzdUpXUCswaGRFaldxK2tXSVlHVk02djdoTkN1bjE5SkI1RmF2ZHRaczFia2NnbmZFUkYrcXJ6a0hqY1QraDIyQ1FzUWVDb0NDR2wwRDZNby9ud3ZDZU1wcnRoczN2NGI2Y2tJQ214STRnVGgrOG9sZ0E0dGlFUTVzTVhMYlh5ZXh3VGtQNEJWb2tsUndBQWVOcGpZR1JnWUFCaVNRbC96M2grbTY4TXpDd01JUEE0UXRjZVFmLy95NnJGdEFmSTVXQmdBb2tDQU9GL0NMTUFlTnBqWUdSZ1lHYjR6OERBd0tyTVVQZi9KNnNXQTFBRUJUQUJBRnUwQTlRRFZBQUFCU01BZmdBQUFBQUFnZ0FBZU5wallHUmdZR0JpQ0dJQTBReFFFZ2tBQUFpZkFGZ0FlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ3dOcUZnWW1WcVF0Z0YyV3dqWndRQ2FucTJOL2RoL0hRTjF5ZCsyRUROVDhVM0s5Z2x2UitKWlc0QjFkTW1XZWVpSHZMWExQZ25TZUs4bG1TVno0eWw5SjhacTU0NFN2elJQTHZ6RFVyZmpmQlhhNkRqV29YakkzKzVGeTMzdHZZZDhHcnBXNlMzMXB2NDJHd1JoMXZ5b3hkUDU2ZGFuV2pXellFSEJldURGZ2lpcDBrSnJIbkpKMmpZODArSmIxd2tGeXhSTlA4NjdmUys3UTVwSitNYkk3Y1JBMmpMSHJSczJ3VmJYcXBhZjhBeUJFdjd3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpzdG1hcnk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOQUFBb0FBQUFBQThRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdjS3habG1OdFlYQUFBQUZBQUFBQUxnQUFBRFFBRE9DZVoyeDVaZ0FBQVhBQUFBQ09BQUFBcU1EYmszRm9aV0ZrQUFBQ0FBQUFBQzBBQUFBMko0U2RlMmhvWldFQUFBSXdBQUFBSUFBQUFDUUZaUFpNYUcxMGVBQUFBbEFBQUFBS0FBQUFDZ05wQUpCc2IyTmhBQUFDWEFBQUFBZ0FBQUFJQUNvQVZHMWhlSEFBQUFKa0FBQUFHQUFBQUNBQUJnQVpibUZ0WlFBQUFud0FBQUN5QUFBQkxFTnZaWXh3YjNOMEFBQURNQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm0zTTQ0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFBQkpIWktjVms2QTlzRHJ3ZmV6TlZmVEJnWW1LdTV6d0NGR1JFcS92OW5ZQUFBVFl3US93QjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytRKzgvLzhIa2w3Ly84dHZCOHN6QUFCbXBRZUhBQUI0Mm1OZ1lwanduNEZ4THpNRGd6Q0RPQU9EdUtDWnVhS1l1Q2didTdLZ01aaFdWQk1HTWljdzhUSUs4REF4OGNUSGc4aC9IM2g3b3FNL01UL2haV1RrRmVObC9KTUNwaGlaei81SllXQmdZdEFHbWhrR05KTVpiS2F4b0xJd3lDQjFVek56SUJ0TUF5MDVHUjNkQ3pUcUk4aU11RGdReWNqUHczU09lYzRmQjZpeHpITWd4dkl5QUFDVHNoMk5BQUI0Mm1OZ1pHQmdBT0tvVmpibGVINmJyd3pNTEF3ZzhEaEMxeDVCLzJkZzNNc000bkl3TUlFb0FOM01COGtBQUFCNDJtTmdaR0JncnY1aXdzREErSkpCbTBHSGNTOERVQVFGTUFFQVhvb0RxZ0ZWQUFBQjZRQ1FBQ3NBQUFBQUFBQUFLZ0JVZU5wallHUmdZR0Jta0dCZ1lnQUJSZ1kwQUFBREp3QWdlTnBkanNFS2drQVFoajlKaXd3NkJuWGFKMWdVZzZBWHNDZndycmlFa0FxdUNIYm8yUnRsVHM1aDV0dC92b0VGWW40RUxCVndXUHRTb2ZCQk9lTEVXWGt2NlZVNTVvWmhSeEFlSlRuelZBNkZYOG9SRndybHZlUWY1Wmc3WHorMjVUQS9kQlJ1OEUzZm1kUW1tdVN1YzBNNXV0cFVzNm1ueGsvdjFtUTJzUm1la1phU2dabkg1bFhnaER3TlBaMzhNTVdTYkp4Y25HNzFTc2tkdFhpVmJJelFKSmRlK2x0OFE3WmVXN0kvUWFRdGZRQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpzdG1hcnkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTThBQW9BQUFBQUE5QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnY0hCWkZtTnRZWEFBQUFGQUFBQUFMZ0FBQURRQURPQ2VaMng1WmdBQUFYQUFBQUNJQUFBQXFJT1BPLzFvWldGa0FBQUIrQUFBQUMwQUFBQTJKMHlkZTJob1pXRUFBQUlvQUFBQUh3QUFBQ1FFMWZYamFHMTBlQUFBQWtnQUFBQUtBQUFBQ2dNTEFIZHNiMk5oQUFBQ1ZBQUFBQWdBQUFBSUFDb0FWRzFoZUhBQUFBSmNBQUFBR0FBQUFDQUFCZ0FaYm1GdFpRQUFBblFBQUFDMkFBQUJOU0NTU010d2IzTjBBQUFETEFBQUFCQUFBQUFnQUFNQUFYamFZMkJtYkdXY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkIxd052WnJNdjJnd016R2JjVjRIQ2pBZ1YvLzh6TUFBQUxqd1FRd0I0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUSs4Ly84SGtsNy8vOHR2QjhzekFBQm1wUWVIQUFCNDJtTmdZaWovejhEWXlzekFJTXdnenNBZ0xtaG1iaXdtTHNyR3Jpd0lwZFdFZ2N4eVJxN3YzSXlNM0ZGUklQSTdWMTFZMkZmbVYxeU1qRnpDWEl4L2dzQVVJL08xUDBFTVFNREVJQWswVXdWb0pqUFlUR05CWldHUVFlcW1RTU1Gb2JTWStKTHc4QVpHcnE4Z1E4TERRU1NRZVoxNTNSOFRxTEhNNnlER2NnR05CQUF1Z3h3NGVOcGpZR1JnWUFCaTJaa2ZhdUw1YmI0eU1MTXdnTURqQ0YxN0JQMmZnYkdWR2NUbFlHQUNVUUFLdkFpckFBQUFlTnBqWUdSZ1lEYjdvczNBd0RpWFFaSkJnckdWQVNpQ0FwZ0FSbFFDc2dBQlZRQUFBWjBBZHdBWkFBQUFBQUFBQUNvQVZIamFZMkJrWUdCZ1pwQmdZR0lBQVVZR05BQUFBeWNBSUhqYWJZd3hENEl3RUlVZkVRaml3dVNnU3hQM0JsSlhaeVpYTm9jU0dzSkFTU2doWVhIeGovc2cxVVZ2dVB2dTNYc0hJTVVUQWRZS2tHeDlyWkNjZUk1d1FPWTVwbnIybk9LRUMzWUl3ajJWRERmUElmbnVPY0lSRDg4eGRlYzV4UlV2Ti9WNlhJcjhNeXN6dW02d29wQmZxVFRXakhveWphZ1gwY3lkbTl0ZUtKbEx4VmNUZW1pTVdGQWcvOWtyR0xKRGh3RVdncHI4NHlycHNwdFQ4MkxRMEZuekprZ3pzNDY5WlVKQWJYa0o5UWJCdVM2cEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFZTUFBb0FBQUFBQnpRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVWwxRldOdFlYQUFBQUU0QUFBQVB3QUFBRXdCQUFEc1oyeDVaZ0FBQVhnQUFBTW5BQUFENE9YQnJHSm9aV0ZrQUFBRW9BQUFBQzhBQUFBMktsYWVNR2hvWldFQUFBVFFBQUFBSUFBQUFDUUh2UU11YUcxMGVBQUFCUEFBQUFBWUFBQUFHQkJxQVdSc2IyTmhBQUFGQ0FBQUFBNEFBQUFPQTBRQ1FtMWhlSEFBQUFVWUFBQUFGd0FBQUNBQUNBQnZibUZ0WlFBQUJUQUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUdBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0yc000Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVl5aGhadmdQNURORHBKSFUvQWNLQXdEc3pnMU9lTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQ3lBTkJjREIxQ09pVUdQd1pjaGw2SGsvMytnR0lSZC9QLy8vOHYvdC82ZjluOGlXQWNVQUFCTzl3M2pBSGphVlpQZnF4dEZGTWZubk5uZFNYYVQyZXl2bVRTL3MwazJOOWwyazV2TjNlWGU1aVlwcWQ2cWhiWmFhRitMS0FXMUlLamdtMVdFZ29LSS9nMCtDVDRMUXAvMG4xQVFINFQrQlgzeTlqcDc2MzJRK2NHZWMyYlB6UG5PWndpUWp3Z2h6OGdueENRazU4RENhSm5sQy9FTWVvMWcyR3VJd1pFTW9aZXFRWURjUER2VHZzR241RFloUUpraHVwRDV4Z3hzaUdhd3pLVEljZzhNRm80dE1HUVJGWkxEREppS3JrR3VJZmZ5VEgwUGpDaVRhU2FrVjdqVFRQckdPREkwOFVRRDVvNjd0djc1dFkxRnNjYVAydlRiRjNkTTM0ZEhUM1JBZjhaTEFMYisvbnNtUmFpeTFWUi9yRUdwNW50OWNPM3ZnZ3A5Qjc0eXVmOTFHOXhhM3NLSHAzOUx4Z0MxQVFNTnFEcVp3d0RjQmw0Ly9jS25MWHgwK21lZ1ZWb1VhVmtGTkUwdHFKV0F4azFFd1F5Z1dxaVdsNzNUcDNpRHE3aG5LOU5YYWdHWm56Mm5mOEJ2NUFOQ1JodFZSRFRtMUVaT28vR0daZ2RMWlFJcktrOGd5OWNvaXRLejgxbklEakREVmp0eENBeTV5UElzUFhlcEZrYmo1UWFWNTcvZlh5WmM1dkJMYkZQMDQ4TTNZczdhdmw0T1dqNlljY1V5Yks4VFdqb3pMUU44cHp6ZVhXZnkzbmJ5cGxtLy84cEp2V1VweGRDenVFbmJ2U01YM2JJQm91SU1qdmNPZ1ZaSEFXSXdXZDI2eEMzV0N2U1NhQWFndi9YanlodWtGRmZyZnZ2ajI3N05vZVpNZjVvbnNoYTBBTGFKcjFLaWZhM2pEWEY2MEwrS09OME9kcWpMK3JLYXJJeXJ6WDdmQ1hGejdDTEt1UlNKTnB0VXJONjd1LzFnSDNHM0Z6UTZGMGwxajV6citOclpjL2dMZmlVN1pTU0t2WE5aZk1WTmdZNjRVR1VONlVJeHdqcVFLc0xXTUU0dWVwUm5SU3N3U3pDRG45MWpsMThSVHYxd3J6TnpMbXZZcXNyNWh6ZnZBd3prVU90ZThrNzY1cXJYazBDM2ZwcTRGUWxZTjUyOXQvZnZVaHdGQWlROGJsU0JWYTJoTytJbHpTczMxdTJGY0JQdElBa0hrZXpxZGEvQWJjNmpKcFk1TjRmdCtxeG14enBNRmlNQmR0Z3Nhb3BWVFYvaVorUXlJUjVsUXAxWDlmOWRjdTY5ZkFFYlJZZVFMRjJJUUwyQWYxNDNNSXh2Q0wxVVZqZlZzV1c4dTdJRi9lUkJHMTM3WWJka1JuMmNQT0NPYThQM0wzNmZIaUMrdXFneWhlcThycVJPRTB0Q2t5cGlQdzJuaU4wZk5GT3hUUDRGUGxkK1ZnQjQybU5nWkdCZ0FPSm9yV21DOGZ3Mlh4bVlXUmhBNEhHRXJqMkMvditOcFo5cFA1REx3Y0FFRWdVQStCd0pkZ0I0Mm1OZ1pHQmdadmpQd01EQUVzMmcvZjhNU3o4RFVBUUZzQUVBWFZzRDh3TEdBQUFCV3dCMEJGc0FUQVFOQURBQ0tBQkpBYmtBS3dBQUFBQUFGZ0NhQVQ0QnFBSHdBQUI0Mm1OZ1pHQmdZR1BJWXdEUkRGQVNDUUFBQzhjQWVBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFVQUFvQUFBQUFCS2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hjTjN0bU50WVhBQUFBRThBQUFBTlFBQUFFUUFVZ1FuWjJ4NVpnQUFBWFFBQUFFN0FBQUJaTHlJVy81b1pXRmtBQUFDc0FBQUFDNEFBQUEyS0tpZGUyaG9aV0VBQUFMZ0FBQUFIZ0FBQUNRR0JRSWlhRzEwZUFBQUF3QUFBQUFVQUFBQUZBc0tBUGxzYjJOaEFBQURGQUFBQUF3QUFBQU1BSzRCQ0cxaGVIQUFBQU1nQUFBQUdBQUFBQ0FBQ0FBZmJtRnRaUUFBQXpnQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRUNBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXNtT2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHBxTUU5bVp2Z1A1RE16TUlLRUdSRXEvZ09GQWR1ckRXd0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtOQmxzbVNmLy93OWthVUJZLzIvK1AvYW5FS3dXREFEbkFRdDJBQUFBZU5wTnpyOU93bEFVQnZCelRyRTF0b0J0dUxjTkZ2blQ1RlppZ2dHaERSb2RqQnBqSkE1ZzRxSUVpaGpqRS9BQWhuY3djV0F5OFFuWTNId1BGbWNuSjR2V2FveG5PUG5POHZzT0lBdytBVHNTZ0Ftd2tDa0p0NEsrOFB4ZHJLVXhoYVpzNUpGam13ZlZzbzFvaStxUW8zWjVoTFRmVFV2dlMvM3UrZFBPM3VRc3VOS1dleC9qMFh3KzBCTVFEVUl6Y3NzL0xuSlpTV0dwRWFsdVhXeWc4TDBhTjFjUjEyS1JKUytPcVgxaVNJZ3M3b0Zmc1IvZVRkNWFSb0xpSGlEWWdqSE5jQVJxckJabFVmZk1vc2N6c3ZJdjAzUDRvSEd1MGxCbFRBM3ZWYzQxQ3BLTTRTa3FPUVcvMTh0ZmluOHRBVkNIcHBDTER0T3BvT0lJMmRSbHZvM01kWlRHWnMxemRVK3NZNFA4WEhieDRQYkcwVkhLSHhiYmp5MnJtU1hLTmkyYXZsNzNFQTBybkszd2dpUVZNalpaTnNzRGZBRnFYRHh5QUhqYVkyQmtZR0FBNHFVNzNVN0g4OXQ4WldCbVlRQ0J4eEc2OWdqNlB3UFRRMllRbDRPQkNVUUJBQjJUQ1ZVQUFIamFZMkJrWUdCbStNOEFKR1VZbEJnWW1CNHlBRVZRQUNzQU5aSUNMZ0FBQW9BQUFBR05BR1FCalFBNUF4d0FPZ0pVQUNJQUFBQUFBQ3dBVmdDQ0FMSjQybU5nWkdCZ1lHV1FZMkJpQUFGR0JqUUFBQVB6QUNoNDJrV01NVy9DTUJDRnY0Z0VpWFRvVW5WZ0FBL01WcUl3ZDJGZ1ltVmlBV3lpREhHUUV5SWhvWTc5M1QyTUpXNTQrdTY5ZHdmay9KTHduSVRQb005SnlXUjdjY1lIWDVHbnNpMGo1OHhaTVNGSlorSXMrSW1jU25LSW5QSE5KZkpVL0Vma25EVi9tNjY5M2dicjFhNHoxcnR6Njh0aWIzM2ZkRTZWdWdqNzFqcnJqNE0xNm5SWFptejZzVzVWcFF0ZHNhR2o1Y3FOQVl0SHNSUEhCSGFjSmZPVUZPeUQwOU5JNnFSVm9zVjk1MXZKWGVnY3d5Y2puUk4zVWNNb1Y3MW9MVzFGRlM0MTFUOWpQUzhQQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOMEFBb0FBQUFBQStnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVjQUFBQmdoY3g0SEdOdFlYQUFBQUU4QUFBQU1RQUFBRHdIQnYwc1oyeDVaZ0FBQVhBQUFBQ3VBQUFBdkxRVWFJaG9aV0ZrQUFBQ0lBQUFBQ3dBQUFBMktKbWVNbWhvWldFQUFBSk1BQUFBSGdBQUFDUUYxZ0hYYUcxMGVBQUFBbXdBQUFBTUFBQUFEQWUxQUtsc2IyTmhBQUFDZUFBQUFBZ0FBQUFJQUN3QVhtMWhlSEFBQUFLQUFBQUFGd0FBQUNBQUJRQWdibUZ0WlFBQUFwZ0FBQURLQUFBQk11MEtrZXB3YjNOMEFBQURaQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Xc0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lOR0JpU1FVbHlXRHBRMFpKN016UEFmeUdkbVlBUUpNeUpVL0FjS0F3QUIzdzNiQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeWhveVQvNy9IOGdIMC84di9Na0hxd0lDQUpmQUNUQUFBQUI0Mm1OZ1pDaGdZR0I4d3JTU1FSSklDN0tKV1RPSzZqUHlNNW9hRzVtcEMvSXhxcHVLbVptYmlUR0dNeXQ0cXFjSEZMaXBleW93NjRTSUtKWVlpM0l6ZGY4OUtTV3F5c3pJeEtRcUtzWEVKY0xKcU1Ja3BzZklCVFNLd1pLQmdXazIwM1lHT1NCSFhGbVBrVjFaaVUwYzNRSXpOVzFHVTZZYWVXVk8zOElhWlg1R1pqbFhsZWlJTkROSkMya21KbWtMU2FidHJ6UGpHQVVrL3I2QzJTTWl4U1FvTGF6S3dNQUFBRFYySEtRQUFIamFZMkJrWUdBQTRydE14WTd4L0RaZkdaaFpHRURnY1lTdVBUTE5kSmxwTzVEaVlHQUM4UUR2SWdnaWVOcGpZR1JnWUdiNHo4REF3SFNad1JKSXptWUFpcUFBWmdCRU5BS3pBQUFDMHdBQUFrY0FjQUtiQURrQUFBQUFBQ3dBWG5qYVkyQmtZR0JnWnBCbkFORU1VQklKQUFBRHZ3QW1BSGphUFl3eHE4SXdGSVcvWWhYdEd4d0VoemRJOEFlRVNoKzR1RGs0dVRxOHpab2dIWnBLV29zdTRrLzNOZ1J2NFBEZGM4NE5rUEVpWVppRWVkQmhVbm56eUdOK1dFU2VpTCtLblBITG1oRkpPaE5ueFM1eXlwVC95R09XbEpFbjRqOGlaL3p4M2pmMTdkNVpyNDZOc2Q1ZGFyODlXZDlXalZNYm5RL3J3VHJyejUwMXFud3EwMWR0ZjYxVm9YTmRzS2VoNXNhZERvdEhjUlRIQkhaY0pQTnNPWVc5cFpMTVNXZURKdittQjBsZGFKekRMMFlhSlU5UlF5ODNyZWhWdW9vaTNHbUtEMWlzTGtzQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWmNBQW9BQUFBQUI1QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVkMGxtTnRZWEFBQUFFNEFBQUFSZ0FBQUZRQW1nRmxaMng1WmdBQUFZQUFBQU5lQUFBRUlNeTk5bnBvWldGa0FBQUU0QUFBQUM0QUFBQTJLZlNka21ob1pXRUFBQVVRQUFBQUhnQUFBQ1FIUndLZWFHMTBlQUFBQlRBQUFBQWdBQUFBSUJIb0FYaHNiMk5oQUFBRlVBQUFBQklBQUFBU0JDb0M3bTFoZUhBQUFBVmtBQUFBR0FBQUFDQUFEQUJKYm1GdFpRQUFCWHdBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFHVUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtc21XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcnFNSlF3TS93SDhwa2gwa2hxL2dPRkFiNXRETTBBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0J5QU5BOERCMUNPaFVHSFFZL0JpY0dYb2VUL2Y2QW9pT2NJNUJYLy8vLy82djhyL3cvOTMvRi9NbGdmSEFBQXRUTVA5Z0FBZU5vOVUxK0lHMFVZbjkvTVpQYVNabmVTYkhhWEpKdmRTemJkMVRTWDNGMjJ1MDJrT2VqWlh2WGE4OXFpWHN1QldOQlRzRDVJLzRBdlBhU28wQXFpSU9pTEQvb20rQ1Q0VW53UURud3M5Vm1oOU5Gbkg1TTRHemhudmgxbXZ2MFlmbisrSVNCNzh6RjVRbTRSaTVCVVNCaUl3blNDTk5aRTBFZWNwUFlUSG9pT0RTYnJYWEN6V21zMmF4dDRNeTZzb1VpTit0Nm93aVdXZXo0NFVRUGt1dnFPeUFka1NkMW5vQjNHeWJwOUJIL0ZWNUhZMmVxck9rbzY4emw5UnY4aUE3S3VLcEdrNjdaalZ1MWhZb3NCdENpTTRzU3hrM1NBbGlhcXRwTTRCbFErU3c4VnZDSDdGZStJcWk0d3NWY3NGSE8zRDVkeTBFK1lNY3Rycy9tTzdwbzZnNTQ3MkN1aW1HOVB2djJuZFplK1VVSmVUZzl0eVpvYUdBTmRraHBRZE40OS82RGFLWUZLUTJUcGdoUUkvc0RWakE4anArWlRKdWhqNHBFdU9hT1FtbkVRQ1lXdDVjRXlvSGx3bEdwQ2E0a0ZYak1EbDRSUkVBcU5IZStaS2hqKytFVWpha3FKdmYyYjdQRGE5alhRcmRMbE83T3ZYY01ZZTk5Lzg5WnRpdjdtQTkvTWZmaG8veTZscXhkL3Y4QUJZNWVPeXBTNUd1aVY4YXNIc3JBejJqNW5USGpHQUNiT3M0OHVkRjZta0xYcFQremV6c2xkTm50ZUVZWE1oOTU4emxmb2IyUkxIUlFBRDhsQ3dQK0ZOUlhvOFBRSkNFdllQbXhyOFRjam9VQ2J5WUtpOHNJeE1VRzJFVkVvMkMrZkswZ25SMHJYdy91RkhFcjYyTXQ5TmJzcHl2TDZRNDdHS1dXSHdkOC8wSFYrdGljK3hhWlhrby9NSW5aeFo4bW9mTmFBcktSTmVtdjZkMFhUQlY5NFFKVWpRakh4NlBiMG5zR1pSVCtlUGpYeVpnMmdlV1BoVWtPdDNXWHFsaGhycWxLdFBIMU1MMlpPS1ZGZ0xYcnU5UHhmL0l3ak1sR0hQalFEam5jY3RpYlU3Q09hWUxqdVZFWGtLVSt5R2FtY2luQkR0ZDdDeWlCTTR3UmY2aVA3M0JxdzZyWlhyVUtWVXI5UTdyKzMrUm9RMkczVzlxd3I4blV2eDJxVVRycjFTeHgrTWRwL2FRUE5jZ3N1N2pkTnNJMTYyeGFpWk9YRFJqc3V5MVdPcEJlME9rN0Fvd3JsSWM5RnpvdStZQytNZ3pVNTRJZ0R6K1gxc3B2eGNCU1BxL1FUMGlQRVpKcXdxcWt5S2xHOVh6MW1FYVptSURKSDFCdDFiRWRpbUNoT2YxN2lkTG4rU2p0WHlQTzY0VVJudTBQVjNGczNtcER5N1NqdmNwZHF3WTJtTE9HNzJWTzdVRm1qOU16bEVwaVJIOVRxZlk1aFYvUFJ5dVQ5b1Y0RUdxMkhtYmhLMnY4QWdJcVlpZ0FBZU5wallHUmdZQUJpKzlvczUzaCttNjhNekN3TUlQQTRRdGNlUWYrM1l0Rmx1Z3ZrY2pBd2dVUUI4ODBJc3dBQWVOcGpZR1JnWUdiNHp3QWtIektJLzkvQ29zc0FGRUVCSEFCZlR3UHNBQUFDZGdBQUFSd0FXQUVjQUZrREFBQWtBd2dBS3dQaEFDd0Izd0ExQVhJQUZ3QUFBQUFBS0FBOEFKQUE3QUZpQWNZQ0VBQUFlTnBqWUdSZ1lPQmc4R0JnWmdBQlJnWTBBQUFJZFFCV2VOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpzdG1hcnk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpzdG1hcnkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQxLjAzNTcyMiwtNTUuNTcxMzYyKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTM0LjAyMTk2LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDQxLjAzNTcyMiwtNTUuNTcxMzYyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9JzQxLjAzNTcyMicgeT0nLTU1LjU3MTM2Mic+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc1MS43ODcwNjUnIHk9Jy01NS41NzEzNjInPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNTUuNjYxNDM4JyB5PSctNTUuNTcxMzYyJz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9JzYzLjIxODE5NycgeT0nLTU0LjA3Njk4MSc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSc2Ny42ODc1NjYnIHk9Jy01NS41NzEzNjInPiw8dHNwYW4geD0nNzIuMTE1Mzc0Jz4uPC90c3Bhbj48dHNwYW4geD0nNzYuNTQzMTgyJz4uPC90c3Bhbj48dHNwYW4geD0nODAuOTcwOTknPi48L3RzcGFuPjx0c3BhbiB4PSc4NS4zOTg3OTgnPiw8L3RzcGFuPjx0c3BhbiB4PSc4OS44MjY2MDYnPkI8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc5Ny4zODMzNjUnIHk9Jy01NC4wNzY5ODEnPm08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMTA0Ljk1MTEwMScgeT0nLTU1LjU3MTM2Mic+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3Ni4yMTI0MywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg0MS4wMzU3MjIsLTU1LjU3MTM2MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSc0MS4wMzU3MjInIHk9Jy01NS41NzEzNjInPk08dHNwYW4geD0nNTEuNzg3MDY1Jz5BPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEwOS4xNTQwNywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSg0MS4wMzU3MjIsLTU1LjU3MTM2MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSc0MS4wMzU3MjInIHk9Jy01NS41NzEzNjInPu6BijwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc0NS4wNDg0NicgeT0nLTU1LjU3MTM2Mic+zpM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNTEuMjc1MTI5JyB5PSctNTUuNTcxMzYyJz4uczwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSc2MS40Nzk4NTgnIHk9Jy01NS41NzEzNjInPj08L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNzEuOTk1OTM4JyB5PSctNTUuNTcxMzYyJz50PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jzc1LjU5MzU3MycgeT0nLTU1LjU3MTM2Mic+7oGLPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jzc5LjYwNjI5MicgeT0nLTUyLjU4MjU4NSc+TTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNLTU0LjgwNjkyIDBILTM5LjA3NzUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoLTEuMCwwLjAsMC4wLC0xLjAsLTU0LjU1NjkyLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTM4LjgyNzUsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8cGF0aCBkPSdNMzguNTc3NSAzLjYxNjYySDcxLjE1Njg5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDcxLjQwNjg5LDMuNjE2NjIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQyLjQ5Mzg3LDguNjc4NDQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDQxLjAzNTcyMiwtNTUuNTcxMzYyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9JzQxLjAzNTcyMicgeT0nLTU1LjU3MTM2Mic+7oGKPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9JzQ0LjM2Njk5OCcgeT0nLTU1LjU3MTM2Mic+zpM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNDkuMjkyOTk3JyB5PSctNTUuNTcxMzYyJz4uczwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc1NS40MTkzNjMnIHk9Jy01NS41NzEzNjInPu6BizwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSc1OC43NTA2MDInIHk9Jy01My4zMjk3NjgnPk08L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTM4LjU3NzUtMy42MTY2Mkg3MS4xNTY4OScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg3MS40MDY4OSwtMy42MTY2MiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDIuODcwNiwtMTEuNjc4NDQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKDQxLjAzNTcyMiwtNTUuNTcxMzYyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjAnIHg9JzQxLjAzNTcyMicgeT0nLTU1LjU3MTM2Mic+7oGKPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9JzQ0LjM2Njk5OCcgeT0nLTU1LjU3MTM2Mic+zpM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nNDkuMjkyOTk3JyB5PSctNTUuNTcxMzYyJz4udDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc1NC42Njg3MScgeT0nLTU1LjU3MTM2Mic+7oGLPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzU3Ljk5OTkzOCcgeT0nLTUzLjMyOTc2OCc+TTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9zdmc+" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
      \begin {tikzpicture}[diagram,node distance=3cm]
        \node  (1) {$M(B_{1},\ldots ,B_{m})$};
        \node  [right = of 1] (2) {$MA$};
        \node  [left = of 1] (e) {${\mathopen {}\llbracket \Gamma .s=t\rrbracket \mathclose {}}_{M}$};
        \draw  [>->,morphism] (e) to (1);
        \draw  [->,morphism,offset=-1.5] (1) to node {${\mathopen {}\llbracket \Gamma .s\rrbracket \mathclose {}}_{M}$} (2);
        \draw  [->,morphism,offset=1.5] (1) to node[swap] {${\mathopen {}\llbracket \Gamma .t\rrbracket \mathclose {}}_{M}$} (2);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></fr:figure></fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\top \rrbracket \mathclose {}}_{M}]]></fr:tex> is the terminal object of <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(M(B_{1},\ldots ,B_{m}))]]></fr:tex>.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi  \wedge  \psi \rrbracket \mathclose {}}_{M}]]></fr:tex> is the intersection of <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi \rrbracket \mathclose {}}_{M}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\psi \rrbracket \mathclose {}}_{M}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(M(B_{1},\ldots ,B_{m}))]]></fr:tex>.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi  \vee  \psi \rrbracket \mathclose {}}_{M}]]></fr:tex> is the union of <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi \rrbracket \mathclose {}}_{M}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\psi \rrbracket \mathclose {}}_{M}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(M(B_{1},\ldots ,B_{m}))]]></fr:tex>.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi  \Rightarrow  \psi \rrbracket \mathclose {}}_{M}]]></fr:tex> is the <fr:link
type="local"
href="ct-001C.xml"
addr="ct-001C"
title="Heyting implication">Heyting implication</fr:link> <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi \rrbracket \mathclose {}}_{M} \Rightarrow  {\mathopen {}\llbracket \Gamma .\psi \rrbracket \mathclose {}}_{M}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(M(B_{1},\ldots ,B_{m}))]]></fr:tex>.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\lnot \varphi \rrbracket \mathclose {}}_{M}]]></fr:tex> is the Heyting negation of <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi \rrbracket \mathclose {}}_{M}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(M(B_{1},\ldots ,B_{m}))]]></fr:tex>.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\exists x\colon A.\mkern 5mu\varphi \rrbracket \mathclose {}}_{M}]]></fr:tex> is the <fr:link
type="local"
href="ct-000K.xml"
addr="ct-000K"
title="Image">image</fr:link> of the following composite:
    <fr:tex
display="block"><![CDATA[       {\mathopen {}\llbracket \Gamma ,x\colon A.\varphi \rrbracket \mathclose {}}_{M} \rightarrowtail  M(B_{1},\ldots ,B_{m},A) \xrightarrow {\pi } M(B_{1},\ldots ,B_{m})     ]]></fr:tex>
    where <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex> is the projection of the first <fr:tex
display="inline"><![CDATA[m]]></fr:tex> factors.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\forall x\colon A.\mkern 5mu\varphi \rrbracket \mathclose {}}_{M}]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\forall _{\pi }({\mathopen {}\llbracket \Gamma ,x\colon A.\varphi \rrbracket \mathclose {}}_{M})]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\forall _{\pi }]]></fr:tex> is the right adjoint associated with a <fr:link
type="local"
href="ct-0019.xml"
addr="ct-0019"
title="Heyting category">Heyting category</fr:link> and <fr:tex
display="inline"><![CDATA[\pi \colon M(B_{1},\ldots ,B_{m},A)\to M(B_{1},\ldots ,B_{m})]]></fr:tex> is the projection of the first <fr:tex
display="inline"><![CDATA[m]]></fr:tex> factors.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\bigvee _{i \in  I}\varphi _{i}\rrbracket \mathclose {}}_{M}]]></fr:tex> is the arbitrary union of each <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi _{i}\rrbracket \mathclose {}}_{M}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(M(B_{1},\ldots ,B_{m}))]]></fr:tex>.</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\bigwedge _{i \in  I}\varphi _{i}\rrbracket \mathclose {}}_{M}]]></fr:tex> is the arbitrary intersection of each <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket \Gamma .\varphi _{i}\rrbracket \mathclose {}}_{M}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(M(B_{1},\ldots ,B_{m}))]]></fr:tex>.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1274</fr:anchor><fr:addr
type="user">log-000B</fr:addr><fr:route>log-000B.xml</fr:route><fr:title
text="Model">Model</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>18</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[M]]></fr:tex> be a <fr:link
type="local"
href="log-0006.xml"
addr="log-0006"
title="Sigma structure"><fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structure</fr:link> in a category <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
  Fix an <fr:link
type="local"
href="log-000A.xml"
addr="log-000A"
title="Axiomatization">axiomatization</fr:link> of a theory <fr:tex
display="inline"><![CDATA[\mathscr {T}]]></fr:tex> interpretable in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
  Then <fr:tex
display="inline"><![CDATA[M]]></fr:tex> is a <fr:em><fr:strong>model</fr:strong></fr:em> of <fr:tex
display="inline"><![CDATA[\mathscr {T}]]></fr:tex>, denoted as <fr:tex
display="inline"><![CDATA[M \vDash  \mathscr {T}]]></fr:tex>, if every axiom of (the given axiomatization of) <fr:tex
display="inline"><![CDATA[\mathscr {T}]]></fr:tex> is <fr:link
type="local"
href="log-000T.xml"
addr="log-000T"
title="Satisfaction">satisfied</fr:link>.</fr:p><fr:p>The category <fr:tex
display="inline"><![CDATA[\mathscr {T}\text {-}\mathsf {Mod}(\mathcal {C})]]></fr:tex> is the full subcategory of <fr:tex
display="inline"><![CDATA[\Sigma \text {-}\mathsf {Str}(\mathcal {C})]]></fr:tex> spanned by the models of <fr:tex
display="inline"><![CDATA[\mathscr {T}]]></fr:tex>, and the category <fr:tex
display="inline"><![CDATA[\mathscr {T}\text {-}\mathsf {Mod}(\mathcal {C})_{e}]]></fr:tex> has the same objects as <fr:tex
display="inline"><![CDATA[\mathscr {T}\text {-}\mathsf {Mod}(\mathcal {C})]]></fr:tex> but the morphisms are all <fr:link
type="local"
href="log-0009.xml"
addr="log-0009"
title="Elementary morphism">elementary morphisms</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Backlinks">Backlinks</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1746</fr:anchor><fr:addr
type="user">log-000S</fr:addr><fr:route>log-000S.xml</fr:route><fr:title
text="Identity morphisms in the internal language of a category">Identity morphisms in the <fr:link
type="local"
href="log-000P.xml"
addr="log-000P"
title="Internal language of a category">internal language</fr:link> of a category</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a <fr:link
type="local"
href="ct-000O.xml"
addr="ct-000O"
title="Regular category">regular category</fr:link>.
  <fr:tex
display="inline"><![CDATA[f\colon A\to A]]></fr:tex> is the identity morphism iff <fr:tex
display="inline"><![CDATA[x\colon A|\top  \vdash  f(x) = x]]></fr:tex> is <fr:link
type="local"
href="log-000T.xml"
addr="log-000T"
title="Satisfaction">satisfied</fr:link> in the <fr:link
type="local"
href="log-000P.xml"
addr="log-000P"
title="Internal language of a category">internal language</fr:link> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1385</fr:anchor><fr:addr
type="machine">#298</fr:addr><fr:route>unstable-298.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Suppose that <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is the identity morphism.
    Then by <fr:ref
addr="log-0007"
href="log-0007.xml"
taxon="Definition" />, <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket f(x)\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A} \circ  {\mathopen {}\llbracket x\rrbracket \mathclose {}}_{\mathcal {C}} = {\mathopen {}\llbracket x\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex>.
    But the equalizer with itself is the terminal object.
    Thus, <fr:tex
display="inline"><![CDATA[\top  \leq  {\mathopen {}\llbracket f(x) = x\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> as required.</fr:p>
  <fr:p>Conversely, suppose that the terminal object of <fr:tex
display="inline"><![CDATA[\mathsf {Sub}(A)]]></fr:tex> (i.e., the identity morphism <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A}]]></fr:tex>) factors through <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket f(x) = x\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex>.
    Then it follows that <fr:tex
display="inline"><![CDATA[\mathsf {id}_{A}]]></fr:tex> equalizes <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket f(x)\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket x\rrbracket \mathclose {}}_{\mathcal {C}}]]></fr:tex>.
    Since <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket x\rrbracket \mathclose {}}_{\mathcal {C}} = \mathsf {id}_{A}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[{\mathopen {}\llbracket f(x)\rrbracket \mathclose {}}_{\mathcal {C}} = {\mathopen {}\llbracket f\rrbracket \mathclose {}}_{\mathcal {C}} = f]]></fr:tex>, it follows that <fr:tex
display="inline"><![CDATA[f = \mathsf {id}_{A}]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Related">Related</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1747</fr:anchor><fr:addr
type="user">log-0006</fr:addr><fr:route>log-0006.xml</fr:route><fr:title
text="Sigma structure">Sigma structure</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>17</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with finite products and <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> be a <fr:link
type="local"
href="log-0001.xml"
addr="log-0001"
title="Signature">signature</fr:link>.
  The category of <fr:em><fr:strong><fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structures</fr:strong></fr:em> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, denoted as <fr:tex
display="inline"><![CDATA[\Sigma \text {-}\mathsf {Str}(\mathcal {C})]]></fr:tex>, consists of the following data:</fr:p>
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
  
  <html:tr>
    
  <html:th>Objects</html:th>

    
  <html:th>Morphisms</html:th>

  </html:tr>

  
  <html:tr>
    
  <html:td>
      A <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structure consists of the following data:
      <fr:ul><fr:li>Each sort <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> is associated with an object <fr:tex
display="inline"><![CDATA[MA]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.
          This is extended to any finite string of sorts by the assignment <fr:tex
display="inline"><![CDATA[M(A_{1},\ldots ,A_{n}) \mapsto  MA_{1} \times  \cdots  \times  MA_{n}]]></fr:tex>.
          The empty string is associated with the terminal object <fr:tex
display="inline"><![CDATA[1]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:li>
        <fr:li>Each function symbol <fr:tex
display="inline"><![CDATA[f\colon A_{1},\ldots ,A_{n}\to B]]></fr:tex> is associated with a morphism <fr:tex
display="inline"><![CDATA[Mf\colon M(A_{1},\ldots ,A_{n})\to MB]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:li>
        <fr:li>Each relation symbol <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1},\ldots ,A_{n}]]></fr:tex> is associated with a subobject of <fr:tex
display="inline"><![CDATA[M(A_{1},\ldots ,A_{n})]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:li></fr:ul>
    </html:td>

    
  <html:td>
      Let <fr:tex
display="inline"><![CDATA[M]]></fr:tex> and <fr:tex
display="inline"><![CDATA[N]]></fr:tex> be <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex>-structures.
      A <fr:em><fr:strong>homomorphism</fr:strong></fr:em> <fr:tex
display="inline"><![CDATA[h\colon M\to N]]></fr:tex> consists of an indexed family of morphisms <fr:tex
display="inline"><![CDATA[h_{A}\colon MA\to NA]]></fr:tex> for each sort <fr:tex
display="inline"><![CDATA[A]]></fr:tex>.
      This data is subject to the following conditions:
      <fr:ul><fr:li>For each function symbol <fr:tex
display="inline"><![CDATA[f\colon A_{1},\ldots ,A_{n}\to B]]></fr:tex>, the following square commutes:
          
    
      
      <fr:figure><fr:resource
hash="afca79891410f1ca592bfa4b822463a4"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI1MC41ODkzMnB0JyBoZWlnaHQ9JzExOS42OTY4NjJwdCcgdmlld0JveD0nLTcyIC03MiAxNjcuMDU5NTQ3IDc5Ljc5NzkwOCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTVlBQW9BQUFBQUE0UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MUcyTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUJrQUFBQVpERnVBckpvWldGa0FBQUJ5QUFBQUN3QUFBQTJLUmllTW1ob1pXRUFBQUgwQUFBQUhnQUFBQ1FGeXdMV2FHMTBlQUFBQWhRQUFBQUlBQUFBQ0FZS0FKSnNiMk5oQUFBQ0hBQUFBQVlBQUFBR0FESUFBRzFoZUhBQUFBSWtBQUFBRndBQUFDQUFCQUFnYm1GdFpRQUFBandBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEQ0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd5TS93SDhwa2gwa2hxL2dPRkFhTjNERmdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy85RHlQOFh3SHdHQUZGSEJvMEFBQUFBQVFDU0FBQUNOd0tyQUI0QUFBRVJCaFk3QVJVbUp5TUdCelV6TWpZbkVRNEJKeU0xTXhZL0FUWTNOaFlCbUFRaVRqTXNPdEU2TEROT0lRTXVWQk1TRWhJK0J6ODVHQTRDaS8zTkZ4UXRBd0VCQXkwVUZ3SUFFZ3dCTFFJS0Fnb3VBUWtBZU5wallHUmdZQURpNzJzZEF1UDViYjR5TUxNd2dNRGpDRjFYWkpvNWlHazFrT0pnWUFMeEFBWHBDRVI0Mm1OZ1pHQmdadmpQQUNTREdDWXhOREtaTXdCRlVBQVRBRUxjQXFnQUFBTlNBQUFDdUFDU0FBQUFBQUF5QUFCNDJtTmdaR0JnWUdLUVp3RFJERkFTQ1FBQUE2UUFKUUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFVSUFBb0FBQUFBQmN3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngySEdOdFlYQUFBQUU0QUFBQU1nQUFBRHdBclFCeloyeDVaZ0FBQVd3QUFBSThBQUFDbENqeGVJMW9aV0ZrQUFBRHFBQUFBQzhBQUFBMktaK2VXV2hvWldFQUFBUFlBQUFBSHdBQUFDUUhOZ041YUcxMGVBQUFBL2dBQUFBUUFBQUFFQThrQVVGc2IyTmhBQUFFQ0FBQUFBb0FBQUFLQWJBQXpHMWhlSEFBQUFRVUFBQUFHQUFBQUNBQUNBQlVibUZ0WlFBQUJDd0FBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUUvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1Qc2s0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpNaGpadmdQNURORHBKSFUvQWNLQXdEemhBMXBlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPakhrL2Y4UDVEdUM2UDhIL2s4RnF3SUNBSlZIQ1JvQUFIamFOWkcvYjlOUUVNZmYzWHY0eGZaemJNZU8zUitwV3pmRmJpb2FOMmxxS3hWeStrdUJxRldISWpvVUJvbzZnS0FMU0V3TVNDQ0VHSkRnWDJCalltQ0RxUklxNGk5Z1lXT0FQNEFGcVNuUHJYcDN3OTE5bC92Y2x5QzVmM3BLai9FbjZaS3JoSUFUd0dMcStSNVB3SVFvenNIMzBpeUJrQ3NtS2p5QXpQZjhNaFRpZEJSSGFaWkRCam0wUFU1RC9QMEVSaFowQjJCc1pXMndVUUZ3UkdtWkdmYnd1OFBvcGxBQW81TE9BV3psY2FmSmRBUmVicTBGOEk1YjAyTHZGOVR4Nk9TMWJZQWl4cEVDVUxDcUtnQzMrM3VBN05EVjFZb0dTSVZjTXFCY3cxR0VlaFA3dWhDUGhwK0lERXFlU3BZZitJWE1rZzdwRVpJNTJWS1VnQkl0ZFZJL0RNQlhlSkVCOFBNbVBGZmFxYk1vT1RwUlhJOFVUaTk2eW9jdnFlM1dITWUxNFAyREY4aldEV3N3dUhjSDZJNHdiejBmcnBkZHI1cE5mRHc2ZklPRHJjK1RObnY0OWVBdDI5NysxNmMzY1ZRWURBQVV3NVVVTjFiNzg1bzZxNXE3cmMxY1U1ZXBwSlFnRnZUbzNkVzVIRUY0SjBlNHY5VWU0UENQSTFtQTNENzlTK2ZnbU93UTBxUHBVaHJGWmZrd3FNZnk3MWxhcE9mTFM5dGVWVEdocUtwU3pEa3NTb3ZjTTc0bXhHY09wZkVacjBuTGhXdlp0OURRRkxESHBpS0JxakJLMGhITkNicFR1M3g4dnovWXhpcnp5eHJETU9xWnJGVG9FOEpxYkNROVJOV1pSNG5hSHJFdmwzaERWV3ZqSGlnSHJ4Ym1QY09lQWJ6VzFGUkU3VkpTcXlVTTUvS1pGVnp0WGxuUjg3Q21XM1VLYTRrcGRkMXR1WldFd1VKanRKSThTNjRqYTNrakhkZi9NT21ZbFVwQS9nT3RtbURYZU5wallHUmdZQURpdTgxYy92SDhObDhabUZrWVFPQnhoSzRyZ3Y3L2xma0cwMTBnbDRPQkNTUUtBQmQ4Q25RQWVOcGpZR1JnWUdiNHo4REF3S0xHRU1QZ3gzeURBU2lDQWxnQVFhb0N1QUFEVkFBQUJDVUFhUVFtQUh3RGhRQmNBQUFBQUFCbUFNd0JTZ0FBZU5wallHUmdZR0JoQ0daZ1pnQUJSZ1kwQUFBSkhBQmRlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ3dOcUZnWW1WcVF0Z0YyV3dqWndRQ2FucTJOL2RoL0hRTjF5ZCsyRUROVDhVM0s5Z2x2UitKWlc0QjFkTW1XZWVpSHZMWExQZ25TZUs4bG1TVno0eWw5SjhacTU0NFN2elJQTHZ6RFVyZmpmQlhhNkRqV29YakkzKzVGeTMzdHZZZDhHcnBXNlMzMXB2NDJHd1JoMXZ5b3hkUDU2ZGFuV2pXellFSEJldURGZ2lpcDBrSnJIbkpKMmpZODArSmIxd2tGeXhSTlA4NjdmUys3UTVwSitNYkk3Y1JBMmpMSHJSczJ3VmJYcXBhZjhBeUJFdjd3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1NQUFvQUFBQUFBM2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVeDBvMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNFWjJ4NVpnQUFBV1FBQUFCWUFBQUFXT2ErZEJWb1pXRmtBQUFCdkFBQUFDd0FBQUEyS0ptZU1HaG9aV0VBQUFIb0FBQUFJQUFBQUNRRlZnSTVhRzEwZUFBQUFnZ0FBQUFJQUFBQUNBVWFBSEJzYjJOaEFBQUNFQUFBQUFZQUFBQUdBQ3dBQUcxaGVIQUFBQUlZQUFBQUZ3QUFBQ0FBQkFBYmJtRnRaUUFBQWpBQUFBREtBQUFCTXUwS2tlcHdiM04wQUFBQy9BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTZtV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9hTWhneU0vd0g4cGtoMGtocS9nT0ZBZFNCRE44QWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpRy8vOUR5UDhYd0h3R0FGRkhCbzBBQUFBQUFRQndBQUFCNUFLcEFCa0FBQUVSQmhZN0FSVXZBUThCTlRNeU5pY1JEZ0VuTlJZMk56WVdBVmNESUVrbloxQndSaWRKSUFNc1ZCUWhkRE1WQ3dLTC9ja2FGU1VEQVFJQ0pSVWFBZ29VQ1FFa0FoWXVBUW9BZU5wallHUmdZQURpbmpzSjhmSDhObDhabUZrWVFPQnhoSzRyTXMxMG1Xa2xrT0pnWUFMeEFBazFDTFI0Mm1OZ1pHQmdadmpQd01EQWRKbWhnQ0daOFFrRFVBUUZNQUVBVnBvRGxBTFRBQUFDUndCd0FBQUFBQUFzQUFCNDJtTmdaR0JnWUdLUVlnRFJERkFTQ1FBQUF5Y0FJQUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFb2Z1TGc1T0xrNnZNMmFJQjJhU2xxTEx1SlA5ellFYitEdzNYUE9EWkR4SW1HWWhIblFZVko1ODhoamZsaEVub2kvaXB6eHk1b1JTVG9UWjhVdWNzcVUvOGhqbHBTUkorSS9JbWY4OGQ0MzllM2VXYStPamJIZVhXcS9QVm5mVm8xVEc1MFA2OEU2NjgrZE5hcDhLdE5YYlgrdFZhRnpYYkNub2ViR25RNkxSM0VVeHdSMlhDVHpiRG1GdmFXU3pFbG5neWIvcGdkSlhXaWN3eTlHR2lWUFVVTXZONjNvVmJxS0l0eHBpZzlZckM1TEFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOMEFBb0FBQUFBQTlnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdpTUp5NDJOdFlYQUFBQUZBQUFBQU1RQUFBRHdCQ1FEMFoyeDVaZ0FBQVhRQUFBQ2xBQUFBcVA3UnJWUm9aV0ZrQUFBQ0hBQUFBQzhBQUFBMktWaWRpR2hvWldFQUFBSk1BQUFBSGdBQUFDUUdjZ0E2YUcxMGVBQUFBbXdBQUFBTUFBQUFEQWg5QVNac2IyTmhBQUFDZUFBQUFBZ0FBQUFJQUJvQVZHMWhlSEFBQUFLQUFBQUFGd0FBQUNBQUJRQWpibUZ0WlFBQUFwZ0FBQURPQUFBQk9CTi9LcnR3YjNOMEFBQURhQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FNbUJpU1FVbHlXRHBUY3puQ2RXZkdQRVFNRHN5THpPYUF3STBMRi8vOE1EQUFyekErVUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lOSUEwRzVCbUJNcHVaN2orL3orUUQ2Yi9lLzNYQnFzQ0FnQ3ZWQW4zQUFBQWVOb1ZqVThLZ2tBY1JuL2YrR2RxMUNUVVVTTXdMWFFaR09naXlQUFV0Z3Q0cCs3UXJoc0VEcTUwMHhWcWVvc0hEejc0Q0hTbkowMDRrME1Vck1DTHNycWdyZVdFM1NZNlFGdnVRVW1PYlBzWGFVQ1A3NGU5V1VDNURwNUJSdmErT0lMYlZWbVZIYXF5YmRvbVE0Zm1WTWVTdlZSL3RjeFE4SG4wUk1LTVlCaldZSW5qanNxekZxRUpLTlhmVEpGYXMvTEJZcTRIdm9nWmZEVzRScnJVbHo4dFdoKzZBQUFBZU5wallHUmdZQURpUHozN2xlUDViYjR5TUxNd2dNRGpDRjFYQlAzL0hmTkVKbUVnbDRPQkNTUUtBQ21wQ2cwQWVOcGpZR1JnWUZiOFl3UWtKeklVTXhRejNXRUFpcUFBWmdCYW93T3dBQUFEa1FBQUFWc0Fjd09SQUxNQUFBQUFBQm9BVkhqYVkyQmtZR0JnWmxCaUFORU1VQklKQUFBRUNnQXBBSGphVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9GUmlZMkZnWW1YcUF0aWdESEdRSFNKRnFqcnl1M3U0SG5yRDZYay83b0NTSHpLZWsvRWE5M055Q2xGL1hQRENXK0twcUVYaWtnK1dUTWp5bVRoek5vbHpTYjRTRjd4elNUd1YvenR4eVNlUGJkZmU3cjMxYXQ4WjY5MjVEZVA2WUgxb09xZFd1b3A2WjUzMXg5NGFkUnFWR1pvd1hGdFY2MHJYYk9sb3VYR254K0pSN01VeGtSMW55UUlqYXc3UkNUU1NPbW10MEZULzhwM2tMbmFPOFpPUnpra1NKVFRJVlpCOWxiYWlqcGVhK2hmemVUQlBBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFZMEFBb0FBQUFBQjhnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoV2gxWjJOdFlYQUFBQUU0QUFBQVBBQUFBRXdCRGdFUFoyeDVaZ0FBQVhRQUFBTlVBQUFFZE5oV2Z2Um9aV0ZrQUFBRXlBQUFBQzhBQUFBMktsYWRoMmhvWldFQUFBVDRBQUFBSUFBQUFDUUh3Z01wYUcxMGVBQUFCUmdBQUFBWUFBQUFHQko0QVZ0c2IyTmhBQUFGTUFBQUFBNEFBQUFPQkF3Q3FtMWhlSEFBQUFWQUFBQUFGd0FBQUNBQUNBQlNibUZ0WlFBQUJWZ0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUdLQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1GbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjByNk11UXhNL3dIOHBraDBraHEvZ09GQWJNM0RNQUFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQ3lBTkJjREIxQ09pY0dQSVkwaGd5SHYvMytnbUMrTS9YL0wvN24vNS95ZkR0WUJCUUJZVkE0VWVOcU4wNytQRzBVVUIvQjliMlpudkQ4OHM3ODNuSCtkdmM2dUV3Zjc3dXhiazdPeHp6bUxRTzZBQzBWT1ZGU1JFSWxDUllWQWdqUkJRQUJCUVFzVkhmOEFJZzBpRWgwRm9xU2lTNGVnczgzc0hRU0pBcUZ0WnVjNzByN1B2TGNhYUVmck5mMElIMmpIbWdhRXM2Z0JlY0Q2SUNIdHd6Q1BvM3prQStPdHpBSVdGMmtVQytnRFYra1U0aW1NL0ZHdTFnbEw4M2lRUjdGZmJBL3lPR0JaeW1oMGp3TDNzb2JVMzUzUExJS08yS3VSVDFiWHpTQ0FPL2Qwd0tBdlNnQlN2MzNMSkFobFBybW92ME9oNUFSK0V6ejVhV2lUbS9DK0tZSVBhdUE1b3lxK3V2dzE1aHlRSmh3b0VGV1p5d0c4RFZ3czd3YWtpbmVXdjRUVXJoSWtoZ29vVlFlY0VwQnVCVEhpREFodHFlT0d2M3lBendxVisxSzlCcHFpYTFmWEsvSXpmcU9OaTNzUWtMVFNERWhCam5laVVGMElaOWxmNFBSdksvajVidDZIVkFVTkdFVUNNZ0hreG4xU3NyakJWai9kWllCaHo1REV1MzJyakNEWXVLdS8xNXlESno1MGJSMzAxeWxaRk44djlCS0VQdW5pMGZJSFVkSnR2TG44N1pTaG0rZFFJUnlwREowNkpsd3Y2bWYyOGhGOEs2eXNZRG9GRXlzRjh0Unh1TzdqYS9panRsODRwUElMNEsyaXhFRVVSNHlyRGs1aFJzNzZwVFJxZjZkb2FaSm1hVDVTblJRb1FlRllCbC9zT2RUWk1PYmJuVDJBZHBnU2tBMHBaYnRKYWoxNVZFZGZYcGVoaUs0a0Z5WUFTYVJ5cHk2bDU5WE4wc1lyUlF5ZnJiNjc1dTRQZ3dPU0p2Vk5iTFBNTWhEb1lmajU3eWRFU1U1ZXJtVHArZlkvRVR5UlBubWZ0a3FnblZxZVgvK0JiK0pEN2JDd3FHTHJ5TmtaS1dUeFRqN0tCM0ZkTlVZOVNqaWNnZHBSMDZpNm9JNVJaZXJCN3NpZlFwcWNYY0FvanpqTVg2aStkUG1ab2ExbUQzMjdiSkpxWStLaGF6S0lMVGVaZHA0Q1VoWlJwT2FsTXprK0ozVi8weWlac2VHNStzY1VaZHR3QUFSZlhEb1ArTlhxWVhNQWVuOVk3azNZdU5Kc3VpMmNQZTBoeGx0eDFLUDlDN2ExMmI1eXNCMXVJeDUwSXV2YTIybEZXdUNYSTF5VXBVbE5XZUtVMk1xNXBaeGZ3dmZhaTVvMkkvbnU4SlJRL0dZOVJacGlWSXlkbXJmL1pTY1NCVW16dDdxMnhhUmZiMWs2TnkwR2dXdGtCd3Nlbit4ZnVrRWUwemZILzZMYnNxQUgzY3VIWGNGcmdXNkUxUURtWDIvMVlpZXNBdXozQWdzUTVienV0L0hpYm5PTTJIdnV2L1hlZ09CazJxeTljUnhJQVk2ci9RbnU1Wk0wZU5wallHUmdZQURpL0E5dnJPUDViYjR5TUxNd2dNRGpDRjFYQlAxZm42V2Y2U0tReThIQUJCSUZBQ3FZQ2ljQWVOcGpZR1JnWUdiNHo4REF3QkxOWVBEL09Fcy9BMUFFQmJBQkFGMWxBL01DeGdBQUJGc0FUQU9lQUVjQ09nQkxBcXdBVFFMVEFEQUFBQUFBQUlRQTZBRk9BY0lDT2dBQWVOcGpZR1JnWUdCakNHUUEwUXhRRWdrQUFBanlBRnNBZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmdBQW9BQUFBQUE5UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFVOejdHTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUNnQUFBQXJLQUNIYVJvWldGa0FBQUNCQUFBQUMwQUFBQTJLRWVkaDJob1pXRUFBQUkwQUFBQUh3QUFBQ1FFandHOGFHMTBlQUFBQWxRQUFBQUtBQUFBQ2dSR0FHUnNiMk5oQUFBQ1lBQUFBQWdBQUFBSUFDd0FWbTFoZUhBQUFBSm9BQUFBRndBQUFDQUFCUUFaYm1GdFpRQUFBb0FBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFEVUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtdk1jNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwVFVZTkJrWnZnUDVETkRwSkhVL0FjS0F3RHZrUTBlZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pFajV6OEFZd3N6QUlNN0F3Q3FpcEthdXgyaXVabVp1eDJqRXo4akhLTTRtSk04b3hoZ3NsbXlvS2NQSUtLTm1tQ2JHeUJQbndjamtFcy9QL0kwcktUNWlsYTNUd3REa1ZCNkJ4RC90bGYvK3BRaXlNQUFCSTRNbDBGeE5pTG1NWW16c2ZJeEtwa0JUMVUzVTlCblZ6TTJNeE1UbEdCazF3Q2FLOHNaNk1RWDdDREV6TW9xQzdXR0FtcGowdDNYaEIxOGhGaWF3UFFBVkpDRk1lTnBqWUdSZ1lBRGlUeFB2Mk1mejIzeGxZR1poQUlISEVicXVDUG8vQTFNRE00akx3Y0FFb2dBaXpBa3ZBQUFBZU5wallHUmdZR2I0ejhEQXdOVEFZTWxneVJqQ0FCUkJBVXdBTzJ3Q1VBQUNnQUFBQVkwQVpBQTVBQUFBQUFBQUFDd0FWbmphWTJCa1lHQmdacEJnQU5FTVVCSUpBQUFERUFBZkFIamFSWXd4YjhJd0VJVy9pQVNKZE9oU2RXQUFEOHhXb2pCM1lXQmlaV0lCYktJTWNaQVRJaUdoanYzZFBZd2xibmo2N3IxM0IrVDhrdkNjaE0rZ3owbkpaSHR4eGdkZmthZXlMU1BuekZreElVbG40aXo0aVp4S2NvaWM4YzBsOGxUOFIrU2NOWCticnIzZUJ1dlZyalBXdTNQcnkySnZmZDkwVHBXNkNQdldPdXVQZ3pYcWRGZG1iUHF4YmxXbEMxMnhvYVBseW8wQmkwZXhFOGNFZHB3bDg1UVU3SVBUMDBqcXBGV2l4WDNuVzhsZDZCekRKeU9kRTNkUnd5aFh2V2d0YlVVVkxqWFZQMk05THc4QUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWE1BQW9BQUFBQUJ2QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVkMHZtTnRZWEFBQUFFNEFBQUFRUUFBQUV3QXBBRFhaMng1WmdBQUFYd0FBQUxjQUFBRGtGSUZIdzFvWldGa0FBQUVXQUFBQUM0QUFBQTJLZlNkbm1ob1pXRUFBQVNJQUFBQUhnQUFBQ1FIVkFLWmFHMTBlQUFBQktnQUFBQWNBQUFBSEJITkFWUnNiMk5oQUFBRXhBQUFBQkFBQUFBUUFob0M4RzFoZUhBQUFBVFVBQUFBR0FBQUFDQUFDd0JKYm1GdFpRQUFCT3dBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGd0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtNm1hY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcnFNUGd4TS93SDhwa2gwa2hxL2dPRkFkWjFEUFVBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0N5QU5CY0RCMUNPaVVHSFFZL0JpY0h2LzMrZ0dJanR5T0Q3Ly8vL3EvK3YvRC8wZndkWUJ4UUFBRG9TRFhJQUFBQjQyajJTeld2VVFCakc1NWxKSnB2ZHpjenVaamRMdTE5dGQ3dlJmbGh0MTZ3dHVvTGZXQ3pWZ3JaUUVBcGFCZlVnYlFVdjlpQitZRVZRRUR4NThlWlY4Rkk4Q0lySG9tY0Y5U1QrRGVuNkpxV0daREo1NXlVOHYrZDVHZGg4ZDRwdHNadXN3RmhiYWlqNHpYWUg3WllsNi92UUN0cmVsbEdYRFE5Qzl3N0JjUE05bFVyUFVWeHFKUThnelZYdi9HVE8wT2dicWNGZ2RJRXQwUE9KM1dBSitwL0NRTE1Wakh1ZlVCdXQwUjE0MFZxalBzNGEzUzcveWIrek1UWk9uUWphNDE3UnpYc1RnU2ZIWVBsTnZ4VVV2YUE5aG41TDVyMWlVRlNnZWxTZUlIa1Q0ajJ1eUx3ajBmRkdDMGliSytzSkUwN0tiUW5iMnU3T09HWFhFWERNNWZrMDB2WkE1OVhmL2pWK01RTmJoK3VlRmhVTFFvQW50QVdraTFkUDNzODNNdUJheWFpYzFCTDFMN2dROFFnMjNBMkY1SnVzeW9iWUlWTHF0dXErSkczOVZSUVVyQ3FLNUpxMCttV3MxNDNFQlUyLzNwU1cyTjBMYXBoNDg3VGtWN1RHL09LU1dKK2JuZ00vblRtM3V2MmlyTlJVOWZYTHl5c2MrNDdmcjdubXJZM0ZOYzczbi9sNHlnRFVMSi9NY2xHMndNOVBuVjNXeVpuSjZXT3FZMFFFY0hGUzNEN1ZPTUdoZThLMzRzN000S3pZL3AyVHlTaUhrVzdYR09VZjJHbjZJQUZWQkxHQi80MTFTWFR6WUFxeUlMMGF2RUo4R2tHUWFEZUlFU21Mb29zT29vMzBtMUs4ZTBTU0JpZkoxL1Y3U1JNWlo2cHFQdDlla2xtOThNUkFhWmppVU1iMVpjY3hqb3pJQnpoZXplZ05ONDFackNaVTdtRUpPdGV1OEp2aGo1emxTQ1BPZ0ZNaWtraXFmRHE4b3d4UjRIZkRyOHAyZXdCdXF6aWxFcTFEZmJ5Y0VhSkNyVlkyM09Sbm9xVElGQlRpbWR0REdUMmdqSTVFckFwMTZRdGZSR0RGbldrYThBa2k0bXFPWVJlc0ZHY2o2YVNHTmpsQWc2OGc1RE5oMnFsRTEzNW9vbmZZalhIU1FNb2tvTWRHcFZGUm1jZVpsUHkxQ3BTSHRhREJ1M2JONWh4cDQvQW9udzAvcTRUdytHSXUvSzNzYkMvbjVZZ2dwWGNJQmkyK0k5cHl3ai80bHNxV1NPd09veUdqOTE3MkQzRXVpQ0o0Mm1OZ1pHQmdBR0pMU1huT2VINmJyd3pNTEF3ZzhEaEMxeFZCLzdkaTBXVzZDK1J5TURDQlJBSExsd2ZRQUFCNDJtTmdaR0JnWnZqUEFDUWZNcWo4MzhDaXl3QVVRUUhzQUdBbEEvUUFBQUoyQUFBQkhBQllBUndBV1FNQUFDUURDQUFyQStFQUxBTTJBQ2dBQUFBQUFDZ0FQQUNRQU93QllnSEllTnBqWUdSZ1lHQm44R0JnWmdBQlJnWTBBQUFJV2dCVmVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02Ljc5NDcyNSwtNjAuNDQ3NTAxKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMyLjg2MDUsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYuNzk0NzI1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYuNzk0NzI1JyB5PSctNjAuNDQ3NTAxJz5NPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzMuOTU2NjE3JyB5PSctNjAuNDQ3NTAxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzcuODMwOTkxJyB5PSctNjAuNDQ3NTAxJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzE1LjMwMjk5JyB5PSctNTguOTUzMTInPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nMTkuNzcyMzYnIHk9Jy02MC40NDc1MDEnPiw8dHNwYW4geD0nMjQuMjAwMTY4Jz4uPC90c3Bhbj48dHNwYW4geD0nMjguNjI3OTc2Jz4uPC90c3Bhbj48dHNwYW4geD0nMzMuMDU1Nzg0Jz4uPC90c3Bhbj48dHNwYW4geD0nMzcuNDgzNTkyJz4sPC90c3Bhbj48dHNwYW4geD0nNDEuOTExNCc+QTwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzQ5LjM4MzM5OScgeT0nLTU4Ljk1MzEyJz5uPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzU0LjgwNjM5MScgeT0nLTYwLjQ0NzUwMSc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMzIuMDI3MTYsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Ljc5NDcyNSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Ljc5NDcyNScgeT0nLTYwLjQ0NzUwMSc+TjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScyLjI5NjE2NScgeT0nLTYwLjQ0NzUwMSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSc2LjE3MDUzOCcgeT0nLTYwLjQ0NzUwMSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PScxMy42NDI1MzcnIHk9Jy01OC45NTMxMic+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScxOC4xMTE5MDcnIHk9Jy02MC40NDc1MDEnPiw8dHNwYW4geD0nMjIuNTM5NzE1Jz4uPC90c3Bhbj48dHNwYW4geD0nMjYuOTY3NTIzJz4uPC90c3Bhbj48dHNwYW4geD0nMzEuMzk1MzMxJz4uPC90c3Bhbj48dHNwYW4geD0nMzUuODIzMTM5Jz4sPC90c3Bhbj48dHNwYW4geD0nNDAuMjUwOTQ3Jz5BPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nNDcuNzIyOTQ2JyB5PSctNTguOTUzMTInPm48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nNTMuMTQ1OTM5JyB5PSctNjAuNDQ3NTAxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTguOTA5NzNWLTQ3LjQ5NTc3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00Ny43NDU3NyknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYyLjQzNTkxLC0zMC4yMDI3NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYuNzk0NzI1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYuNzk0NzI1JyB5PSctNjAuNDQ3NTAxJz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yLjEzMDQ2NycgeT0nLTU5LjQ0NTY4OCc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSczLjAzMDgxNCcgeT0nLTU3Ljk1MTI5Mic+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSc5LjIzMTM3NScgeT0nLTYwLjQ0NzUwMSc+w5c8dHNwYW4geD0nMTcuMjcyMjM2Jz7CtzwvdHNwYW4+PHRzcGFuIHg9JzIwLjk5OTAxMic+wrc8L3RzcGFuPjx0c3BhbiB4PScyNC43MjU3ODknPsK3PC90c3Bhbj48dHNwYW4geD0nMjguOTA2MDY5Jz7DlzwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzM2Ljk0NjkyOScgeT0nLTYwLjQ0NzUwMSc+aDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc0MS42MTExODcnIHk9Jy01OS40NDU2ODgnPkE8dHNwYW4geT0nLTU4LjQ0OTQzOSc+bjwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDc1LjkxOTA0LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Ljc5NDcyNSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02Ljc5NDcyNScgeT0nLTYwLjQ0NzUwMSc+TTx0c3BhbiB4PSczLjk1NjYxNyc+QjwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDc2Ljc1MjM4LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNi43OTQ3MjUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNi43OTQ3MjUnIHk9Jy02MC40NDc1MDEnPk48dHNwYW4geD0nMi4yOTYxNjUnPkI8L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMzcuNDE2MDUgMEg3MC44NjM1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDcxLjExMzUsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ny44NTk1Myw0LjE3MjkxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNi43OTQ3MjUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNi43OTQ3MjUnIHk9Jy02MC40NDc1MDEnPk08dHNwYW4geD0nMS41NTAzODcnPmY8L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNODUuMzU4MjYtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw4NS4zNTgyNiwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4LjYyMjE1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYuNzk0NzI1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYuNzk0NzI1JyB5PSctNjAuNDQ3NTAxJz5oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yLjEzMDQ2NycgeT0nLTU5LjQ0NTY4OCc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMzYuNTgyNy01Ni45MDU1SDcxLjY5Njg0JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDcxLjk0Njg0LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC41MDUzNywtNjQuNTc4NDEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02Ljc5NDcyNSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02Ljc5NDcyNScgeT0nLTYwLjQ0NzUwMSc+Tjx0c3BhbiB4PScuMjYzNTQxJz5mPC90c3Bhbj48L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \DiagramSquare {
              width = 3cm,
              nw = {M(A_{1},\ldots ,A_{n})},
              ne = MB,
              sw = {N(A_{1},\ldots ,A_{n})},
              se = NB,
              north = Mf,
              south = Nf,
              west = {h_{A_{1}} \times  \cdots  \times  h_{A_{n}}},
              east = {h_{B}},
            }
          ]]></fr:resource-source></fr:resource></fr:figure></fr:li>
        <fr:li>For each relation symbol <fr:tex
display="inline"><![CDATA[R \rightarrowtail  A_{1},\ldots ,A_{n}]]></fr:tex>, there is a morphism <fr:tex
display="inline"><![CDATA[g\colon MR\to NR]]></fr:tex> such that the following diagram commutes:
          
    
      
      <fr:figure><fr:resource
hash="62110a92adaa00deaa43a4497b96dec2"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzI0NS41OTU3NjZwdCcgaGVpZ2h0PScxMTAuOTIxNDg0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTYzLjczMDUxMSA3My45NDc2NTYnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1ZQUFvQUFBQUFBNFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVeDFHMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNFWjJ4NVpnQUFBV1FBQUFCa0FBQUFaREZ1QXJKb1pXRmtBQUFCeUFBQUFDd0FBQUEyS1JpZVFHaG9aV0VBQUFIMEFBQUFIZ0FBQUNRRnl3TFdhRzEwZUFBQUFoUUFBQUFJQUFBQUNBWUtBSkpzYjJOaEFBQUNIQUFBQUFZQUFBQUdBRElBQUcxaGVIQUFBQUlrQUFBQUZ3QUFBQ0FBQkFBZ2JtRnRaUUFBQWp3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRENBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVptV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9hTWhneU0vd0g4cGtoMGtocS9nT0ZBYU4zREZnQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpRy8vOUR5UDhYd0h3R0FGRkhCbzBBQUFBQUFRQ1NBQUFDTndLckFCNEFBQUVSQmhZN0FSVW1KeU1HQnpVek1qWW5FUTRCSnlNMU14WS9BVFkzTmhZQm1BUWlUak1zT3RFNkxETk9JUU11VkJNU0VoSStCejg1R0E0Q2kvM05GeFF0QXdFQkF5MFVGd0lBRWd3QkxRSUtBZ291QVFrQWVOcGpZR1JnWUFEaTcyc2RUT1A1YmI0eU1MTXdnTURqQ0YwZlpKbzVpR2sxa09KZ1lBTHhBQUozQ0RaNDJtTmdaR0JnWnZqUEFDU0RHQ1l4TkRLWk13QkZVQUFUQUVMY0FxZ0FBQU5TQUFBQ3VBQ1NBQUFBQUFBeUFBQjQybU5nWkdCZ1lHS1Fad0RSREZBU0NRQUFBNlFBSlFCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRXFmbTV1RGs2dkQyNndKMHFHcHBMWG9JdjUwYjBQd0JnN2ZQZWZjQUJrdkVvWkptQWNkSnBVM2p6em1oMFhraWZpcnlCbS9yQm1ScEROeFZ1d2lwMHo1anp4bVNSbDVJdjRqY3NZZjczMVQzKzZkOWVyWUdPdmRwZmJiay9WdDFUaTEwZm13SHF5ei90eFpvOHFuTW4zVjl0ZGFGVHJYQlhzYWFtN2M2YkI0RkVkeFRHREhSVExQbGxQWVd5ckpuSFEyYVBKdmVwRFVoY1k1L0dLa1VmSVVOZlJ5MDRwZXBhc293cDJtK0FCVk1pNURBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUllBQW9BQUFBQUJQZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MS9XTnRZWEFBQUFFNEFBQUFNUUFBQUR3QXJRQnhaMng1WmdBQUFXd0FBQUdUQUFBQnlMUGFTc0JvWldGa0FBQURBQUFBQUM4QUFBQTJLWTZlWjJob1pXRUFBQU13QUFBQUh3QUFBQ1FISlFPRWFHMTBlQUFBQTFBQUFBQU1BQUFBREFyK0FNVnNiMk5oQUFBRFhBQUFBQWdBQUFBSUFHWUE1RzFoZUhBQUFBTmtBQUFBR0FBQUFDQUFCZ0JVYm1GdFpRQUFBM3dBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFFVEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtWHNVNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaTWhqWnZnUDVETkRwSkhVL0FjS0F3RG9RUTFLZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pMay9mOFA1SVBwL3dmK1R3R3JBZ0lBbFNVSkdBQUFBSGphSFk4L2I5TlFGTVhmdWUveG52ODgyL0dmMkdrVFF0MFVXNmxvbktURlZoQnlRbFFGSWhCRGh3NFZDeElMQXd0SXpJeUlrWS9CekNkZ0tlSTdzREh3QlJocHNMbm5MdWVlNFo0ZkkvWjZ0K1BYOUpNdDJFUEdFQTV4V3NaSnJBcDR5UElhU1Z4V0JWSWxQWkpxaUNxSkV4ZHRlSmpsV1ZuVnFGQmpIaXVlMHUvMzZFM3RFTmhmcmJmbkFSQnE0NEZ3L0pzZm9lQlB0UVJsaHEwQVg3NDdtd2lib056WmVvalBxbk9vcjM1aFJOLytmdklkU04wbkRuQjB1aWFnL00wVlNMeUpiRE93UUZ3M1J3R3VMTm9qakNhMHNiVitlL09WTlFQMll2ZUhIK09hWFRDMjVPWDlNc3ZkNWdsR2VkTzFLbHZGU2RONEhuZWxoM2E3c3ZVMVRodXNTTWxHRStUL3FjcThkZExqYmt0YWZVOGRTOExmUDhnMG1kb3hHZ29ySEM0T0xsWC81V2I3bkxvaWNTMUJhYmIwaE5IbXQzVm5mRjRzaWN6d2hHajdiTjd6N3hwcWJKcURmZ3o1NnVQMEpIYjhJOURqaVdVU1diZUt3YUFRZEZ3ZnJlalI0dDdLcnRPQjNSbHhyQXV2eWUxb0ZnV0Z3SFM4RnhRZmlpY2tabkh2TEVxKzNBbTlJQml5Znc2Nk9tMEFlTnBqWUdSZ1lBRGlTemR6bmVQNWJiNHlNTE13Z01EakNGMGZCUDMvSy9OeHBydEFMZ2NERTBnVUFEUUZDeE1BZU5wallHUmdZR2I0ejhEQXdLTEtFTU1Relh5Y0FTaUNBcGdCUVY0Q3NnQURWQUFBQkNVQWFRT0ZBRndBQUFBQUFHWUE1SGphWTJCa1lHQmdaZ2htWUdJQUFVWUdOQUFBQ09vQVczamFUWXc5YjhJd0ZFVlAxQVNwWVdCQkhSaGFENTJ0b01EYWhZR0psYWtMWUJkbHNJMmNFQW1wNnRqZjNZZngwRGRjbmZ0aEF6VS9GTnl2WUpiMGZpV1Z1QWRYVEpsbm5vaDd5MXl6NEowbml2SlprbGMrTXBmU2ZHYXVlT0VyODBUeTc4dzFLMzQzd1YydWc0MXFGNHlOL3VSY3Q5N2IySGZCcTZWdWt0OWFiK05oc0VZZGI4cU1YVCtlbldwMW8xczJCQndYcmd4WUlvcWRKQ2F4NXlTZG8yUE5QaVc5Y0pCY3NVVFQvT3UzMHZ1ME9hU2ZqR3lPM0VRTm95eDYwYk5zRlcxNnFXbi9BTWdSTCs4QUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5nQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTno3R050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDZ0FBQUFyS0FDSGFSb1pXRmtBQUFDQkFBQUFDMEFBQUEyS0VlZGxXaG9aV0VBQUFJMEFBQUFId0FBQUNRRWp3RzhhRzEwZUFBQUFsUUFBQUFLQUFBQUNnUkdBR1JzYjJOaEFBQUNZQUFBQUFnQUFBQUlBQ3dBVm0xaGVIQUFBQUpvQUFBQUZ3QUFBQ0FBQlFBWmJtRnRaUUFBQW9BQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRFVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXZNYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWU5Ca1p2Z1A1RE5EcEpIVS9BY0tBd0R2a1EwZWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaRWo1ejhBWXdzekFJTTdBd0NxaXBLYXV4Mml1Wm1adXgyakV6OGpIS000bUpNOG94aGdzbG15b0tjUElLS05tbUNiR3lCUG53Y2prRXMvUC9JMHJLVDVpbGEzVHd0RGtWQjZCeEQvdGxmLytwUWl5TUFBQkk0TWwwRnhOaUxtTVltenNmSXhLcGtCVDFVM1U5Qm5Wek0yTXhNVGxHQmsxd0NhSzhzWjZNUVg3Q0RFek1vcUM3V0dBbXBqMHQzWGhCMThoRmlhd1BRQVZKQ0ZNZU5wallHUmdZQURpVHhQdktNZnoyM3hsWUdaaEFJSEhFYm8rQ1BvL0ExTURNNGpMd2NBRW9nQWZXZ2toQUFBQWVOcGpZR1JnWUdiNHo4REF3TlRBWU1sZ3lSakNBQlJCQVV3QU8yd0NVQUFDZ0FBQUFZMEFaQUE1QUFBQUFBQUFBQ3dBVm5qYVkyQmtZR0JnWnBCZ0FORU1VQklKQUFBREVBQWZBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNTUFBb0FBQUFBQTNnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVXgwbzJOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDRVoyeDVaZ0FBQVdRQUFBQllBQUFBV09hK2RCVm9aV0ZrQUFBQnZBQUFBQ3dBQUFBMktKbWVQbWhvWldFQUFBSG9BQUFBSUFBQUFDUUZWZ0k1YUcxMGVBQUFBZ2dBQUFBSUFBQUFDQVVhQUhCc2IyTmhBQUFDRUFBQUFBWUFBQUFHQUN3QUFHMWhlSEFBQUFJWUFBQUFGd0FBQUNBQUJBQWJibUZ0WlFBQUFqQUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQUMvQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm02bVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvYU1oZ3lNL3dIOHBraDBraHEvZ09GQWRTQkROOEFlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aUcvLzlEeVA4WHdId0dBRkZIQm8wQUFBQUFBUUJ3QUFBQjVBS3BBQmtBQUFFUkJoWTdBUlV2QVE4Qk5UTXlOaWNSRGdFbk5SWTJOellXQVZjRElFa25aMUJ3UmlkSklBTXNWQlFoZERNVkN3S0wvY2thRlNVREFRSUNKUlVhQWdvVUNRRWtBaFl1QVFvQWVOcGpZR1JnWUFEaW5qc0p6dkg4Tmw4Wm1Ga1lRT0J4aEs0UE1zMTBtV2tsa09KZ1lBTHhBQVhEQ0taNDJtTmdaR0JnWnZqUHdNREFkSm1oZ0NHWjhRa0RVQVFGTUFFQVZwb0RsQUxUQUFBQ1J3QndBQUFBQUFBc0FBQjQybU5nWkdCZ1lHS1FZZ0RSREZBU0NRQUFBeWNBSUFCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRW9mdUxnNU9MazZ2TTJhSUIyYVNscUxMdUpQOXpZRWIrRHczWFBPRFpEeEltR1loSG5RWVZKNTg4aGpmbGhFbm9pL2lwenh5NW9SU1RvVFo4VXVjc3FVLzhoamxwU1JKK0kvSW1mODhkNDM5ZTNlV2ErT2piSGVYV3EvUFZuZlZvMVRHNTBQNjhFNjY4K2ROYXA4S3ROWGJYK3RWYUZ6WGJDbm9lYkduUTZMUjNFVXh3UjJYQ1R6YkRtRnZhV1N6RWxuZ3liL3BnZEpYV2ljd3k5R0dpVlBVVU12TjYzb1ZicUtJdHhwaWc5WXJDNUxBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjBBQW9BQUFBQUE5Z0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJnaU1KeTQyTnRZWEFBQUFGQUFBQUFNUUFBQUR3QkNRRDBaMng1WmdBQUFYUUFBQUNsQUFBQXFQN1JyVlJvWldGa0FBQUNIQUFBQUM4QUFBQTJLVmlkbG1ob1pXRUFBQUpNQUFBQUhnQUFBQ1FHY2dBNmFHMTBlQUFBQW13QUFBQU1BQUFBREFoOUFTWnNiMk5oQUFBQ2VBQUFBQWdBQUFBSUFCb0FWRzFoZUhBQUFBS0FBQUFBRndBQUFDQUFCUUFqYm1GdFpRQUFBcGdBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFEYUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNJNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTW1CaVNRVWx5V0RwVGN6bkNkV2ZHUEVRTURzeUx6T2FBd0kwTEYvLzhNREFBcnpBK1VBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZTklBMEc1Qm1CTXB1WjdqKy96K1FENmIvZS8zWEJxc0NBZ0N2VkFuM0FBQUFlTm9WalU4S2drQWNSbi9mK0dkcTFDVFVVU013TFhRWkdPZ2l5UFBVdGd0NHArN1FyaHNFRHE1MDB4VnFlb3NIRHo3NENIU25KMDA0azBNVXJNQ0xzcnFncmVXRTNTWTZRRnZ1UVVtT2JQc1hhVUNQNzRlOVdVQzVEcDVCUnZhK09JTGJWVm1WSGFxeWJkb21RNGZtVk1lU3ZWUi90Y3hROEhuMFJNS01ZQmpXWUluampzcXpGcUVKS05YZlRKRmFzL0xCWXE0SHZvZ1pmRFc0UnJyVWx6OHRXaCs2QUFBQWVOcGpZR1JnWUFEaVB6MzcyZVA1YmI0eU1MTXdnTURqQ0YwZkJQMy9IZk5FSm1FZ2w0T0JDU1FLQUNZM0NmOEFlTnBqWUdSZ1lGYjhZd1FrSnpJVU14UXozV0VBaXFBQVpnQmFvd093QUFBRGtRQUFBVnNBY3dPUkFMTUFBQUFBQUJvQVZIamFZMkJrWUdCZ1psQmlBTkVNVUJJSkFBQUVDZ0FwQUhqYVRZdzliOEl3RUlhZmlBU0pkT2hTZGVnQUhwaXRvRlJpWTJGZ1ltWHFBdGlnREhHUUhTSkZxanJ5dTN1NEhuckQ2WGsvN29DU0h6S2VrL0VhOTNOeUNsRi9YUERDVytLcHFFWGlrZytXVE1qeW1UaHpOb2x6U2I0U0Y3eHpTVHdWL3p0eHlTZVBiZGZlN3IzMWF0OFo2OTI1RGVQNllIMW9PcWRXdW9wNlo1MzF4OTRhZFJxVkdab3dYRnRWNjByWGJPbG91WEdueCtKUjdNVXhrUjFueVFJamF3N1JDVFNTT21tdDBGVC84cDNrTG5hTzhaT1J6a2tTSlRUSVZaQjlsYmFpanBlYStoZnplVEJQQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVGdBQW9BQUFBQUJld0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFlKMDhtTnRZWEFBQUFFNEFBQUFNZ0FBQUR3QWh3Qy9aMng1WmdBQUFXd0FBQUlSQUFBQ3RQYjAramhvWldGa0FBQURnQUFBQUM4QUFBQTJLSTJkaVdob1pXRUFBQU93QUFBQUlBQUFBQ1FGMEFIdGFHMTBlQUFBQTlBQUFBQVFBQUFBRUFwL0FLbHNiMk5oQUFBRDRBQUFBQW9BQUFBS0FjZ0E0bTFoZUhBQUFBUHNBQUFBR0FBQUFDQUFCd0JSYm1GdFpRQUFCQVFBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFFMUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtbXM4NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUk1aOGhqWnZnUDVETkRwSkhVL0FjS0F3RG9mZzFrZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLWmpEay9mOFA1S2VENlArei9rOEZxd0lDQUpuaENVQUFBSGphamRFOWI5TlFGQWJnZTg1MWZCdC8zVGkyNzRYV05YRSs3RUNEa3phSlRaWGcxRTJFVkNyYWlvR3FDTEd4SXlFa0JJTGZnUGdKVEd6TTdJaitJeVNXRkxzREF3TkM3M3FHOXprdlFUSzR1b3M5K0U0U3NpUUVxQVZNamVJY3hudEN1aXFUWWl6U0xJY0ZxQ3lCT00ycUJDQnp5TW9EdW9BMGp1SklaU3F6UU1pOTZoVERsL1ZYYjRiUEZlZ0lXNERWOU8zUW5YZDh3V1IyVkZ3Z0xiaDlkTkdmbW5TemFYcndhVWpCOVNhYnk1YlhzQ0dLZzBQZllQQjJYUXlmVXZRRzI2SGo2SUZXUTlEOW02UFdzN0VDNTJjdlRoeStvdEFWRFFFTmUvM3JHOWQ3SFFYNjA2ZzRPTTJnMStJbUtUSGswZFZQZkllWDVMaVNsWlVEWkNxSHFxdW5WbVhUc1F4S2I1bDJGRTlLVE1XTDR1b0hYTEdnazhBMGMzS0lPdTNybDJTcFlGQ2MrSS8zSDB3TVFCY2R3OVNvZjJ2ZVJGdFRRZXAySisvZkEycGFRaUNLL3Z6c0JxODVyZnFHSnV0TnUvWlJRZDZ0TndBc3RocjBBTCtzTDhNeDFJWVRNNW1yczYwd3ROdTR1TjlFbENNcEVtVjQyOUJiM2NQbHJyZUx1T3dML2VHSGFJdnI0SmdDVnliWEZJMXZNSVVhcFhOVU9qL0REM0pLeUlLbTA4azF3WUloSkNVcFIxSE5sUXI1WDNiSzBhSlIvSDdIMEZYdUJHMjl4alJkQmRldXg4c1ZrK2NIZ3lmMEQ3MDErNHR1OElydTd1d2Y3MWhzMjYzVlBkK0Y0dXNva1EzUEJ6aElYQjBRZVJFNFhid3pEV2VJeWRHLzljMHh4WGtlYnI4K2M3bFZyazErQXl1L1dOc0FBQUI0Mm1OZ1pHQmdBR0wvQnQ3OGVINmJyd3pNTEF3ZzhEaEMxd2RCLzlkbE9zWjBITWpsWUdBQ2lRSUE5dVlKSXdCNDJtTmdaR0JnWnZqUHdNREFkSmxCaDBHVWFSRURVQVFGc0FBQVJVZ0N3d0xHQUFBQ09nQXNBcXdBVFFMVEFEQUFBQUFBQUc0QTRnRmFBQUI0Mm1OZ1pHQmdZR0VJWUdCaUFBRkdCalFBQUFpNkFGbDQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFZSUFBb0FBQUFBQjF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVWQwd21OdFlYQUFBQUU0QUFBQVFnQUFBRlFBbXdGQloyeDVaZ0FBQVh3QUFBTVZBQUFEOURtcFVQbG9aV0ZrQUFBRWxBQUFBQzhBQUFBMktmU2RyR2hvWldFQUFBVEVBQUFBSGdBQUFDUUhWQUtaYUcxMGVBQUFCT1FBQUFBY0FBQUFIQkhPQVZOc2IyTmhBQUFGQUFBQUFCQUFBQUFRQWlRRFBHMWhlSEFBQUFVUUFBQUFHQUFBQUNBQUNnQmRibUZ0WlFBQUJTZ0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUYvQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm02bWFjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBycU1BUXhNL3dIOHBraDBraHEvZ09GQWRicERQa0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQnlBTkE4REIxQ09oVUdIUVkvQmtjR1BJZWovZjZBb2hPY0w0djIvK3YvSy8wUC90Ly9mQXRZSEJ3Q3VJZy9UQUFCNDJsV1N6NHZjWkJ6Rzg3enZtemVUeWM5SlpoSm5aekt6dTdPYnRMTTdYZHpKSnV4cXA4aXdWcEJLRWJiZG9pZEJ0NEk5NlNyc3hWV2t0YWdVdlBsL0NGNkt0NHJIb25oVVVBOGluZ1N2bWZoTnhnb055WnYzTjgvbit6d0tsT1B5UUhtczNGRTZpcEpMQnphU09KOGhUelU1dW9RMHk0UEhZaVEzQW5CblpRemh0N3RSMUwyQ20ybnpXWmpNWGpuZTk0U0QxZTBoaEVJUGxGdjBQVkxlVVJwMG40MzFPTTEyZzBjWVRvYjBaa0hWRG1rZlV6YktrdjNLZmxaMmxGM2FpU3pmRFVLL0hVeXpRTzVBUytJa3pjSWd5M2V3cHNsMkVHYWhEWnF2cHFja2I4cS93WnV5YlVuTWdra0hwdnJlZVVPRlpmZ3AxN1ZGK1lyVjl5ME9TejA1Tm1IcTY3T3YvbHA3bjkxd29UdkZlZUR3U0FQbllBMUhBOHp3cmNOUDJoc3VtR1BMYXJycFNJeSt4NnRMbnUyeUZCUDJyWEtWQnR6QkFGa3Q1SCtCUHFRVzd4bVFIUmtNRVhUcVZVbHJwTkxQa3FwSFRLR1BHYXFPVEdMSnYvNVVBSnY3cE8vOHc2WUsxem9ZcUY4dTNwQXQ1OVpuQXIwdHdyTEYyeWVXSlM1dnk3dVlEMXpuYzkvRWRadzJiTzllRDQ2WFIreE84WXVuV1ZMVUxJeklKT0FQMk12RkI3YmdIWFpXL0dEcmZoZGd1bDNUOXFnZHI3Syt5M2xFVzdWVzhaQzlWQkgzcVFpZG12VkNXZkM3N0tGeXVXSzFNWklKVDNnRkZpNWRXVThJb3VLS2QvQUVySWM4aXhOSkswUGtWQUVLa0EwdUgzQlZOeHFsZmsvRnlwWmY0NWlBb1JMUWZSRnRSTFo3M3pYa2I2ZEFmOHZoWk9EdDJ6cGpNTVh6RTNhOStNNXU4SUM5N2hXLzIzcHJoYkYrUldBNFM0Sk5qUzFGYTFieEozNDBXajBTdTJRVXN2cGZyUEkxTHYvZ0tyRzR5bXNWVFJXYUdmWkllRnlGM0I4Z2JEdTFhVk15TWN2RG9CNXI1RTlsN1JXeWE0KzRSbHdqeDl0UFJkSlBSN1d0YTNRSEhjRDUvTjNESTMvUUUybG5mMi9tTkI5MEQ3blFCTHhuL0l5aUtWVUVkblJnam4zdm9sQU5xYlBKNGRtY2svOVc0K09QS0xXMlRmWi8wWStwSmhpZG5ESHg0bFYydXZnSG04SHFVWC91YVNZRDh4WS9hZmx6WWZkZ3ZSdXRJY2xOenBodWpiMExLbXVxUnZDQzI3M2tKMVkwWTR1L3ZTZVorQy9mbEluOUZxc0xkalMvbGs3L0JRTzdqTWNBQUFCNDJtTmdaR0JnQU9MTWM5dUU0L2x0dmpJd3N6Q0F3T01JWFI4RS9kK0tSWmZwTHBETHdjQUVFZ1VBRVBzSlpBQjQybU5nWkdCZ1p2alBBQ1FmTXFqODM4Q2l5d0FVUVFIc0FHQWxBL1FBQUFKMkFBQUJIQUJZQVJ3QVdRTUFBQ1FENFFBc0F6WUFLQU1KQUNvQUFBQUFBQ2dBUEFDUUFRWUJiQUg2ZU5wallHUmdZR0JuaUdGZ1lnQUJSZ1kwQUFBS053Qm9lTnBOanJGcXd6QVFoajlUeDFDbjBLa2RPaFJOR1lXTit3Q0JESm15Wml3a2tRZ09TQXF5WThnUytnQjk2RjRVRFQzQjhkMTN2NFNBbWhzRjl5cDRUZjFlSlpWTUQ1NHg1eTF6SlVkbHJ2bGd3Uk5GK1N6bWsyWG1raGUrTTg5NDU1UzVFditUdWVhTDMxVnc1OHRvbzlvRVk2TS9PTmUzemRiR29ROWV0YnA1aUxYMU51NUdhOVQrcXN6VUQ5UFJxVTQzdW1ORndISG13b2dseXM4MllreGl6MEYyanA2V2htMXlnMHhCTmtxY0Z2cy9zWmFFVDZsZGVzMUlhczlWdW1HU3pDRDlLR2xGbCs1cXVqL2Y5REM3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTguNTE0MTM4LC02My4zNzI2Mjgpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOS4yMzA5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01OC41MTQxMzgsLTYzLjM3MjYyOClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNTguNTE0MTM4JyB5PSctNjMuMzcyNjI4Jz5NPHRzcGFuIHg9Jy00Ny43NjI3OTUnPlI8L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtOC4zOTc1NSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU4LjUxNDEzOCwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01OC41MTQxMzgnIHk9Jy02My4zNzI2MjgnPk48dHNwYW4geD0nLTQ5LjQyMzI0OCc+UjwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTcuNDE2MzIsLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTguNTE0MTM4LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU4LjUxNDEzOCcgeT0nLTYzLjM3MjYyOCc+ZzwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi40OTc3NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTguNTE0MTM4LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTU4LjUxNDEzOCcgeT0nLTYzLjM3MjYyOCc+TTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDcuNzYyNzk1JyB5PSctNjMuMzcyNjI4Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00My44ODg0MjInIHk9Jy02My4zNzI2MjgnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTM2LjQxNjQyMycgeT0nLTYxLjg3ODI0Nyc+MTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMzEuOTQ3MDUzJyB5PSctNjMuMzcyNjI4Jz4sPHRzcGFuIHg9Jy0yNy41MTkyNDUnPi48L3RzcGFuPjx0c3BhbiB4PSctMjMuMDkxNDM3Jz4uPC90c3Bhbj48dHNwYW4geD0nLTE4LjY2MzYyOSc+LjwvdHNwYW4+PHRzcGFuIHg9Jy0xNC4yMzU4MjEnPiw8L3RzcGFuPjx0c3BhbiB4PSctOS44MDgwMTMnPkE8L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMi4zMzYwMTQnIHk9Jy02MS44NzgyNDcnPm48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMy4wODY5NzgnIHk9Jy02My4zNzI2MjgnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTMuMzMxMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU4LjUxNDEzOCwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01OC41MTQxMzgnIHk9Jy02My4zNzI2MjgnPk48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTQ5LjQyMzI0OCcgeT0nLTYzLjM3MjYyOCc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDUuNTQ4ODc0JyB5PSctNjMuMzcyNjI4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0zOC4wNzY4NzUnIHk9Jy02MS44NzgyNDcnPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTMzLjYwNzUwNicgeT0nLTYzLjM3MjYyOCc+LDx0c3BhbiB4PSctMjkuMTc5Njk4Jz4uPC90c3Bhbj48dHNwYW4geD0nLTI0Ljc1MTg5Jz4uPC90c3Bhbj48dHNwYW4geD0nLTIwLjMyNDA4Mic+LjwvdHNwYW4+PHRzcGFuIHg9Jy0xNS44OTYyNzQnPiw8L3RzcGFuPjx0c3BhbiB4PSctMTEuNDY4NDY2Jz5BPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTMuOTk2NDY3JyB5PSctNjEuODc4MjQ3Jz5uPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9JzEuNDI2NTI2JyB5PSctNjMuMzcyNjI4Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xNS45ODY0MyAwSDQ3LjQ0MjIxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0xLjAsMC4wLDAuMCwtMS4wLDE2LjIzNjQzLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuNjkyMjEsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzMC44NjQzMiwyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTguNTE0MTM4LC02My4zNzI2Mjgpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNODUuMzU4MjYtOC45MDk3M1YtNDcuNDk1NzcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw4NS4zNTgyNiwtNDcuNzQ1NzcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg4LjYyMjE1LC0zMC4yMDI3NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU4LjUxNDEzOCwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01OC41MTQxMzgnIHk9Jy02My4zNzI2MjgnPmg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUzLjg0OTg4JyB5PSctNjIuMzcwODE1Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy00OC42ODg1OTknIHk9Jy02MC44NzY0MTknPjE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTQyLjQ4ODAzNycgeT0nLTYzLjM3MjYyOCc+w5c8dHNwYW4geD0nLTM0LjQ0NzE3Nyc+wrc8L3RzcGFuPjx0c3BhbiB4PSctMzAuNzIwNCc+wrc8L3RzcGFuPjx0c3BhbiB4PSctMjYuOTkzNjIzJz7CtzwvdHNwYW4+PHRzcGFuIHg9Jy0yMi44MTMzNDQnPsOXPC90c3Bhbj48L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTE0Ljc3MjQ4NCcgeT0nLTYzLjM3MjYyOCc+aDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTAuMTA4MjI2JyB5PSctNjIuMzcwODE1Jz5BPHRzcGFuIHk9Jy02MS4zNzQ1NjYnPm48L3RzcGFuPjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTUuMTUzMDktNTYuOTA1NUg0OC4yNzU1NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgtMS4wLDAuMCwwLjAsLTEuMCwxNS40MDMwOSwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00yLjIgMi41ODA2M0MxLjc5ODA3IDEuMDMyMjMgLjkwMjQgLjMwMTA3IDAgMEMuOTAyNC0uMzAxMDcgMS43OTgwNy0xLjAzMjIzIDIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguNTI1NTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMwLjg2NDMyLC01OS43MTczMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU4LjUxNDEzOCwtNjMuMzcyNjI4KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
            \DiagramSquare {
              width = 3cm,
              nw = {MR},
              ne = {M(A_{1},\ldots ,A_{n})},
              sw = {NR},
              se = {N(A_{1},\ldots ,A_{n})},
              north/style = {>->},
              south/style = {>->},
              east = {h_{A_{1}} \times  \cdots  \times  h_{A_{n}}},
              west = {g},
            }
          ]]></fr:resource-source></fr:resource></fr:figure></fr:li></fr:ul>
    </html:td>

  </html:tr>

</html:table>
<fr:p>Composition and identities are defined componentwise from those in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1748</fr:anchor><fr:addr
type="user">log-0002</fr:addr><fr:route>log-0002.xml</fr:route><fr:title
text="Terms">Terms</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> be a <fr:link
type="local"
href="log-0001.xml"
addr="log-0001"
title="Signature">signature</fr:link>.
  The collection of <fr:em><fr:strong>(raw) terms</fr:strong></fr:em> over <fr:tex
display="inline"><![CDATA[\Sigma ]]></fr:tex> is inductively generated by the following rules:</fr:p><fr:ul><fr:li>Each variable <fr:tex
display="inline"><![CDATA[x]]></fr:tex> of sort <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is a term of sort <fr:tex
display="inline"><![CDATA[A]]></fr:tex>.</fr:li>
  <fr:li>Let us write <fr:tex
display="inline"><![CDATA[t\colon A]]></fr:tex> if <fr:tex
display="inline"><![CDATA[t]]></fr:tex> is a term of sort <fr:tex
display="inline"><![CDATA[A]]></fr:tex>.
    If <fr:tex
display="inline"><![CDATA[f\colon A_{1},\ldots ,A_{n}\to B]]></fr:tex> is a function symbol and <fr:tex
display="inline"><![CDATA[t_{1}\colon A_{1},\ldots ,t_{n}\colon A_{n}]]></fr:tex> are terms of corresponding sorts, then <fr:tex
display="inline"><![CDATA[f(t_{1},\ldots ,t_{n})\colon B]]></fr:tex>.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>