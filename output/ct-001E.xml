<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1559</fr:anchor><fr:addr
type="user">ct-001E</fr:addr><fr:route>ct-001E.xml</fr:route><fr:title
text="Exponentiable object">Exponentiable object</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with finite products.
  An object <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is said to be <fr:em><fr:strong>exponentiable</fr:strong></fr:em> if the functor <fr:tex
display="inline"><![CDATA[A \times  (\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]]></fr:tex> admits a right adjoint <fr:tex
display="inline"><![CDATA[(\mathord {\hspace {1pt}\text {--}\hspace {1pt}})^{A}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Backlinks">Backlinks</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1560</fr:anchor><fr:addr
type="user">ct-001G</fr:addr><fr:route>ct-001G.xml</fr:route><fr:title
text="Exponentiable objects and right adjoints"><fr:link
type="local"
href="ct-001E.xml"
addr="ct-001E"
title="Exponentiable object">Exponentiable</fr:link> objects and right adjoints</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a cartesian category.
  Then an object <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is exponentiable iff <fr:tex
display="inline"><![CDATA[B^{*}\colon \mathcal {C}\to {{\mathcal {C}}_{/{B}}}]]></fr:tex> admits a right adjoint <fr:tex
display="inline"><![CDATA[\Pi _{B}]]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1122</fr:anchor><fr:addr
type="machine">#289</fr:addr><fr:route>unstable-289.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Note that pullbacks over the terminal object <fr:tex
display="inline"><![CDATA[1]]></fr:tex> are products.
    Thus, we may assume that <fr:tex
display="inline"><![CDATA[B^{*}]]></fr:tex> sends each object <fr:tex
display="inline"><![CDATA[A \in  \mathcal {C}]]></fr:tex> to the first projection <fr:tex
display="inline"><![CDATA[B \times  A \to  B]]></fr:tex>.</fr:p>
  <fr:p>Suppose that <fr:tex
display="inline"><![CDATA[B^{*}]]></fr:tex> admits a right adjoint <fr:tex
display="inline"><![CDATA[\Pi _{B}]]></fr:tex>.
    <fr:tex
display="inline"><![CDATA[B \times  (\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]]></fr:tex> can be expressed as <fr:tex
display="inline"><![CDATA[\Sigma _{B}B^{*}]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\Sigma _{B}]]></fr:tex> is constructed in <fr:ref
addr="ct-000I"
href="ct-000I.xml"
taxon="Lemma" />.
    By <fr:ref
addr="ct-000J"
href="ct-000J.xml"
taxon="Lemma" />, <fr:tex
display="inline"><![CDATA[\Sigma _{B}]]></fr:tex> is left adjoint to <fr:tex
display="inline"><![CDATA[B^{*}]]></fr:tex>.
    Thus, we may define <fr:tex
display="inline"><![CDATA[(\mathord {\hspace {1pt}\text {--}\hspace {1pt}})^{B} := \Pi _{B}B^{*}]]></fr:tex>.</fr:p>
  <fr:p>Conversely, suppose that <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is exponentiable.
    Let us use the notation <fr:tex
display="inline"><![CDATA[(\mathord {\hspace {1pt}\text {--}\hspace {1pt}})^{\dag }]]></fr:tex> to denote the exponential transpose.
    Then given any object <fr:tex
display="inline"><![CDATA[f\colon A\to B]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>, let <fr:tex
display="inline"><![CDATA[\Pi _{B}f]]></fr:tex> be given by the following pullback, where <fr:tex
display="inline"><![CDATA[\pi _{1}\colon B \times  1\to B]]></fr:tex> is the product projection.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="74c63fca3521e6cf67a210bca0649385"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEzMS45MDg4MTJwdCcgaGVpZ2h0PScxMjMuODg3NjcxcHQnIHZpZXdCb3g9Jy03MiAtNzIgODcuOTM5MjA4IDgyLjU5MTc4MSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTVlBQW9BQUFBQUE0UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFV4MUcyTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQ0VaMng1WmdBQUFXUUFBQUJrQUFBQVpERnVBckpvWldGa0FBQUJ5QUFBQUN3QUFBQTJLT2VHV0dob1pXRUFBQUgwQUFBQUhnQUFBQ1FGeXdMV2FHMTBlQUFBQWhRQUFBQUlBQUFBQ0FZS0FKSnNiMk5oQUFBQ0hBQUFBQVlBQUFBR0FESUFBRzFoZUhBQUFBSWtBQUFBRndBQUFDQUFCQUFnYm1GdFpRQUFBandBQUFES0FBQUJNdXNJa2Vad2IzTjBBQUFEQ0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtWm1XY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb2FNaGd5TS93SDhwa2gwa2hxL2dPRkFhTjNERmdBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlHLy85RHlQOFh3SHdHQUZGSEJvMEFBQUFBQVFDU0FBQUNOd0tyQUI0QUFBRVJCaFk3QVJVbUp5TUdCelV6TWpZbkVRNEJKeU0xTXhZL0FUWTNOaFlCbUFRaVRqTXNPdEU2TEROT0lRTXVWQk1TRWhJK0J6ODVHQTRDaS8zTkZ4UXRBd0VCQXkwVUZ3SUFFZ3dCTFFJS0Fnb3VBUWtBZU5wallHUmdZQURpSC93RnJQSDhObDhabUZrWVFPQ3gvY0lJWkpvNWlHazFrT0pnWUFMeEFQb0dDR2Q0Mm1OZ1pHQmdadmpQQUNTREdDWXhOREtaTXdCRlVBQVRBRUxjQXFnQUFBTlNBQUFDdUFDU0FBQUFBQUF5QUFCNDJtTmdaR0JnWUdLUVp3RFJERkFTQ1FBQUE2UUFKUUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPWUFBb0FBQUFBQkFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxQ3dTNTJOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENCeloyeDVaZ0FBQVd3QUFBRFJBQUFBNElnSTRQeG9aV0ZrQUFBQ1FBQUFBQzhBQUFBMktldUZvMmhvWldFQUFBSndBQUFBSHdBQUFDUUYyQUVPYUcxMGVBQUFBcEFBQUFBSUFBQUFDQWIvQUg5c2IyTmhBQUFDbUFBQUFBWUFBQUFHQUhBQUFHMWhlSEFBQUFLZ0FBQUFGd0FBQUNBQUJBQktibUZ0WlFBQUFyZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURpQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1ybWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4UUVBREF5cElLUzVMWjJCVEFBSm1yVCtXREF6TVdzekhnY0tNQ0JYLy96TXdBQUFLZVE3Q0FBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytRb0svLzlEeVBzUHdmSU1BRktpQnB3QUFIamFOWXN4VHNNd0dFYjkvWTUvMXluRkZrMEpsSktvdGhVYVZTUUkyb1FCdFNzRFIyQkR2UUJpWXVFQTNLVG40VDVRa0ZqZTh0NFRFQi9mbnE3cFN6d0tnUklGSm16QitoZDkxYUs2V25WYmRHdUxZNFFHcTY2L0xXWFZVclhlSU85Tzg3OTRpdzN1Q21Tcy9XSEJUbzVNQWxaYVNuMlVreHdrR21xWXl2TjYzR1J6NSthVHMzb3hKYVdIaWlKekpDakhOUDIzV1RPdXNTLzZ4ZEsvdno2OTVBTUNUdHp1L3UwenRqZExPNUlwcHhTc0p6WW1tWlhod1Y5RVIrVGlaWGd1WjRsaFE5NEdPbFJDL0FDZmJCZGRBQUFBZU5wallHUmdZQURpOVd2WnJlUDViYjR5TUxNd2dNQmorNFVSQ1BxL0Vrc28weFVnbDRPQkNTUUtBQk9wQ2RjQWVOcGpZR1JnWU5iNlk4bkF3QkxLVU05UXk2VExBQlJCQVV3QVM2c0M2d0FFVlFBQUFxb0Fmd0FBQUFBQWNBQUFlTnBqWUdSZ1lHQmk4R1FBMFF4UUVna0FBQWUrQUU4QWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFXVUFBb0FBQUFBQm53QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVjQUFBQmdoZDE0WTJOdFlYQUFBQUU4QUFBQU93QUFBRXdFY2dRNFoyeDVaZ0FBQVhnQUFBSzRBQUFETUU3d2JyeG9aV0ZrQUFBRU1BQUFBQzhBQUFBMktPK0ZybWhvWldFQUFBUmdBQUFBSGdBQUFDUUdpZ0pLYUcxMGVBQUFCSUFBQUFBVUFBQUFGQTIzQVBWc2IyTmhBQUFFbEFBQUFBd0FBQUFNQVo0Q1htMWhlSEFBQUFTZ0FBQUFHQUFBQUNBQUNRQk1ibUZ0WlFBQUJMZ0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUZpQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0yc2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lOR0JpU1FVbHlXRHBSMFlqN0F6UEFmeUdkbVlBUUpNeUpVL0FjS0F3QVNlUTR6QUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1Jnc2dEUVhBd2RRam9uQmlTR05lUlB6Z2YvL2dXSnc5di85LytmOENmempBdFlCQlFCeTV3Nm5BSGphUlpMUFR4TkJGTWZuelN5emJObnVicmZkWFVyYjdZOHR1MVNreFpadUtlQXVQd3FTRmdUa1VERW1xRkVUbFVUamo1c2FNREhocEFjOWVPQWdCeE91WG8wM3VYaVVtMzhGRjdscDYyd1Q0MHp5TXZPKzcvQSs3L3NRUWMzdWI3S0Z2NklzR2tOMWhHclJtbXVYd0tLMmEyUk5NQ1RnV2FReVVENGI1SFEzV3ZHQTFUaVdUWG55NzAyby9tMmZBMEdKUzJsUUpYaDIreUdRdmUwcjF3R3ZxcHZQTzArU09CS3VwNDZPN3IwQVhGMDlTQ3Q5ano1dDd4SHdsbisyUUZ6SEdaMm5RTGdjRDNoenBuRlhEVzFNdHVZa2ozQVdENkJDZyt6TVp5OXhJT2wvUHVPZHRWSVRkMDU0Z2hDZ1ZyZUU3K01mYUpaOVNOQW02emhuT3g1VWRFT252SjRHRDN6UzR3bWFaZm15enFnczI3SGRHaU9Wc0F3VlY2Y09IRTRwbkRJa3pGMFltUUxJYXpZQk9TM0xjajVMVWtWNXhjUlJlVVBXSkgzZUtzd0FXRHJURlZPV1ZkVU05UTl0QnpLODd4dzNJN01Uc1FWaVcyWUc1Nmt6SUdEZ1d0cUhzelpoYU8ydGhHTVA1LzlMRUxmSDNuQzVma0RzRUZUdVR1SjlmSUtTeUVGTnh0TWJ2a2I1NEJiQklkUjJvbTR0dUdXZHR3TllobGYyb2NqODZoVVJxcGtRWUU3WURtWE1WUThNaHVzQjNpZk5FYWZBWFZiVXEzZThsckxJcGVBd1Vvc2FjOWVXYm55UEp3eEZvSEpDRHgzQVpIRzlMa3ZsU0lOQWMrYm1MaDRjTEZaR3p1TjY4bHdoUEQ2S0czN2JTR3dXSHl3b1loMmdPdHc1RmJDSVh5K3R4TFVGcm5WS0FUREhzWEJjR3VkbUZYVzUwVG1WbElzTjh2Wnhia3FSUUZRVFllanZTOTFDZ1hmRjdobCtCMStReXo1ODRFblZaMjdWZ3MyaUpRaE1aSDRaV1ZjM21PcFliQXZaTHVxQncyd1NQUms4UDJLYWVSSWJiQXo1NmxxaFR3cFJ3S042dG1yQ0t6bkpOc3FJNzRZd0JrMFJBRkpxV0JNSDJOUkZlUHBya2MxQWRzWS90ckZSRVFHRElFekhNaHFBb01tQ2ltdnBrcitWRWtPeE9FQjBPRFB0dnl5eGx2OEN0elY2RVhqYVkyQmtZR0FBNHI2bHRzM3gvRFpmR1poWkdFRGdzZjNDQ0FUOVg1ODVrdWtTa012QndBUVNCUUFpaGdvNkFIamFZMkJrWUdCbStNOEFKRXNZOVA1ZllJNWtBSXFnQUZZQVhEUUQyZ0FBQXNZQUFBTjBBRW9DT2dCTEFwY0FNZ0tzQUM0QUFBQUFBR0FBeGdFK0FaaDQybU5nWkdCZ1lHWHdabUJtQUFGR0JqUUFBQWh2QUZaNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVM4QUFvQUFBQUFCV3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDA1Mk50WVhBQUFBRTRBQUFBTWdBQUFEd0FuUUI3WjJ4NVpnQUFBV3dBQUFIcUFBQUNMTGxHV1dob1pXRmtBQUFEV0FBQUFDOEFBQUEyS0p5RnVHaG9aV0VBQUFPSUFBQUFIZ0FBQUNRR0xRSE5hRzEwZUFBQUE2Z0FBQUFRQUFBQUVBcHpBSVZzYjJOaEFBQUR1QUFBQUFvQUFBQUtBV29Bc0cxaGVIQUFBQVBFQUFBQUdBQUFBQ0FBQ0FCQ2JtRnRaUUFBQTl3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRXNBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbW1zTTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkVoalp2Z1A1RE5EcEpIVS9BY0tBd0RoNVEwemVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS09qR2svZjhQNUR1QzZQOEgvczhGcXdJQ0FKUmZDUklBQUhqYU5kRXhiOU5BRkFmdys5L0Y1eVRZUGhQSGRxdkVTUnluTmlvaUtYV3cyd29NYW1oQXJSSVZLbENIU2toSTBBMGgxQmJZTW5TRUNZRUVDd3NiSDRBQkppWStBQ3NEWXVRekpPRmNpWnZ1L3U4TnYzZVBVTktaeitsditvdjB5Q29oS1pKMDFYR3RxaE1uRHU5QmpjS29uN2hPa3ZiZ3E3enF1SWxyUU9aNUhHZElZL1lGajNoVjU4aWNTelkwNVdoU1ZLQ2ZzL3FzcE03bVk3MXU2UXk2Y3JpdlFTdTFzL2QvL1JONjMwUkpUQ2VPWUo0S3hrQ0xRZ1UwOS9IV2FiVmpnZ3FENTNGWmNBUS9jSmZJdzhqRitaUngrbzAweURKWmsxS3JIMFJjMnZ3R2JBTnFBeTRYNEtyUHo3eFdqa3ZDS0FpNXl2N2ZtV3lJUDcydVJaNFEyRDk0eUNaN08zdWd0OHpSOGV4TjNUQTJHaC9mUFRpaTZBNU9tNWJ5NU5YQkNhVXJ0NzhQQzRDeFM5ZlBVMVpYUWU5c2JCK0s4bmg5WjlQSUN2a0VzTERGbmcwN055bkU0dlF6ZXo1ZTJtV3pQeFZlSmdRa21YZnBGZnFUM0pDUEhLQktiRHVNTXNUeW94MHU0YW5rV1VIdWpxOGpneXR6QTRIc0NaTzBDNVdyWE5COEhSRmVaSVlpWE9QcWNpc0JBbHZZb0c1Z2VvVW8xRVlEenhURGhmTGl1T1luRkcxYk9NQkNTelFMdmxDS21uMnZCbFBndyt6cndMcDJ1YmxKTzRIWHFsVDBzQ0JYeDU2TzhKWjVIQzh2YksvUW9ITldXVkx5U2xNUDE0N3pzUW41QnhrblZJSUFBSGphWTJCa1lHQUE0dnBKNzl6aitXMitNakN6TUlEQVkvdUZFUWo2dng0ekc5TmRJSmVEZ1Fra0NnQXRDQXBFQUhqYVkyQmtZR0JtK004QUpEa1lWUDRmWUdaakFJcWdBQllBU1VnREFBQUFBbllBQUFNQUFDUURDQUFyQWZVQU5nQUFBQUFBVkFDd0FSWUFBSGphWTJCa1lHQmdZWEJrWUdZQUFVWUdOQUFBQjFvQVMzamFUWTZ4YXNNd0VJWS9VOGRRcDlDcEhUb1VUUm1GamZzQWdReVpzbVlzSkpFSURrZ0tzbVBJRXZvQWZlaGVGQTA5d2ZIZGQ3K0VnSm9iQmZjcWVFMzlYaVdWVEErZU1lY3RjeVZIWmE3NVlNRVRSZmtzNXBObDVwSVh2alBQZU9lVXVSTC9rN25taTk5VmNPZkxhS1BhQkdPalB6alh0ODNXeHFFUFhyVzZlWWkxOVRidVJtdlUvcXJNMUEvVDBhbE9ON3BqUmNCeDVzS0lKY3JQTm1KTVlzOUJkbzZlbG9adGNvTk1RVFpLbkJiN1A3R1doRStwWFhyTlNHclBWYnBoa3N3Zy9TaHBSWmZ1YXJvLzMvUXd1d0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPRUFBb0FBQUFBQS9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVjExNUdOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBREZBQUFBekhVWExjMW9aV0ZrQUFBQ0xBQUFBQzhBQUFBMktXNkdhR2hvWldFQUFBSmNBQUFBSHdBQUFDUUhWZ04zYUcxMGVBQUFBbndBQUFBSUFBQUFDQWQ2QUh4c2IyTmhBQUFDaEFBQUFBWUFBQUFHQUdZQUFHMWhlSEFBQUFLTUFBQUFHQUFBQUNBQUJnQkJibUZ0WlFBQUFxUUFBQUROQUFBQk9QTmJLcDl3YjNOMEFBQURkQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm0zc3M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFluQmladmdQNURORHBKSFUvQWNLQXdEcVN3MHllTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzlEeVAvN3dYd0dBRktzQnA0QUFBQjQybU5nWnFqNS81LzVCdE1lQmcwR0V3WjdCZ1p6WVhOVE5YMUdOalZURXpOeFJUbEdjVFoyRUpSalpJY3dGQ0V5Um1iQ3huYU01aVpxNnNwcWJPek1NRFl6Kzc4MlprRVJHV0ZoRVFIR3hka3RUQ3pPdkFLZW5oa0pqTXhCUFB6UnpmK2MrVVRFUk0xbE54eks3V1B5OU5rdEw4aVNjelJsSW91ZjN5ODM1bEFtU1I1ZUZrWkdSalplRVU1R3htQkhOMTB1VGcxTy9qQkRienN1VGl0bVJqWWVVVTVHQVVaNzVpUkhMVHNtUmg2eHY0ZVlFbjJNUEpuK3ZSUm1ZQUFBbXVRbWF3QUFBSGphWTJCa1lHQUE0b2pXaDgvaitXMitNakN6TUlEQVkvdUZFUWo2LzMvbUcweDdnRndPQmlhUUtBQlIzd3dsQUhqYVkyQmtZR0JtK00vQXdNQ2l4bERENE1kOGd3RW9nZ0tZQUVTSUF0WUFBMVFBQUFRbUFId0FBQUFBQUdZQUFIamFZMkJrWUdCZ1luQmdZR1lBQVVZR05BQUFCd3NBU0hqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvTURhaFlHSmxha0xZQmRsc0kyY0VBbXA2dGpmM1lmeDBEZGNuZnRoQXpVL0ZOeXZZSmIwZmlXVnVBZFhUSmxubm9oN3kxeXo0SjBuaXZKWmtsYytNcGZTZkdhdWVPRXI4MFR5Nzh3MUszNDN3VjJ1ZzQxcUY0eU4vdVJjdDk3YjJIZkJxNlZ1a3Q5YWIrTmhzRVlkYjhxTVhUK2VuV3AxbzFzMkJCd1hyZ3hZSW9xZEpDYXg1eVNkbzJQTlBpVzljSkJjc1VUVC9PdTMwdnUwT2FTZmpHeU8zRVFOb3l4NjBiTnNGVzE2cVduL0FNZ1JMKzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTU1BQW9BQUFBQUEzUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFR4MEZXTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQjBaMng1WmdBQUFXUUFBQUJVQUFBQVZKNVA3NTFvWldGa0FBQUJ1QUFBQUMwQUFBQTJLR2lHaUdob1pXRUFBQUhvQUFBQUlBQUFBQ1FFVEFKQmFHMTBlQUFBQWdnQUFBQUlBQUFBQ0FRZUFHcHNiMk5oQUFBQ0VBQUFBQVlBQUFBR0FDb0FBRzFoZUhBQUFBSVlBQUFBRmdBQUFDQUFCUUFYYm1GdFpRQUFBakFBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFDL0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtNG1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb3FNaWd5TS93SDhwa2gwa2hxL2dPRkFhTDdERUVBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlLLy85RHlQOFB3SHdHQUUvM0JuMEFBQUFBQWdCcUFBQUE0QUxiQUFzQUZRQUFFd01PQVNJbUp3TStBVElXRXc0Q0xnRTJOeDRCNENnQkNCTUpBU2dDSWkwa0FRRWhNU0VDSUJ3WUlRS2ovanNQQ1FrUUFjUWFIaDM5ZlJraEFTQXpJZ0VCSVFCNDJtTmdaR0JnQUdJbHo1bi80L2x0dmpJd3N6Q0F3R1A3aFJISU5OTmxwdHRBaW9PQkNjUURBQmRzQ1o0QUFBQjQybU5nWkdCZ1p2alB3TURBZEpraGl5R2I0UUVEVUFRRk1BRUFWbGdEa1FMVEFBQUJTd0JxQUFBQUFBQXFBQUI0Mm1OZ1pHQmdZR0lRQTJJUVlHUkFBd0FDMmdBZEFBQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU4wQUFvQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hjeDRCV050WVhBQUFBRThBQUFBTVFBQUFEd0hJUDBmWjJ4NVpnQUFBWEFBQUFDc0FBQUEwRjZXay8xb1pXRmtBQUFDSEFBQUFDMEFBQUEyS0hLR1pXaG9aV0VBQUFKTUFBQUFIUUFBQUNRR0FRSW5hRzEwZUFBQUFtd0FBQUFNQUFBQURBZUFBSDFzYjJOaEFBQUNlQUFBQUFnQUFBQUlBQ29BYUcxaGVIQUFBQUtBQUFBQUZ3QUFBQ0FBQlFBcmJtRnRaUUFBQXBnQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRGFBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWFtQ2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMG9hTWk5Z1p2Z1A1RE16TUlLRUdSRXEvZ09GQWZZMURjUUFBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5aG95TC9qL0g4Z0gwLzh2L0VrQ3F3SUNBSms1Q1QwQUFBQjQybU5nWklobVlHQmN5N1NhUVFKSUM3S0pXVE9LcWl1em14b2JtYWtMOGpHcW00cVptWnVKTWVveUt6Z3BCcTRLVkhTV1o5YjBFWlRKTVJaa1orci9lMGhHVklHWldVRlVoa2xJbUlOUm5rbFVuNUVMYUF5REVnTUQwMTJtSFF5YW1HWXFvdkhOMUxRWlRSVkZsWlhZbUVxWXBDd2x2R2Q2U1ZwSU0vMDd5eVJ0SVFua1NGaEtNWUhFbVhhRFdCbC9YOGlJZ0t3VWtXSHkvTHNkenBhUUVaV1hGMlZnQUFDN1J5RnNlTnBqWUdSZ1lBRGltR2JKaGZIOE5sOFptRmtZUU9DeC9jSUlaSnJwTHRNT0lNWEJ3QVRpQVFBRlFRa2JBQUFBZU5wallHUmdZR2I0endBaUdaUVlsSm51TWdCRlVBQXpBRFZuQWk4QUFBQUNnQUFBQWdBQVd3TUFBQ0lBQUFBQUFDb0FhSGphWTJCa1lHQmdadEJpQU5FTVVCSUpBQUFFMGdBeEFIamFSWXd4YjhJd0VJVy9pQVNKZE9oU2RXQUFEOHhXb2pCM1lXQmlaV0lCYktJTWNaQVRJaUdoanYzZFBZd2xibmo2N3IxM0IrVDhrdkNjaE0rZ3owbkpaSHR4eGdkZmthZXlMU1BuekZreElVbG40aXo0aVp4S2NvaWM4YzBsOGxUOFIrU2NOWCticnIzZUJ1dlZyalBXdTNQcnkySnZmZDkwVHBXNkNQdldPdXVQZ3pYcWRGZG1iUHF4YmxXbEMxMnhvYVBseW8wQmkwZXhFOGNFZHB3bDg1UVU3SVBUMDBqcXBGV2l4WDNuVzhsZDZCekRKeU9kRTNkUnd5aFh2V2d0YlVVVkxqWFZQMk05THc4QUFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTcuNTcwOTQ0LC02MC40NDc1MDEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTAuMTc3NjMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU3LjU3MDk0NCwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy01Ny41NzA5NDQnIHk9Jy02MC40NDc1MDEnPs6gPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01MC4wOTg5NDUnIHk9Jy01OC45NTMxMic+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDMuMjQxNjY0JyB5PSctNjAuNDQ3NTAxJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yLjUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ny41NzA5NDQsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTcuNTcwOTQ0JyB5PSctNjAuNDQ3NTAxJz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTguMzU0MTdWLTQ4LjU1MTM1JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC44MDEzNSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuNTI3NzcsLTMwLjQ1Mjc2KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTcuNTcwOTQ0LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTU3LjU3MDk0NCcgeT0nLTYwLjQ0NzUwMSc+ITwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OS43MTQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU3LjU3MDk0NCwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01Ny41NzA5NDQnIHk9Jy02MC40NDc1MDEnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTUwLjA5ODk0NScgeT0nLTY0LjA2Mjg2NSc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OS40MjA2MSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU3LjU3MDk0NCwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy01Ny41NzA5NDQnIHk9Jy02MC40NDc1MDEnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ5LjUxNDMzNScgeT0nLTY0LjA2Mjg2NSc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTQuNzMzMTcgMEg0NC42NTg0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0NC45MDg0NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI3LjQ5ODc1LDQuMTcyOTEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ny41NzA5NDQsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTcuNTcwOTQ0JyB5PSctNjAuNDQ3NTAxJz7OsjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS02LjQwOTczVi00Ni41ODM1MScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ2LjgzMzUxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMjguNDk2NjEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ny41NzA5NDQsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTcuNTcwOTQ0JyB5PSctNjAuNDQ3NTAxJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01Mi45MDQzNTknIHk9Jy02My40NTQwMTgnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTcuMDU1NTQtNTYuOTA1NUg0NC4zNjUwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0NC42MTUwNywtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjEuNTc5ODgsLTY2LjU3Mjg1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTcuNTcwOTQ0LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU3LjU3MDk0NCcgeT0nLTYwLjQ0NzUwMSc+z4A8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTUyLjY2MTg3OCcgeT0nLTYzLjgxODE3Nyc+4oCgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy01Mi45MTIwOTknIHk9Jy01OC4yODQ1NzYnPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = {\Pi _{B}f},
      nw/style = {pullback},
      ne = {A^{B}},
      sw = 1,
      se = {B^{B}},
      north = \beta ,
      east = {f^{B}},
      south = {\pi _{1}^{\dag }},
      west = {\mathsf {!}},
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Now let <fr:tex
display="inline"><![CDATA[\alpha \colon f\to g]]></fr:tex> be a morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>, we extend the above assignment to morphisms as follows:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="4fa034167f7dca1a305bb0805ae1fd71"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE5MS4yNDYyNzFwdCcgaGVpZ2h0PScxODEuNTE4NzU1cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTI3LjQ5NzUxNCAxMjEuMDEyNTAzJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOOEFBb0FBQUFBQS9nQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoYng0QkdOdFlYQUFBQUU4QUFBQU1RQUFBRHdITVB6L1oyeDVaZ0FBQVhBQUFBQzJBQUFBekFxNjNZdG9aV0ZrQUFBQ0tBQUFBQzBBQUFBMktMcUdmR2hvWldFQUFBSllBQUFBSGdBQUFDUUdZQUtkYUcxMGVBQUFBbmdBQUFBTUFBQUFEQWQ5QUtOc2IyTmhBQUFDaEFBQUFBZ0FBQUFJQUNvQVptMWhlSEFBQUFLTUFBQUFHQUFBQUNBQUJnQXBibUZ0WlFBQUFxUUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQURjQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1xbWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBvcU1pOWdadmdQNURNek1JS0VHUkVxL2dPRkFmUG9EYk1BQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeWlveUwvai9IOGdIMC84Zi9Fa0Nxd0lDQUpkSkNTMEFBQUI0MmxYSlN3N0JZQlNHNGUrY05xV1JsS2FYOUVMVHYvU1NDQW1paUlUTkdObURoV0JvWmdNR1JoSzdNTEVBaVJWVWxJSEU3SG56Z3JFR2NPY2JhckFBUTlJb1NsSnBRVVBiMExoUCtTU2dlMFpWUTZXTW8xNkhTQXdFaDAxSDhPRTFyNnRxZzY1ZTBDbzJycUJ3RkpVYklNd0FLZVlUMGpKMHhaNlRsVmJHbzJHZTZ1SS84NlJMWTJHMUk0WFA3RS9kL2RhWmVmdzZmcjF6cHo1L3hJK1BWc1hUTjJKWmprMlBsOFhsWjcxVWJBSnZEemNoRmdBQWVOcGpZR1JnWUFCaXZibmJCZVA1YmI0eU1MTXdnTUJqKzRWQnlEU3pLdE50SU1YQndBVGlBUUQ3bXdoMUFBQUFlTnBqWUdSZ1lHYjR6d0FrNHhrc0dheVlWUm1BSWlpQUdRQTFEZ0lGQUFBQzB3QUFBVXNBYWdOZkFEa0FBQUFBQUNvQVpuamFZMkJrWUdCZ1p0QmdZR0lBQVVZR05BQUFCTGNBTUhqYVBZd3hxOEl3RklXL1loWHRHeHdFaHpkSThBZUVTaCs0dURrNHVUcTh6Wm9nSFpwS1dvc3U0ay8zTmdSdjRQRGRjODROa1BFaVlaaUVlZEJoVW5uenlHTitXRVNlaUwrS25QSExtaEZKT2hObnhTNXl5cFQveUdPV2xKRW40ajhpWi96eDNqZjE3ZDVacjQ2TnNkNWRhcjg5V2Q5V2pWTWJuUS9yd1Rycno1MDFxbndxMDFkdGY2MVZvWE5kc0tlaDVzYWREb3RIY1JUSEJIWmNKUE5zT1lXOXBaTE1TV2VESnYrbUIwbGRhSnpETDBZYUpVOVJReTgzcmVoVnVvb2kzR21LRDFpc0xrc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPWUFBb0FBQUFBQkFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxQ3dTNTJOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENCeloyeDVaZ0FBQVd3QUFBRFJBQUFBNElnSTRQeG9aV0ZrQUFBQ1FBQUFBQzhBQUFBMktldUZsMmhvWldFQUFBSndBQUFBSHdBQUFDUUYyQUVPYUcxMGVBQUFBcEFBQUFBSUFBQUFDQWIvQUg5c2IyTmhBQUFDbUFBQUFBWUFBQUFHQUhBQUFHMWhlSEFBQUFLZ0FBQUFGd0FBQUNBQUJBQktibUZ0WlFBQUFyZ0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURpQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1ybWVjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4UUVBREF5cElLUzVMWjJCVEFBSm1yVCtXREF6TVdzekhnY0tNQ0JYLy96TXdBQUFLZVE3Q0FBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytRb0svLzlEeVBzUHdmSU1BRktpQnB3QUFIamFOWXN4VHNNd0dFYjkvWTUvMXluRkZrMEpsSktvdGhVYVZTUUkyb1FCdFNzRFIyQkR2UUJpWXVFQTNLVG40VDVRa0ZqZTh0NFRFQi9mbnE3cFN6d0tnUklGSm16QitoZDkxYUs2V25WYmRHdUxZNFFHcTY2L0xXWFZVclhlSU85Tzg3OTRpdzN1Q21Tcy9XSEJUbzVNQWxaYVNuMlVreHdrR21xWXl2TjYzR1J6NSthVHMzb3hKYVdIaWlKekpDakhOUDIzV1RPdXNTLzZ4ZEsvdno2OTVBTUNUdHp1L3UwenRqZExPNUlwcHhTc0p6WW1tWlhod1Y5RVIrVGlaWGd1WjRsaFE5NEdPbFJDL0FDZmJCZGRBQUFBZU5wallHUmdZQURpOVd2WmcrUDViYjR5TUxNd2dNQmorNFZCQ1BxL0Vrc28weFVnbDRPQkNTUUtBQmFkQ2VNQWVOcGpZR1JnWU5iNlk4bkF3QkxLVU05UXk2VExBQlJCQVV3QVM2c0M2d0FFVlFBQUFxb0Fmd0FBQUFBQWNBQUFlTnBqWUdSZ1lHQmk4R1FBMFF4UUVna0FBQWUrQUU4QWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtUUFhTURHZ0FBQUNPQUFVPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1ZQUFvQUFBQUFBNFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hVeDFHMk50WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNFWjJ4NVpnQUFBV1FBQUFCa0FBQUFaREZ1QXJKb1pXRmtBQUFCeUFBQUFDd0FBQUEyS09lR1RHaG9aV0VBQUFIMEFBQUFIZ0FBQUNRRnl3TFdhRzEwZUFBQUFoUUFBQUFJQUFBQUNBWUtBSkpzYjJOaEFBQUNIQUFBQUFZQUFBQUdBRElBQUcxaGVIQUFBQUlrQUFBQUZ3QUFBQ0FBQkFBZ2JtRnRaUUFBQWp3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRENBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVptV2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG9hTWhneU0vd0g4cGtoMGtocS9nT0ZBYU4zREZnQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpRy8vOUR5UDhYd0h3R0FGRkhCbzBBQUFBQUFRQ1NBQUFDTndLckFCNEFBQUVSQmhZN0FSVW1KeU1HQnpVek1qWW5FUTRCSnlNMU14WS9BVFkzTmhZQm1BUWlUak1zT3RFNkxETk9JUU11VkJNU0VoSStCejg1R0E0Q2kvM05GeFF0QXdFQkF5MFVGd0lBRWd3QkxRSUtBZ291QVFrQWVOcGpZR1JnWUFEaUgvd0Zzdkg4Tmw4Wm1Ga1lRT0N4L2NJZ1pKbzVpR2sxa09KZ1lBTHhBUHo2Q0hONDJtTmdaR0JnWnZqUEFDU0RHQ1l4TkRLWk13QkZVQUFUQUVMY0FxZ0FBQU5TQUFBQ3VBQ1NBQUFBQUFBeUFBQjQybU5nWkdCZ1lHS1Fad0RSREZBU0NRQUFBNlFBSlFCNDJqMk1NYXZDTUJTRnYySVY3UnNjQkljM1NQQUhoRXFmbTV1RGs2dkQyNndKMHFHcHBMWG9JdjUwYjBQd0JnN2ZQZWZjQUJrdkVvWkptQWNkSnBVM2p6em1oMFhraWZpcnlCbS9yQm1ScEROeFZ1d2lwMHo1anp4bVNSbDVJdjRqY3NZZjczMVQzKzZkOWVyWUdPdmRwZmJiay9WdDFUaTEwZm13SHF5ei90eFpvOHFuTW4zVjl0ZGFGVHJYQlhzYWFtN2M2YkI0RkVkeFRHREhSVExQbGxQWVd5ckpuSFEyYVBKdmVwRFVoY1k1L0dLa1VmSVVOZlJ5MDRwZXBhc293cDJtK0FCVk1pNURBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVY0QUFvQUFBQUFCbFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hWMTB2V050WVhBQUFBRTRBQUFBTlFBQUFEd0FuUUI5WjJ4NVpnQUFBWEFBQUFLZ0FBQURFQ1JiSHJwb1pXRmtBQUFFRUFBQUFDOEFBQUEyS0tHRm8yaG9aV0VBQUFSQUFBQUFIZ0FBQUNRR0hBSE9hRzEwZUFBQUJHQUFBQUFVQUFBQUZBdzFBS0pzYjJOaEFBQUVkQUFBQUF3QUFBQU1BWHdDUW0xaGVIQUFBQVNBQUFBQUdBQUFBQ0FBQ1FCQ2JtRnRaUUFBQkpnQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRmJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMG82TWFRek0vd0g4cGtoMGtocS9nT0ZBZEtDRFFvQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS09qT2svLzhQNURzeHBQMy8vMy8vLzdsZ1ZVQUFBSlNWQ1JRQUFBQjQyazJTVDA4VFVSREFkOTdidmkybDdGdGFkcmRrMlc3YmJYY0wyUEpuNnk0RktYOXFWeWdwVktzR1RSUFV4SmlZWUVRQk1mRkFEQ2FZNk1uSVFROWV2UGtSOUdSaTRsMC9nY2FESnorQW9mV3R4TVRNTzd6TXpPSDNteGtPYzZQZFkwelFCeTdKalhCVEhPZkZTNlpOU3E2YVRvSXNncEFFbFZBZ1FqcklLVzdjcVlEbldyWnBFUUgvKzJQVzRMeDlydGs2cGJEZXZvSDNXeXN0UU9la3hrN254WkFvVGlmZkhHMXNJeWhXRDR4NDZNNno5aTVDNDBzZmZSNUFiS0p5UDhKREFxRHowL1ZiTkxKYVhsa1VLenpXQllBNDFQQTlQM3NXQVIwOGZvY2ZyT2FhdVBNOVJpSWNCNXpUL1lsNzBkZUFHYkFJcG0zWmMxQ3liTVljQUt0SjhCVFhDd2dOU0RJQmxpK0M3WHBCS0txaWVrd0hSK1l4aWZTRUFNSGx0ZHFUY1Y4akN2Q1Bsdk1iYnFsQStCNGhoQXYrOEZaMTd6WEdyVkw5L2tGck9FK1dSSWlpejUzZkltTVdxSFgxTmtCMWFuMGowUzdzWGtlUUdTbTJFNzBBS0xxNW1ITUFIKzAvM2E2WExtQStteFBYUklTNWdOM3RGdEZweGo0ZnNOTVR1SXhsVjhDWlpHaUVEVDBBajV2QnpKMDVxSURLOHN5UjlWaXVWMlNHekJFNXJrSnMyS3VJSWFxS1owWlNMb0FwVXhtUWFrbzZiMXZSUmxXWHFKK0lESzVxYVplaHlWUUJTS1Nvd2FkcEtCeVZMMmtnVVhqVmVWK056MDRZaXlocjZxbFlyTS9pK3dqZ3V3MTRpWFVDRC9QMWNXUm0vMVp5b2FCaTlGbFRPOEhLbUF2aXhHNFJmc0FuZGoxeko1dGdKaFUyOFFFaUtBYTRjOEg3Zi9iTWhQa29LdmJjTVRoWlZ4QXNpK0hiVm5UejJ2SUN5dHJ4QVVWUkxEOGpEYUpNejBLeDNFQjRScEpxVFdPUzhrTVJEUjJXUUF6MWo2Vm1aYVUvQnBDMDFGUHNZQjkzeWhOWHNGSFJRZEdNTU5zUGI4ZnN5R0Z2QWNQRnhzMm1MUGs0cTJ1c1grdjgraExPaERNOE9QWm96YytuWnhESWVvNzdBMk90ZVA1NDJtTmdaR0JnQU9LbFZ5UGI0L2x0dmpJd3N6Q0F3R1A3aFVFSStyOGVNemZURlNDWGc0RUpKQW9BTDVFS1NBQjQybU5nWkdCZ1p2alBBQ1E1R1BqK0gyRG1aZ0NLb0FCV0FFZXVBdkFBQUFKMkFBQURDQUFyQXRzQU13SDFBRFlCNXdBT0FBQUFBQUJjQUxvQklBR0llTnBqWUdSZ1lHQmxjR1JnWmdBQlJnWTBBQUFIZFFCTWVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFPRUFBb0FBQUFBQS9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVjExNUdOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBREZBQUFBekhVWExjMW9aV0ZrQUFBQ0xBQUFBQzhBQUFBMktXNkdYR2hvWldFQUFBSmNBQUFBSHdBQUFDUUhWZ04zYUcxMGVBQUFBbndBQUFBSUFBQUFDQWQ2QUh4c2IyTmhBQUFDaEFBQUFBWUFBQUFHQUdZQUFHMWhlSEFBQUFLTUFBQUFHQUFBQUNBQUJnQkJibUZ0WlFBQUFxUUFBQUROQUFBQk9QTmJLcDl3YjNOMEFBQURkQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm0zc3M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFluQmladmdQNURORHBKSFUvQWNLQXdEcVN3MHllTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzlEeVAvN3dYd0dBRktzQnA0QUFBQjQybU5nWnFqNS81LzVCdE1lQmcwR0V3WjdCZ1p6WVhOVE5YMUdOalZURXpOeFJUbEdjVFoyRUpSalpJY3dGQ0V5Um1iQ3huYU01aVpxNnNwcWJPek1NRFl6Kzc4MlprRVJHV0ZoRVFIR3hka3RUQ3pPdkFLZW5oa0pqTXhCUFB6UnpmK2MrVVRFUk0xbE54eks3V1B5OU5rdEw4aVNjelJsSW91ZjN5ODM1bEFtU1I1ZUZrWkdSalplRVU1R3htQkhOMTB1VGcxTy9qQkRienN1VGl0bVJqWWVVVTVHQVVaNzVpUkhMVHNtUmg2eHY0ZVlFbjJNUEpuK3ZSUm1ZQUFBbXVRbWF3QUFBSGphWTJCa1lHQUE0b2pXaC8vaitXMitNakN6TUlEQVkvdUZRUWo2LzMvbUcweDdnRndPQmlhUUtBQlUwd3d4QUhqYVkyQmtZR0JtK00vQXdNQ2l4bERENE1kOGd3RW9nZ0tZQUVTSUF0WUFBMVFBQUFRbUFId0FBQUFBQUdZQUFIamFZMkJrWUdCZ1luQmdZR1lBQVVZR05BQUFCd3NBU0hqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvTURhaFlHSmxha0xZQmRsc0kyY0VBbXA2dGpmM1lmeDBEZGNuZnRoQXpVL0ZOeXZZSmIwZmlXVnVBZFhUSmxubm9oN3kxeXo0SjBuaXZKWmtsYytNcGZTZkdhdWVPRXI4MFR5Nzh3MUszNDN3VjJ1ZzQxcUY0eU4vdVJjdDk3YjJIZkJxNlZ1a3Q5YWIrTmhzRVlkYjhxTVhUK2VuV3AxbzFzMkJCd1hyZ3hZSW9xZEpDYXg1eVNkbzJQTlBpVzljSkJjc1VUVC9PdTMwdnUwT2FTZmpHeU8zRVFOb3l4NjBiTnNGVzE2cVduL0FNZ1JMKzhBQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVpVQUFvQUFBQUFCMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hkMTRiR050WVhBQUFBRThBQUFBUGdBQUFFd0VkUVEzWjJ4NVpnQUFBWHdBQUFOcUFBQUVFTVl3R3hob1pXRmtBQUFFNkFBQUFDOEFBQUEyS08rRm9HaG9aV0VBQUFVWUFBQUFIZ0FBQUNRR2h3S0thRzEwZUFBQUJUZ0FBQUFZQUFBQUdCQ3ZBUlZzYjJOaEFBQUZVQUFBQUE0QUFBQU9BNTRDZkcxaGVIQUFBQVZnQUFBQUdBQUFBQ0FBQ2dCTWJtRnRaUUFBQlhnQUFBRE5BQUFCT1BOZktxTndiM04wQUFBR1NBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbU9zNDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFIwWWo3QXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBVnZnNDhBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdzZ0RRWEF3ZFFqb25CaVNHZGVSUHpnZi8vZ1dJZzlrWVErLy8rLzdQL0JQMXhCZXVBQWdCekd3NnBBQUI0MmsyVHkyOGJWUlRHN3psM1BNT014L1B5UE9KNC9KaE1QT1BReEdONVlqdWhpUjNYYmtpYzVsR0NGR3hWdEZTMFZkVktWQlJRaFFBMVNFalpnY3EyQzFnZ2RZdkVCc1NPYnRoMngxK1JUVmtnZ2MwZFYwam9TbGQzNWh6cGZyLzdmWWRRTXB6K1RVZjRLL0hJQ2xrbnBKMXR0NElJZkQ1b09WNFJIQVVFdHZNcThJS1gvTE5iMmJnRHJDZjBBMTZnLzUwcGIvOTJ4b0dvNVpRU0dBcDgvUDRIUUUrdnYzVU5jTjg0L216eTBFVTlzMTU0OXV6dTU0RE4vYWNsTGZYZ2grdW5GRG83Zit5QmZJUmxXK0NCY2dzQzRQSEc0TFloWFYzYjZ5a2R5dmtDZ0FFRGV2K1M5eVlIaXYzUGozai9NQnJpNUlWQUNVR3lQRjNCQ2p3bk5kSW5CQ2pUeXdkaEIrS0c3Wmk4NE5peDNXcDNvTXYwMXlCc3RaUEZnSmhzMWtDNzBBcURrSUh3Z2dLMjAwaGEwWHNnUG53VXZjdUJiK3MyS0lhcmUrYUc3OXFDMDk3dGpaRDJWSDEzVkcxbTZMeVJzZUJKUk1HMFZ1ZjdaVXZUSVFpTGwxeFpnRThudldoTTBWb3VlTmxzdWlpbEVOSnVybDYrRm5Od2NuVHJJS3NPS0N6YW1nMmFQdm5yWnpWZDhUbW9Ob1BlMW1FYkttVTFReEsyN3ZRbC9qUmoyeUtrVW9RMlkxbU5uUmtabzJTcy8yZXlTNURvTDBFUkVyc1lHS3NHQ1psajJzdzRySE4yV2xxVURZbUhlQ1hYTVpjZjdZeHZJTGV0bTFmdkhOeVZFYkR2cGdTSmxlZkYwaE1PdUZSOU03OWZDZG5GY2VtVGI4WlZEZ3czRFNnWk1hTGY4bVBBTzdzM0QwMk5zWXl2cEwzRzI3YzFDUkN0YlgzMzNpanlHeU1LL3NyYWFYNTFFM0NCVU5LWXJ1RVp2aUF1Q2NtUXVUVUxsNVc4L3N3ZHlwaXlyM0FhdGhBa0VJeXAwWVVheStPc2lmSldFWkxNclFZaHp6TGE3SUREZkdTbW5kRmhOVnppRGpUam5WdWRQZTB5VjREdjlYYlc2WTIzYi95ZXl6dWF5S3Q1VzNvS2E3V2pkVlZwNkV6emNPTzl4emczVjR1cnk3anV2cjZVcVYvQVFmZkV5Ui9YN3ZVMWVSMmdXWm1jaXlqalY5dFhjbGFmMnp2bkFaRGoyUFk4cW5OYm1yRXptSndyMnVhQWZ2M2h3aHVhQXJLUno4QnJxY0pONWgrUTJ2UlAvQlorSVMzMndXendnMllYbVBoa2N2Z0lrcGd5dnh5dlpUdXNHdnBzeWhJYmhWY1pucFdoMDlXTHhVVnF6ZzNtdThiaFVrcGg3dUFGMjJzVzRVdlZaUlBqNUI1TGlHQnBJa0NCQlZKT0ErUmsrT2psWmZZR2Fsai83Z1NkV0FZRVVieG9saTBBMFZKRkE5dWxxRHNxeUpLWkE4aFd5aGU3WDBSTThyOWM1SnkwQUFCNDJtTmdaR0JnQU9KcHhuZDJ4dlBiZkdWZ1ptRUFnY2YyQzRNUTlIOWQ1a2ltUzBBdUJ3TVRTQlFBTXlBS2x3QjQybU5nWkdCZ1p2alBBQ1JMR0hRWStKa2pHWUFpS0lBTkFEWklBaGtBQUFMR0FBQURkQUJLQWpvQUxBTDRBRDhDbHdBeUFxd0FMZ0FBQUFBQVlBRE9BVFlCcmdJSUFBQjQybU5nWkdCZ1lHUHdabUJtQUFGR0JqUUFBQWlLQUZkNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjBBQW9BQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFWUFBQUJnaGN4NEJXTnRZWEFBQUFFOEFBQUFNUUFBQUR3SElQMGZaMng1WmdBQUFYQUFBQUNzQUFBQTBGNldrLzFvWldGa0FBQUNIQUFBQUMwQUFBQTJLSEtHV1dob1pXRUFBQUpNQUFBQUhRQUFBQ1FHQVFJbmFHMTBlQUFBQW13QUFBQU1BQUFBREFlQUFIMXNiMk5oQUFBQ2VBQUFBQWdBQUFBSUFDb0FhRzFoZUhBQUFBS0FBQUFBRndBQUFDQUFCUUFyYm1GdFpRQUFBcGdBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFEYUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtYW1DY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdFRWpBeEpJS1M1TEIwb2FNaTlnWnZnUDVETXpNSUtFR1JFcS9nT0ZBZlkxRGNRQUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZzBnRFFia0dZRXlob3lML2ovSDhnSDAvOHYvRWtDcXdJQ0FKazVDVDBBQUFCNDJtTmdaSWhtWUdCY3k3U2FRUUpJQzdLSldUT0txaXV6bXhvYm1ha0w4akdxbTRxWm1adUpNZW95S3pncEJxNEtWSFNXWjliMEVaVEpNUlprWityL2UwaEdWSUdaV1VGVWhrbEltSU5SbmtsVW41RUxhQXlERWdNRDAxMm1IUXlhbUdZcW92SE4xTFFaVFJWRmxaWFltRXFZcEN3bHZHZDZTVnBJTS8wN3l5UnRJUW5rU0ZoS01ZSEVtWGFEV0JsL1g4aUlnS3dVa1dIeS9Mc2R6cGFRRVpXWEYyVmdBQUM3UnlGc2VOcGpZR1JnWUFEaW1HYkpuZkg4Tmw4Wm1Ga1lRT0N4L2NJZ1pKcnBMdE1PSU1YQndBVGlBUUFJTlFrbkFBQUFlTnBqWUdSZ1lHYjR6d0FpR1pRWWxKbnVNZ0JGVUFBekFEVm5BaThBQUFBQ2dBQUFBZ0FBV3dNQUFDSUFBQUFBQUNvQWFIamFZMkJrWUdCZ1p0QmlBTkVNVUJJSkFBQUUwZ0F4QUhqYVJZd3hiOEl3RUlXL2lBU0pkT2hTZFdBQUQ4eFdvakIzWVdCaVpXSUJiS0lNY1pBVElpR2hqdjNkUFl3bGJuajY3cjEzQitUOGt2Q2NoTStnejBuSlpIdHh4Z2Rma2FleUxTUG56Rmt4SVVsbjRpejRpWnhLY29pYzhjMGw4bFQ4UitTY05YK2JycjNlQnV2VnJqUFd1M1ByeTJKdmZkOTBUcFc2Q1B2V091dVBnelhxZEZkbWJQcXhibFdsQzEyeG9hUGx5bzBCaTBleEU4Y0VkcHdsODVRVTdJUFQwMGpxcEZXaXhYM25XOGxkNkJ6REp5T2RFM2RSd3loWHZXZ3RiVVVWTGpYVlAyTTlMdzhBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNy40ODI5NzcsLTIyLjAyNjc5KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTkuNzU1NzQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE3LjQ4Mjk3NywtMjIuMDI2Nzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE3LjQ4Mjk3NycgeT0nLTIyLjAyNjc5Jz7OoDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTAuMDEwOTc4JyB5PSctMjAuNTMyNDA5Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0zLjE1MzY5NycgeT0nLTIyLjAyNjc5Jz5nPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yLjUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNy40ODI5NzcsLTIyLjAyNjc5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xNy40ODI5NzcnIHk9Jy0yMi4wMjY3OSc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC04LjM1NDE2Vi00OC41NTEzNScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguODAxMzUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjI2Mzg5LC0zMC40NTI3NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE3LjQ4Mjk3NywtMjIuMDI2Nzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OS41MzI3NiwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTcuNDgyOTc3LC0yMi4wMjY3OSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTcuNDgyOTc3JyB5PSctMjIuMDI2NzknPkM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTkuNjQ5ODYzJyB5PSctMjUuNjQyMTU0Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ5LjQyMDYxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTcuNDgyOTc3LC0yMi4wMjY3OSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTcuNDgyOTc3JyB5PSctMjIuMDI2NzknPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTkuNDI2MzY5JyB5PSctMjUuNjQyMTU0Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xNC4zMTEyOCAwSDQ0LjQ3NzIyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ0LjcyNzIyLDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjkuNjQ0MjQsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE3LjQ4Mjk3NywtMjIuMDI2Nzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS02LjQwOTczVi00Ni41ODM1MScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ2LjgzMzUxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMjguNDk2NjEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNy40ODI5NzcsLTIyLjAyNjc5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0xNy40ODI5NzcnIHk9Jy0yMi4wMjY3OSc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTMuMzQ2MDI3JyB5PSctMjUuMDMzMzA3Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J003LjA1NTU0LTU2LjkwNTVINDQuMzY1MDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDQuNjE1MDcsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIxLjU3OTg4LC02Ni41NzI4NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE3LjQ4Mjk3NywtMjIuMDI2Nzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTE3LjQ4Mjk3NycgeT0nLTIyLjAyNjc5Jz7PgDwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTIuNTczOTExJyB5PSctMjUuMzk3NDY2Jz7igKA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTEyLjgyNDEzMicgeT0nLTE5Ljg2Mzg2NSc+MTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTAuNDE1OTIsMzcuNzM4MyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE3LjQ4Mjk3NywtMjIuMDI2Nzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE3LjQ4Mjk3NycgeT0nLTIyLjAyNjc5Jz7OoDwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTAuMDEwOTc4JyB5PSctMjAuNTMyNDA5Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy0zLjE1MzY5NycgeT0nLTIyLjAyNjc5Jz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDEuMzM2ODcgMzEuODg0MTJDLTQ2LjAzMDgtMy4wNjAwMy0zNC45NzEwNC0yOS45NTg3NC03LjQ1MTQtNTEuMTkwNTcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43OTE3MiwtMC42MTA4MSwwLjYxMDgxLDAuNzkxNzIsLTcuMjUzNDgsLTUxLjM0MzI4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDEuOTUyNDgsLTIyLjUwNjQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xNy40ODI5NzcsLTIyLjAyNjc5KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xNy40ODI5NzcnIHk9Jy0yMi4wMjY3OSc+ITwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2UtZGFzaGFycmF5PSczLjAsMi4wJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KPHBhdGggZD0nTS0zMS44ODQ1MiAzMS44ODQxMkwtOC41OTI5NiA4LjU5NjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTUsLTAuNzA3MDMsMC43MDcwMywwLjcwNzE1LC04LjQxNjE3LDguNDE5OCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNLTMxLjU3MTk2IDE0LjMwODAxSC04LjU1MTk0VjI2LjA5NjkySC0zMS41NzE5NlonIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yOC41NzE5NiwxOC4zMTM1OCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE3LjQ4Mjk3NywtMjIuMDI2Nzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTE3LjQ4Mjk3NycgeT0nLTIyLjAyNjc5Jz7OoDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTEuNjAyMjExJyB5PSctMjEuMDI0OTc3Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy01LjcwNTg2NicgeT0nLTIyLjAyNjc5Jz7OsTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS0yNS41MDUxMyA0Mi4xNzU3QzYuMjE0MDIgNDUuODYzODIgMzAuMzIxMjYgMzUuNDQ3NDggNDkuMDc2NTggMTAuMjIzMicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjU5NjY1LC0wLjgwMjQzLDAuODAyNDMsMC41OTY2NSw0OS4yMjU3NCwxMC4wMjI2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxOS45NDgzMyw0MS4xNjQzNCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE3LjQ4Mjk3NywtMjIuMDI2Nzkpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTE3LjQ4Mjk3NycgeT0nLTIyLjAyNjc5Jz7OsTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTIuMzAzNjM2JyB5PSctMjUuMDMzMzA3Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02LjQwNzI5JyB5PSctMjIuMDI2NzknPs6yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw = {\Pi _{B}g},
        nw/style = {pullback},
        ne = {C^{B}},
        sw = 1,
        se = {B^{B}},
        east = {g^{B}},
        south = {\pi _{1}^{\dag }}
      }
      \node  [above left = of nw] (pif) {$\Pi _{B}f$};
      \draw  [->,morphism,bend right] (pif) to node[swap] {$\mathsf {!}$} (sw);
      \draw  [->,morphism,exists] (pif) to node[desc] {$\Pi _{B}\alpha $} (nw);
      \draw  [->,morphism,bend left] (pif) to node {$\alpha ^{B}\beta $} (ne);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Note that</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {align*}       g^{B}\alpha ^{B}\beta  &= (g\alpha )^{B}\beta  && \text {functoriality of $(\mathord {\hspace {1pt}\text {--}\hspace {1pt}})^{B}$}\\                   &= f^{B}\beta \\                   &= \pi _{1}^{\dag }\mathsf {!}     \end {align*}   ]]></fr:tex>
  <fr:p>Let any morphism <fr:tex
display="inline"><![CDATA[\alpha \colon B^{*}(A')\to f]]></fr:tex> be given.</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="46ff9a61cbcb1b3d9e4c6fdf32196ba6"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzEyNi4zODY4MDlwdCcgaGVpZ2h0PSc4NS45NTIyNzlwdCcgdmlld0JveD0nLTcyIC03MiA4NC4yNTc4NzMgNTcuMzAxNTE5Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT3NBQW9BQUFBQUJCd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFMEFBQUJncW1OaWUyTnRZWEFBQUFGRUFBQUFNd0FBQUR5ZVdtUmJaMng1WmdBQUFYZ0FBQURnQUFBQTdEME5RbHRvWldGa0FBQUNXQUFBQUNzQUFBQTJLZXFHQ1dob1pXRUFBQUtFQUFBQUh3QUFBQ1FGN2dEYWFHMTBlQUFBQXFRQUFBQU1BQUFBREFrS0FPMXNiMk5oQUFBQ3NBQUFBQWdBQUFBSUFGUUFkbTFoZUhBQUFBSzRBQUFBRndBQUFDQUFCUUEyYm1GdFpRQUFBdEFBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEb0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtWm1hY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFBNE1EakoxU1hKYk93S1lrL3NDQVdldVBKUU1Ec3hiemNhQXdJMEwxLy84TURBRG90dzdmQUFBQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWm1SZ1VoSi9ZUEQvUHdNRGhMNzdTdjRTV0JVUUFBQ25pUW15QUhqYUxZNVBTc1F3SEVienBjTXZWTlBhUDJuU29rN0hES2E3a1NsMUNpTDFFb29ic1lqUXZXdHZvT0FSUm5EbkdieUd5em1MbU1Xc0h0LzdObytCZmJBbGY4YU9kWXloMzdSYTBSRzAwU2FHdTBBTkVpdDBOeERVV09mcEd0Y01hR3MwN3JMYjlOb0l2SDNLU3FYMGZYK1hjNmdxL0lxSTJ6UW4rWDVPVVZGNnJ6aUtNdHBLeWxQTEQzRThoc3JHZkRnOUUyV21RRS9UMVR4QVp0YlRiUUZsay8wUmp0UDZJTXJBNjBlZnhrYlc0SlZmczhTUGdKYStvODhIOUswMkpQRHlTMUxud1d3YlZQUEtBVFBzL2g1U0lhSUVQL0VDaXhNcDJUOXVmQi9RZU5wallHUmdZQURoZnFtajhmdzJYeG1ZV1JoQTRMSDl3Z3hrbWlXVXlRWkljVEF3Z1hnQTg3NElEZ0I0Mm1OZ1pHQmcxdnBqeWNEQUVzb1F6K0RCbE13QUZFRUJ6QUJJZFFMTkFBUlZBQUFDOGdDT0FjTUFYd0FBQUFBQVZBQjJlTnBqWUdSZ1lHQm1NR1VBMFF4UUVna0FBQVhsQUR3QWVOcE5qRDF2d2pBUWhwK0lCSWwwNkZKMTZBQWVtSzJnbEpXRmdZbVZxUXRnZ3pMRVFYYUlGS25xeU8vdTRYcm9EYWZuL2JnRFNuN0llRTdHYTl6UHlTbEUvWEhCQzIrSnA2SVdpVXMrV0RJaHkyZml6TmtremlYNVNsend6aVh4VlB6dnhDV2ZQTFpkZTd2MzFxdDlaNngzNXphTTY0UDFvZW1jV3VrcTZwMTExaDk3YTlScFZHWm93bkJ0VmEwclhiT2xvK1hHblI2TFI3RVh4MFIybkNVTGpLdzVSQ2ZRU09xa3RVSlQvY3Qza3J2WU9jWlBSam9uU1pUUUlGZEI5bFhhaWpwZWF1cGY3K2t3UndBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVY0QUFvQUFBQUFCbEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hkeDRqbU50WVhBQUFBRThBQUFBTlFBQUFFUUFld1JlWjJ4NVpnQUFBWFFBQUFLZEFBQURES2hMTVRWb1pXRmtBQUFFRkFBQUFDOEFBQUEyS08rRjFtaG9aV0VBQUFSRUFBQUFIZ0FBQUNRR2xnSkthRzEwZUFBQUJHUUFBQUFVQUFBQUZBN2NBUTVzYjJOaEFBQUVlQUFBQUF3QUFBQU1BWFlDUG0xaGVIQUFBQVNFQUFBQUdBQUFBQ0FBQ1FCQ2JtRnRaUUFBQkp3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRmJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbStzRTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFIwWk43SXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBbHVRNWRBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdNZ0RRSEVJTGtuQmpTbURmKy93OWtPVUpZL3cvOG4vc25HS3dXREFEMWx3dldBQUFBZU5wRmtzOVBFMEVVeCtlOTJlNjJ1M1YzdTkxTzB3SmJ0bHQyVVNuRkx1eENoZkl6Q0JSRXdBVGJtR0NNZ2FBa21oZ05pUnBENGtFdnhoZ1BIcnh3TUNIZVREeHkwMzlBUFduOE0vUW1yYk1teHBsa011OTlEL1A5Zk9jUkpMVk9oMDdnZCtLVGdKQVFnckRLc21tVCtWV1dNYVVLU0lNd1VvZHNIVUxQMWtETVdPQm5XVllGcm9oZUhYd3UyUFFyN01zNU5ZNHRkamFwbTdXSko3SUllbUlnRDduMmozVlpSQ2V1aUFCYWJQZEtrb0lXSHpoL0NOTFFBMXhna0V5ZFBFdXJncElCQ2dMSU5DVUJwT0x2SGh0S3dsU1FKbmd0Q0tCckVqMXpES3VFVUxMVStVMmJlRXhzVWlaajNIRTZETndLT0tJYlpHMEx1RE9KbnlLM0t0bFJqd1hweUdQZ2VvNHJTdlRmbllyczQxTUJFbnBPTFlDaHdyMGJ0NEVlYksxZkJWd3hOaDYyNzNaajZ0Ull6OUhSN2lQQWtaVTNCVDEyNSszV0FZWDZ3cmNHSkM5aEw1TkVvRUpSQXR3WW45czI1TFhSeHJSYXA0TERDUXlZbzNzejlnVUJWSGJ5SHZkV0swdlkvaUpSUW9BME9oVzhpWi9KRkM5b1pKTTdMcnBSbEN6TFJJa1ZvQTZUOUM5UFpKYjNxMUhlanV1NVFjaEpWZFRBRDVqb3dXRk5GL1I4WXZwY2Z3MmdsSEY1dEFWTjAwbzI3Um5VbGkxTWEydGFSbVV6enVseEFJZHhYYmMwelRBc09aN2ZpbVI0MWY2MGxKb2FObWVwNjFpOVdCSTlKWUVnTkRLdmYyMVNqcmJaN1BMY3Z0Si9DWEp1K2JsUWpBUGhDOGxrNXlkK2dFOWtNS0xwc3lCa1FUZ2N6WWNwU3FMcnFkSDBlRUVZYmY0cEhDM2dQQVd3SU9MMlhJK3JiaFJBMXVUc0FRNEpUSkZMU1lOUGoxL08xYzJCL1lYV05SVG1VK2JhenNYZEpBTE9kc2NrbWN2NVJPR2xBRUpzYUtKcnBjL2pEL3VGK3k5YS9RSVkzUXFnYlBpSVR1RDRnRHVMMTFkTmZZNUNhMW14cTVlM2RSa1FNL09weFZ2TmlsTnRVbkRLb3dkZHd4T0F4VDk1b0hRSEFBQUFlTnBqWUdSZ1lBRGloMmQzYXNiejIzeGxZR1poQUlISDlnc3pFUFIvZmVaSXBsdEFMZ2NERTBnVUFFSGlDdjhBZU5wallHUmdZR2I0endBa1N4aXMvbDlnam1RQWlxQUFWZ0JkU0FQbUFBQUN4Z0FBQTNBQU9nTjBBRW9DT2dCTEF2Z0FQd0FBQUFBQVdBQzRBUjRCaG5qYVkyQmtZR0JnWlhCa1lHWUFBVVlHTkFBQUIzVUFUSGphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9DQ3hkV0ZnWW1YcUF0aEZHV3dqSjBSQ3FqcjJkL2RoUFBRTlYrZCsyRURORHdYM0s1Z2x2VjlKSmU3QkZWUG1tU2ZpM2pMWExIam5pYUo4bHVTVmo4eWxOSitaSzE3NHlqeVIvRHR6ellyZlRYQ1g2MkNqMmdWam96ODUxNjMzTnZaZDhHcXBtK1MzMXR0NEdLeFJ4NXN5WTllUFo2ZGEzZWlXRFFISGhTc0Rsb2hpSjRsSjdEbEo1K2hZczA5Skx4d2tWeXpSTlAvNnJmUStiUTdwSnlPYkl6ZFJ3eWlMWHZRc1cwV2JYbXJhUDh1aEwvY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNRUFBb0FBQUFBQTJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVzQUFBQmdhRHBoMldOdFlYQUFBQUZBQUFBQUtnQUFBRFFBRE9DRFoyeDVaZ0FBQVd3QUFBQkFBQUFBUUViVG8xaG9aV0ZrQUFBQnJBQUFBQzBBQUFBMktTYUdDV2hvWldFQUFBSGNBQUFBSGdBQUFDUUVoLy9qYUcxMGVBQUFBZndBQUFBSUFBQUFDQVRpQURGc2IyTmhBQUFDQkFBQUFBWUFBQUFHQUNBQUFHMWhlSEFBQUFJTUFBQUFGd0FBQUNBQUJBQVFibUZ0WlFBQUFpUUFBQURPQUFBQk9CTi9LcnR3YjNOMEFBQUM5QUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1LbVNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4SUlBQUVqdWx1Q3lkZ2UyQndRTURac1UvUmd3TXpJck01NERDakFnVi8vOHpNQUFBSFlzUDBRQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytROE0vditIa1BJWHdmSU1BR1J5QjJ3QUFBQUJBREVBSndFMEFqd0FEZ0FBQVFNR0xnRW5OeE0rQVRjZUFSY1dBU25CQnhBZUFnV0hCQmdkR0NNQkFnSGovbGdVQXcwS0VBRzdEaUVCQVI0WkNBQjQybU5nWkdCZ0FPSmRYM01FNC9sdHZqSXdzekNBd0dQN2hSbklOUE5FSmhzZ3hjSEFCT0lCQUJvQkNRY0FBQUI0Mm1OZ1pHQmdWdnhqQkNRbk1oZ3l5REthTUFCRlVBQVRBRUVhQW00QUFBT1JBQUFCVVFBeEFBQUFBQUFnQUFCNDJtTmdaR0JnWUdMZ1p3RFJERkFTQ1FBQUFoUUFGUUI0MmsyTVBXL0NNQkNHbjRnRWlYVG9VblhvQUI2WXJhQlVZbU5oWUdKbDZnTFlvQXh4a0IwaVJhbzY4cnQ3dUI1NncrbDVQKzZBa2g4eW5wUHhHdmR6Y2dwUmYxend3bHZpcWFoRjRwSVBsa3pJOHBrNGN6YUpjMG0rRWhlOGMwazhGZjg3Y2NrbmoyM1gzdTY5OVdyZkdldmR1UTNqK21COWFEcW5WcnFLZW1lZDljZmVHblVhbFJtYU1GeGJWZXRLMTJ6cGFMbHhwOGZpVWV6Rk1aRWRaOGtDSTJzTzBRazBranBwcmRCVS8vS2Q1QzUyanZHVGtjNUpFaVUweUZXUWZaVzJvbzZYbXZvWDgza3dUd0FBZU5wallHWkFCb3dNYUFBQUFJNEFCUT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNOEFBb0FBQUFBQTZRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdpT1J6RzJOdFlYQUFBQUZBQUFBQUtRQUFBRFFBREFFcVoyeDVaZ0FBQVd3QUFBQjRBQUFBZUpNU1BKRm9aV0ZrQUFBQjVBQUFBQ3dBQUFBMktMR0Z4V2hvWldFQUFBSVFBQUFBSGdBQUFDUUdOZi9kYUcxMGVBQUFBakFBQUFBR0FBQUFCZ093QUFCc2IyTmhBQUFDT0FBQUFBWUFBQUFHQUR3QUFHMWhlSEFBQUFKQUFBQUFGd0FBQUNBQUJBQWtibUZ0WlFBQUFsZ0FBQURUQUFBQlBxODNkZUZ3YjNOMEFBQURMQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1sbUdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFVEF4SklLUzVMQjBwZVo3ak9MUFZIazRHQldZcjVPbENZRWFIaS8zOEdCZ0RyblE3dkFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hDQytOZi8vNGVRLzdYQWZBWUFYdVVITXdBQUFBQUJBSlFBQ1FLR0FmZ0FJZ0FBQVRjMkZ4WVhCZzhDSHdFV0J3WUhKaThCQnc0Qkl5WW5KajhCSnlZM05qY3lGd0dPeXc0S0V3RUNBeHE3cFRJRUFRRVRDd1hVeXdrSUJoRURBeEROelJBREF4RUdCQUVkeWhFQkFoTUtBeHE3cFRJSUF4TUNBZ1RVeXdvRkFoTUhEYzdPRFFjVEFnSUFBSGphWTJCa1lHQUE0cFg1ZHMzeC9EWmZHWmhaR0VEZ3NmM0NER1NhV1lieEI1RGlZR0FDOFFBTXVnajZlTnBqWUdSZ1lKYjZvd2trWlJpbU1FeGphbU1BaXFBQVJnQk15Z01YQUFBREhBQUFBSlFBQUFBQUFBQUFQQUFBZU5wallHUmdZR0JpVUdZQTBReFFFZ2tBQUFRSUFDa0FlTnBOanJGcXd6QVFoajlUeDFBbmtLa2RPaFJOR1lXTjh3Q0ZESm15Wml3a2tRZ09XQTZTWS9CUzhnQjk2RjRVRFQzQjhlbS83NFNBa2g4eUhwV3hqUDFST1lYY25qeGp6bHZpUW81S1hQTEJpaGV5L0ZXU1Q3NFM1eXo0VGp6am5VdmlRdko3NHBJMXY1dSt1OTRHNjlXdU45YTdVeGVtdXRwYkg5cmVxVnBYejJCcm5mV0h3UnAxbkpRWjJ6Q2VPOVhvU2pkczZPbTRjbVBBNHVWbk8wbE1aTWRKWm9HSm1vcDl6QUt0ekoxNE5WclMvOFpXREJldFEzek5pSFdVbVJJYVpTOUlQNHV2YU9LdXB2a0RDVkV4RXdCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUM0QUFBQTJLR21Gem1ob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0dU4rTTlmSDg5dDhaV0JtWVFDQngvWUxNeEQwZjBhbXk4d2dMZ2NERTRnQ0FESUZDajRBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRTUFBb0FBQUFBQkpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngwKzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRkxBQUFCWURtU3NUSm9aV0ZrQUFBQ3NBQUFBQzhBQUFBMktKeUdwMmhvWldFQUFBTGdBQUFBSGdBQUFDUUdMQUlPYUcxMGVBQUFBd0FBQUFBTUFBQUFEQWgrQUU5c2IyTmhBQUFEREFBQUFBZ0FBQUFJQUZRQXNHMWhlSEFBQUFNVUFBQUFGZ0FBQUNBQUJ3QTZibUZ0WlFBQUF5d0FBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVBQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c0k0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEeUtRMUhlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyaldQTVUvQ1FBQ0Y3OTNCSFdEYlExdmFHQUZUUVpwb0ZFTkpLd3dNS21nMEVwVEVNSkNZbUNpYmcwRmNHUmgxTWpGeGNuSHpCN2c0T2ZrbkhJeWp2d0d3TmZGTkwxL2U4RDFDU1g0NnBWLzBreFJKaVJBZm5sOHlMZDB3WGMva1JRaW40SlE5eS9UOEltekJEZFB5TEEwQkQ3RmJnKyt5VjV4elErV29tV3NwS05IK01CYUZPcU9YV1Z4TXBrMDFyYXNNYXJUWFVhREVsMnFQUC9hQW5pUVJsK09oS1ZsR2dESFFtQlNBWWwzVVIwWStDU28xSHVLRTVNaDk0SmdFWVdSMU9tYWN2cEVzV1NHYmdhbGV6ams4Y0xPelNHa1FXVmhjZ2d1Yi8vbnFvWnhYY0hJRkx0aC9aOEhBZmI1YmNESlNvdE05WThQMlFSdDBOM2w0UGJsUGExbzErL1J3MnFkWTN4NHQ2dEhMMis2QTBvMjk5MFlFMEZxME1rdFpXb0FlVmZkN010R3NIR3hwdFVqNEFEcnE3S3FSMzZHUTgrTVhkdE5jYnJISjl4eFBrRit6dlR1REFIamFZMkJrWUdBQTRqWXpaOXQ0ZnB1dkRNd3NEQ0R3Mkg1aEJvTCsvNWVaamVrdWtNdkJ3QVFTQlFBT0RRb3BBSGphWTJCa1lHQm0rTThBSkRrWVZCaVltTmtZZ0NJb2dCa0FJOGNCUWdBQUFuWUFBQU1BQUNRRENBQXJBQUFBQUFCVUFMQjQybU5nWkdCZ1lHYXdCR0lRWUdSQUF3QUdkd0JDQUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5MTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUyLjQ2MDQ4NCwtNjMuMzU0ODcyKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE1LjMwNzI1LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Mi40NjA0ODQsLTYzLjM1NDg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTIuNDYwNDg0JyB5PSctNjMuMzU0ODcyJz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy00Mi4xOTAwMScgeT0nLTYzLjM1NDg3Mic+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMyLjIyNzM5NycgeT0nLTYzLjM1NDg3Mic+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMjQuNzU1Mzk4JyB5PSctNjYuOTcwMjM2Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTMuMTU1NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNDYwNDg0LC02My4zNTQ4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUyLjQ2MDQ4NCcgeT0nLTYzLjM1NDg3Mic+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyOC40NTI3NCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTIuNDYwNDg0LC02My4zNTQ4NzIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyNC40MDkzNSwtNDUuMTc5MTIpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Mi40NjA0ODQsLTYzLjM1NDg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTIuNDYwNDg0JyB5PSctNjMuMzU0ODcyJz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J000LjgyODcyLTcuMjQzMDRMMjIuNjgyMTMtMzQuMDIwMScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjU1NDcyLC0wLjgzMTk3LDAuODMxOTcsMC41NTQ3MiwyMi44MjA4MiwtMzQuMjI4MDkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNC45MDIxOSwtMjkuNDQ2OTMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Mi40NjA0ODQsLTYzLjM1NDg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTIuNDYwNDg0JyB5PSctNjMuMzU0ODcyJz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00Ni4xMDEzMjInIHk9Jy02Ni4zNjEzOSc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00MS45MzYzNTMnIHk9Jy02My4zNTQ4NzInPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTM4LjgyMzAxJyB5PSctNjMuMzU0ODcyJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zMi44MzE1NDknIHk9Jy02Ni4zNjEzOSc+7oCwPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0zMC4xMzY3NzQnIHk9Jy02My4zNTQ4NzInPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTE5Ljg2MjggMEg0OC4wOTk5NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4zNDk5NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMxLjYzMTk5LDIuODExODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Mi40NjA0ODQsLTYzLjM1NDg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTIuNDYwNDg0JyB5PSctNjMuMzU0ODcyJz7OsTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTIuNjMyMzItNi40MDk3M0wzNC4yMjMzNi0zNC4wMjAxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KC0wLjU1NDcyLC0wLjgzMTk3LDAuODMxOTcsLTAuNTU0NzIsMzQuMDg0NjcsLTM0LjIyODA5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0Ni41NTMwNSwtMjguMDk1ODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Mi40NjA0ODQsLTYzLjM1NDg3MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNTIuNDYwNDg0JyB5PSctNjMuMzU0ODcyJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (1) {$B \times  A'$};
      \node  [right = of 1] (2) {$A$};
      \node  [between = 1 and 2] (ref) {};
      \node  [below = 1.5cm of ref] (3) {$B$};
      \draw  [->,morphism] (1) to node[swap] {$B^{*}(A')$} (3);
      \draw  [->,morphism] (1) to node {$\alpha $} (2);
      \draw  [->,morphism] (2) to node {$f$} (3);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Then this morphism corresponds to a unique morphism <fr:tex
display="inline"><![CDATA[A' \to  \Pi _{B}f]]></fr:tex> as follows:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="685275cf6ed15cd0e2f68b59fa35d7dc"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE4NC41MzE2NjZwdCcgaGVpZ2h0PScxODAuMTczNzUzcHQnIHZpZXdCb3g9Jy03MiAtNzIgMTIzLjAyMTExMSAxMjAuMTE1ODM2Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNWUFBb0FBQUFBQTRRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVNQUFBQmdoVXgxRzJOdFlYQUFBQUU0QUFBQUtRQUFBRFFBREFDRVoyeDVaZ0FBQVdRQUFBQmtBQUFBWkRGdUFySm9aV0ZrQUFBQnlBQUFBQ3dBQUFBMktPZUdXR2hvWldFQUFBSDBBQUFBSGdBQUFDUUZ5d0xXYUcxMGVBQUFBaFFBQUFBSUFBQUFDQVlLQUpKc2IyTmhBQUFDSEFBQUFBWUFBQUFHQURJQUFHMWhlSEFBQUFJa0FBQUFGd0FBQUNBQUJBQWdibUZ0WlFBQUFqd0FBQURLQUFBQk11c0lrZVp3YjNOMEFBQURDQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1abVdjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0FFakF4SklLUzVMQjBvYU1oZ3lNL3dIOHBraDBraHEvZ09GQWFOM0RGZ0FlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aUcvLzlEeVA4WHdId0dBRkZIQm8wQUFBQUFBUUNTQUFBQ053S3JBQjRBQUFFUkJoWTdBUlVtSnlNR0J6VXpNalluRVE0Qkp5TTFNeFkvQVRZM05oWUJtQVFpVGpNc090RTZMRE5PSVFNdVZCTVNFaEkrQno4NUdBNENpLzNORnhRdEF3RUJBeTBVRndJQUVnd0JMUUlLQWdvdUFRa0FlTnBqWUdSZ1lBRGlIL3dGclBIOE5sOFptRmtZUU9DeC9jSUlaSm81aUdrMWtPSmdZQUx4QVBvR0NHZDQybU5nWkdCZ1p2alBBQ1NER0NZeE5ES1pNd0JGVUFBVEFFTGNBcWdBQUFOU0FBQUN1QUNTQUFBQUFBQXlBQUI0Mm1OZ1pHQmdZR0tRWndEUkRGQVNDUUFBQTZRQUpRQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVxZm01dURrNnZEMjZ3SjBxR3BwTFhvSXY1MGIwUHdCZzdmUGVmY0FCa3ZFb1pKbUFjZEpwVTNqenptaDBYa2lmaXJ5Qm0vckJtUnBETnhWdXdpcDB6NWp6eG1TUmw1SXY0amNzWWY3MzFUMys2ZDllcllHT3ZkcGZiYmsvVnQxVGkxMGZtd0hxeXovdHhabzhxbk1uM1Y5dGRhRlRyWEJYc2FhbTdjNmJCNEZFZHhUR0RIUlRMUGxsUFlXeXJKbkhRMmFQSnZlcERVaGNZNS9HS2tVZklVTmZSeTA0cGVwYXNvd3AybStBQlZNaTVEQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU9FQUFvQUFBQUFBL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWMTE1R050WVhBQUFBRTRBQUFBS1FBQUFEUUFEQUNWWjJ4NVpnQUFBV1FBQUFERkFBQUF6SFVYTGMxb1pXRmtBQUFDTEFBQUFDOEFBQUEyS1c2R2FHaG9aV0VBQUFKY0FBQUFId0FBQUNRSFZnTjNhRzEwZUFBQUFud0FBQUFJQUFBQUNBZDZBSHhzYjJOaEFBQUNoQUFBQUFZQUFBQUdBR1lBQUcxaGVIQUFBQUtNQUFBQUdBQUFBQ0FBQmdCQmJtRnRaUUFBQXFRQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRGRBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbTNzczRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWW5CaVp2Z1A1RE5EcEpIVS9BY0tBd0RxU3cweWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZoTy8vOUR5UC83d1h3R0FGS3NCcDRBQUFCNDJtTmdacWo1LzUvNUJ0TWVCZzBHRXdaN0JnWnpZWE5UTlgxR05qVlRFek54UlRsR2NUWjJFSlJqWkljd0ZDRXlSbWJDeG5hTTVpWnE2c3BxYk96TU1EWXorNzgyWmtFUkdXRmhFUUhHeGRrdFRDek92QUtlbmhrSmpNeEJQUHpSemYrYytVVEVSTTFsTnh6SzdXUHk5Tmt0TDhpU2N6UmxJb3VmM3k4MzVsQW1TUjVlRmtaR1JqWmVFVTVHeG1CSE4xMHVUZzFPL2pCRGJ6c3VUaXRtUmpZZVVVNUdBVVo3NWlSSExUc21SaDZ4djRlWUVuMk1QSm4rdlJSbVlBQUFtdVFtYXdBQUFIamFZMkJrWUdBQTRvaldoOC9qK1cyK01qQ3pNSURBWS91RkVRajYvMy9tRzB4N2dGd09CaWFRS0FCUjN3d2xBSGphWTJCa1lHQm0rTS9Bd01DaXhsREQ0TWQ4Z3dFb2dnS1lBRVNJQXRZQUExUUFBQVFtQUh3QUFBQUFBR1lBQUhqYVkyQmtZR0JnWW5CZ1lHWUFBVVlHTkFBQUJ3c0FTSGphVFl3OWI4SXdGRVZQMUFTcFlXQkJIUmhhRDUydG9NRGFoWUdKbGFrTFlCZGxzSTJjRUFtcDZ0amYzWWZ4MERkY25mdGhBelUvRk55dllKYjBmaVdWdUFkWFRKbG5ub2g3eTF5ejRKMG5pdkpaa2xjK01wZlNmR2F1ZU9FcjgwVHk3OHcxSzM0M3dWMnVnNDFxRjR5Ti91UmN0OTdiMkhmQnE2VnVrdDlhYitOaHNFWWRiOHFNWFQrZW5XcDFvMXMyQkJ3WHJneFlJb3FkSkNheDV5U2RvMlBOUGlXOWNKQmNzVVRUL091MzB2dTBPYVNmakd5TzNFUU5veXg2MGJOc0ZXMTZxV24vQU1nUkwrOEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBWklBQW9BQUFBQUIxUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaGQxNGJHTnRZWEFBQUFFOEFBQUFQZ0FBQUV3RWN3UTRaMng1WmdBQUFYd0FBQU5nQUFBRUFPRkxYZHBvWldGa0FBQUUzQUFBQUM4QUFBQTJLTytGcm1ob1pXRUFBQVVNQUFBQUhnQUFBQ1FHaWdKTGFHMTBlQUFBQlN3QUFBQVlBQUFBR0JDdkFUUnNiMk5oQUFBRlJBQUFBQTRBQUFBT0E0NENiRzFoZUhBQUFBVlVBQUFBR0FBQUFDQUFDZ0JNYm1GdFpRQUFCV3dBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFHUEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtT3M0NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdJTkdCaVNRVWx5V0RwUjBZajdBelBBZnlHZG1ZQVFKTXlKVS9BY0tBd0FWdmc0OEFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ3NnRFFYQXdkUWpvbkJpU0dOZVJQemdmLy9nV0lnOWtZUSsvLysvM1ArQlAxeEJldUFBZ0J5Nmc2b0FBQjQya1dUejIvYlpCakgzK2Q1SGJ0MlhOdHhZcnRwRXFlSkU3dGxheExpeG1tNk5tblhySFJKdTY0VXFhUkM2cGhnMDlna0VML0VBZENLaE5RVElPREFZUWQybUxRckVpZkVqVjQ0c2h0L1JTL2JEUkllRnlIOFNxLzh2dDlYZXAvUDgvMitqTFBCNUM4K3dsOVppUzJ5RG1QdGREdnk2K0NKZnVTVVhIQTBrR2dXZFJDbFVyeG5SK213QzNRbThIeFI0di85YzlIKzdWUUEyY2hxUlRBMStPaXRkNEdmSEwvNkJ1Q3VlZkRwK0lNOHBxWTdoYWRQNzMwRzJOcDlWRFFTN3owNVB1SFEzZjV6Q09wTm5MTWxFYmhRbGdBUFZ2dDNUR1YvZWJpaGRibmdTUUFtOVBtRHE2VlhCTkRzdjMvQ0IzdjFBWTZmU1p3eFlNTkpIZC9CUDlnNkxYaGNKbFZjOW9NdWhMWmppNUpkaEM3MCtBVlBYQ3p0TjIyaTh2ekFqOXBFcXFFT1lXU0xBVHhlTVFSalZ0NTRlWDRGb0dMNUhQU2lydXVWRWkvVTlCMFgwL3ErYm1uMlZXOWhGY0N6U1RkY1hUZE5WNW1hUFk1bCtINThOa2l0TDJVMnVlKzVjMWdSZzZTTUlBeXRIMTRjY2tJN0hPVUN2MXI1WDRLc3YvaVZVSjRDUmgreTN1UTUvZ3huckJiVFZGMW8yMUY3S1hSc0p5TktvaDhRV1EyQ3FCMFBNb1hRSXVJcGdnc3hkK0FIcFBweEE1d01zVWZZRU95a1VsRk5SWVJ3TWR2TlhQNWsrK2dXQ2x1cHpQN2RHL2RVQk56TUp5U0Y1Rm01K0swQVFxS3hsdHV0Qm5SeFdQejRtNk41QWN4OEVsQXhRMFF2OGtMQXU5ZHY3MldNUG9lam5XU3ArZG9kUXdGRWF5dDEvZjZvN2pWSEhMekY1WlBjMGhwZ21YSFduQ3pqS1Q1amVSYXdBZmx6RVNhTFdHaFFyWnlZMHYvaU5HM0pqeUdJcWRtREd1WHY0aEFYTFJkaTI1YjhRQ1FQVzExd3lMNHU0Q2tmekFjTHdnM0RmUDN0N3RDNEpoVGdjYXFkZGphT3RtNzluczA1aGl6cU9WdDVCTXUxbXgxZGE2YW81c0hxbXc5eFpxWVd6bC9HVHY2bGhlbkdKZXozRHAzY1FlMytwcUYyQUZyVjhibU1LbjY1dFpPMU5vWGh1UWlBZ2tEVFdiMGhyQnZtZG45OHJobHJmZjcxKytVVlF3UFZ6RTNEVktKd204VlpyRTFlNEhmd0M0dG9JY1VaYS9Vb2ZlMzRwWWgxaUVOSmZqbWx5SFpJRFR4NlZiR05jV0twRXhjeWRIc3AxNjN3ekV4L3RtZnVMU1EwY2djdjJhV1dDMS9vZVhvaFR2YWhnZ2lXSVFNVXpHbExUVktLVlBqdytUWHFnUjQwZmp4RUoxUUJRWmF2Wk9Zc0FOblNaUlBieFhwdlZGQ1ZUQllnWFoyNzB2dThUaVgvQXpDSWwvVjQybU5nWkdCZ0FPSUU2ZkR2OGZ3Mlh4bVlXUmhBNExIOXdnZ0UvVitmT1pMcEVwREx3Y0FFRWdVQUdmUUtFQUI0Mm1OZ1pHQmdadmpQQUNSTEdQVCtYMkNPWkFDS29BQTJBRncxQTlzQUFBTEdBQUFEZEFCS0Fqb0FTd0w0QUQ4Q2x3QXlBcXdBTGdBQUFBQUFZQURHQVM0QnBnSUFBQUI0Mm1OZ1pHQmdZR1B3Wm1CbUFBRkdCalFBQUFpS0FGZDQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFBZ3NYVmhZR0psNmdMWVJSbHNJeWRFUXFvNjluZjNZVHowRFZmbmZ0aEF6UThGOXl1WUpiMWZTU1h1d1JWVDVwa240dDR5MXl4NDU0bWlmSmJrbFkvTXBUU2ZtU3RlK01vOGtmdzdjODJLMzAxd2wrdGdvOW9GWTZNL09kZXQ5emIyWGZCcXFadmt0OWJiZUJpc1VjZWJNbVBYajJlbld0M29sZzBCeDRVckE1YUlZaWVKU2V3NVNlZm9XTE5QU1M4Y0pGY3MwVFQvK3EzMFBtME82U2NqbXlNM1VjTW9pMTcwTEZ0Rm0xNXEyai9Mb1MvM0FBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTU1BQW9BQUFBQUEzUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFR4MEZXTnRZWEFBQUFFNEFBQUFLUUFBQURRQURBQjBaMng1WmdBQUFXUUFBQUJVQUFBQVZKNVA3NTFvWldGa0FBQUJ1QUFBQUMwQUFBQTJLR2lHaUdob1pXRUFBQUhvQUFBQUlBQUFBQ1FFVEFKQmFHMTBlQUFBQWdnQUFBQUlBQUFBQ0FRZUFHcHNiMk5oQUFBQ0VBQUFBQVlBQUFBR0FDb0FBRzFoZUhBQUFBSVlBQUFBRmdBQUFDQUFCUUFYYm1GdFpRQUFBakFBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFDL0FBQUFCQUFBQUFnQUFNQUFYamFZMkJtNG1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwb3FNaWd5TS93SDhwa2gwa2hxL2dPRkFhTDdERUVBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlLLy85RHlQOFB3SHdHQUUvM0JuMEFBQUFBQWdCcUFBQUE0QUxiQUFzQUZRQUFFd01PQVNJbUp3TStBVElXRXc0Q0xnRTJOeDRCNENnQkNCTUpBU2dDSWkwa0FRRWhNU0VDSUJ3WUlRS2ovanNQQ1FrUUFjUWFIaDM5ZlJraEFTQXpJZ0VCSVFCNDJtTmdaR0JnQUdJbHo1bi80L2x0dmpJd3N6Q0F3R1A3aFJISU5OTmxwdHRBaW9PQkNjUURBQmRzQ1o0QUFBQjQybU5nWkdCZ1p2alB3TURBZEpraGl5R2I0UUVEVUFRRk1BRUFWbGdEa1FMVEFBQUJTd0JxQUFBQUFBQXFBQUI0Mm1OZ1pHQmdZR0lRQTJJUVlHUkFBd0FDMmdBZEFBQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU1FQUFvQUFBQUFBMlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRXNBQUFCZ2FEcGgyV050WVhBQUFBRkFBQUFBS2dBQUFEUUFET0NEWjJ4NVpnQUFBV3dBQUFCQUFBQUFRRWJUbzFob1pXRmtBQUFCckFBQUFDMEFBQUEyS1NhRjZXaG9aV0VBQUFIY0FBQUFIZ0FBQUNRRWgvL2phRzEwZUFBQUFmd0FBQUFJQUFBQUNBVGlBREZzYjJOaEFBQUNCQUFBQUFZQUFBQUdBQ0FBQUcxaGVIQUFBQUlNQUFBQUZ3QUFBQ0FBQkFBUWJtRnRaUUFBQWlRQUFBRE9BQUFCT0JOL0tydHdiM04wQUFBQzlBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbUttU2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXhJSUFBRWp1bHVDeWRnZTJCd1FNRFpzVS9SZ3dNeklyTTU0RENqQWdWLy84ek1BQUFIWXNQMFFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1E4TS92K0hrUElYd2ZJTUFHUnlCMndBQUFBQkFERUFKd0UwQWp3QURnQUFBUU1HTGdFbk54TStBVGNlQVJjV0FTbkJCeEFlQWdXSEJCZ2RHQ01CQWdIai9sZ1VBdzBLRUFHN0RpRUJBUjRaQ0FCNDJtTmdaR0JnQU9KZFgzTUM0L2x0dmpJd3N6Q0F3R1A3aFJISU5QTkVKaHNneGNIQUJPSUJBQ0hoQ1NjQUFBQjQybU5nWkdCZ1Z2eGpCQ1FuTWhneXlES2FNQUJGVUFBVEFFRWFBbTRBQUFPUkFBQUJVUUF4QUFBQUFBQWdBQUI0Mm1OZ1pHQmdZR0xnWndEUkRGQVNDUUFBQWhRQUZRQjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFCVVltTmhZR0psNmdMWW9BeHhrQjBpUmFvNjhydDd1QjU2dytsNVArNkFraDh5bnBQeEd2ZHpjZ3BSZjF6d3dsdmlxYWhGNHBJUGxrekk4cGs0Y3phSmMwbStFaGU4YzBrOEZmODdjY2tuajIzWDN1Njk5V3JmR2V2ZHVRM2orbUI5YURxblZycUtlbWVkOWNmZUduVWFsUm1hTUZ4YlZldEsxMnpwYUxseHA4ZmlVZXpGTVpFZFo4a0NJMnNPMFFrMGtqcHByZEJVLy9LZDVDNTJqdkdUa2M1SkVpVTB5RldRZlpXMm9vNlhtdm9YODNrd1R3QUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT1lBQW9BQUFBQUJBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFb0FBQUJncUN3UzUyTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURDQnpaMng1WmdBQUFXd0FBQURSQUFBQTRJZ0k0UHhvWldGa0FBQUNRQUFBQUM4QUFBQTJLZXVGbzJob1pXRUFBQUp3QUFBQUh3QUFBQ1FGMkFFT2FHMTBlQUFBQXBBQUFBQUlBQUFBQ0FiL0FIOXNiMk5oQUFBQ21BQUFBQVlBQUFBR0FIQUFBRzFoZUhBQUFBS2dBQUFBRndBQUFDQUFCQUJLYm1GdFpRQUFBcmdBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFEaUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtcm1lY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeFFFQURBeXBJS1M1TFoyQlRBQUptclQrV0RBek1Xc3pIZ2NLTUNCWC8vek13QUFBS2VRN0NBQUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUW9LLy85RHlQc1B3ZklNQUZLaUJwd0FBSGphTllzeFRzTXdHRWI5L1k1LzF5bkZGazBKbEpLb3RoVWFWU1FJMm9RQnRTc0RSMkJEdlFCaVl1RUEzS1RuNFQ1UWtGamU4dDRURUIvZm5xN3BTendLZ1JJRkptekIraGQ5MWFLNlduVmJkR3VMWTRRR3E2Ni9MV1hWVXJYZUlPOU84Nzk0aXczdUNtU3MvV0hCVG81TUFsWmFTbjJVa3h3a0dtcVl5dk42M0dSejUrYVRzM294SmFXSGlpSnpKQ2pITlAyM1dUT3VzUy82eGRLL3Z6Njk1QU1DVHR6dS91MHp0amRMTzVJcHB4U3NKelltbVpYaHdWOUVSK1RpWlhndVo0bGhROTRHT2xSQy9BQ2ZiQmRkQUFBQWVOcGpZR1JnWUFEaTlXdlpyZVA1YmI0eU1MTXdnTUJqKzRVUkNQcS9Fa3NvMHhVZ2w0T0JDU1FLQUJPcENkY0FlTnBqWUdSZ1lOYjZZOG5Bd0JMS1VNOVF5NlRMQUJSQkFVd0FTNnNDNndBRVZRQUFBcW9BZndBQUFBQUFjQUFBZU5wallHUmdZR0JpOEdRQTBReFFFZ2tBQUFlK0FFOEFlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ2xKV0ZnWW1WcVF0Z2d6TEVRWGFJRktucXlPL3U0WHJvRGFmbi9iZ0RTbjdJZUU3R2E5elB5U2xFL1hIQkMyK0pwNklXaVVzK1dESWh5MmZpek5ra3ppWDVTbHp3emlYeFZQenZ4Q1dmUExaZGU3djMxcXQ5WjZ4MzV6YU02NFAxb2VtY1d1a3E2cDExMWg5N2E5UnBWR1pvd25CdFZhMHJYYk9sbytYR25SNkxSN0VYeDBSMm5DVUxqS3c1UkNmUVNPcWt0VUpUL2N0M2tydllPY1pQUmpvblNaVFFJRmRCOWxYYWlqcGVhdXBmNytrd1J3QUFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVM4QUFvQUFBQUFCV3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDA1Mk50WVhBQUFBRTRBQUFBTWdBQUFEd0FuUUI3WjJ4NVpnQUFBV3dBQUFIcUFBQUNMTGxHV1dob1pXRmtBQUFEV0FBQUFDOEFBQUEyS0p5RnVHaG9aV0VBQUFPSUFBQUFIZ0FBQUNRR0xRSE5hRzEwZUFBQUE2Z0FBQUFRQUFBQUVBcHpBSVZzYjJOaEFBQUR1QUFBQUFvQUFBQUtBV29Bc0cxaGVIQUFBQVBFQUFBQUdBQUFBQ0FBQ0FCQ2JtRnRaUUFBQTl3QUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRXNBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbW1zTTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkVoalp2Z1A1RE5EcEpIVS9BY0tBd0RoNVEwemVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS09qR2svZjhQNUR1QzZQOEgvczhGcXdJQ0FKUmZDUklBQUhqYU5kRXhiOU5BRkFmdys5L0Y1eVRZUGhQSGRxdkVTUnluTmlvaUtYV3cyd29NYW1oQXJSSVZLbENIU2toSTBBMGgxQmJZTW5TRUNZRUVDd3NiSDRBQkppWStBQ3NEWXVRekpPRmNpWnZ1L3U4TnYzZVBVTktaeitsditvdjB5Q29oS1pKMDFYR3RxaE1uRHU5QmpjS29uN2hPa3ZiZ3E3enF1SWxyUU9aNUhHZElZL1lGajNoVjU4aWNTelkwNVdoU1ZLQ2ZzL3FzcE03bVk3MXU2UXk2Y3JpdlFTdTFzL2QvL1JONjMwUkpUQ2VPWUo0S3hrQ0xRZ1UwOS9IV2FiVmpnZ3FENTNGWmNBUS9jSmZJdzhqRitaUngrbzAweURKWmsxS3JIMFJjMnZ3R2JBTnFBeTRYNEtyUHo3eFdqa3ZDS0FpNXl2N2ZtV3lJUDcydVJaNFEyRDk0eUNaN08zdWd0OHpSOGV4TjNUQTJHaC9mUFRpaTZBNU9tNWJ5NU5YQkNhVXJ0NzhQQzRDeFM5ZlBVMVpYUWU5c2JCK0s4bmg5WjlQSUN2a0VzTERGbmcwN055bkU0dlF6ZXo1ZTJtV3pQeFZlSmdRa21YZnBGZnFUM0pDUEhLQktiRHVNTXNUeW94MHU0YW5rV1VIdWpxOGpneXR6QTRIc0NaTzBDNVdyWE5COEhSRmVaSVlpWE9QcWNpc0JBbHZZb0c1Z2VvVW8xRVlEenhURGhmTGl1T1luRkcxYk9NQkNTelFMdmxDS21uMnZCbFBndyt6cndMcDJ1YmxKTzRIWHFsVDBzQ0JYeDU2TzhKWjVIQzh2YksvUW9ITldXVkx5U2xNUDE0N3pzUW41QnhrblZJSUFBSGphWTJCa1lHQUE0dnBKNzl6aitXMitNakN6TUlEQVkvdUZFUWo2dng0ekc5TmRJSmVEZ1Fra0NnQXRDQXBFQUhqYVkyQmtZR0JtK004QUpEa1lWUDRmWUdaakFJcWdBQllBU1VnREFBQUFBbllBQUFNQUFDUURDQUFyQWZVQU5nQUFBQUFBVkFDd0FSWUFBSGphWTJCa1lHQmdZWEJrWUdZQUFVWUdOQUFBQjFvQVMzamFUWTZ4YXNNd0VJWS9VOGRRcDlDcEhUb1VUUm1GamZzQWdReVpzbVlzSkpFSURrZ0tzbVBJRXZvQWZlaGVGQTA5d2ZIZGQ3K0VnSm9iQmZjcWVFMzlYaVdWVEErZU1lY3RjeVZIWmE3NVlNRVRSZmtzNXBObDVwSVh2alBQZU9lVXVSTC9rN25taTk5VmNPZkxhS1BhQkdPalB6alh0ODNXeHFFUFhyVzZlWWkxOVRidVJtdlUvcXJNMUEvVDBhbE9ON3BqUmNCeDVzS0lKY3JQTm1KTVlzOUJkbzZlbG9adGNvTk1RVFpLbkJiN1A3R1doRStwWFhyTlNHclBWYnBoa3N3Zy9TaHBSWmZ1YXJvLzMvUXd1d0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOMEFBb0FBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVZQUFBQmdoY3g0QldOdFlYQUFBQUU4QUFBQU1RQUFBRHdISVAwZloyeDVaZ0FBQVhBQUFBQ3NBQUFBMEY2V2svMW9aV0ZrQUFBQ0hBQUFBQzBBQUFBMktIS0daV2hvWldFQUFBSk1BQUFBSFFBQUFDUUdBUUluYUcxMGVBQUFBbXdBQUFBTUFBQUFEQWVBQUgxc2IyTmhBQUFDZUFBQUFBZ0FBQUFJQUNvQWFHMWhlSEFBQUFLQUFBQUFGd0FBQUNBQUJRQXJibUZ0WlFBQUFwZ0FBQUROQUFBQk9JTGhLcWx3YjNOMEFBQURhQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1hbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4d0VFakF4SklLUzVMQjBvYU1pOWdadmdQNURNek1JS0VHUkVxL2dPRkFmWTFEY1FBQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1JnMGdEUWJrR1lFeWhveUwvai9IOGdIMC84di9Fa0Nxd0lDQUprNUNUMEFBQUI0Mm1OZ1pJaG1ZR0JjeTdTYVFRSklDN0tKV1RPS3FpdXpteG9ibWFrTDhqR3FtNHFabVp1Sk1lb3lLemdwQnE0S1ZIU1daOWIwRVpUSk1SWmtaK3IvZTBoR1ZJR1pXVUZVaGtsSW1JTlJua2xVbjVFTGFBeURFZ01EMDEybUhReWFtR1lxb3ZITjFMUVpUUlZGbFpYWW1FcVlwQ3dsdkdkNlNWcElNLzA3eXlSdElRbmtTRmhLTVlIRW1YYURXQmwvWDhpSWdLd1VrV0h5L0xzZHpwYVFFWldYRjJWZ0FBQzdSeUZzZU5wallHUmdZQURpbUdiSmhmSDhObDhabUZrWVFPQ3gvY0lJWkpycEx0TU9JTVhCd0FUaUFRQUZRUWtiQUFBQWVOcGpZR1JnWUdiNHp3QWlHWlFZbEpudU1nQkZVQUF6QURWbkFpOEFBQUFDZ0FBQUFnQUFXd01BQUNJQUFBQUFBQ29BYUhqYVkyQmtZR0JnWnRCaUFORU1VQklKQUFBRTBnQXhBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXIxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY2IHtmb250LWZhbWlseTpjbXI3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY3IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yMi40ODkwNDYsLTIyLjkyMzQ1MilzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMC4xNzc2MywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuNDg5MDQ2LC0yMi45MjM0NTIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTIyLjQ4OTA0NicgeT0nLTIyLjkyMzQ1Mic+zqA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTE1LjAxNzA0NycgeT0nLTIxLjQyOTA3MSc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctOC4xNTk3NjYnIHk9Jy0yMi45MjM0NTInPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTIuNSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjQ4OTA0NiwtMjIuOTIzNDUyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0yMi40ODkwNDYnIHk9Jy0yMi45MjM0NTInPjE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtOC4zNTQxN1YtNDguNTUxMzUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjgwMTM1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy4yNjM4OSwtMzAuNDUyNzYpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi40ODkwNDYsLTIyLjkyMzQ1MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJy8+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ5LjcxNCwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuNDg5MDQ2LC0yMi45MjM0NTIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIyLjQ4OTA0NicgeT0nLTIyLjkyMzQ1Mic+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTUuMDE3MDQ3JyB5PSctMjYuNTM4ODE2Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ5LjQyMDYxLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuNDg5MDQ2LC0yMi45MjM0NTIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIyLjQ4OTA0NicgeT0nLTIyLjkyMzQ1Mic+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTQuNDMyNDM3JyB5PSctMjYuNTM4ODE2Jz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xNC43MzMxNyAwSDQ0LjY1ODQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ0LjkwODQ2LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjcuNDk4NzUsNC4xNzI5MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjQ4OTA0NiwtMjIuOTIzNDUyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi40ODkwNDYnIHk9Jy0yMi45MjM0NTInPs6yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ2LjU4MzUxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDYuODMzNTEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOC40OTY2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIyLjQ4OTA0NiwtMjIuOTIzNDUyKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0yMi40ODkwNDYnIHk9Jy0yMi45MjM0NTInPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE3LjgyMjQ2MScgeT0nLTI1LjkyOTk2OSc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNy4wNTU1NC01Ni45MDU1SDQ0LjM2NTA3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ0LjYxNTA3LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyMS41Nzk4OCwtNjYuNTcyODUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMi40ODkwNDYsLTIyLjkyMzQ1MilzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjIuNDg5MDQ2JyB5PSctMjIuOTIzNDUyJz7PgDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PSctMTcuNTc5OTgnIHk9Jy0yNi4yOTQxMjgnPuKAoDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMTcuODMwMjAxJyB5PSctMjAuNzYwNTI3Jz4xPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00NS4zOTEwOCwzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuNDg5MDQ2LC0yMi45MjM0NTIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTIyLjQ4OTA0NicgeT0nLTIyLjkyMzQ1Mic+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTUuMDE3MDQ3JyB5PSctMjYuNTM4ODE2Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuMjQyNjgtMS43MjcxLTM1LjI2Njg1LTI5LjI0ODA4LTcuNDQ4MTItNTEuMTg2MzknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43ODUxNywtMC42MTkxOSwwLjYxOTE5LDAuNzg1MTcsLTcuMjUxODMsLTUxLjM0MTE3KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDIuMTEwOTMsLTIxLjQ5NzAxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuNDg5MDQ2LC0yMi45MjM0NTIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTIyLjQ4OTA0NicgeT0nLTIyLjkyMzQ1Mic+ITwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyBzdHJva2UtZGFzaGFycmF5PSczLjAsMi4wJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KPHBhdGggZD0nTS0zMy44MjkyNSAzMy44Mjg1N0wtOC43MDQwNCA4LjcwNzY5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzA3MTUsLTAuNzA3MDMsMC43MDcwMywwLjcwNzE1LC04LjUyNzI1LDguNTMwOTMpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS0zMC41Mjk5NyA0MS41MTQ5NEMyLjc1ODUgNDYuNDA5OTMgMjguNDkxNDEgMzYuMjAzMSA0OS4wNjQ1OSAxMC4yMTQnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC42MjA2NCwtMC43ODQwMywwLjc4NDAzLDAuNjIwNjQsNDkuMjE5NzYsMTAuMDE4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxNy4zMzgyLDQwLjIwODc5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjIuNDg5MDQ2LC0yMi45MjM0NTIpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIyLjQ4OTA0NicgeT0nLTIyLjkyMzQ1Mic+zrE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTE3LjMwOTcwNCcgeT0nLTI1LjkyOTk2OSc+4oCgPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw = {\Pi _{B}f},
        nw/style = {pullback},
        ne = {A^{B}},
        sw = 1,
        se = {B^{B}},
        east = {f^{B}},
        south = {\pi _{1}^{\dag }},
        north = \beta ,
      }
      \node  [above left = of nw] (pif) {$A'$};
      \draw  [->,morphism,bend right] (pif) to node[swap] {$\mathsf {!}$} (sw);
      \draw  [->,morphism,exists] (pif) to (nw);
      \draw  [->,morphism,bend left] (pif) to node {$\alpha ^{\dag }$} (ne);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>The unit and counit of the adjunction can be extracted from the square above.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1561</fr:anchor><fr:addr
type="user">ct-001H</fr:addr><fr:route>ct-001H.xml</fr:route><fr:title
text="Exponentiable objects under slicing"><fr:link
type="local"
href="ct-001E.xml"
addr="ct-001E"
title="Exponentiable object">Exponentiable</fr:link> objects under slicing</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a cartesian category.
  If <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is exponentiable in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> then so is <fr:tex
display="inline"><![CDATA[B^{*}(A)]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex> for any object <fr:tex
display="inline"><![CDATA[B \in  \mathcal {C}]]></fr:tex>.
  Moreover, the pullback functor <fr:tex
display="inline"><![CDATA[B^{*}]]></fr:tex> preserves any exponential that exists in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</fr:p>
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1124</fr:anchor><fr:addr
type="machine">#288</fr:addr><fr:route>unstable-288.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>14</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>For each object <fr:tex
display="inline"><![CDATA[f\colon C\to B]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>, let us define the action on objects of <fr:tex
display="inline"><![CDATA[(\mathord {\hspace {1pt}\text {--}\hspace {1pt}})^{B^{*}(A)}]]></fr:tex> by the following pullback square:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="885ea05615db14850364e8fc50ad539e"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE1Ny4yMTk3NTZwdCcgaGVpZ2h0PScxMjMuODg3NjcxcHQnIHZpZXdCb3g9Jy03MiAtNzIgMTA0LjgxMzE3MSA4Mi41OTE3ODEnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFFQUFvQUFBQUFCSlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTjBybU50WVhBQUFBRTRBQUFBTWdBQUFEd0FUZ0I5WjJ4NVpnQUFBV3dBQUFFOEFBQUJZUGxmdzExb1pXRmtBQUFDcUFBQUFDMEFBQUEyS09pRm9XaG9aV0VBQUFMWUFBQUFIZ0FBQUNRRnVnSzBhRzEwZUFBQUF2Z0FBQUFRQUFBQUVBcGVBVnBzYjJOaEFBQURDQUFBQUFvQUFBQUtBT1lBYUcxaGVIQUFBQU1VQUFBQUZ3QUFBQ0FBQmdBdGJtRnRaUUFBQXl3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRCtBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbW1zNDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWURCaVp2Z1A1RE5EcEpIVS9BY0tBd0RYS1F6aGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS2FqSVkvZjhQNUd1QTZQODMvMThFcXdJQ0FJdDBDTVVBQUhqYUxjK3hUc0pnRUFmd3Uydjd0WlFJQ1pFV0lZVzJTTDhFRlNJcE1GWENab2dZZzRsR1NTZUNBU2FNaXpvYTNabjFCWWpQNEdqd0JYd0huOEJGRS9XamVMZmMzZkQvNVFEaDhSZndUUUxJQTJBQ1ZXWWFVYTh6bDFlUWU3elIzTU5tbzJha0diNzJIaFRKMWZTZGF3MVp0dTEwN0VDV0E3dmp0TE1NNmFQeCtSTGVaTXpib2F6THVtK2RCOVA1L0RJNHMzeGRqb0VvaElHd1pzTEtpWVdwUzgycm9oOEJLWTk3WWpEemFCbzQrMCtWU09HblhoMHZybFJKV29FSXEweFVORTIyQmlkM21QME80M0VGSTFBWUlRRDE2Um0yQUVxcVUvZGJKT0xGSnk1VFJYWUNpOHpqNGxJenpLV2Z4RkwwSVBYZG4wMHA5aFYwa1VaZHYyZGtIRVF2bmRnbXVwOU1ueVFhN1Zmclk2U3l2cGFreGFLZ1VPeDlkOUk2T01aeWtRbzUyOElOM2gzU2VIQTBydGo4RUZHT3QxTUFmekF3TzFCNDJtTmdaR0JnQU9MWW84OEs0L2x0dmpJd3N6Q0F3R1A3aFVFSStqOERjeEF6aU12QndBU2lBQ3cwQ2EwQUFBQjQybU5nWkdCZ1p2alBBQ1NER0dJWllwbWlHWUFpS0lBRkFEM1RBblVBQUFOU0FBQUNLZ0NhQWlvQVl3SzRBRjBBQUFBQUFEWUFhQUN3QUFCNDJtTmdaR0JnWUdIUVlRRFJERkFTQ1FBQUJSOEFOQUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVdBQUFvQUFBQUFCbXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hkeDRZbU50WVhBQUFBRThBQUFBT3dBQUFFd0Vjd1EyWjJ4NVpnQUFBWGdBQUFLaUFBQURJTzRSZkxKb1pXRmtBQUFFSEFBQUFDOEFBQUEyS05PRnFtaG9aV0VBQUFSTUFBQUFIZ0FBQUNRR2JnSkdhRzEwZUFBQUJHd0FBQUFVQUFBQUZBMnpBT1ZzYjJOaEFBQUVnQUFBQUF3QUFBQU1BWTRDVG0xaGVIQUFBQVNNQUFBQUdBQUFBQ0FBQ1FCTWJtRnRaUUFBQktRQUFBRE5BQUFCT1BOZktxTndiM04wQUFBRmRBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbTJzczRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFIwWkQ3QXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBUi9RNHhBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdzZ0RRWEF3ZFFqb25Ca1NHTmVSUHpnZi8vZ1dKdzl2OEQvK2Y4Q2Z6akF0WUJCUUJ5dEE2bUFIamFSWks5VXhOQkhJYnYzVDN1Y3NseGU3bms5a2hDRHBJTGR3UXdpUWxKSUVBQ0VoZ21ZY1NQSWtEang0eUYyamtXemppampLTXoyR2loaFlXRnRQNEpqaVdOcGRvNS9nODBXcHE0aDRXNzFlNjd4ZnY4bnBXSTFCcU42QnI1SWRXa2hpUTEwV2hXdVpOSThscVYyMG0xRExXRWVodE9HODBneDZEWUxtb09kd3lJUkFuYXFJa2dSNy9qVVRSbFJNZ2huOWZOWkd2dGVWU0JxUzJra1JyK3ZCWlZpQmVKS1FBYnU3dXZVN0RJd3NvSjFNcGpzc09oeC8rOFRCaHl6QWFGakNpTnEwQTg4dkdwRmRPU01VSTFjWlpsbUV5bGM1K3hKMG1RK3FNeXVVZStTdXZpUUVVajFZQ2E5OE1xM09HS3lxZlFSb2Q2aXQ5d3duTGl2aHIyOWZ6QWJ6VDlNZ3pDVUd0d0pjQkp5NVROdExaeGNiWUZGR3hmVkp0aWpCVnlORnRpdXk1SnNLdk1OdmdscjdnS2VGemtwc3VZWmJuUlNQcEdHT1B0OExRWFgxOU1ibExmYzZkSlFRbGlHb0hjdDkvOUh0Qzhpc0ZCSnZCbkN2OGpwUHdMcitSOEJKSllWS3FPbHNneCtTWk5Tb0hVRXp3Q3hZV3RxT0V1SWFDS0h5UWF6WEJYdWVxSHNBS3Yya0VKM3I5SDlGeUl3RnowQTBVd2g2b0ViaHZrbVBabWc2SjgyYlQyNzdUNzVwYWN4VW04bVhBMkRyZHZma2xsSEZOVFdJWkgzMk9wZEdXWkdkVjRsNkszZXV1SVRFeVVhck1MWkhseXJqaGVtU2ZkenNESlhDL2QzelQxWmFBK016elRpRTVlYk8rbTdFMjVmeWEwRWlFSTVMUmNrZGROYTZjN1BEUE10UzU5L1NEZk1nM29WbVlja2JIc2JTbDBWeHI5Sm0vd0tmeHBVRU1uOVk2dzFmUjh3VkpHS0ZINGNuSU43b2cwOEJRR0Z3NFBEWXRKbk1kb2QrS3VXNkRKaVc2NlkrMFZ4d3p4MWNnOHo5VmRQR09Ub0xLVE9vb1NBdHZVZ0t3MWJ1c3hNWFVkRDM5dGlSbXdvUEpoUUp5YURnSk5XMGxPMjRCbU04MGl6YWx5NXlDclI1TXBJREV6dmRKNVVoYVYvd0lTMG03Y0FBQjQybU5nWkdCZ0FPS0EzMHE1OGZ3Mlh4bVlXUmhBNExIOXdpQUUvVitmMlpicEZwREx3Y0FFRWdVQUhBSUtBUUI0Mm1OZ1pHQmdadmpQQUNRTEdQVCtYMkMyWlFDS29BQldBRm04QTdvQUFBTEdBQUFEY0FBNkFqb0FTd0tYQURJQ3JBQXVBQUFBQUFCWUFMNEJOZ0dRZU5wallHUmdZR0JsOEdaZ1pnQUJSZ1kwQUFBSWJ3QldlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRb0FBb0FBQUFBQkxnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUU0QUFBQmdxR3dVcjJOdFlYQUFBQUZFQUFBQU13QUFBRHdrSUI2R1oyeDVaZ0FBQVhnQUFBRlZBQUFCaUthN2x1Qm9aV0ZrQUFBQzBBQUFBQzhBQUFBMktldUZsMmhvWldFQUFBTUFBQUFBSHdBQUFDUUdEZ0VQYUcxMGVBQUFBeUFBQUFBTUFBQUFEQW54QVExc2IyTmhBQUFETEFBQUFBZ0FBQUFJQUhBQXhHMWhlSEFBQUFNMEFBQUFGd0FBQUNBQUJRQktibUZ0WlFBQUEwd0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUVIQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1EbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4UUVBRGhIS0FjaGxTaXN2U0dkZ1VGSlRFbWJYK1dESXdNR3N4SHdjS016TEF3Zi8vREF3QUJGME96QUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFabVJnVWxCUUV2Ly9uNEVCUXQ5L2VQYzFXQlVRQUFDUFJ3amlBSGphTlkvTlRzSlFFSVh2bWRLNUZpZ3Q5TFlGZjJpNHJhM0VDSXBRakRHd2RlRlM0OFpvakpFSE1LN2N1TmZFUjlERW5UNlBTOTlGcjBZM001bHp6aVRmRVJEM1g1cTI2RU1jQ29FRVhZVHNnZVhQbU9aRDVNVzRuS09jZUdnZ0hXQmNUa2VKbFE4cG44d1FsMUg4RzU1amh0MHVGRXR0WG5CdHVVNEZiRXZMa3ZXWXJLV0toRjJyV3AxK01GQTkzKytGN2Y3R010bXlabFBHbkJGc24ybjUzMVdEb0kvMzduUmpVOS9kSEYzRlN3UzAvT3U5Mjhkc3VMM3B1VmFWcTVSNm10aHhLcXRKZXFCWE1wL0l6OWJTczJTMTRyQkQya3ZKcElTcEpKNUVTbGY0RkdOelRNdFJwQXh5RkVkeEE0WTFNZlNtMVJ5U0M1MmJuUmQ1TWNNb1FaRlBUTmtvbG5oNHFYZFVrOTlPVHdLQzZqaXZMcE51Qmx4L1hHYzNiQnRkRWNLMisxem5vS21waHBVTFIra0d6ZFo2c3QxUzRNdkZmdGRDSzk1WkhJZFEydjh6bkl2RlR0VnRnWkp6OFExSjl5MjNBQUFBZU5wallHUmdZQUJpWmQvSmsrUDViYjR5TUxNd2dNQmorNFZCQ1BxL0Vrc28weFVnbDRPQkNTUUtBQTlsQ2NNQWVOcGpZR1JnWU5iNlk4bkF3QkxLVU05UXk1VE1BQlJCQWN3QVQ2NERJZ0FFVlFBQUFxb0Fmd0x5QUk0QUFBQUFBSEFBeEhqYVkyQmtZR0JnWnZCa0FORU1VQklKQUFBSDJRQlFBSGphVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9KU1ZoWUdKbGFrTFlJTXl4RUYyaUJTcDZzanY3dUY2NkEybjUvMjRBMHAreUhoT3htdmN6OGtwUlAxeHdRdHZpYWVpRm9sTFBsZ3lJY3RuNHN6WkpNNGwrVXBjOE00bDhWVDg3OFFsbnp5MlhYdTc5OWFyZldlc2QrYzJqT3VEOWFIcG5GcnBLdXFkZGRZZmUydlVhVlJtYU1Kd2JWV3RLMTJ6cGFQbHhwMGVpMGV4RjhkRWRwd2xDNHlzT1VRbjBFanFwTFZDVS8zTGQ1SzcyRG5HVDBZNkowbVUwQ0JYUWZaVjJvbzZYbXJxWCsvcE1FY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRNEFBb0FBQUFBQk1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngyQm1OdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDVloyeDVaZ0FBQVdRQUFBRjZBQUFCbUtwOWg4Vm9aV0ZrQUFBQzRBQUFBQzhBQUFBMktXNkdmV2hvWldFQUFBTVFBQUFBSHdBQUFDUUhRd040YUcxMGVBQUFBekFBQUFBTUFBQUFEQXVmQU9Wc2IyTmhBQUFEUEFBQUFBZ0FBQUFJQUdZQXpHMWhlSEFBQUFORUFBQUFGZ0FBQUNBQUJ3QkJibUZ0WlFBQUExd0FBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUVMQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm12czg0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmladmdQNURORHBKSFUvQWNLQXdEMmhnMVRlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aE8vLzhEU2NmLy8vOGZBUE1aQUZLb0JwNTQyalhQdjBvY1VSZ0Y4SHUrZTduWDJibXpPK01kWitLL2tYVmhWb1M0dXE0ektETCtaV0ZRTEJSVG1FYkZRakUyQ1ZqWkpWaWtDQ1N2NEF0WXBFdXFoUkRJRTZTeHN6Q3ZFSEIwUlB5KzVuQk85V1BFVGg0ZStHKzZZZk5za1RHWUNMTkpFQWFxaFJyaVpvWXdTTklXNmtyV1NLb0lhUmlFVlR5TjQzRXpUdElNS1RLMEE4WHJkSGVPVjlPMkFZYVdWL1AxZnNEb3ZnWGhlTVVmSS9pR2xxQzR6MWFBSno5MHBvUk5VTldaMVFqZmxEdXU5MjdSb043OVo4K0IxTVBFQVE1M3dBS1UxOTBEaVRQZnR2b3JJSzdMVW9DckNnMFNHbFBVdGJWK1gzeG41WEYyVVZyKzBrODJ3VHBzaWJIVXBITnhDektlNnlSaFBVSW8xZE5IVU0raC9yeTBFek5iT2pweHN4Rkx4Vjh5VjhVbDkvd1JZM3dYVjZlZlNLdzVicDRmNzROdjY5cmJqOFZhMVE4RzB0SHIzdGtYeWpkL2pIbmkzYStqcjJKcjYzK1g3OUtnZGdRQTZmaWxZbWVsKzdwaVRWaTFOek1iV2NWYTRLV3loTGhZNG9jcmt4bEJCL2M5T3RoczUxVDhNNHc5QXAzVVFrTUFBSGphWTJCa1lHQUE0cWRUVlZiRzg5dDhaV0JtWVFDQngvWUxneEQwLy8vTU41anVBcmtjREV3Z1VRQkRkZ3ZjQUhqYVkyQmtZR0JtK00vQXdNQ2l4cERKNE1kOGd3RW9nZ0tZQVVMVUFzUUFBMVFBQUFRbEFHa0VKZ0I4QUFBQUFBQm1BTXg0Mm1OZ1pHQmdZR1p3QUdJUVlHUkFBd0FISmdCSkFBQjQyazJNUFcvQ01CUkZUOVFFcVdGZ1FSMFlXZytkcmFEQTJvV0JpWldwQzJBWFpiQ05uQkFKcWVyWTM5Mkg4ZEEzWEozN1lRTTFQeFRjcjJDVzlINGxsYmdIVjB5Wlo1NkllOHRjcytDZEo0cnlXWkpYUGpLWDBueG1ybmpoSy9ORTh1L01OU3QrTjhGZHJvT05haGVNamY3a1hMZmUyOWgzd2F1bGJwTGZXbS9qWWJCR0hXL0tqRjAvbnAxcWRhTmJOZ1FjRjY0TVdDS0tuU1Ftc2Vja25hTmp6VDRsdlhDUVhMRkUwL3pydDlMN3REbWtuNHhzanR4RURhTXNldEd6YkJWdGVxbHAvd0RJRVMvdkFBQUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTa0FBb0FBQUFBQlVnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVjExRTJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDWFoyeDVaZ0FBQVdRQUFBSGFBQUFDRU5IM1krUm9aV0ZrQUFBRFFBQUFBQzhBQUFBMktNMkdYbWhvWldFQUFBTndBQUFBSGdBQUFDUUdZd0lrYUcxMGVBQUFBNUFBQUFBUUFBQUFFQXVvQUlkc2IyTmhBQUFEb0FBQUFBb0FBQUFLQVdRQXVtMWhlSEFBQUFPc0FBQUFHQUFBQUNBQUNBQTZibUZ0WlFBQUE4UUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVtQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1lc1U0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFluQmhadmdQNURORHBKSFUvQWNLQXdENmdBMWdlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2Z3UvLzhEU2FmLy8vL3ZCL01aQUZMT0JxQjQyalhRejJvVFVSVEg4ZnU3WjNMSHBtVW1kbkFtMG1aQ1REUFRSQ1lVTXN5a0FWdnAyRmhUVEZJaldtb3dLSWhZc1A1cHJWMTBrVVZGbEhZaFFqY3VYT2hPZkFOWHJseTU4Z2wwNVROSTB0NFJ3dGxjRG5meFBSOUc3T0xKZ0FUL3hteFdZbFhHUXNQUHU4SVBySnlOY3hwVUc1YlFJZFJjdkRNRG83S0FNSERjdkNOVUdyMUpmcWg4UHBweU03cU85ZTU5Nm5kV08rQlhVOWRmRE45UGExck4vbmpjMitFb1J3ZFpJN0YxMk4zbGZHN2xlMTBCdERhZlA4dHBXZ1ZmcXpVZTZzbm0vT3FTdHFCUVJnVU1MTlB6K3N3VkR2Mzg0QXU5YkJiYU5Qd3pLWktNZ1ZWTy90STQveFUzZ3pUa1hjZGRoTys0c2prT3RteUVaaERHaFZuWThnQzVMOE1Od25oTXk3UkNlUTRsTDVOSWppWEFjYXUxL0dxdVBpVk1LUHZYWm51Qjd3bGxURTJRVnk4K2kvWStFSFg4eHZaQnB6Z3JWalJNOEIvRGY1cHNWblZuWXhPSXF1dTlkTmZidmNkeG9WVHVwc2NCUHZGNHFWQUJIZmZmN0RUOEc2VE1GTFNXeG9reHhsbFJtb2ZTUE0yOFdEd1lnVnRDaldkay9kL1ZpazlZUk9DV29VcjFUMGVJN0pSazN0NEh0VXJWemY3d2EwYVh4TDhQWTg2M2QvZXNXdnJNSlBpajVsYldrTG9wb293QXZYdnkrdWtsN3lhUkxTUXNqd1kvcFNPVWRuYnRUdTYyKzJBRDBHWGFLU0VnWGN3QUFIamFZMkJrWUdBQVloK1Y2MC9qK1cyK01qQ3pNSURBWS91RlFRajYvMHRtYzZZclFDNEhBeE5JRkFBekdRc0JBSGphWTJCa1lHQm0rTThBSlAwWk5QOWZZRFpuQUlxZ0FCWUFWWjBEalFBQUFuWUFBQU1JQUNzQzJ3QXpBMDhBS1FBQUFBQUFYQUM2QVFnQUFIamFZMkJrWUdCZ1liQmtZR1lBQVVZR05BQUFCcElBUTNqYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNCB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDAuNDYwMDQ1LC02MC40NDc1MDEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNC4yNzg0NywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDAuNDYwMDQ1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQwLjQ2MDA0NScgeT0nLTYwLjQ0NzUwMSc+RDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNC4wNDM0LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDAuNDYwMDQ1LC02MC40NDc1MDEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTQwLjQ2MDA0NScgeT0nLTYwLjQ0NzUwMSc+QjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0yOC42NDQzNSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MC40NjAwNDUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDAuNDYwMDQ1JyB5PSctNjAuNDQ3NTAxJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zNS43OTM0NjEnIHk9Jy02My40NTQwMTgnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTMwLjM5NTIzNCcgeT0nLTY1LjQ2NDI0MSc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0yNi4yMzAyNjUnIHk9Jy02My40NTQwMTgnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTIzLjUzMjAxJyB5PSctNjMuNDU0MDE4Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xOC4zNzA3MycgeT0nLTYzLjQ1NDAxOCc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OS43MTczLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MC40NjAwNDUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDAuNDYwMDQ1JyB5PSctNjAuNDQ3NTAxJz5DPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zMi42MjY5MzInIHk9Jy02NC4wNjI4NjUnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDkuNjA1MTUsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MC40NjAwNDUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDAuNDYwMDQ1JyB5PSctNjAuNDQ3NTAxJz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy0zMi40MDM0MzcnIHk9Jy02NC4wNjI4NjUnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguODM0MDEgMEg0NC42NjE3NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0NC45MTE3NiwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI0LjU1MDgxLDQuMTcyOTEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MC40NjAwNDUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDAuNDYwMDQ1JyB5PSctNjAuNDQ3NTAxJz7OsjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS02LjQwOTczVi00Ni41ODM1MScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ2LjgzMzUxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMjguNDk2NjEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MC40NjAwNDUsLTYwLjQ0NzUwMSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNDAuNDYwMDQ1JyB5PSctNjAuNDQ3NTAxJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zNS43OTM0NjEnIHk9Jy02My40NTQwMTgnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguNTk4OTQtNTYuOTA1NUg0NC41NDk2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ0Ljc5OTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIyLjQ0Mzg1LC02Ni41NzI4NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQwLjQ2MDA0NSwtNjAuNDQ3NTAxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00MC40NjAwNDUnIHk9Jy02MC40NDc1MDEnPs+APC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zNS41NTA5NzknIHk9Jy02My44MTgxNzcnPuKAoDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMzUuODAxMjAxJyB5PSctNTguMjg0NTc2Jz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = D,
      nw/style = pullback,
      ne = {C^{A}},
      sw = B,
      se = {B^{A}},
      east = {f^{A}},
      south = {\pi _{2}^{\dag }},
      west = {f^{B^{*}(A)}},
      north = \beta ,
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>where <fr:tex
display="inline"><![CDATA[\pi _{2}^{\dag }]]></fr:tex> is the exponential transpose of the projection <fr:tex
display="inline"><![CDATA[\pi _{2}\colon A \times  B\to B]]></fr:tex>.</fr:p>
  <fr:p>Let <fr:tex
display="inline"><![CDATA[\alpha \colon f\to g]]></fr:tex> be a morphism in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{B}}}]]></fr:tex>.
    The above assignment can be extended to an action on morphisms by the universal property of pullbacks:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="651e1be2af28dc67a2965d6110a5a061"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIxMS45OTE1OTdwdCcgaGVpZ2h0PScxODMuMDExNzQ2cHQnIHZpZXdCb3g9Jy03MiAtNzIgMTQxLjMyNzczMSAxMjIuMDA3ODMxJz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUTRBQW9BQUFBQUJNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MkJtTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUY2QUFBQm1LcDloOFZvWldGa0FBQUM0QUFBQUM4QUFBQTJLVzZHcTJob1pXRUFBQU1RQUFBQUh3QUFBQ1FIUXdONGFHMTBlQUFBQXpBQUFBQU1BQUFBREF1ZkFPVnNiMk5oQUFBRFBBQUFBQWdBQUFBSUFHWUF6RzFoZUhBQUFBTkVBQUFBRmdBQUFDQUFCd0JCYm1GdFpRQUFBMXdBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFFTEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdnM4NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RDJoZzFUZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpYUHYwb2NVUmdGOEh1K2U3blgyYm16TytNZForSy9rWFZoVm9TNHVxNHpLREwrWldGUUxCUlRtRWJGUWpFMkNWalpKVmlrQ0NTdjRBdFlwRXVxaFJESUU2U3hzekN2RUhCMFJQeSs1bkJPOVdQRVRoNGUrRys2WWZOc2tUR1lDTE5KRUFhcWhScmlab1l3U05JVzZrcldTS29JYVJpRVZUeU40M0V6VHRJTUtUSzBBOFhyZEhlT1Y5TzJBWWFXVi9QMWZzRG92Z1hoZU1VZkkvaUdscUM0ejFhQUp6OTBwb1JOVU5XWjFRamZsRHV1OTI3Um9ONzlaOCtCMU1QRUFRNTN3QUtVMTkwRGlUUGZ0dm9ySUs3TFVvQ3JDZzBTR2xQVXRiVitYM3huNVhGMlVWciswazgyd1Rwc2liSFVwSE54Q3pLZTZ5UmhQVUlvMWROSFVNK2gvcnkwRXpOYk9qcHhzeEZMeFY4eVY4VWw5L3dSWTN3WFY2ZWZTS3c1YnA0Zjc0TnY2OXJiajhWYTFROEcwdEhyM3RrWHlqZC9qSG5pM2EranIySnI2MytYNzlLZ2RnUUE2ZmlsWW1lbCs3cGlUVmkxTnpNYldjVmE0S1d5aExoWTRvY3JreGxCQi9jOU90aHM1MVQ4TTR3OUFwM1VRa01BQUhqYVkyQmtZR0FBNHFkVFZYemorVzIrTWpDek1JREFZL3VGbVFqNi8zL21HMHgzZ1Z3T0JpYVFLQUE0SkF1dUFIamFZMkJrWUdCbStNL0F3TUNpeHBESjRNZDhnd0VvZ2dLWUFVTFVBc1FBQTFRQUFBUWxBR2tFSmdCOEFBQUFBQUJtQU14NDJtTmdaR0JnWUdad0FHSVFZR1JBQXdBSEpnQkpBQUI0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRb0FBb0FBQUFBQkxnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUU0QUFBQmdxR3dVcjJOdFlYQUFBQUZFQUFBQU13QUFBRHdrSUI2R1oyeDVaZ0FBQVhnQUFBRlZBQUFCaUthN2x1Qm9aV0ZrQUFBQzBBQUFBQzhBQUFBMktldUZ4V2hvWldFQUFBTUFBQUFBSHdBQUFDUUdEZ0VQYUcxMGVBQUFBeUFBQUFBTUFBQUFEQW54QVExc2IyTmhBQUFETEFBQUFBZ0FBQUFJQUhBQXhHMWhlSEFBQUFNMEFBQUFGd0FBQUNBQUJRQktibUZ0WlFBQUEwd0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUVIQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1EbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4UUVBRGhIS0FjaGxTaXN2U0dkZ1VGSlRFbWJYK1dESXdNR3N4SHdjS016TEF3Zi8vREF3QUJGME96QUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFabVJnVWxCUUV2Ly9uNEVCUXQ5L2VQYzFXQlVRQUFDUFJ3amlBSGphTlkvTlRzSlFFSVh2bWRLNUZpZ3Q5TFlGZjJpNHJhM0VDSXBRakRHd2RlRlM0OFpvakpFSE1LN2N1TmZFUjlERW5UNlBTOTlGcjBZM001bHp6aVRmRVJEM1g1cTI2RU1jQ29FRVhZVHNnZVhQbU9aRDVNVzRuS09jZUdnZ0hXQmNUa2VKbFE4cG44d1FsMUg4RzU1amh0MHVGRXR0WG5CdHVVNEZiRXZMa3ZXWXJLV0toRjJyV3AxK01GQTkzKytGN2Y3R010bXlabFBHbkJGc24ybjUzMVdEb0kvMzduUmpVOS9kSEYzRlN3UzAvT3U5Mjhkc3VMM3B1VmFWcTVSNm10aHhLcXRKZXFCWE1wL0l6OWJTczJTMTRyQkQya3ZKcElTcEpKNUVTbGY0RkdOelRNdFJwQXh5RkVkeEE0WTFNZlNtMVJ5U0M1MmJuUmQ1TWNNb1FaRlBUTmtvbG5oNHFYZFVrOTlPVHdLQzZqaXZMcE51Qmx4L1hHYzNiQnRkRWNLMisxem5vS21waHBVTFIra0d6ZFo2c3QxUzRNdkZmdGRDSzk1WkhJZFEydjh6bkl2RlR0VnRnWkp6OFExSjl5MjNBQUFBZU5wallHUmdZQUJpWmQvSjV2SDhObDhabUZrWVFPQ3gvY0pNQlAxZmlTV1U2UXFReThIQUJCSUZBQVFUQ1pVQWVOcGpZR1JnWU5iNlk4bkF3QkxLVU05UXk1VE1BQlJCQWN3QVQ2NERJZ0FFVlFBQUFxb0Fmd0x5QUk0QUFBQUFBSEFBeEhqYVkyQmtZR0JnWnZCa0FORU1VQklKQUFBSDJRQlFBSGphVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9KU1ZoWUdKbGFrTFlJTXl4RUYyaUJTcDZzanY3dUY2NkEybjUvMjRBMHAreUhoT3htdmN6OGtwUlAxeHdRdHZpYWVpRm9sTFBsZ3lJY3RuNHN6WkpNNGwrVXBjOE00bDhWVDg3OFFsbnp5MlhYdTc5OWFyZldlc2QrYzJqT3VEOWFIcG5GcnBLdXFkZGRZZmUydlVhVlJtYU1Kd2JWV3RLMTJ6cGFQbHhwMGVpMGV4RjhkRWRwd2xDNHlzT1VRbjBFanFwTFZDVS8zTGQ1SzcyRG5HVDBZNkowbVUwQ0JYUWZaVjJvbzZYbXJxWCsvcE1FY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFFQUFvQUFBQUFCSlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTjBybU50WVhBQUFBRTRBQUFBTWdBQUFEd0FUZ0I5WjJ4NVpnQUFBV3dBQUFFOEFBQUJZUGxmdzExb1pXRmtBQUFDcUFBQUFDMEFBQUEyS09pRnoyaG9aV0VBQUFMWUFBQUFIZ0FBQUNRRnVnSzBhRzEwZUFBQUF2Z0FBQUFRQUFBQUVBcGVBVnBzYjJOaEFBQURDQUFBQUFvQUFBQUtBT1lBYUcxaGVIQUFBQU1VQUFBQUZ3QUFBQ0FBQmdBdGJtRnRaUUFBQXl3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRCtBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbW1zNDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWURCaVp2Z1A1RE5EcEpIVS9BY0tBd0RYS1F6aGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS2FqSVkvZjhQNUd1QTZQODMvMThFcXdJQ0FJdDBDTVVBQUhqYUxjK3hUc0pnRUFmd3Uydjd0WlFJQ1pFV0lZVzJTTDhFRlNJcE1GWENab2dZZzRsR1NTZUNBU2FNaXpvYTNabjFCWWpQNEdqd0JYd0huOEJGRS9XamVMZmMzZkQvNVFEaDhSZndUUUxJQTJBQ1ZXWWFVYTh6bDFlUWU3elIzTU5tbzJha0diNzJIaFRKMWZTZGF3MVp0dTEwN0VDV0E3dmp0TE1NNmFQeCtSTGVaTXpib2F6THVtK2RCOVA1L0RJNHMzeGRqb0VvaElHd1pzTEtpWVdwUzgycm9oOEJLWTk3WWpEemFCbzQrMCtWU09HblhoMHZybFJKV29FSXEweFVORTIyQmlkM21QME80M0VGSTFBWUlRRDE2Um0yQUVxcVUvZGJKT0xGSnk1VFJYWUNpOHpqNGxJenpLV2Z4RkwwSVBYZG4wMHA5aFYwa1VaZHYyZGtIRVF2bmRnbXVwOU1ueVFhN1Zmclk2U3l2cGFreGFLZ1VPeDlkOUk2T01aeWtRbzUyOElOM2gzU2VIQTBydGo4RUZHT3QxTUFmekF3TzFCNDJtTmdaR0JnQU9MWW84OUU0L2x0dmpJd3N6Q0F3R1A3aFprSStqOERjeEF6aU12QndBU2lBQ0RpQ1g4QUFBQjQybU5nWkdCZ1p2alBBQ1NER0dJWllwbWlHWUFpS0lBRkFEM1RBblVBQUFOU0FBQUNLZ0NhQWlvQVl3SzRBRjBBQUFBQUFEWUFhQUN3QUFCNDJtTmdaR0JnWUdIUVlRRFJERkFTQ1FBQUJSOEFOQUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQWJRQUFvQUFBQUFDQ1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRWNBQUFCZ2hkeDRXR050WVhBQUFBRThBQUFBUUFBQUFFd0VkZ1EzWjJ4NVpnQUFBWHdBQUFQaUFBQUV6UDI4SUt0b1pXRmtBQUFGWUFBQUFDOEFBQUEyS05PRjFtaG9aV0VBQUFXUUFBQUFIZ0FBQUNRR2JBSklhRzEwZUFBQUJiQUFBQUFjQUFBQUhCTGxBVkJzYjJOaEFBQUZ6QUFBQUJBQUFBQVFBNUFFdUcxaGVIQUFBQVhjQUFBQUdBQUFBQ0FBQ3dCTWJtRnRaUUFBQmZRQUFBRE5BQUFCT1BOZktxTndiM04wQUFBR3hBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbTJzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnSU5HQmlTUVVseVdEcFIwWkQ3QXpQQWZ5R2RtWUFRSk15SlUvQWNLQXdBT1d3NG5BSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmdzZ0RRWEF3ZFFqb25Ca1NHZGVSUHpnZi8vZ1dLT0RHbk1HMEhzL3dmK3ova1QvTWNOckFNS0FITDZEcXA0MmxXVXkyL2pWQmpGL2QzcjJQR2pmc1crYmw1T1VpZDJPazJURURkSm4wa3o2VlI5MGM0QVVpY1JnbUdrWVRUTUJnRkNGVWd3SUpDR0RhQ0JCUXNXZER0ck5pQ1czYkFFZG9qL29adVpCUXNTUHFjTGhMMjY5MXpKNTNmUGQ4d1JibjA2cFZ2a1R5N2lPaHpYaFU2M3hkeVV6YUlXYzJ5eEFXSWQyajF3ZTlBTlN6b0lqZ2VSeTF3TlVCSENIa1FvbE9nZmNDYW50U1Fac3lYVnNOZTNQcE1GTUtSYUJ0S1R2MTZTQmVJbkZRRkFUenk0clZMUWs3V05jeENiSDVJOUJxcjV6eGNwalZjY29NQ0RURTBSd0V3Ky9kaFNKRnNoVk1JMXo0T2hpL1RhTDNEQ2NjQWRUaHZrTGZJYnQ0MExpbzVFRGNTRklMYkNYQ2FJckFBOTZGTmZDRHB1YkE3M1c3RmZQd2lEVGpkb2dFWjBpRHBNQ09GODNlQ05qRFI0b2JvT1VIWUN0RmJRZGIxY292bTZmdVNSbEg1TGR6UjIzVi9jQlBBWjZvYW42NWJseWNuTTY3RU0zMDR1RHN6dEZYdElBOThya3JJUUtoSUIvdEQ1N3ZrcFhSRGhkSlFOZzByNVB3blN3ZktYL0VJU09Id0lWNXN1a3dwY2NIVnVHTk1naVRBalFjZTJJTG9zWWgwRTZDTmtIY0pPTjM2OVdSWjRnUGFoRXlLVUlNWlh3TnhXZkpTVTNwYmVQV3U4eHFOZms0Rm01Y3lTdmVubm1PaDI5d2NqUWdlNnVUK3F0dWRveHBwejRFbURndTJzWklaRnh6QWhDTDNyT1ZXRUR5YUR4cGdTcDVZdnBWS0tKeWNJS0xsMHMvaHF4TVBwelh2SEtYMkhRcGtaREF4ejh2ZFB1bEx4ZWFpMmc4SDJTUmNxUlgxdXh0YWZQaU0venRnd3FZb0hYV1JaaVdjSHlaQlNnLzh4WVd5eC93SjRFR2VLWUtnR01abHJZNjRkMHVTWklwZFZDeWNyV2s3MzdOclozdmdPNFhkTis5Yjk0d2NxQVRMTUpVUVo1WXhVZU1JRG4yaHVaVitzaFBqaHFQRCsxK01xRDFaT0FTSmJFU0YreDQrQTNOKy9lMklieURJK1VrcXRWOTQwWkNERTJUWDNINDRhZm10RXdWOWUvU1M3c2dWa2dhTmNhN3BLSHBQZnVSd1hjZ2VZRmdKNDRNUzNQMHVISWxQcUNxZkZ4Q0NHUUtaV0grcmdYeDJpcy9KZ2VDdEJLT0I4eHJYQ0hERzB4L1NnR2k3eXg0WjErMTd2MExqQjUrSGM3S2Jjd1hqM3pxL3ByR3RJZ3A1bDh2ZXdXcis1cG1zdEV6MGZiTDd4aU16UDE2TnFqYXpscmkzT05aZklUdi9VemI1Y2Z6ZzAxRFdBZG1WeUtSR1ZmTDU3bEhhRy9PRWxWcEJnbVlCY05Kcjh0bUh0N1V3dU5XTnJoMzcxenNLNm9ZRnFaZWNnbWNqZjVlS2UxYWZQeVRmd2MveFhBREh1VDd1UHplcjY4Y0ExSUI1VHpNc3RkWmlMYXVnTE9zUXhpbGN6UEpPaDF6YzlyMHp0K1oxTTN6cFpUR2lZRGxsaXBiWUhuK281b0x5YmZpUVRBbzRoQWVSeElGVUZHNkxDZTg5dTRCM29ZZk9IVStKR0toQ1FwQTI3NkFCSWppNVpwRnRvOUVkNVZiYlRBS2xLY2FQL1VRTXQvd3VHVzZ3RUFBQjQybU5nWkdCZ0FHSmw4MlB2NC9sdHZqSXdzekNBd0dQN2haa0krcjh1c3kzVExTQ1hnNEVKSkFvQUo0SUtZZ0I0Mm1OZ1pHQmdadmpQQUNRTEdIVCtYMkMyWlFDS29BQjJBRm1RQTdvQUFBTEdBQUFEY0FBNkFqb0FTd0k2QUN3QytBQS9BcGNBTWdLc0FDNEFBQUFBQUZnQXZnRXNBWlFDREFKbWVOcGpZR1JnWUdCbjhHWmdaZ0FCUmdZMEFBQUlwUUJZZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmdJTEYxWVdCaVplb0MyRVVaYkNNblJFS3FPdlozOTJFODlBMVg1MzdZUU0wUEJmY3JtQ1c5WDBrbDdzRVZVK2FaSitMZU10Y3NlT2VKb255VzVKV1B6S1UwbjVrclh2aktQSkg4TzNQTml0OU5jSmZyWUtQYUJXT2pQem5YcmZjMjlsM3dhcW1iNUxmVzIzZ1lyRkhIbXpKajE0OW5wMXJkNkpZTkFjZUZLd09XaUdJbmlVbnNPVW5uNkZpelQwa3ZIQ1JYTE5FMC8vcXQ5RDV0RHVrbkk1c2pOMUhES0l0ZTlDeGJSWnRlYXRvL3k2RXY5d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTUVBQW9BQUFBQUEyUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnYURwaDJXTnRZWEFBQUFGQUFBQUFLZ0FBQURRQURPQ0RaMng1WmdBQUFXd0FBQUJBQUFBQVFFYlRvMWhvWldGa0FBQUJyQUFBQUMwQUFBQTJLU2FHQzJob1pXRUFBQUhjQUFBQUhnQUFBQ1FFaC8vamFHMTBlQUFBQWZ3QUFBQUlBQUFBQ0FUaUFERnNiMk5oQUFBQ0JBQUFBQVlBQUFBR0FDQUFBRzFoZUhBQUFBSU1BQUFBRndBQUFDQUFCQUFRYm1GdFpRQUFBaVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFDOUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtS21TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeElJQUFFanVsdUN5ZGdlMkJ3UU1EWnNVL1Jnd016SXJNNTREQ2pBZ1YvLzh6TUFBQUhZc1AwUUI0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZRklBMEN4QUMrUThNL3YrSGtQSVh3ZklNQUdSeUIyd0FBQUFCQURFQUp3RTBBandBRGdBQUFRTUdMZ0VuTnhNK0FUY2VBUmNXQVNuQkJ4QWVBZ1dIQkJnZEdDTUJBZ0hqL2xnVUF3MEtFQUc3RGlFQkFSNFpDQUI0Mm1OZ1pHQmdBT0pkWDNONDQvbHR2akl3c3pDQXdHUDdoWm5JTlBORUpoc2d4Y0hBQk9JQkFCbURDUVVBQUFCNDJtTmdaR0JnVnZ4akJDUW5NaGd5eURLYU1BQkZVQUFUQUVFYUFtNEFBQU9SQUFBQlVRQXhBQUFBQUFBZ0FBQjQybU5nWkdCZ1lHTGdad0RSREZBU0NRQUFBaFFBRlFCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUJVWW1OaFlHSmw2Z0xZb0F4eGtCMGlSYW82OHJ0N3VCNTZ3K2w1UCs2QWtoOHlucFB4R3ZkemNncFJmMXp3d2x2aXFhaEY0cElQbGt6SThwazRjemFKYzBtK0VoZThjMGs4RmY4N2Nja25qMjNYM3U2OTlXcmZHZXZkdVEzaittQjlhRHFuVnJxS2VtZWQ5Y2ZlR25VYWxSbWFNRnhiVmV0SzEyenBhTGx4cDhmaVVlekZNWkVkWjhrQ0kyc08wUWswa2pwcHJkQlUvL0tkNUM1Mmp2R1RrYzVKRWlVMHlGV1FmWlcyb282WG12b1g4M2t3VHdBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU2tBQW9BQUFBQUJVZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFYxMUUyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1haMng1WmdBQUFXUUFBQUhhQUFBQ0VOSDNZK1JvWldGa0FBQURRQUFBQUM4QUFBQTJLTTJHakdob1pXRUFBQU53QUFBQUhnQUFBQ1FHWXdJa2FHMTBlQUFBQTVBQUFBQVFBQUFBRUF1b0FJZHNiMk5oQUFBRG9BQUFBQW9BQUFBS0FXUUF1bTFoZUhBQUFBT3NBQUFBR0FBQUFDQUFDQUE2Ym1GdFpRQUFBOFFBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFbUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtZXNVNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBZbkJoWnZnUDVETkRwSkhVL0FjS0F3RDZnQTFnZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1Fndmd1Ly84RFNhZi8vLy92Qi9NWkFGTE9CcUI0MmpYUXoyb1RVUlRIOGZ1N1ozTEhwbVVtZG5BbTBtWkNURFBUUkNZVU1zeWtBVnZwMkZoVFRGSWpXbW93S0loWXNQNXByVjEwa1VWRmxIWWhRamN1WE9oT2ZBTlhybHk1OGdsMDVUTkkwdDRSd3RsY0RuZnhQUjlHN09MSmdBVC94bXhXWWxYR1FzUFB1OElQckp5TmN4cFVHNWJRSWRSY3ZETURvN0tBTUhEY3ZDTlVHcjFKZnFoOFBwcHlNN3FPOWU1OTZuZFdPK0JYVTlkZkROOVBhMXJOL25qYzIrRW9Sd2RaSTdGMTJOM2xmRzdsZTEwQnREYWZQOHRwV2dWZnF6VWU2c25tL09xU3RxQlFSZ1VNTE5Qeitzd1ZEdjM4NEF1OWJCYmFOUHd6S1pLTWdWVk8vdEk0L3hVM2d6VGtYY2RkaE8rNHNqa090bXlFWmhER2hWblk4Z0M1TDhNTnduaE15N1JDZVE0bEw1TklqaVhBY2F1MS9HcXVQaVZNS1B2WFpudUI3d2xsVEUyUVZ5OCtpL1krRUhYOHh2WkJwemdyVmpSTThCL0RmNXBzVm5Wbll4T0lxdXU5ZE5mYnZjZHhvVlR1cHNjQlB2RjRxVkFCSGZmZjdEVDhHNlRNRkxTV3hva3h4bGxSbW9mU1BNMjhXRHdZZ1Z0Q2pXZGsvZC9WaWs5WVJPQ1dvVXIxVDBlSTdKUmszdDRIdFVyVnpmN3dhMGFYeEw4UFk4NjNkL2VzV3ZyTUpQaWo1bGJXa0xvcG9vd0F2WHZ5K3VrbDd5YVJMU1FzandZL3BTT1VkbmJ0VHU2MisyQUQwR1hhS1NFZ1hjd0FBSGphWTJCa1lHQUFZaCtWNjUzeC9EWmZHWmhaR0VEZ3NmM0NUQVQ5L3lXek9kTVZJSmVEZ1Fra0NnQW54d3JUQUhqYVkyQmtZR0JtK004QUpQMFpOUDlmWURabkFJcWdBQllBVlowRGpRQUFBbllBQUFNSUFDc0Myd0F6QTA4QUtRQUFBQUFBWEFDNkFRZ0FBSGphWTJCa1lHQmdZYkJrWUdZQUFVWUdOQUFBQnBJQVEzamFUWTZ4YXNNd0VJWS9VOGRRcDlDcEhUb1VUUm1GamZzQWdReVpzbVlzSkpFSURrZ0tzbVBJRXZvQWZlaGVGQTA5d2ZIZGQ3K0VnSm9iQmZjcWVFMzlYaVdWVEErZU1lY3RjeVZIWmE3NVlNRVRSZmtzNXBObDVwSVh2alBQZU9lVXVSTC9rN25taTk5VmNPZkxhS1BhQkdPalB6alh0ODNXeHFFUFhyVzZlWWkxOVRidVJtdlUvcXJNMUEvVDBhbE9ON3BqUmNCeDVzS0lKY3JQTm1KTVlzOUJkbzZlbG9adGNvTk1RVFpLbkJiN1A3R1doRStwWFhyTlNHclBWYnBoa3N3Zy9TaHBSWmZ1YXJvLzMvUXd1d0FBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXN5Nztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zLjQxNTgyNSwtMjEuMDMxNDUzKXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuNjgxMjQsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTMuNDE1ODI1LC0yMS4wMzE0NTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTMuNDE1ODI1JyB5PSctMjEuMDMxNDUzJz5EPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9JzUuMTA5MTYzJyB5PSctMjQuNjQ2ODE3Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuMDQzNCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTMuNDE1ODI1LC0yMS4wMzE0NTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTMuNDE1ODI1JyB5PSctMjEuMDMxNDUzJz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMy4yNjM4OSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zLjQxNTgyNSwtMjEuMDMxNDUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zLjQxNTgyNScgeT0nLTIxLjAzMTQ1Myc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScuNzIxMTI1JyB5PSctMjQuMDM3OTcnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nNi4xMTkzNTInIHk9Jy0yNi4wNDgxOTMnPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PScxMC4yODQzMjEnIHk9Jy0yNC4wMzc5Nyc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxMi45ODI1NzYnIHk9Jy0yNC4wMzc5Nyc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PScxOC4xNDM4NTYnIHk9Jy0yNC4wMzc5Nyc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4zMTQ1MywtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMy40MTU4MjUsLTIxLjAzMTQ1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMy40MTU4MjUnIHk9Jy0yMS4wMzE0NTMnPkM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nNC40MTcyODgnIHk9Jy0yNC42NDY4MTcnPu6AsDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc3LjIxMjM2NCcgeT0nLTI2LjA1ODIyNic+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OS42MDUxNSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTMuNDE1ODI1LC0yMS4wMzE0NTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTMuNDE1ODI1JyB5PSctMjEuMDMxNDUzJz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzQuNjQwNzgzJyB5PSctMjQuNjQ2ODE3Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xMC4yMzY3OSAwSDQzLjI1ODk5JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQzLjUwODk5LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjYuOTk3ODgsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTMuNDE1ODI1LC0yMS4wMzE0NTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS02LjQwOTczVi00Ni41ODM1MScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ2LjgzMzUxKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMjguNDk2NjEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zLjQxNTgyNSwtMjEuMDMxNDUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zLjQxNTgyNScgeT0nLTIxLjAzMTQ1Myc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScuNzIxMTI1JyB5PSctMjQuMDM3OTcnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguNTk4OTQtNTYuOTA1NUg0NC41NDk2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ0Ljc5OTYsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDIyLjQ0Mzg1LC02Ni41NzI4NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTMuNDE1ODI1LC0yMS4wMzE0NTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMuNDE1ODI1JyB5PSctMjEuMDMxNDUzJz7PgDwvdGV4dD4KPHRleHQgY2xhc3M9J2YxJyB4PScxLjQ5MzI0MScgeT0nLTI0LjQwMjEyOSc+4oCgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9JzEuMjQzMDE5JyB5PSctMTguODY4NTI4Jz4yPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00NC41MTY3NywzNy43MzgzKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMy40MTU4MjUsLTIxLjAzMTQ1MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctMy40MTU4MjUnIHk9Jy0yMS4wMzE0NTMnPkQ8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTS00MS4wODExOCAzMy44Mjg1N0MtNDYuNTM0NDUtMS4wMjk5Mi0zNi4wNjA1OC0yOC4xNjA2Ni04Ljk4ODA4LTQ5Ljk5ODczJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuNzc4MywtMC42Mjc4MiwwLjYyNzgyLDAuNzc4MywtOC43OTM1MiwtNTAuMTU1NjkpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC02NS44Mjc0OCwtMjMuMTgwNzEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zLjQxNTgyNSwtMjEuMDMxNDUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zLjQxNTgyNScgeT0nLTIxLjAzMTQ1Myc+ZjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxLjI1MDc1OScgeT0nLTI0LjAzNzk3Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzYuNjQ4OTg2JyB5PSctMjYuMDQ4MTkzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMTAuODEzOTU1JyB5PSctMjQuMDM3OTcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMTMuNTEyMjEnIHk9Jy0yNC4wMzc5Nyc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PScxOC42NzM0OScgeT0nLTI0LjAzNzk3Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzMuMCwyLjAnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNLTMzLjgyODA4IDMzLjgyODU3TC05LjI3NzE2IDkuMjgxMDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNCwtMC43MDcwNSwwLjcwNzA1LDAuNzA3MTQsLTkuMTAwMzcsOS4xMDQzMSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNLTM3LjMyMzQxIDE2LjYyODA3SC01LjQyODI3VjI5Ljk4OTk4SC0zNy4zMjM0MVonIHN0cm9rZT0nbm9uZScvPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0zNC4zMjM0MSwxOS42MjgwNyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTMuNDE1ODI1LC0yMS4wMzE0NTMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTMuNDE1ODI1JyB5PSctMjEuMDMxNDUzJz7OsTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScxLjc2MzUxNicgeT0nLTI0LjAzNzk3Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9JzcuMTYxNzQzJyB5PSctMjYuMDQ4MTkzJz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMTEuMzI2NzEyJyB5PSctMjQuMDM3OTcnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMTQuMDI0OTY3JyB5PSctMjQuMDM3OTcnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMTkuMTg2MjQ3JyB5PSctMjQuMDM3OTcnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tMzEuNDA0MjggNDEuMzk5OTZDMS40Mzg3NSA0Ni43NjA2MiAyNy4yMjQ2NiAzNy4wMDExOSA0Ny45NzIyNiAxMS42MjU3MycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjYzMjkzLC0wLjc3NDEyLDAuNzc0MTIsMC42MzI5Myw0OC4xMzA1LDExLjQzMjIpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE2LjEyMzIxLDQyLjE2MzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0zLjQxNTgyNSwtMjEuMDMxNDUzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy0zLjQxNTgyNScgeT0nLTIxLjAzMTQ1Myc+zrE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nMS43NjM1MTYnIHk9Jy0yNC4wMzc5Nyc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSc3LjQyMjkyNycgeT0nLTIxLjAzMTQ1Myc+zrI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw = D',
        nw/style = pullback,
        ne = {{C'}^{A}},
        sw = B,
        se = {B^{A}},
        east = {g^{A}},
        south = {\pi _{2}^{\dag }},
        west = {g^{B^{*}(A)}},
        west/node/style = {right},
      }
      \node  [above left = of nw] (d) {$D$};
      \draw  [->,morphism,bend right] (d) to node[swap] {$f^{B^{*}(A)}$} (sw);
      \draw  [->,morphism,exists] (d) to node[desc] {$\alpha ^{B^{*}(A)}$} (nw);
      \draw  [->,morphism,bend left] (d) to node {$\alpha ^{A}\beta $} (ne);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>The unit and the counit can be defined by the following commutative squares:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="83f72be82718c6bbb0495712f9ef7ea4"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzMyNS42MjYwOTdwdCcgaGVpZ2h0PScxOTkuMTY0MzE0cHQnIHZpZXdCb3g9Jy03MiAtNzIgMjE3LjA4NDA2NSAxMzIuNzc2MjA5Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5BQUFvQUFBQUFBNlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ2lPUnpHMk50WVhBQUFBRkFBQUFBS1FBQUFEUUFEQUVxWjJ4NVpnQUFBV3dBQUFCNEFBQUFlSk1TUEpGb1pXRmtBQUFCNUFBQUFDMEFBQUEyS0xHRnVXaG9aV0VBQUFJVUFBQUFIZ0FBQUNRR05mL2RhRzEwZUFBQUFqUUFBQUFHQUFBQUJnT3dBQUJzYjJOaEFBQUNQQUFBQUFZQUFBQUdBRHdBQUcxaGVIQUFBQUpFQUFBQUZ3QUFBQ0FBQkFBa2JtRnRaUUFBQWx3QUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRE1BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWxtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVUQXhKSUtTNUxCMHBlWjdqT0xQVkhrNEdCV1lyNU9sQ1lFYUhpLzM4R0JnRHJuUTd2QUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeENDK05mLy80ZVEvN1hBZkFZQVh1VUhNd0FBQUFBQkFKUUFDUUtHQWZnQUlnQUFBVGMyRnhZWEJnOENId0VXQndZSEppOEJCdzRCSXlZbkpqOEJKeVkzTmpjeUZ3R095dzRLRXdFQ0F4cTdwVElFQVFFVEN3WFV5d2tJQmhFREF4RE56UkFEQXhFR0JBRWR5aEVCQWhNS0F4cTdwVElJQXhNQ0FnVFV5d29GQWhNSERjN09EUWNUQWdJQUFIamFZMkJrWUdBQTRwWDVkclBqK1cyK01qQ3pNSURBWS91RlNjZzBzd3pqRHlERndjQUU0Z0VBRDY0SkJnQUFBSGphWTJCa1lHQ1crcU1KSkdVWXBqQk1ZMnBqQUlxZ0FFWUFUTW9ERndBQUF4d0FBQUNVQUFBQUFBQUFBRHdBQUhqYVkyQmtZR0JnWWxCbUFORU1VQklKQUFBRUNBQXBBSGphVFk2eGFzTXdFSVkvVThkUUo1Q3BIVG9VVFJtRmpmTUFoUXlac21Zc0pKRUlEbGdPa21Qd1V2SUFmZWhlRkEwOXdmSHB2KytFZ0pJZk1oNlZzWXo5VVRtRjNKNDhZODViNGtLT1Nsenl3WW9Yc3Z4VmtrKytFdWNzK0U0ODQ1MUw0a0x5ZStLU05iK2J2cnZlQnV2VnJqZld1MU1YcHJyYVd4L2EzcWxhVjg5Z2E1MzFoOEVhZFp5VUdkc3duanZWNkVvM2JPanB1SEpqd09MbFp6dEpUR1RIU1dhQmlacUtmY3dDcmN5ZGVEVmEwdi9HVmd3WHJVTjh6WWgxbEprU0dtVXZTRCtMcjJqaXJxYjVBd2xSTVJNQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFFQUFvQUFBQUFCSlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTjBybU50WVhBQUFBRTRBQUFBTWdBQUFEd0FUZ0I5WjJ4NVpnQUFBV3dBQUFFOEFBQUJZUGxmdzExb1pXRmtBQUFDcUFBQUFDMEFBQUEyS09pRndXaG9aV0VBQUFMWUFBQUFIZ0FBQUNRRnVnSzBhRzEwZUFBQUF2Z0FBQUFRQUFBQUVBcGVBVnBzYjJOaEFBQURDQUFBQUFvQUFBQUtBT1lBYUcxaGVIQUFBQU1VQUFBQUZ3QUFBQ0FBQmdBdGJtRnRaUUFBQXl3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRCtBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbW1zNDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWURCaVp2Z1A1RE5EcEpIVS9BY0tBd0RYS1F6aGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS2FqSVkvZjhQNUd1QTZQODMvMThFcXdJQ0FJdDBDTVVBQUhqYUxjK3hUc0pnRUFmd3Uydjd0WlFJQ1pFV0lZVzJTTDhFRlNJcE1GWENab2dZZzRsR1NTZUNBU2FNaXpvYTNabjFCWWpQNEdqd0JYd0huOEJGRS9XamVMZmMzZkQvNVFEaDhSZndUUUxJQTJBQ1ZXWWFVYTh6bDFlUWU3elIzTU5tbzJha0diNzJIaFRKMWZTZGF3MVp0dTEwN0VDV0E3dmp0TE1NNmFQeCtSTGVaTXpib2F6THVtK2RCOVA1L0RJNHMzeGRqb0VvaElHd1pzTEtpWVdwUzgycm9oOEJLWTk3WWpEemFCbzQrMCtWU09HblhoMHZybFJKV29FSXEweFVORTIyQmlkM21QME80M0VGSTFBWUlRRDE2Um0yQUVxcVUvZGJKT0xGSnk1VFJYWUNpOHpqNGxJenpLV2Z4RkwwSVBYZG4wMHA5aFYwa1VaZHYyZGtIRVF2bmRnbXVwOU1ueVFhN1Zmclk2U3l2cGFreGFLZ1VPeDlkOUk2T01aeWtRbzUyOElOM2gzU2VIQTBydGo4RUZHT3QxTUFmekF3TzFCNDJtTmdaR0JnQU9MWW84OE00L2x0dmpJd3N6Q0F3R1A3aFVrSStqOERjeEF6aU12QndBU2lBQ1JVQ1kwQUFBQjQybU5nWkdCZ1p2alBBQ1NER0dJWllwbWlHWUFpS0lBRkFEM1RBblVBQUFOU0FBQUNLZ0NhQWlvQVl3SzRBRjBBQUFBQUFEWUFhQUN3QUFCNDJtTmdaR0JnWUdIUVlRRFJERkFTQ1FBQUJSOEFOQUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zczg7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5RQUFvQUFBQUFBN3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hZcDBMMk50WVhBQUFBRTRBQUFBTVFBQUFEd0FnQUM4WjJ4NVpnQUFBV3dBQUFDTUFBQUFqQ3dWdUtkb1pXRmtBQUFCK0FBQUFDOEFBQUEySithR2ZtaG9aV0VBQUFJb0FBQUFId0FBQUNRRkRBR2phRzEwZUFBQUFrZ0FBQUFNQUFBQURBV0VBSEpzYjJOaEFBQUNWQUFBQUFnQUFBQUlBRElBUm0xaGVIQUFBQUpjQUFBQUdBQUFBQ0FBQmdBZGJtRnRaUUFBQW5RQUFBRE9BQUFCT0FkMUtyMXdiM04wQUFBRFJBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXZNWTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFJNWWNoazV2NFA1RE56TTZLcCtROFVCZ0Q5UFEyb2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS3BqQmsvdjhQNUlQcC8zUC96d1NyQWdJQW1ORUpOZ0FBQUFBQ0FDWC85Z0hhQXNjQUVBQWJBQUFCRVNNMURnRUhMZ0VuUGdFM05oWVhFUU0xSmlNbUJnY2VBVGMyQWRwWkhsUXdVV2NDQW1sU0dGZ3lBeWcrT0dJREFsYzRTd0xIL1RrMUdpUUJBNFprWllZREFSVWlBU3o5dU5vMEFVMWZXRklCQXdBQUFnQk5BQUFBdEFLK0FBTUFCd0FBRXhVak5SY1JJeEcwWjE5V0FyNW5aL2YrT1FISEFBQUFlTnBqWUdSZ1lBRGlzMXhYbU9QNWJiNHlNTE13Z01Cais0VkpDUHIvTjZZQXB1TkFMZ2NERTBnVUFDT0dDcnNBZU5wallHUmdZT2IrejhEQXdCVEFvTXJnejNpTEFTaUNBcGdCUWdZQ3RBQUNVQUFBQWpFQUpRRURBRTBBQUFBQUFESUFSbmphWTJCa1lHQmdacEJoWUdJQUFVWUdOQUFBQTRzQUpIamFUWXc5YjhJd0VJYWZxQWxTdzhDQ09qQzBIanBiUVdGZ1ltRmdZbVZpQWV5aURIR1FIU0loVlIzNTNUMk1CODdTNlhrL3prREpIeG1QeVpqRS9aaWNRdFNUQzhaTUU0OUVmU1V1bWZITkcxbitMczRucThTNUpQdkVCUi84SkI2Si81dTRaTUY5M2JXWGEyKzkybmJHZW5kcVExanVyQTlONTlSY1YxRnZyTFArMEZ1ampqZGxoaVlNNTFiVnV0STFhenBhTGx6cHNYZ1VXM0ZNWk1kSnNpQnZ5UzQ2Z1VaU0o2MDVtdW9sMzBqdVl1Y1FmekxTT1hLVGJSamtLc2crUzF0UngwdE4vUS9xYlRBN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVZvQUFvQUFBQUFCbVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDJEV050WVhBQUFBRTRBQUFBTlFBQUFFUUFXUUVUWjJ4NVpnQUFBWEFBQUFLU0FBQURJR3Z4eWxKb1pXRmtBQUFFQkFBQUFDOEFBQUEyS2JPRnkyaG9aV0VBQUFRMEFBQUFJQUFBQUNRSGlRTnRhRzEwZUFBQUJGUUFBQUFVQUFBQUZCTExBZHBzYjJOaEFBQUVhQUFBQUF3QUFBQU1BWVFDWEcxaGVIQUFBQVIwQUFBQUdBQUFBQ0FBQ1FCS2JtRnRaUUFBQkl3QUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRlhBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbVBzUTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkVoalp2Z1A1RE5EcEpIVS9BY0tBd0R3RVExYWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VTY0dGd1kwdjcvQjdJY0lhei9CLzd2L3o4UHJCWU1BT1VnQzJZQUFBQjQybldTVFdnVFFSVEg1ODJzTS9uWXoreG1OMDJicExzcG0zN1l4Q2JwYmx0cVl0b2FqYTMxQ3dVclNoVUZqZmFpNEVGN0VKUWlGU3lLTnk4VmI0TGdRZkNncDBJUnZIclFpemRCUFhrWG16amJLSUxndk11YmVYUDQvV2IrQ0tOTDdUWjVpeitoY1RTSkVPaHBLSG1tWmJJQ0tPRG1LbUNabmw4QW0xRUZVNVlHM3pJdEdZS2g0K1pjejYrQUR4VW9tb3pZK090MVNPeUs2Z0RKUFZPTm1SaUFMb1ltQkVscnZkTUZNaXRTd0c0b3lnQTBlcTJjRjZJWW1Ed3lsWWFIVEhYRWhjK1F4UnRicTVvRVZPekdCSUNBR2c4RE1LMitBRmhZTXFMaFdBUXdFZm1oQUlSRmNCZUdiQjdYbzZKNHRmVVM4VVhRTW5mNWlOK2dmbFJHVllSODNSOTFDMERkMGJKbjJXbXdLQXNxRGF6VDJKMUowZE5MM0tQczVySXVaZVJQVDFocmhXaEdqNjRiS2p5OWZBY0wwNUxhYUZ4Y0JISlVWRTdkYmszTGhobjNVeTgybHU3anh0enJqQ1pjMlR6L1FKaWYvMUVueDNHWEtBa0FRQ1dEV3h5cjFZY2o0ZjZ3Y21Ka3RoSUpUeEJ1eVVWVXFKSnp0Y0VLQnRIYzJzQm41NG9OM1BxbWN4ZU1iclRiUW9xN1pGRHh2eVovQlFpelNzWGdPL0tReThNUXVQVG5OcndSQytEdlBpZmtkSG5mOGxyckFtYzJ4bExmVjRuOTdORGp5YkU4OVBiWWkvNlRqUG9QOGFOYks4M2RRM1A0TnlqT2IzM1E4WGh0WnIyNU41bnFCcEV6QXJyWkhzYWIrRDNhenpkRUFjcGsvclJCYWtxbVpWQm1abmcyZks4S25wL3RrSmFDZnJ1Q0dHVzNJOFM5SEI2dklIY0dkNEl2NDFKWVM4WnF3ODVCQWdQeFFXTEVGVmxQOWUzUVlqMWE5S1NrRzhvWm1RcUprSlE5MG4rQVh6RUhDWWhwVmRHVFZrUk1MRWxHaUFod3IvV3E0a3dPSkVzWW5MemprSnhtUnhoZzdNV3J6ZlhtUk1meXNOMWJWcldDQUgwN2d5czBKNGN3Sk5UcUd0Q3VLQUdFZmdHWFNuOGRBQUI0Mm1OZ1pHQmdBT0tBbE43YjhmdzJYeG1ZV1JoQTRMSDl3aVFFL1YrWFJaYnBMcERMd2NBRUVnVUFKNllLUlFCNDJtTmdaR0JnWnZqUHdNREFVc0NRK2Y4N2l5d0RVQVFGc0FJQVlBb0QvZ05VQUFBRUpRQnBCQ1lBZkFSd0FIb0N2QUI3QUFBQUFBQm1BTXdCSGdHUWVOcGpZR1JnWUdCbDhHUmdaZ0FCUmdZMEFBQUlQUUJVZU5wTmpEMXZ3akFVUlUvVUJLbGhZRUVkR0ZvUG5hMmd3TnFGZ1ltVnFRdGdGMld3alp3UUNhbnEyTi9kaC9IUU4xeWQrMkVETlQ4VTNLOWdsdlIrSlpXNEIxZE1tV2VlaUh2TFhMUGduU2VLOGxtU1Z6NHlsOUo4WnE1NDRTdnpSUEx2ekRVcmZqZkJYYTZEaldvWGpJMys1RnkzM3R2WWQ4R3JwVzZTMzFwdjQyR3dSaDF2eW94ZFA1NmRhbldqV3pZRUhCZXVERmdpaXAwa0pySG5KSjJqWTgwK0piMXdrRnl4Uk5QODY3ZlMrN1E1cEorTWJJN2NSQTJqTEhyUnMyd1ZiWHFwYWY4QXlCRXY3d0FBQUhqYVkyQm13QXNBQUgwQUJBPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBU0lBQW9BQUFBQUJUZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFOEFBQUJnaVNVVThHTnRZWEFBQUFGRUFBQUFNd0FBQUVRZ05DTllaMng1WmdBQUFYZ0FBQUd3QUFBQitDZ0Q0bUZvWldGa0FBQURLQUFBQUM4QUFBQTJLZXVGdDJob1pXRUFBQU5ZQUFBQUh3QUFBQ1FIREFFUWFHMTBlQUFBQTNnQUFBQVFBQUFBRUE1R0FnSnNiMk5oQUFBRGlBQUFBQW9BQUFBS0FUUUFxRzFoZUhBQUFBT1VBQUFBRndBQUFDQUFCZ0JLYm1GdFpRQUFBNndBQUFETkFBQUJPQk43S3Jkd2IzTjBBQUFFZkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtbnNnNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdJQUdvQklnNVFEbE1xUVVsNlVESmE4cmlUTnIvYkZrWUdEV1lqNE9GR1prZ0lQLy94a1lBQzZKRDZZQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdBeUFOQWNRZ3VTdUt5Z29pZi8vajJEOTE3ci82TzRic0Zvd0FBRDJFZ3ZJQUhqYU5WQk5iOU5BRU4yWnRYZmp4QitiZUczSC9ZakoydGlOS2hLYUpqWlVLTGx5NElJRTRvS29xcXI1QVZWUFhMaFRxVCtoU056Z3AvVFVRNC84RFM1STJiS0o0REtqbWZkRzg5NGpRSDQvM3RFemJNZ1RRb0JuRUVlTXF3bzR5OHRxdG9TcW5OZE5uVUZUSDhkSlROL3ErNWNXVGQyVy9xUGRJS1ZpdlJZMDlRSzk5djJVQW1oOWY4S2RsSEpnT3FDcDcydTlCWVRlOHN3TDh1VlI0VE44SUsvTmtNRUFJaFlBNDV2U2xCTXdUK3NsMVBNQWZNakhNS3ViYVViTENaYnpCU1Ixbkd6SlMxakE4UUNrVVdwTzRJSjZqZ1hNNXBSeU4wSGFzampZblRaTlIrRllEb1VZUnYzUndRN2F2R05qd1ZpQllBdUdPLzlST1E1SDhIUFFIQnlxejVkdnpwTVdBdlRFeFl1cjYyTHkvRER3YUp1MU1ROFVNc2V4OXJMOGxkb3RCS0lvOXZPUDJaN2xNQWRWa0tOaGtZMi9HNUxqT2Z3aU16TTA5VFNXUnJLSkx2SEJhTTJNZXVOcWFmS3RWR2w2V1pYVkFxYlpKbWhqTms0NGZQM21wckxMZm54NEh5TEkxUG51TVZUZGtMblhUNWtYOWMxZUlrUjk3OVpsWVZkaEIzWlBIYWw4WE93UGViOG5nWjJ0VGdZVWVzblI2bDBFVW9sL2dITzZPbXA3UGNEc0Uva0xOWFZJTjNqYVkyQmtZR0FBNHFoUGIzcmorVzIrTWpDek1JREFZL3VGU1FqNnZ4SkxLTk1WSUplRGdRa2tDZ0JIY2dzU0FIamFZMkJrWUdEVyttUEp3TUFTeWxEUFVNdWN5QUFVUVFFc0FFK2RBeUlBQkZVQUFBUlZBUFVDcWdCL0F2SUFqZ0FBQUFBQU9BQ29BUHdBQUhqYVkyQmtZR0JnWWZCa0FORU1VQklKQUFBSDlBQlJBSGphVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9KU1ZoWUdKbGFrTFlJTXl4RUYyaUJTcDZzanY3dUY2NkEybjUvMjRBMHAreUhoT3htdmN6OGtwUlAxeHdRdHZpYWVpRm9sTFBsZ3lJY3RuNHN6WkpNNGwrVXBjOE00bDhWVDg3OFFsbnp5MlhYdTc5OWFyZldlc2QrYzJqT3VEOWFIcG5GcnBLdXFkZGRZZmUydlVhVlJtYU1Kd2JWV3RLMTJ6cGFQbHhwMGVpMGV4RjhkRWRwd2xDNHlzT1VRbjBFanFwTFZDVS8zTGQ1SzcyRG5HVDBZNkowbVUwQ0JYUWZaVjJvbzZYbXJxWCsvcE1FY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFZQUFBb0FBQUFBQndnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVjQUFBQmdoZHg0ZG1OdFlYQUFBQUU4QUFBQVBBQUFBRXdFYndSRFoyeDVaZ0FBQVhnQUFBTVpBQUFEdEdQUTBUSm9aV0ZrQUFBRWxBQUFBQzhBQUFBMktPK0Z3R2hvWldFQUFBVEVBQUFBSGdBQUFDUUdpZ0pMYUcxMGVBQUFCT1FBQUFBWUFBQUFHQkRxQVMxc2IyTmhBQUFFL0FBQUFBNEFBQUFPQTFBQ09HMWhlSEFBQUFVTUFBQUFHQUFBQUNBQUNnQkNibUZ0WlFBQUJTUUFBQUROQUFBQk9QTmZLcU53YjNOMEFBQUY5QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm11c2c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lOR0JpU1FVbHlXRHBSMFpEN0F6UEFmeUdkbVlBUUpNeUpVL0FjS0F3QVpRUTVGQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1Jnc2dEUVhBd2RRam9uQmlTR05lVHZ6Z2YvL2dXS09NUGIvQS8vbi92SDk0d3JXQVFVQWMvVU9yM2phUlpMTmJ4dFZGTVhmdVc4ODR4bFA1bzNITTI5aTF4N2JHV2NtYVZvN2plTXhpUk03YlZKYUVxcWs3U0trUXNvR0lSVlZLaEt0aE1SbkVRdllzSUVGQ3haMGdWU3hRV3hSZHlCV2JJQVZpRCtEN3FqTkd3cGk4M1RmUFp2ZnVlY3dZcHV6R2QrbTMxbWZaWXdOa1EzWFpGanhaWDlOQnI3Umc5SEZZSXh3akdIYUZ0Q0RDUDFRaGc2VW9xZGo5SlhRNXIvaVRhdnFGT21XWExGZGYzUDdRMHVIYTU2cm9Ucjk0NGFsVTF3czZZQW8zSDdKNWhERmM2T0hNRmJmb3FzU2R2bnB4eFZIS3dYZzBHRHhzZ0dVaTErLzU1Vk12MFRjVkg5Tmd5c01mdll4RGhuamJILzJGeitoeDZ6TnpyTU5SVndaWmtrUHNaNWtZVHVDSWpQVXF5dFVvNTN2WkZiSkdiTWtqUlBkNFAvTlhKZmZmNlRCZEt0T0U1NkQrNi9jQlg5d2V1TmwwRFh2NXR2VE4rcFVudHRvUEhwMCt4M1E0Tm9YVGJmdytsZW5EempHVjM4N2dIMUVMV25vNE5xQ0FicTV0ZmVxWjExLzd1Q2lNK1phckJ4NDJPTjNMcld2YUhEazAyL3B6bUZ2bjZhL0dKd3hzSU5aajE2am45bU8rdkFjVXhFdkpQa3BaU2gxUXpZeHhvVC80eWVIVmZ1MS9ONXhraWJaVURsMVNLQ2ZTVDNGdzAxWGMydm14UXRMbTBBblNOUnBtMEtJVHBzM3V1TEZpQ3JpdWdnY2VTbGUzZ0ppcVhRM0VzTHpJcXRZTzgxbGZEYjlZYis4cys3djhpU09XdFRSMDVKSjBBNkN6NThjYzJYdCtPUk1taXgyL3BkUVRjNS9vaTBVd1ZqdVpYVzJTTS9qUjdhZGUzbm1ZMWdaVTVLcTJZRWdoeWZwaEdlRDlYODNQWFJWd2NZa1ZaL0NTQm1ocmJzVTFCd2YyajJOazF3ZUhjMEx5Mmo0QlRPbys3Qlc3Skl1S3RGQ3FXQllxa0ZTMk9uR0M4WCtyZGFWZFJ0QU9KM1lNYm5sQUQvTnpTOWRJTnBkQ21yUi9TTmZPSERMWjc5WjdZWnVVQWQydW40SlJPNXVYYlpvY1dQVW9VSnZmZTdNTXcvZDJSUDZGTi9sN2M4UjQyUXdVUWtNODdib1BlVEJxQXpDZGlaRHBhYXhhcGJxbDh4VDAxVWt1WXp4cEJ4RkhlN1A3OVVtM3VGeXdWSDFweFhaSGtUNFFOUlZTOExxK3hZUkF0Y0VHdDVjWUpmVUpXM2MrL1B5WmEwaDB0VXZqeW5zMnlDWTVzaHZCWUFaQ05PalliTTNPV25ZbGw4RktvdXQwZVRkbmtMK0c4UHNndGtBQUFCNDJtTmdaR0JnQU9Kb2hlTEg4ZncyWHhtWVdSaEE0TEg5d2lRRS9WK1ZPWkxwRnBETHdjQUVFZ1VBSFBFS0tnQjQybU5nWkdCZ1p2alBBQ1JMR1BUK1gyQ09aQUNLb0FBMkFGdzFBOXNBQUFMR0FBQURjQUE2QTNRQVNnSTZBRXNDV2dBd0Fxd0FMZ0FBQUFBQVdBQzRBUjRCZ0FIYUFBQjQybU5nWkdCZ1lHTndaR0JtQUFGR0JqUUFBQWVRQUUxNDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVrQUFvQUFBQUFCZlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDFGMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNYWjJ4NVpnQUFBV1FBQUFKWUFBQUN1SkhqY2Nsb1pXRmtBQUFEdkFBQUFDOEFBQUEyS00yR2gyaG9aV0VBQUFQc0FBQUFIZ0FBQUNRR1hnSWxhRzEwZUFBQUJBd0FBQUFVQUFBQUZBNm9BS3RzYjJOaEFBQUVJQUFBQUF3QUFBQU1BV0lDREcxaGVIQUFBQVFzQUFBQUdBQUFBQ0FBQ1FBNmJtRnRaUUFBQkVRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRkdBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkhCaFp2Z1A1RE5EcEpIVS9BY0tBd0Q3MVExamVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZndS8vOERTY2YvLy84ZkFQTVpBRkxLQnFCNDJqWFJ2MDhUWVJ6SDhlZnpmTnZuYUdudktsZnVhcURYbEpZZVlGb0l2ZHdCaWNWUXFRaXgvS2hCZ28xRUV5U1NpRDlBWkdEb2dERWFHSXdKaVhGdzBNMDR1emc1TVRtNU9xaVQ4VTh3YlgyT2hPZFpubnh6dy92N09zWlp0dDNtUC9rUE5zeEdHZlBnZXFPR3FjZU5vbXVJWVNoMnpuWmMwM0M5WWFRVkVUZE0xMVFoNS82NFdJSlhwTTlZRi9Hb1FNbklkeU1TM0dsMEJCSHQxQjBLS2ExMk5kcXJSd25SNE1aS0JKRlFYK25OMy9RdVg0NGhwRFViaGtaSkJVVGdIWm9DUk15NzB3ZnhiQXhjVTRVL0Rtc0NtUk1zTVhtSVhXZzNTZkF2ekdKRGJFeVc2azdHRnJJdGJhRmJoV0xCRkJxRWtoYW52Ym9mNStic1RFNG9kUFltK1VIeHcxR1BuZFEwck5UdlVLTTJWd08vRXJ2MnBQVzZWMVVuckhmSGF6c2NoZkpCU2c5dUhkWjNPUitaK1ZvSkFPb0NIei9IcVZjQlg1eVkzZERDMWZHNUtiVVU4RGVBam1sNlhNbGU1dERPTnovUzAyci9BclYrZDRrd1kyREY5aC9xNU4vOVpwQ0tqQlNkaEpPelpiTWZiRnJ3Sks5Zm1JSWxGNUR6QW16WDg2OWhHcVluMTZId0pSTGhVQkFjeS9QVHowWXFQY0pBWVAvcXdKcnI1RVVncEFRcFh4bDhWTjU3UzFSelpyY1Bhb01EWWtaRmhKKzAvcW15V2RGeXE1dEFlV3hsTFZIUDc5N202QnNxMUJPZEFJL2NuK292Z280YkwzWm1uU1VLWlB2VmVaV1ROT2RzVUpwNzBqekI4cjY0ZXdadUNzVy9aOWFucnFhL3dpUmN1d0JGcXI4L1F0bUtTZWJ0ZmREODBOaG1vL1VwcVVuaVg0Yys1OHRiZStaRW9xTUwvRjUxSzZWTDNSaFJVdjcyVncrZVA3eVl2MDVrQ1FuTHk4MXYwaEdCaGRUaXpmUU5lMzBWMEdUYWYvUUJkMWQ0Mm1OZ1pHQmdBT0pqVVp0cjQvbHR2akl3c3pDQXdHUDdoVWtJK3Y5TFpuT211MEF1QndNVFNCUUFQaDRMVGdCNDJtTmdaR0JnWnZqUEFDVDlHVlQrWDJBMlp3Q0tvQUJXQUZVckE0a0FBQUoyQUFBREFBQWtBd2dBS3dMYkFETURUd0FwQUFBQUFBQlVBTEFCRGdGY2VOcGpZR1JnWUdCbHNHUmdaZ0FCUmdZMEFBQUdyUUJFZU5wTmpyRnF3ekFRaGo5VHgxQ24wS2tkT2hSTkdZV04rd0NCREpteVppd2trUWdPU0FxeVk4Z1MrZ0I5NkY0VURUM0I4ZDEzdjRTQW1oc0Y5eXA0VGYxZUpaVk1ENTR4NXkxekpVZGxydmxnd1JORitTem1rMlhta2hlK004OTQ1NVM1RXYrVHVlYUwzMVZ3NTh0b285b0VZNk0vT05lM3pkYkdvUTlldGJwNWlMWDFOdTVHYTlUK3FzelVEOVBScVU0M3VtTkZ3SEhtd29nbHlzODJZa3hpejBGMmpwNldobTF5ZzB4Qk5rcWNGdnMvc1phRVQ2bGRlczFJYXM5VnVtR1N6Q0Q5S0dsRmwrNXF1ai9mOURDN0FBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUM0QUFBQTJLR21Gd21ob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0dU4rTTQvSDg5dDhaV0JtWVFDQngvWUxreEQwZjBhbXk4d2dMZ2NERTRnQ0FEVDVDa29BQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5nQUFvQUFBQUFBOVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTno3R050WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUI4WjJ4NVpnQUFBV1FBQUFDZ0FBQUFyS0FDSGFSb1pXRmtBQUFDQkFBQUFDNEFBQUEyS0JhRndXaG9aV0VBQUFJMEFBQUFId0FBQUNRRWp3RzhhRzEwZUFBQUFsUUFBQUFLQUFBQUNnUkdBR1JzYjJOaEFBQUNZQUFBQUFnQUFBQUlBQ3dBVm0xaGVIQUFBQUpvQUFBQUZ3QUFBQ0FBQlFBWmJtRnRaUUFBQW9BQUFBRE5BQUFCT0lMaEtxbHdiM04wQUFBRFVBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbXZNYzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWU5Ca1p2Z1A1RE5EcEpIVS9BY0tBd0R2a1EwZWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZpYS8vOERTWTMvLy8vZkJQTVpBRkNiQm9WNDJtTmdaRWo1ejhBWXdzekFJTTdBd0NxaXBLYXV4Mml1Wm1adXgyakV6OGpIS000bUpNOG94aGdzbG15b0tjUElLS05tbUNiR3lCUG53Y2prRXMvUC9JMHJLVDVpbGEzVHd0RGtWQjZCeEQvdGxmLytwUWl5TUFBQkk0TWwwRnhOaUxtTVltenNmSXhLcGtCVDFVM1U5Qm5Wek0yTXhNVGxHQmsxd0NhSzhzWjZNUVg3Q0RFek1vcUM3V0dBbXBqMHQzWGhCMThoRmlhd1BRQVZKQ0ZNZU5wallHUmdZQURpVDErNFQ4ZnoyM3hsWUdaaEFJSEg5Z3VURVBSL0JxWUdaaENYZzRFSlJBRUFQZDhLUFFBQWVOcGpZR1JnWUdiNHo4REF3TlRBWU1sZ3lSakNBQlJCQVV3QU8yd0NVQUFDZ0FBQUFZMEFaQUE1QUFBQUFBQUFBQ3dBVm5qYVkyQmtZR0JnWnBCZ0FORU1VQklKQUFBREVBQWZBSGphUll3eGI4SXdFSVcvaUFTSmRPaFNkV0FBRDh4V29qQjNZV0JpWldJQmJLSU1jWkFUSWlHaGp2M2RQWXdsYm5qNjdyMTNCK1Q4a3ZDY2hNK2d6MG5KWkh0eHhnZGZrYWV5TFNQbnpGa3hJVWxuNGl6NGlaeEtjb2ljOGMwbDhsVDhSK1NjTlgrYnJyM2VCdXZWcmpQV3UzUHJ5Mkp2ZmQ5MFRwVzZDUHZXT3V1UGd6WHFkRmRtYlBxeGJsV2xDMTJ4b2FQbHlvMEJpMGV4RThjRWRwd2w4NVFVN0lQVDAwanFwRldpeFgzblc4bGQ2QnpESnlPZEUzZFJ3eWhYdldndGJVVVZMalhWUDJNOUx3OEFBQUI0Mm1OZ1prQUdqQXhvQUFBQWpnQUYpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5NztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBT0FBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFc0FBQUJnaU9OaU9XTnRZWEFBQUFGQUFBQUFNUUFBQUR5L21pSGJaMng1WmdBQUFYUUFBQUN6QUFBQXRGN1AySHhvWldGa0FBQUNLQUFBQUM4QUFBQTJLU2VGNjJob1pXRUFBQUpZQUFBQUhnQUFBQ1FHTC8va2FHMTBlQUFBQW5nQUFBQU1BQUFBREFoekFPUnNiMk5oQUFBQ2hBQUFBQWdBQUFBSUFEb0FXbTFoZUhBQUFBS01BQUFBRndBQUFDQUFCUUFqYm1GdFpRQUFBcVFBQUFET0FBQUJPQk4vS3J0d2IzTjBBQUFEZEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdXNnNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTW1BUVNiSWFXNExCMG9lZjJCQWJQaUh5TUdCbVpGNW5OQVlVYUVpdi8vR1JnQU9Rb1ArZ0I0Mm1OZ1lHQmlZR0JnQm1JUklNa0lwbGtZTklBMEc1Qm1CTXBlZjJEdy96K1FENmIvYThsZkFxc0NBZ0M2aVFwUUFBQUFlTm9OeWswT3dVQVloL0gzLy9aakdLcWsxV2tYS2tnNnNTRSswbTVFcitFS25LSTdCN0swY2dBM2tIVEN5c1lSMEdmM1N4NENYWDRmZm5CQUV5S0lNYUtoTzVzdUlWeWQ2YXlFem9xOHlNY29rVy9XS3VLN3FZNk9IVXJ4Zm5veVppdW82d0U0N25TZnhuTmFvUTBZVTUxc21UaHY0NE9WYUFaZktvWnY2cTZWdEtrSnRDS05MZStvMThCeUY5QkZzRWVSUWtXWTMwUS9aZWRzeDZONEJzYnJld2d0VC9aeDdVMkFOR25SSDdZeElXb0FlTnBqWUdSZ1lBRGkvYzhxd3VQNWJiNHlNTE13Z01Cais0VkpDUHIvTythSlREWkFMZ2NERTBnVUFFTGtDekFBZU5wallHUmdZRmI4WXdRa0p6SVlNc2d5M1dFQWlxQUFaZ0JOcHdNWUFBQURrUUFBQTVFQXN3RlJBREVBQUFBQUFEb0FXbmphWTJCa1lHQmdabEJpQU5FTVVCSUpBQUFFQ2dBcEFIamFUWXc5YjhJd0VJYWZpQVNKZE9oU2RlZ0FIcGl0b0ZSaVkyRmdZbVhxQXRpZ0RIR1FIU0pGcWpyeXUzdTRIbnJENlhrLzdvQ1NIektlay9FYTkzTnlDbEYvWFBEQ1crS3BxRVhpa2crV1RNanltVGh6Tm9selNiNFNGN3h6U1R3Vi96dHh5U2VQYmRmZTdyMzFhdDhaNjkyNURlUDZZSDFvT3FkV3VvcDZaNTMxeDk0YWRScVZHWm93WEZ0VjYwclhiT2xvdVhHbngrSlI3TVV4a1IxbnlRSWphdzdSQ1RTU09tbXQwRlQvOHAza0xuYU84Wk9SemtrU0pUVElWWkI5bGJhaWpwZWEraGZ6ZVRCUEFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3M4O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5MTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMiB7Zm9udC1mYW1pbHk6Y21zeTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjMge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmY1IHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mNiB7Zm9udC1mYW1pbHk6Y21taTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mNyB7Zm9udC1mYW1pbHk6Y21yMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mOCB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mOSB7Zm9udC1mYW1pbHk6Y21yNTtmb250LXNpemU6NC45ODEzMnB4fQpdXT4KPC9zdHlsZT4KPGcgaWQ9J3BhZ2UxJz4KPGcgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjMuNzA2MDI0LC0xMC4yNjMwNzMpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS4zMzQwMSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjMuNzA2MDI0LC0xMC4yNjMwNzMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTIzLjcwNjAyNCcgeT0nLTEwLjI2MzA3Myc+QzwvdGV4dD4KPHRleHQgY2xhc3M9J2YyJyB4PSctMTUuODcyOTExJyB5PSctMTMuODc4NDM3Jz7ugLA8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQuMDQzNCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjcwNjAyNCwtMTAuMjYzMDczKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0yMy43MDYwMjQnIHk9Jy0xMC4yNjMwNzMnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzLjI2Mzg5LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjcwNjAyNCwtMTAuMjYzMDczKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjgnIHg9Jy0yMy43MDYwMjQnIHk9Jy0xMC4yNjMwNzMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTIwLjU5MjY4MScgeT0nLTEwLjI2MzA3Myc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTQuMjMzNTE5JyB5PSctMTMuMjY5NTknPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y4JyB4PSctMTAuMDY4NTUnIHk9Jy0xMC4yNjMwNzMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTYuOTU1MjA3JyB5PSctMTAuMjYzMDczJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjgnIHg9Jy0uOTYzNzQ1JyB5PSctMTAuMjYzMDczJz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzMuOTYzNzc4JyB5PSctMTAuMjYzMDczJz7DlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PScxMi4wMDQ2MzknIHk9Jy0xMC4yNjMwNzMnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nMTYuNjcxMjIzJyB5PSctMTAuMjYzMDczJz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9JzE5Ljc4NDU2NicgeT0nLTEzLjI2OTU5Jz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzI1LjE4Mjc5MycgeT0nLTE1LjI3OTgxMyc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjknIHg9JzI5LjM0Nzc2MicgeT0nLTEzLjI2OTU5Jz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9JzMyLjA0NjAxNycgeT0nLTEzLjI2OTU5Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjknIHg9JzM3LjIwNzI5NycgeT0nLTEzLjI2OTU5Jz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDkyLjUyNTYyLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy43MDYwMjQsLTEwLjI2MzA3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y3JyB4PSctMjMuNzA2MDI0JyB5PSctMTAuMjYzMDczJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xOS44MzE2NTEnIHk9Jy0xMC4yNjMwNzMnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTEwLjE0NTc4NScgeT0nLTEwLjI2MzA3Myc+w5c8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLS4xODMxNzInIHk9Jy0xMC4yNjMwNzMnPkQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nOC4zNDE4MTcnIHk9Jy0xMC4yNjMwNzMnPik8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nMTIuMjE2MTY4JyB5PSctMTUuMjcyMDkxJz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwNi41MTA2NywtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjcwNjAyNCwtMTAuMjYzMDczKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0yMy43MDYwMjQnIHk9Jy0xMC4yNjMwNzMnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTE1LjY0OTQxNicgeT0nLTEzLjg3ODQzNyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOS44ODk1NiAwSDg3LjQ3MDA4JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDg3LjcyMDA4LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDguOTI5ODEsMi44MTE4MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjcwNjAyNCwtMTAuMjYzMDczKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnLz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTExMy44MTEwMi04LjkwOTczVi00Ni41ODM1MScgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDExMy44MTEwMiwtNDYuODMzNTEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDExNy4wNzQ5LC0yOS43NDY2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTIzLjcwNjAyNCwtMTAuMjYzMDczKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjgnIHg9Jy0yMy43MDYwMjQnIHk9Jy0xMC4yNjMwNzMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTIwLjU5MjY4MScgeT0nLTEwLjI2MzA3Myc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTQuMjMzNTE5JyB5PSctMTMuMjY5NTknPuKIlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y4JyB4PSctMTAuMDY4NTUnIHk9Jy0xMC4yNjMwNzMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTYuOTU1MjA3JyB5PSctMTAuMjYzMDczJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjgnIHg9Jy0uOTYzNzQ1JyB5PSctMTAuMjYzMDczJz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9JzMuOTYzNzc4JyB5PSctMTAuMjYzMDczJz7DlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PScxMi4wMDQ2MzknIHk9Jy0xMC4yNjMwNzMnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOCcgeD0nMTYuNjcxMjIzJyB5PSctMTAuMjYzMDczJz4pPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9JzE5Ljc4NDU2NicgeT0nLTEzLjI2OTU5Jz5BPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjU5ODk0LTU2LjkwNTVIMTAxLjQ1NTEyJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDEwMS43MDUxMiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTAuODk2NiwtNjYuNTcyODUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy43MDYwMjQsLTEwLjI2MzA3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMjMuNzA2MDI0JyB5PSctMTAuMjYzMDczJz7PgDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTguNzk2OTU4JyB5PSctMTMuNjMzNzQ5Jz7igKA8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmOScgeD0nLTE5LjA0NzE4JyB5PSctOC4xMDAxNDgnPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTQ0LjE2OTU0LDM3LjczODMpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy43MDYwMjQsLTEwLjI2MzA3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMjMuNzA2MDI0JyB5PSctMTAuMjYzMDczJz5DPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tNDEuMDgxMTggMzMuODI4NTdDLTQ2LjUzNDQ1LTEuMDI5OTItMzYuMDYwNTgtMjguMTYwNjYtOC45ODgwOC00OS45OTg3MycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjc3ODMsLTAuNjI3ODIsMC42Mjc4MiwwLjc3ODMsLTguNzkzNTIsLTUwLjE1NTY5KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDUuMTMxMSwtMjAuNjc5ODkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy43MDYwMjQsLTEwLjI2MzA3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMjMuNzA2MDI0JyB5PSctMTAuMjYzMDczJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHN0cm9rZS1kYXNoYXJyYXk9JzMuMCwyLjAnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgo8cGF0aCBkPSdNLTMzLjgyODA4IDMzLjgyODU3TC05LjI3NzE2IDkuMjgxMDcnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43MDcxNCwtMC43MDcwNSwwLjcwNzA1LDAuNzA3MTQsLTkuMTAwMzcsOS4xMDQzMSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgZmlsbD0nI2ZmZic+CjxnIGZpbGw9JyNmZmYnPgo8cGF0aCBkPSdNLTI4LjY5MTE1IDE0LjU5NDc0SC0xNC4wNjA1M1YyNS42NDE5NUgtMjguNjkxMTVaJyBzdHJva2U9J25vbmUnLz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMjUuNjkxMTUsMTkuNjI4MDcpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0yMy43MDYwMjQsLTEwLjI2MzA3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMjMuNzA2MDI0JyB5PSctMTAuMjYzMDczJz7OtzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMTkuNjAxMjM2JyB5PSctOS4yMDU5MjYnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00tMzEuNzUxNTEgNDIuNTY0OTlDMTkuNzM5OTcgNTguMTY2MTUgNjMuMjA2OCA0OC4wMTMxMiAxMDIuMDk4ODMgMTEuNTYyNzYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC43Mjk2MSwtMC42ODM4LDAuNjgzOCwwLjcyOTYxLDEwMi4yODEyMywxMS4zOTE4KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0My4yMDc5Miw1Mi41NTExKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMjMuNzA2MDI0LC0xMC4yNjMwNzMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTIzLjcwNjAyNCcgeT0nLTEwLjI2MzA3Myc+aWQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTE4LjExMjM2MScgeT0nLTEzLjYzMzc0OSc+4oCgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0xOC4xMTIzNjEnIHk9Jy03LjkwNjQxNyc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMTIuOTUxMDgxJyB5PSctNy45MDY0MTcnPsOXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy03LjU1NDU3MScgeT0nLTcuOTA2NDE3Jz5EPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4=" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        width = 4cm,
        nw = C',
        nw/style = pullback,
        ne = {{(A \times  D)}^{A}},
        sw = B,
        se = {B^{A}},
        east = {(B^{*}(A) \times  f)^{A}},
        south = {\pi _{2}^{\dag }},
        west = {(B^{*}(A) \times  f)^{B^{*}(A)}},
        west/node/style = {right},
      }
      \node  [above left = of nw] (d) {$C$};
      \draw  [->,morphism,bend right] (d) to node[swap] {$f$} (sw);
      \draw  [->,morphism,exists] (d) to node[desc] {$\eta _{f}$} (nw);
      \draw  [->,morphism,bend left] (d) to node {$\mathsf {id}_{A \times  D}^{\dag }$} (ne);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  
    
      
      <fr:figure><fr:resource
hash="117011cef9609a1b7405931fb403c1e3"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE1Ny4yMTk3NTZwdCcgaGVpZ2h0PScxMjkuOTA0OTkxcHQnIHZpZXdCb3g9Jy03MiAtNzIgMTA0LjgxMzE3MSA4Ni42MDMzMjgnPgo8c3R5bGUgdHlwZT0ndGV4dC9jc3MnPgo8IVtDREFUQVtAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFRb0FBb0FBQUFBQkxnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUU0QUFBQmdxR3dVcjJOdFlYQUFBQUZFQUFBQU13QUFBRHdrSUI2R1oyeDVaZ0FBQVhnQUFBRlZBQUFCaUthN2x1Qm9aV0ZrQUFBQzBBQUFBQzhBQUFBMktldUZzV2hvWldFQUFBTUFBQUFBSHdBQUFDUUdEZ0VQYUcxMGVBQUFBeUFBQUFBTUFBQUFEQW54QVExc2IyTmhBQUFETEFBQUFBZ0FBQUFJQUhBQXhHMWhlSEFBQUFNMEFBQUFGd0FBQUNBQUJRQktibUZ0WlFBQUEwd0FBQUROQUFBQk9CTjdLcmR3YjNOMEFBQUVIQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1EbUNjd01ES3dNQTBpK25zUHhHR2ZoRE4rSWJ4RFlNeEl5Y0RFTEF4UUVBRGhIS0FjaGxTaXN2U0dkZ1VGSlRFbWJYK1dESXdNR3N4SHdjS016TEF3Zi8vREF3QUJGME96QUFBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFabVJnVWxCUUV2Ly9uNEVCUXQ5L2VQYzFXQlVRQUFDUFJ3amlBSGphTlkvTlRzSlFFSVh2bWRLNUZpZ3Q5TFlGZjJpNHJhM0VDSXBRakRHd2RlRlM0OFpvakpFSE1LN2N1TmZFUjlERW5UNlBTOTlGcjBZM001bHp6aVRmRVJEM1g1cTI2RU1jQ29FRVhZVHNnZVhQbU9aRDVNVzRuS09jZUdnZ0hXQmNUa2VKbFE4cG44d1FsMUg4RzU1amh0MHVGRXR0WG5CdHVVNEZiRXZMa3ZXWXJLV0toRjJyV3AxK01GQTkzKytGN2Y3R010bXlabFBHbkJGc24ybjUzMVdEb0kvMzduUmpVOS9kSEYzRlN3UzAvT3U5Mjhkc3VMM3B1VmFWcTVSNm10aHhLcXRKZXFCWE1wL0l6OWJTczJTMTRyQkQya3ZKcElTcEpKNUVTbGY0RkdOelRNdFJwQXh5RkVkeEE0WTFNZlNtMVJ5U0M1MmJuUmQ1TWNNb1FaRlBUTmtvbG5oNHFYZFVrOTlPVHdLQzZqaXZMcE51Qmx4L1hHYzNiQnRkRWNLMisxem5vS21waHBVTFIra0d6ZFo2c3QxUzRNdkZmdGRDSzk1WkhJZFEydjh6bkl2RlR0VnRnWkp6OFExSjl5MjNBQUFBZU5wallHUmdZQUJpWmQvSjhmSDhObDhabUZrWVFPQ3gvY0o0QlAxZmlTV1U2UXFReThIQUJCSUZBQWovQ2FrQWVOcGpZR1JnWU5iNlk4bkF3QkxLVU05UXk1VE1BQlJCQWN3QVQ2NERJZ0FFVlFBQUFxb0Fmd0x5QUk0QUFBQUFBSEFBeEhqYVkyQmtZR0JnWnZCa0FORU1VQklKQUFBSDJRQlFBSGphVFl3OWI4SXdFSWFmaUFTSmRPaFNkZWdBSHBpdG9KU1ZoWUdKbGFrTFlJTXl4RUYyaUJTcDZzanY3dUY2NkEybjUvMjRBMHAreUhoT3htdmN6OGtwUlAxeHdRdHZpYWVpRm9sTFBsZ3lJY3RuNHN6WkpNNGwrVXBjOE00bDhWVDg3OFFsbnp5MlhYdTc5OWFyZldlc2QrYzJqT3VEOWFIcG5GcnBLdXFkZGRZZmUydlVhVlJtYU1Kd2JWV3RLMTJ6cGFQbHhwMGVpMGV4RjhkRWRwd2xDNHlzT1VRbjBFanFwTFZDVS8zTGQ1SzcyRG5HVDBZNkowbVUwQ0JYUWZaVjJvbzZYbXJxWCsvcE1FY0FBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFFQUFvQUFBQUFCSlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTjBybU50WVhBQUFBRTRBQUFBTWdBQUFEd0FUZ0I5WjJ4NVpnQUFBV3dBQUFFOEFBQUJZUGxmdzExb1pXRmtBQUFDcUFBQUFDMEFBQUEyS09pRnUyaG9aV0VBQUFMWUFBQUFIZ0FBQUNRRnVnSzBhRzEwZUFBQUF2Z0FBQUFRQUFBQUVBcGVBVnBzYjJOaEFBQURDQUFBQUFvQUFBQUtBT1lBYUcxaGVIQUFBQU1VQUFBQUZ3QUFBQ0FBQmdBdGJtRnRaUUFBQXl3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRCtBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbW1zNDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWURCaVp2Z1A1RE5EcEpIVS9BY0tBd0RYS1F6aGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS2FqSVkvZjhQNUd1QTZQODMvMThFcXdJQ0FJdDBDTVVBQUhqYUxjK3hUc0pnRUFmd3Uydjd0WlFJQ1pFV0lZVzJTTDhFRlNJcE1GWENab2dZZzRsR1NTZUNBU2FNaXpvYTNabjFCWWpQNEdqd0JYd0huOEJGRS9XamVMZmMzZkQvNVFEaDhSZndUUUxJQTJBQ1ZXWWFVYTh6bDFlUWU3elIzTU5tbzJha0diNzJIaFRKMWZTZGF3MVp0dTEwN0VDV0E3dmp0TE1NNmFQeCtSTGVaTXpib2F6THVtK2RCOVA1L0RJNHMzeGRqb0VvaElHd1pzTEtpWVdwUzgycm9oOEJLWTk3WWpEemFCbzQrMCtWU09HblhoMHZybFJKV29FSXEweFVORTIyQmlkM21QME80M0VGSTFBWUlRRDE2Um0yQUVxcVUvZGJKT0xGSnk1VFJYWUNpOHpqNGxJenpLV2Z4RkwwSVBYZG4wMHA5aFYwa1VaZHYyZGtIRVF2bmRnbXVwOU1ueVFhN1Zmclk2U3l2cGFreGFLZ1VPeDlkOUk2T01aeWtRbzUyOElOM2gzU2VIQTBydGo4RUZHT3QxTUFmekF3TzFCNDJtTmdaR0JnQU9MWW84OXM0L2x0dmpJd3N6Q0F3R1A3aGZFSStqOERjeEF6aU12QndBU2lBQ1hPQ1pNQUFBQjQybU5nWkdCZ1p2alBBQ1NER0dJWllwbWlHWUFpS0lBRkFEM1RBblVBQUFOU0FBQUNLZ0NhQWlvQVl3SzRBRjBBQUFBQUFEWUFhQUN3QUFCNDJtTmdaR0JnWUdIUVlRRFJERkFTQ1FBQUJSOEFOQUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVQwQUFvQUFBQUFCYlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWeDE0V050WVhBQUFBRTRBQUFBTWdBQUFEd0FuUUI3WjJ4NVpnQUFBV3dBQUFJbEFBQUNmRFpIeWNsb1pXRmtBQUFEbEFBQUFDOEFBQUEyS1c2RnhXaG9aV0VBQUFQRUFBQUFJQUFBQUNRSFJBTWlhRzEwZUFBQUErUUFBQUFRQUFBQUVBNWJBV0JzYjJOaEFBQUQ5QUFBQUFvQUFBQUtBYVFBekcxaGVIQUFBQVFBQUFBQUdBQUFBQ0FBQ0FCS2JtRnRaUUFBQkJnQUFBRE5BQUFCT1BOYktwOXdiM04wQUFBRTZBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbW5zWTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWkVoalp2Z1A1RE5EcEpIVS9BY0tBd0RnRlEwdWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS09qR2svZjhQNUR1QzZQOEgvczhGcXdJQ0FKUmZDUklBQUhqYU5aRk5heE5SRklidmUrNTRiNUw1emt4bTB0aW1abEltYmJHTmJkSVpXa3BpV3duRzF1SUhDbFlRRlJkYTdVYkJqZTRVRndxSy9nTEJQK0JDY0tHclFoSGN1bkhqVGxEL2d0RFVPdzNlczNudlBXZHhudnN3WW5jT0R2Z1grc0VXMlRKajhLcG9KVUVZeUNac3hJME93aUJKbTZoSllaT1FWYVJoRUZySW1sSGNpSk8wZ3hRZHpBZVMxK2ozUTVSUDZCNVFPYm5hUDFVRVBDTzNwSm51NEt1bjhYVkRnT0tjTGdGWFBHalBhanBCV25PclZieVJUbVJzL1VTZGR2ZWZ1eWFFY1pRNHdPR1U4b0IwZTFzZ2JjZlg4OFVDaUJ2cVVRT1hCUm9oMUdlcHB4dkcvY0VIcGc1bmp4WExkL3JNSmxtYmRSbEx2WFFoYmtMRUMrMGtyRlVSQ3BsVkZYSVlhc1BPZk9LMUZFYzdidFJqSWZuL3pPWGdHWGY5VWMvekhieTcrNVMwTmRQcDkyOWZCNzlnMkZlZkROWXNQeWlsWSs5M2QxNVNmK1BUdUt2ZDI3djFXdHZjL052amwyakVNRFVBd3ZRVnhjV1Yza3doUDVtM0w4K3Rkd3I1SmE0b0ZZaURMcis1TXQwaEdNSCtMdDNZbU8vVDRJK25XTUFlSGN6UUhuMWpwOVdGMnhEU1VtdG5SbHBCNkFzWmpLdC9UNU11a3JRK3hHaGwrYkF5UmZWRFBZbytVdW95cDc0Q3hxOUZNKzlXaWlzejBWbU9xZEkwOTB1MjVZMU5ISEdMbzY1K3hmUjgrNW9sdEhMT3JKK2ZQS05HZ21rT28rcllYaVVzR09VZDA4OXhEUzhHSHp2UjhsU2xSWWhtbzRnMzNGcEJnaWdwZGJmZmJpOE5tYy9WanJVZHQ2bGg0bmcySWhwV2psQjJ1cThnUm5RT3h2NEJlSmxmeVFBQUFIamFZMkJrWUdBQTRpUFBacTJNNTdmNXlzRE13Z0FDaiswWHhpUG8vN3JNTjVqdUFya2NERXdnVVFCV0ZRdktBSGphWTJCa1lHQm0rTS9Bd01DaXhwRDUvenZ6RFFhZ0NBcGdBUUJtbkFSdEExUUFBQVFsQUdrRUpnQjhBcndBZXdBQUFBQUFaZ0RNQVQ0QUFIamFZMkJrWUdCZ1lmQmtZR1lBQVVZR05BQUFDQ0lBVTNqYVRZdzliOEl3RkVWUDFBU3BZV0JCSFJoYUQ1MnRvTURhaFlHSmxha0xZQmRsc0kyY0VBbXA2dGpmM1lmeDBEZGNuZnRoQXpVL0ZOeXZZSmIwZmlXVnVBZFhUSmxubm9oN3kxeXo0SjBuaXZKWmtsYytNcGZTZkdhdWVPRXI4MFR5Nzh3MUszNDN3VjJ1ZzQxcUY0eU4vdVJjdDk3YjJIZkJxNlZ1a3Q5YWIrTmhzRVlkYjhxTVhUK2VuV3AxbzFzMkJCd1hyZ3hZSW9xZEpDYXg1eVNkbzJQTlBpVzljSkJjc1VUVC9PdTMwdnUwT2FTZmpHeU8zRVFOb3l4NjBiTnNGVzE2cVduL0FNZ1JMKzhBQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVmtBQW9BQUFBQUJsZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaGR4NFRHTnRZWEFBQUFFOEFBQUFPd0FBQUV3RWNBUThaMng1WmdBQUFYZ0FBQUtHQUFBRERJM053c3BvWldGa0FBQUVBQUFBQUM4QUFBQTJLTk9GeEdob1pXRUFBQVF3QUFBQUhnQUFBQ1FHYmdKR2FHMTBlQUFBQkZBQUFBQVVBQUFBRkExRUFPTnNiMk5oQUFBRVpBQUFBQXdBQUFBTUFZUUNSRzFoZUhBQUFBUndBQUFBR0FBQUFDQUFDQUJGYm1GdFpRQUFCSWdBQUFETkFBQUJPUE5mS3FOd2IzTjBBQUFGV0FBQUFBd0FBQUFnQUFNQUFIamFZMkJtV3M0NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdJTkdCaVNRVWx5V0RwUjBaRDdBelBBZnlHZG1ZQVFKTXlKVS9BY0tBd0FKL3c0YkFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ3NnRFFYQXdkUWpvbkJrU0dOZVN2emdmLy9nV0p3OXY4RC8rZjg4ZnZqQXRZQkJRQnpRUTZwQUhqYVJaSzliOU5BR01iOTNMbm5qemcrSjdIUFNkTTRUWnpZL1NKSkUycWpoQ2FscFFLMVNGVkJvcFFGTVREUUdRa2tKRUNJaFlXRkRveDA3WitBR05rUllrT01qRWdzZEtUaExBWnVPT251dHp5Lzkza1ZvZ3luVTdwT3Zpa0RKVkdVRkVuYUYzN0pGWU8rOEZ5dEM2MkR0VEg4TWRLNHdjRzhBQU5mK0RZa1lmRVlBd2thOUN1ZW1CVmJKM2ZGc3VXNHcvVlhKb05qck15aWN2Nzlwc2xJcU9jWXdHY2UzckVvdUw0eU9vSFdlMHF1QzFpRlA2OUx0cHJ6UUtIQ3BBVU5LT2luejRzNXc4MFJhc2kzcXNMaEdsMzZpRDFGZ2JJNzdaSWo4a1haa0E4cUUyazJ0R2FVUlJHK1lKcW9ZNHdKRFZtVStGazQrZC9QOG9aUkhDVnAxSVZOT0FhSllERk9obzdxekJwWFZoZUdRTXVMWkxRNjU3elZvTFVPdnhHUUV0L25uaTAydzhYTFFDZ2tkd0xPaThYQTFHZnZaUmpINTU5MkNoc1gzUzBhaGNFOGFiRTRaeENvdTk2N3N3UGExSEJ3V0kyamR1cy9RaVc2OEVadDZsRGtJVXB2K2hPLzhGa1pLVnR5OWpaODVzdjgvU1JOMGdDWld3ZFNMUDEzSjhJUElFMml1Q09OcGFrc3hVOHl0NWpGWWtLNllLZUROakNxMVFkNzE0cXFuaWNMenVyUjdRY2dsK28wSk9yeGZhdmZLTFFBVDVqaE1MLy9tSkoyTkxJYVBkRHgzSEl1S0xmZGNybjdvem9wTFZWTlFxcUI3S0lhVzVHS25XRnZzNGgyZmVNV3dHem1PZmtTMFZ3VHEwdk5rcTBEZVhjdUI3VTlJNmtLa3JsQjZVelB5RnQ4eUxZS1dqYi90WWxzSmcwanByRXVzc0prTjM1RENrZ2FoNHhEMm9tc1RTYXJ5akRHazBJUXRLaGJ2am83S2U0dHp0aHlyY2l5YUt3RmVNbm5RRlcvOGtJR2hlY1lRSzJZOTZ5Y25MQ0ZSNyszdDlVYWozdnZENGcvc0VCZ0dDTjMzZ01Nanh0Rmt0YTdrOE9hWmJvVm9OU2VIMDJlZFdYa3YyZ25ZNThBQUhqYVkyQmtZR0FBWXFHYWFlL2orVzIrTWpDek1JREFZL3VGOFFqNnZ6NnpMZE10SUplRGdRa2tDZ0FtcHdwVUFIamFZMkJrWUdCbStNOEFKQXNZOVA1ZllMWmxBSXFnQUZZQVdid0R1Z0FBQXNZQUFBTndBRG9DT2dCTEFpZ0FNQUtzQUM0QUFBQUFBRmdBdmdFc0FZWjQybU5nWkdCZ1lHVndZV0JpQUFGR0JqUUFBQWVwQUU1NDJrMk1QVy9DTUJSRlQ5UUVxV0ZnUVIwWVdnK2RyYUFnc1hWaFlHSmw2Z0xZUlJsc0l5ZEVRcW82OW5mM1lUejBEVmZuZnRoQXpROEY5eXVZSmIxZlNTWHV3UlZUNXBrbjR0NHkxeXg0NTRtaWZKYmtsWS9NcFRTZm1TdGUrTW84a2Z3N2M4MkszMDF3bCt0Z285b0ZZNk0vT2RldDl6YjJYZkJxcVp2a3Q5YmJlQmlzVWNlYk1tUFhqMmVuV3Qzb2xnMEJ4NFVyQTVhSVlpZUpTZXc1U2Vmb1dMTlBTUzhjSkZjczBUVC8rcTMwUG0wTzZTY2pteU0zVWNNb2kxNzBMRnRGbTE1cTJqL0xvUy8zQUFBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pMTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVNrQUFvQUFBQUFCVWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hWMTFFMk50WVhBQUFBRTRBQUFBTEFBQUFEUUFEQUNYWjJ4NVpnQUFBV1FBQUFIYUFBQUNFTkgzWStSb1pXRmtBQUFEUUFBQUFDOEFBQUEyS00yR2VHaG9aV0VBQUFOd0FBQUFIZ0FBQUNRR1l3SWthRzEwZUFBQUE1QUFBQUFRQUFBQUVBdW9BSWRzYjJOaEFBQURvQUFBQUFvQUFBQUtBV1FBdW0xaGVIQUFBQU9zQUFBQUdBQUFBQ0FBQ0FBNmJtRnRaUUFBQThRQUFBRFNBQUFCUHBrUmRjVndiM04wQUFBRW1BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbWVzVTRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFIwWW5CaFp2Z1A1RE5EcEpIVS9BY0tBd0Q2Z0ExZ2VOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdCU0FOQXNRZ3ZndS8vOERTYWYvLy8vdkIvTVpBRkxPQnFCNDJqWFF6Mm9UVVJUSDhmdTdaM0xIcG1VbWRuQW0wbVpDVERQVFJDWVVNc3lrQVZ2cDJGaFRURklqV21vd0tJaFlzUDVwclYxMGtVVkZsSFloUWpjdVhPaE9mQU5Ycmx5NThnbDA1VE5JMHQ0Und0bGNEbmZ4UFI5RzdPTEpnQVQveG14V1lsWEdRc1BQdThJUHJKeU5jeHBVRzViUUlkUmN2RE1EbzdLQU1IRGN2Q05VR3IxSmZxaDhQcHB5TTdxTzllNTk2bmRXTytCWFU5ZGZETjlQYTFyTi9uamMyK0VvUndkWkk3RjEyTjNsZkc3bGUxMEJ0RGFmUDh0cFdnVmZxelVlNnNubS9PcVN0cUJRUmdVTUxOUHorc3dWRHYzODRBdTliQmJhTlB3ektaS01nVlZPL3RJNC94VTNnelRrWGNkZGhPKzRzamtPdG15RVpoREdoVm5ZOGdDNUw4TU53bmhNeTdSQ2VRNGxMNU5JamlYQWNhdTEvR3F1UGlWTUtQdlhabnVCN3dsbFRFMlFWeTgraS9ZK0VIWDh4dlpCcHpnclZqUk04Qi9EZjVwc1ZuVm5ZeE9JcXV1OWROZmJ2Y2R4b1ZUdXBzY0JQdkY0cVZBQkhmZmY3RFQ4RzZUTUZMU1d4b2t4eGxsUm1vZlNQTTI4V0R3WWdWdENqV2RrL2QvVmlrOVlST0NXb1VyMVQwZUk3SlJrM3Q0SHRVclZ6Zjd3YTBhWHhMOFBZODYzZC9lc1d2ck1KUGlqNWxiV2tMb3Bvb3dBdlh2eSt1a2w3eWFSTFNRc2p3WS9wU09VZG5idFR1NjIrMkFEMEdYYUtTRWdYY3dBQUhqYVkyQmtZR0FBWWgrVjZ4dmorVzIrTWpDek1JREFZL3VGOFFqNi8wdG1jNllyUUM0SEF4TklGQUFzc3dybkFIamFZMkJrWUdCbStNOEFKUDBaTlA5ZllEWm5BSXFnQUJZQVZaMERqUUFBQW5ZQUFBTUlBQ3NDMndBekEwOEFLUUFBQUFBQVhBQzZBUWdBQUhqYVkyQmtZR0JnWWJCa1lHWUFBVVlHTkFBQUJwSUFRM2phVFk2eGFzTXdFSVkvVThkUXA5Q3BIVG9VVFJtRmpmc0FnUXlac21Zc0pKRUlEa2dLc21QSUV2b0FmZWhlRkEwOXdmSGRkNytFZ0pvYkJmY3FlRTM5WGlXVlRBK2VNZWN0Y3lWSFphNzVZTUVUUmZrczVwTmw1cElYdmpQUGVPZVV1UkwvazdubWk5OVZjT2ZMYUtQYUJHT2pQempYdDgzV3hxRVBYclc2ZVlpMTlUYnVSbXZVL3FyTTFBL1QwYWxPTjdwalJjQng1c0tJSmNyUE5tSk1ZczlCZG82ZWxvWnRjb05NUVRaS25CYjdQN0dXaEUrcFhYck5TR3JQVmJwaGtzd2cvU2hwUlpmdWFyby8zL1F3dXdBQWVOcGpZR2JBQ3dBQWZRQUUpIGZvcm1hdCgnd29mZicpO30KdGV4dC5mMCB7Zm9udC1mYW1pbHk6Y21zeTU7Zm9udC1zaXplOjQuOTgxMzJweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21taTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtbWk3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbW1pNTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbXI1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00MC40NjAwNDUsLTU2LjQzNTk2MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxwYXRoIGQ9J001LjY5MDQ2LTE0LjIyNjM2SDE0LjIyNjM2Vi01LjY5MDQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00LjI3ODQ3LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MC40NjAwNDUsLTU2LjQzNTk2MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDAuNDYwMDQ1JyB5PSctNTYuNDM1OTYzJz5EPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC00LjA0MzQsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC00MC40NjAwNDUsLTU2LjQzNTk2MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNDAuNDYwMDQ1JyB5PSctNTYuNDM1OTYzJz5CPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00wLTYuNDA5NzNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTI4LjY0NDM1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQwLjQ2MDA0NSwtNTYuNDM1OTYzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00MC40NjAwNDUnIHk9Jy01Ni40MzU5NjMnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTM1Ljc5MzQ2MScgeT0nLTU5LjQ0MjQ4MSc+QjwvdGV4dD4KPHRleHQgY2xhc3M9J2YwJyB4PSctMzAuMzk1MjM0JyB5PSctNjEuNDUyNzA0Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTI2LjIzMDI2NScgeT0nLTU5LjQ0MjQ4MSc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMjMuNTMyMDEnIHk9Jy01OS40NDI0ODEnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNCcgeD0nLTE4LjM3MDczJyB5PSctNTkuNDQyNDgxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ5LjcxNzMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQwLjQ2MDA0NSwtNTYuNDM1OTYzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00MC40NjAwNDUnIHk9Jy01Ni40MzU5NjMnPkM8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTMyLjYyNjkzMicgeT0nLTYwLjA1MTMyNyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OS42MDUxNSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQwLjQ2MDA0NSwtNTYuNDM1OTYzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy00MC40NjAwNDUnIHk9Jy01Ni40MzU5NjMnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTMyLjQwMzQzNycgeT0nLTYwLjA1MTMyNyc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC44MzQwMSAwSDQ0LjY2MTc2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ0LjkxMTc2LDAuMCknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjIuODUzNTksNi4yMDUwNiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQwLjQ2MDA0NSwtNTYuNDM1OTYzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00MC40NjAwNDUnIHk9Jy01Ni40MzU5NjMnPs61PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjAnIHg9Jy0zNi42OTYwMjMnIHk9Jy01OS44MDY2MzknPuKAoDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctMzYuNjk2MDIzJyB5PSctNTQuMDIzOTczJz5mPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTYuNDA5NzNWLTQ2LjU4MzUxJyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDYuODMzNTEpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0yOC40OTY2MSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTQwLjQ2MDA0NSwtNTYuNDM1OTYzKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00MC40NjAwNDUnIHk9Jy01Ni40MzU5NjMnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTM1Ljc5MzQ2MScgeT0nLTU5LjQ0MjQ4MSc+QTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNOC41OTg5NC01Ni45MDU1SDQ0LjU0OTYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDQuNzk5NiwtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjIuNDQzODUsLTY2LjU3Mjg1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNDAuNDYwMDQ1LC01Ni40MzU5NjMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQwLjQ2MDA0NScgeT0nLTU2LjQzNTk2Myc+z4A8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTM1LjU1MDk3OScgeT0nLTU5LjgwNjYzOSc+4oCgPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0zNS44MDEyMDEnIHk9Jy01NC4yNzMwMzknPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = D,
      nw/style = pullback,
      ne = {C^{A}},
      sw = B,
      se = {B^{A}},
      north = {\varepsilon _{f}^{\dag }},
      west = {f^{B^{*}(A)}},
      south = {\pi _{2}^{\dag }},
      east = {f^{A}},
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Note that <fr:tex
display="inline"><![CDATA[B^{*}(A) \times  f^{B^{*}(A)}]]></fr:tex> is the diagonal of the following pullback square:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="149a7da7ae4799d552fa3ebf29487b29"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzIxMS4zMjEzOXB0JyBoZWlnaHQ9JzExMS4wMTI3OTJwdCcgdmlld0JveD0nLTcyIC03MiAxNDAuODgwOTI3IDc0LjAwODUyOCc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFZQUFvQUFBQUFCTEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVlBQUFCZ2hnRjRNMk50WVhBQUFBRThBQUFBTVFBQUFEd0hLLzFwWjJ4NVpnQUFBWEFBQUFGTkFBQUJnQUp2aHNSb1pXRmtBQUFDd0FBQUFDOEFBQUEyS0Z5RnRXaG9aV0VBQUFMd0FBQUFJQUFBQUNRRnhBR2FhRzEwZUFBQUF4QUFBQUFNQUFBQURBZXNBSGxzYjJOaEFBQURIQUFBQUFnQUFBQUlBR1lBd0cxaGVIQUFBQU1rQUFBQUZ3QUFBQ0FBQlFCQ2JtRnRaUUFBQXp3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRURBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbTZtT2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3RUVqQXhKSUtTNUxCMHFtTVI5Z1p2Z1A1RE16TUlLRUdSRXEvZ09GQVFWbERpY0FBSGphWTJCZ1lHSmdZR0FHWWhFZ3lRaW1XUmcwZ0RRYmtHWUV5cVl4SC9qL0g4Z0gwLzluLzNFQ3F3SUNBS05FQ1pJQUFBQjQya1dQdTFMQ1FCaEc4MjNpaGdCbVF5QWJRUW1YaEkyTUkxRWp5UXc0QkM4MDRveGp4VkRaVzFzN2pnOWdvNFdsdm9hMUwrQzdTQ3R1S3YvdSswOXpqZ0psdm83SUhmbFdwb29DbFlIcUp2U3VDQ2VJdWN1cHpsdVlJRk45S2hJM25pQ1YveVB1bXZCRktKSlVSREFKUTV4d0d1SmpaR2xXd3pnOTNCMEJnU05Vc0JaakxPaW96UUc3OGtpVjNUREg1R2QrL3dUd3VlU1d4NWh0ZThWQzR6YkhlUDM5dXF4TWoydm5xdkM5Tmdsb1dESUl0TG56dGxxb1hSMkw1WFlvZXNFL1FsM3NQMnZkQWhSNVVBYnJGWG5CcDVMSW9lZU93MHphcDc2Z09vMlFSMGwvdDVOd1Y5TFFwd3dlWEo0WFU1bVRZMHl5aXVjRmFtM3JvcEhaMS8wTnMwaEI5bmhuNk9HSjdVRFYzUHBqa1JBNGxnRTA3VTJuWEpJV1pkei96R1phazRVSDd3dml4bVVRR01hNDFuWUF3MkdHVGRKV2xDMmI1V0t0RGxSNzdYSDJFRW5sUDF0Yk1Ka0FBQUI0Mm1OZ1pHQmdBR0pqYmYzZ2VINmJyd3pNTEF3ZzhOaCtZUXlDL3EvUGRJenBJcERMd2NBRUVnVUErRnNKbWdCNDJtTmdaR0JnWnZqUHdNREFkSXhCNy84RnBza01RQkVVd0F3QWFGUUVZZ0xHQUFBQ09nQkxBcXdBTGdBQUFBQUFaZ0RBZU5wallHUmdZR0JtY0dRQTBReFFFZ2tBQUFjUkFFZ0FlTnBOakQxdndqQVVSVS9VQktsaFlFRWRHRm9QbmEyZ0lMRjFZV0JpWmVvQzJFVVpiQ01uUkVLcU92WjM5MkU4OUExWDUzN1lRTTBQQmZjcm1DVzlYMGtsN3NFVlUrYVpKK0xlTXRjc2VPZUpvbnlXNUpXUHpLVTBuNWtyWHZqS1BKSDhPM1BOaXQ5TmNKZnJZS1BhQldPalB6blhyZmMyOWwzd2FxbWI1TGZXMjNnWXJGSEhtekpqMTQ5bnAxcmQ2SllOQWNlRkt3T1dpR0luaVVuc09Vbm42Rml6VDBrdkhDUlhMTkUwLy9xdDlENXREdWtuSTVzak4xSERLSXRlOUN4YlJadGVhdG8veTZFdjl3QUFBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFNNEFBb0FBQUFBQTVnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdpT0p6b0dOdFlYQUFBQUZBQUFBQUtRQUFBRFFBREFFcVoyeDVaZ0FBQVd3QUFBQjBBQUFBZEJmOE5TUm9aV0ZrQUFBQjRBQUFBQzhBQUFBMktTZUZ0bWhvWldFQUFBSVFBQUFBSGdBQUFDUUdzZ0I2YUcxMGVBQUFBakFBQUFBR0FBQUFCZ1JFQUFCc2IyTmhBQUFDT0FBQUFBWUFBQUFHQURvQUFHMWhlSEFBQUFKQUFBQUFGd0FBQUNBQUJBQWpibUZ0WlFBQUFsZ0FBQURPQUFBQk9CTi9LcnR3YjNOMEFBQURLQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1uc2c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FNbUJpU1FVbHlXRHBTOHpuQ2RXZkdQRVFNRHN5THpPYUF3STBMRi8vOE1EQUFYc3c5eUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hDQytOZi8vNGVRLzdYQWZBWUFYdVVITXdBQUFBQUJBTFAvN2dMY0FoTUFJUUFBQVFjZkFSWVZCaU1pTHdFSEJpY21KeVkvQVNjbU56WTNOaDhCUHdFMk16SVhGZ0xONElCcEJRUVVDZ2ZwNGcwS0dBSURFOS9mRVFFQ0dBc000dUFOQlFnVUJBRUI0T0NBYWdRS0dRWHA0QThCQWhjSEU5L2ZEd29YQWdFUDROOE1BeGtKQUFBQWVOcGpZR1JnWUFEaUsrd1BOOGZ6MjN4bFlHWmhBSUhIOWd0akVQVC9kOHdUbVlTQlhBNEdKcEFvQUQ0Z0N2WUFlTnBqWUdSZ1lGYjhZd1FrSnpKc1p0aktkSWNCS0lJQ0dBRmx5d1F3QUFBRGtRQUFBTE1BQUFBQUFBQUFPZ0FBZU5wallHUmdZR0JpVUdJQTBReFFFZ2tBQUFQdkFDZ0FlTnBOakQxdndqQVFocCtJQklsMDZGSjE2QUFlbUsyZ1ZHSmpZV0JpWmVvQzJLQU1jWkFkSWtXcU92SzdlN2dlZXNQcGVUL3VnSklmTXA2VDhScjNjM0lLVVg5YzhNSmI0cW1vUmVLU0Q1Wk15UEtaT0hNMmlYTkp2aElYdkhOSlBCWC9PM0hKSjQ5dDE5N3V2ZlZxM3hucjNia040L3BnZldnNnAxYTZpbnBubmZYSDNocDFHcFVabWpCY1cxWHJTdGRzNldpNWNhZkg0bEhzeFRHUkhXZkpBaU5yRHRFSk5KSTZhYTNRVlAveW5lUXVkbzd4azVIT1NSSWxOTWhWa0gyVnRxS09sNXI2Ri9ONU1FOEFBSGphWTJCbVFBYU1ER2dBQUFDT0FBVT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbW1pNTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBUTRBQW9BQUFBQUJNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MkJtTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQ1ZaMng1WmdBQUFXUUFBQUY2QUFBQm1LcDloOFZvWldGa0FBQUM0QUFBQUM4QUFBQTJLVzZHa1dob1pXRUFBQU1RQUFBQUh3QUFBQ1FIUXdONGFHMTBlQUFBQXpBQUFBQU1BQUFBREF1ZkFPVnNiMk5oQUFBRFBBQUFBQWdBQUFBSUFHWUF6RzFoZUhBQUFBTkVBQUFBRmdBQUFDQUFCd0JCYm1GdFpRQUFBMXdBQUFETkFBQUJPUE5iS3A5d2IzTjBBQUFFTEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdnM4NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSEJpWnZnUDVETkRwSkhVL0FjS0F3RDJoZzFUZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmhPLy84RFNjZi8vLzhmQVBNWkFGS29CcDU0MmpYUHYwb2NVUmdGOEh1K2U3blgyYm16TytNZForSy9rWFZoVm9TNHVxNHpLREwrWldGUUxCUlRtRWJGUWpFMkNWalpKVmlrQ0NTdjRBdFlwRXVxaFJESUU2U3hzekN2RUhCMFJQeSs1bkJPOVdQRVRoNGUrRys2WWZOc2tUR1lDTE5KRUFhcWhScmlab1l3U05JVzZrcldTS29JYVJpRVZUeU40M0V6VHRJTUtUSzBBOFhyZEhlT1Y5TzJBWWFXVi9QMWZzRG92Z1hoZU1VZkkvaUdscUM0ejFhQUp6OTBwb1JOVU5XWjFRamZsRHV1OTI3Um9ONzlaOCtCMU1QRUFRNTN3QUtVMTkwRGlUUGZ0dm9ySUs3TFVvQ3JDZzBTR2xQVXRiVitYM3huNVhGMlVWciswazgyd1Rwc2liSFVwSE54Q3pLZTZ5UmhQVUlvMWROSFVNK2gvcnkwRXpOYk9qcHhzeEZMeFY4eVY4VWw5L3dSWTN3WFY2ZWZTS3c1YnA0Zjc0TnY2OXJiajhWYTFROEcwdEhyM3RrWHlqZC9qSG5pM2EranIySnI2MytYNzlLZ2RnUUE2ZmlsWW1lbCs3cGlUVmkxTnpNYldjVmE0S1d5aExoWTRvY3JreGxCQi9jOU90aHM1MVQ4TTR3OUFwM1VRa01BQUhqYVkyQmtZR0FBNHFkVFZScmorVzIrTWpDek1JREFZL3VGTVFqNi8zL21HMHgzZ1Z3T0JpYVFLQUEraWd2SUFIamFZMkJrWUdCbStNL0F3TUNpeHBESjRNZDhnd0VvZ2dLWUFVTFVBc1FBQTFRQUFBUWxBR2tFSmdCOEFBQUFBQUJtQU14NDJtTmdaR0JnWUdad0FHSVFZR1JBQXdBSEpnQkpBQUI0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhREEyb1dCaVpXcEMyQVhaYkNObkJBSnFlclkzOTJIOGRBM1hKMzdZUU0xUHhUY3IyQ1c5SDRsbGJnSFYweVpaNTZJZTh0Y3MrQ2RKNHJ5V1pKWFBqS1gwbnhtcm5qaEsvTkU4dS9NTlN0K044RmRyb09OYWhlTWpmN2tYTGZlMjloM3dhdWxicExmV20valliQkdIVy9LakYwL25wMXFkYU5iTmdRY0Y2NE1XQ0tLblNRbXNlY2tuYU5qelQ0bHZYQ1FYTEZFMC96cnQ5TDd0RG1rbjR4c2p0eEVEYU1zZXRHemJCVnRlcWxwL3dESUVTL3ZBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3k1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFOa0FBb0FBQUFBQTh3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVvQUFBQmdxbUtWQW1OdFlYQUFBQUZBQUFBQUtnQUFBRFFBRENKcVoyeDVaZ0FBQVd3QUFBQ2tBQUFBcUI2eXRlUm9aV0ZrQUFBQ0VBQUFBQ3dBQUFBMktlcUZrV2hvWldFQUFBSThBQUFBSHdBQUFDUUdIUUVnYUcxMGVBQUFBbHdBQUFBSUFBQUFDQWRIQUk1c2IyTmhBQUFDWkFBQUFBWUFBQUFHQUZRQUFHMWhlSEFBQUFKc0FBQUFGd0FBQUNBQUJBQTJibUZ0WlFBQUFvUUFBQUROQUFBQk9CTjdLcmR3YjNOMEFBQURWQUFBQUJBQUFBQWdBQU1BQVhqYVkyQm1Yc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqUUFFT01FWktjVms2QTV1U3VKSTRzOVlmU3dZR1ppM200MEJoUm9UUy8vOFpHQUFHclE2WUFBQjQybU5nWUdCaVlHQmdCbUlSSU1rSXBsa1lGSUEwQ3hBQytVcmkvLzlEeUx1dndQSU1BRklSQnBVQUFIamFMY2xCQ29KQUdJYmgrU2I0QjBzdGRSeVZLR21pY1Zjb3B0RENMbEcwU3lMd01BVWRvYUJkZCtvd3VXajF3dk15c0FkYjhpdStyR1FNZFZVb1NXT29TRVV1ekFZcFNLeFI3aUVvMDZhdnlVeldvRWlSbVcxWjFTb1N1TDNzUkhyME9SMEREcGxZYjRlNDlnS3k3eXR5d3JoM3lSSEd6dE9td05OOGhHbHJTZTN5WnJZUXNTOUJsMjQzSDhDUDh1NFFRdXJKZjFodGx3OGRIenc5c3g5Vk94WmJlTnBqWUdSZ1lBRGlXcDV3d1hoK202OE16Q3dNSVBEWWZtRU1NczBTeW5nSFNIRXdNSUY0QU9RWkNCaDQybU5nWkdCZzF2cGp5Y0RBRXNyUXg5RFBsTXdBRkVFQlRBQlNnQU5DQUFSVkFBQUM4Z0NPQUFBQUFBQlVBQUI0Mm1OZ1pHQmdZR0l3WlFEUkRGQVNDUUFBQmNvQU93QjQyazJNUFcvQ01CQ0duNGdFaVhUb1VuWG9BQjZZcmFDVWxZV0JpWldwQzJDRE1zUkJkb2dVcWVySTcrN2hldWdOcCtmOXVBTktmc2g0VHNacjNNL0pLVVQ5Y2NFTGI0bW5vaGFKU3o1WU1pSExaK0xNMlNUT0pmbEtYUERPSmZGVS9PL0VKWjg4dGwxN3UvZldxMzFuckhmbk5venJnL1doNlp4YTZTcnFuWFhXSDN0cjFHbFVabWpDY0cxVnJTdGRzNldqNWNhZEhvdEhzUmZIUkhhY0pRdU1yRGxFSjlCSTZxUzFRbFA5eTNlU3U5ZzV4azlHT2lkSmxOQWdWMEgyVmRxS09sNXE2bC92NlRCSEFBQUFlTnBqWUdaQUJvd01hQUFBQUk0QUJRPT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXNzODtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTlFBQW9BQUFBQUE3d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFlwMEwyTnRZWEFBQUFFNEFBQUFNUUFBQUR3QWdBQzhaMng1WmdBQUFXd0FBQUNNQUFBQWpDd1Z1S2RvWldGa0FBQUIrQUFBQUM4QUFBQTJKK2FHY21ob1pXRUFBQUlvQUFBQUh3QUFBQ1FGREFHamFHMTBlQUFBQWtnQUFBQU1BQUFBREFXRUFISnNiMk5oQUFBQ1ZBQUFBQWdBQUFBSUFESUFSbTFoZUhBQUFBSmNBQUFBR0FBQUFDQUFCZ0FkYm1GdFpRQUFBblFBQUFET0FBQUJPQWQxS3Ixd2IzTjBBQUFEUkFBQUFBd0FBQUFnQUFNQUFIamFZMkJtdk1ZNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUk1ZY2hrNXY0UDVETnpNNktwK1E4VUJnRDlQUTJvZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLcGpCay92OFA1SVBwLzNQL3p3U3JBZ0lBbU5FSk5nQUFBQUFDQUNYLzlnSGFBc2NBRUFBYkFBQUJFU00xRGdFSExnRW5QZ0UzTmhZWEVRTTFKaU1tQmdjZUFUYzJBZHBaSGxRd1VXY0NBbWxTR0ZneUF5ZytPR0lEQWxjNFN3TEgvVGsxR2lRQkE0WmtaWVlEQVJVaUFTejl1Tm8wQVUxZldGSUJBd0FBQWdCTkFBQUF0QUsrQUFNQUJ3QUFFeFVqTlJjUkl4RzBaMTlXQXI1blovZitPUUhIQUFBQWVOcGpZR1JnWUFEaXMxeFhwT1A1YmI0eU1MTXdnTUJqKzRVeENQci9ONllBcHVOQUxnY0RFMGdVQUNaNkNzY0FlTnBqWUdSZ1lPYit6OERBd0JUQW9Ncmd6M2lMQVNpQ0FwZ0JRZ1lDdEFBQ1VBQUFBakVBSlFFREFFMEFBQUFBQURJQVJuamFZMkJrWUdCZ1pwQmhZR0lBQVVZR05BQUFBNHNBSkhqYVRZdzliOEl3RUlhZnFBbFN3OENDT2pDMEhqcGJRV0ZnWW1GZ1ltVmlBZXlpREhHUUhTSWhWUjM1M1QyTUI4N1M2WGsvemtESkh4bVB5WmpFL1ppY1F0U1RDOFpNRTQ5RWZTVXVtZkhORzFuK0xzNG5xOFM1SlB2RUJSLzhKQjZKLzV1NFpNRjkzYldYYTIrOTJuYkdlbmRxUTFqdXJBOU41OVJjVjFGdnJMUCswRnVqampkbGhpWU01MWJWdXRJMWF6cGFMbHpwc1hnVVczRk1aTWRKc2lCdnlTNDZnVVpTSjYwNW11b2wzMGp1WXVjUWZ6TFNPWEtUYlJqa0tzZytTMXRSeDB0Ti9RL3FiVEE3QUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXN5MTA7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5BQUFvQUFBQUFBNlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ2lPUnpHMk50WVhBQUFBRkFBQUFBS1FBQUFEUUFEQUVxWjJ4NVpnQUFBV3dBQUFCNEFBQUFlSk1TUEpGb1pXRmtBQUFCNUFBQUFDMEFBQUEyS0xHRnJXaG9aV0VBQUFJVUFBQUFIZ0FBQUNRR05mL2RhRzEwZUFBQUFqUUFBQUFHQUFBQUJnT3dBQUJzYjJOaEFBQUNQQUFBQUFZQUFBQUdBRHdBQUcxaGVIQUFBQUpFQUFBQUZ3QUFBQ0FBQkFBa2JtRnRaUUFBQWx3QUFBRFRBQUFCUHE4M2RlRndiM04wQUFBRE1BQUFBQkFBQUFBZ0FBTUFBWGphWTJCbWxtR2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVUQXhKSUtTNUxCMHBlWjdqT0xQVkhrNEdCV1lyNU9sQ1lFYUhpLzM4R0JnRHJuUTd2QUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeENDK05mLy80ZVEvN1hBZkFZQVh1VUhNd0FBQUFBQkFKUUFDUUtHQWZnQUlnQUFBVGMyRnhZWEJnOENId0VXQndZSEppOEJCdzRCSXlZbkpqOEJKeVkzTmpjeUZ3R095dzRLRXdFQ0F4cTdwVElFQVFFVEN3WFV5d2tJQmhFREF4RE56UkFEQXhFR0JBRWR5aEVCQWhNS0F4cTdwVElJQXhNQ0FnVFV5d29GQWhNSERjN09EUWNUQWdJQUFIamFZMkJrWUdBQTRwWDVkcHZqK1cyK01qQ3pNSURBWS91Rk1jZzBzd3pqRHlERndjQUU0Z0VBRXFJSkVnQUFBSGphWTJCa1lHQ1crcU1KSkdVWXBqQk1ZMnBqQUlxZ0FFWUFUTW9ERndBQUF4d0FBQUNVQUFBQUFBQUFBRHdBQUhqYVkyQmtZR0JnWWxCbUFORU1VQklKQUFBRUNBQXBBSGphVFk2eGFzTXdFSVkvVThkUUo1Q3BIVG9VVFJtRmpmTUFoUXlac21Zc0pKRUlEbGdPa21Qd1V2SUFmZWhlRkEwOXdmSHB2KytFZ0pJZk1oNlZzWXo5VVRtRjNKNDhZODViNGtLT1Nsenl3WW9Yc3Z4VmtrKytFdWNzK0U0ODQ1MUw0a0x5ZStLU05iK2J2cnZlQnV2VnJqZld1MU1YcHJyYVd4L2EzcWxhVjg5Z2E1MzFoOEVhZFp5VUdkc3duanZWNkVvM2JPanB1SEpqd09MbFp6dEpUR1RIU1dhQmlacUtmY3dDcmN5ZGVEVmEwdi9HVmd3WHJVTjh6WWgxbEprU0dtVXZTRCtMcjJqaXJxYjVBd2xSTVJNQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtcjU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVFFQUFvQUFBQUFCSlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRVFBQUFCZ2hVTjBybU50WVhBQUFBRTRBQUFBTWdBQUFEd0FUZ0I5WjJ4NVpnQUFBV3dBQUFFOEFBQUJZUGxmdzExb1pXRmtBQUFDcUFBQUFDMEFBQUEyS09pRnRXaG9aV0VBQUFMWUFBQUFIZ0FBQUNRRnVnSzBhRzEwZUFBQUF2Z0FBQUFRQUFBQUVBcGVBVnBzYjJOaEFBQURDQUFBQUFvQUFBQUtBT1lBYUcxaGVIQUFBQU1VQUFBQUZ3QUFBQ0FBQmdBdGJtRnRaUUFBQXl3QUFBREtBQUFCTXVzSWtlWndiM04wQUFBRCtBQUFBQXdBQUFBZ0FBTUFBSGphWTJCbW1zNDRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpnQU5HQmlTUVVseVdEcFRVWURCaVp2Z1A1RE5EcEpIVS9BY0tBd0RYS1F6aGVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS2FqSVkvZjhQNUd1QTZQODMvMThFcXdJQ0FJdDBDTVVBQUhqYUxjK3hUc0pnRUFmd3Uydjd0WlFJQ1pFV0lZVzJTTDhFRlNJcE1GWENab2dZZzRsR1NTZUNBU2FNaXpvYTNabjFCWWpQNEdqd0JYd0huOEJGRS9XamVMZmMzZkQvNVFEaDhSZndUUUxJQTJBQ1ZXWWFVYTh6bDFlUWU3elIzTU5tbzJha0diNzJIaFRKMWZTZGF3MVp0dTEwN0VDV0E3dmp0TE1NNmFQeCtSTGVaTXpib2F6THVtK2RCOVA1L0RJNHMzeGRqb0VvaElHd1pzTEtpWVdwUzgycm9oOEJLWTk3WWpEemFCbzQrMCtWU09HblhoMHZybFJKV29FSXEweFVORTIyQmlkM21QME80M0VGSTFBWUlRRDE2Um0yQUVxcVUvZGJKT0xGSnk1VFJYWUNpOHpqNGxJenpLV2Z4RkwwSVBYZG4wMHA5aFYwa1VaZHYyZGtIRVF2bmRnbXVwOU1ueVFhN1Zmclk2U3l2cGFreGFLZ1VPeDlkOUk2T01aeWtRbzUyOElOM2gzU2VIQTBydGo4RUZHT3QxTUFmekF3TzFCNDJtTmdaR0JnQU9MWW84ODg0L2x0dmpJd3N6Q0F3R1A3aFRFSStqOERjeEF6aU12QndBU2lBQ2RJQ1prQUFBQjQybU5nWkdCZ1p2alBBQ1NER0dJWllwbWlHWUFpS0lBRkFEM1RBblVBQUFOU0FBQUNLZ0NhQWlvQVl3SzRBRjBBQUFBQUFEWUFhQUN3QUFCNDJtTmdaR0JnWUdIUVlRRFJERkFTQ1FBQUJSOEFOQUI0MmoyTU1hdkNNQlNGdjJJVjdSc2NCSWMzU1BBSGhFcWZtNXVEazZ2RDI2d0owcUdwcExYb0l2NTBiMFB3Qmc3ZlBlZmNBQmt2RW9aSm1BY2RKcFUzanp6bWgwWGtpZmlyeUJtL3JCbVJwRE54VnV3aXAwejVqenhtU1JsNUl2NGpjc1lmNzMxVDMrNmQ5ZXJZR092ZHBmYmJrL1Z0MVRpMTBmbXdIcXl6L3R4Wm84cW5NbjNWOXRkYUZUclhCWHNhYW03YzZiQjRGRWR4VEdESFJUTFBsbFBZV3lySm5IUTJhUEp2ZXBEVWhjWTUvR0trVWZJVU5mUnkwNHBlcGFzb3dwMm0rQUJWTWk1REFBQjQybU5nWnNBTEFBQjlBQVE9KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTEwO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFTVUFBb0FBQUFBQlR3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVngxSEdOdFlYQUFBQUU0QUFBQU1nQUFBRHdBV1FDZFoyeDVaZ0FBQVd3QUFBSERBQUFCL05aM0Q4Qm9aV0ZrQUFBRE1BQUFBQzhBQUFBMktNMkdqMmhvWldFQUFBTmdBQUFBSGdBQUFDUUdYUUpXYUcxMGVBQUFBNEFBQUFBUUFBQUFFQXZOQUhoc2IyTmhBQUFEa0FBQUFBb0FBQUFLQVZJQXNHMWhlSEFBQUFPY0FBQUFHQUFBQUNBQUNBQTZibUZ0WlFBQUE3UUFBQURTQUFBQlBwa1JkY1Z3YjNOMEFBQUVpQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0rc3c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBSMFpIQmhadmdQNURORHBKSFUvQWNLQXdEOXBnMW9lTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHRFNBTkJ1UVpnVEtPakc0L1A4UDVEdUM2UDhIL3U4SHF3SUNBSkNGQ1BBQUFIamFOZEJCYXhOUkVBZnc5MytUdkpmRTdMNjFtKzZybUd4WUU3TllTU05OMkcwRFJqQzJpc1dZV3RHaVJVR29SUTlWdEZZUEhuSW9DTkllUkJBOGVkQ2JlUGJpeVpNbnY0RUg5ZWhuU09MYlFtWXV3NTg1L0dZWVo5WHhtUC9tdjFpRHpUTVdJNHJuUGUwV3ZHYmtpUVprV0F0YmtmYWl1SUZBaW9LbkkyM0Q1RW5jN0NCdTBsZHNpb0lsMFBIcTA4aW5kd2FaTkt3amJvdXljalR1V1VYWElsanByZlU4OHRrVG5mZi9nbDErdzBGV0RRZWVvcElFRVhoR1NTQ3Y3eS90RmFvT3VMSkZFdWVVUU9VSHJqRlR4RTZQaHlUNE4rYXpXYlpncEc2ckVncGpDM3hNMjVBK3RGQVFNaENIWGpmQlJiV3dVaE9TSmpPWmhlYW5nK05oU1Ntc2I5eWp3ZHJLR3ZoRjU4cXowZHVpYmJmOUQrL3U3bkRNZGZmS2JucDdmMk9YOHpPWHZpK25BTHZQRjQ5eUtrcncxZmJsTFpYckxhNmN0enVwNUFLNFdLSW55OVVMSE9yWThETTk3NTNzMCtqdmxNZ3h4dGtwNDQ2TmU0YlZFM1UwUVdzaGs1NTREMjA2Z1o1REZNNUJHdm5IQTNSOXgxQ2Z2Z1JkblYxNE9CaDlLU25EL0xPZmtGN2ZlYUhiTTVrcDhBZTk3YkpyaEE1UnlienV6YU5YajgvV3J4UDV3dUI0ZC9qVFdKRHFsMWR2QnpmRHpWdUFNaS85RDFucVY5d0FlTnBqWUdSZ1lBQmlwK0w2eS9IOE5sOFptRmtZUU9DeC9jSVlCUDMvTDdNNTAxMGdsNE9CQ1NRS0FEQmxDdzBBZU5wallHUmdZR2I0endBay9SbFVHSmlZelJtQUlpaUFCUUF1V2dHN0FBQUNkZ0FBQXdBQUpBTUlBQ3NEVHdBcEFBQUFBQUJVQUxBQS9nQUFlTnBqWUdSZ1lHQmhzR1JnWmdBQlJnWTBBQUFHa2dCRGVOcE5qckZxd3pBUWhqOVR4MUNuMEtrZE9oUk5HWVdOK3dDQkRKbXlaaXdra1FnT1NBcXlZOGdTK2dCOTZGNFVEVDNCOGQxM3Y0U0FtaHNGOXlwNFRmMWVKWlZNRDU0eDV5MXpKVWRscnZsZ3dSTkYrU3ptazJYbWtoZStNODk0NTVTNUV2K1R1ZWFMMzFWdzU4dG9vOW9FWTZNL09OZTN6ZGJHb1E5ZXRicDVpTFgxTnU1R2E5VCtxc3pVRDlQUnFVNDN1bU5Gd0hIbXdvZ2x5czgyWWt4aXowRjJqcDZXaG0xeWcweEJOa3FjRnZzL3NaYUVUNmxkZXMxSWFzOVZ1bUdTekNEOUtHbEZsKzVxdWovZjlEQzdBQUI0Mm1OZ1pzQUxBQUI5QUFRPSkgZm9ybWF0KCd3b2ZmJyk7fQp0ZXh0LmYwIHtmb250LWZhbWlseTpjbXNzODtmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMSB7Zm9udC1mYW1pbHk6Y21zeTEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjIge2ZvbnQtZmFtaWx5OmNtc3k3O2ZvbnQtc2l6ZTo2Ljk3Mzg0OHB4fQp0ZXh0LmYzIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmY0IHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mNSB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjcge2ZvbnQtZmFtaWx5OmNtcjU7Zm9udC1zaXplOjQuOTgxMzJweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE5LjM1MTk0NSwtNjQuMDM2ODI0KXNjYWxlKDAuOTk2MjY0LC0wLjk5NjI2NCknPgo8ZyBmaWxsPScjMDAwJyBzdHJva2U9JyMwMDAnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNCc+CjxnIHN0cm9rZS13aWR0aD0nMC41Jz4KPHBhdGggZD0nTTUuNjkwNDYtMTQuMjI2MzZIMTQuMjI2MzZWLTUuNjkwNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTE0LjEzOTU0LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xOS4zNTE5NDUsLTY0LjAzNjgyNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y0JyB4PSctMTkuMzUxOTQ1JyB5PSctNjQuMDM2ODI0Jz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy05LjY2NjA4JyB5PSctNjQuMDM2ODI0Jz7DlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PScuMjk2NTM0JyB5PSctNjQuMDM2ODI0Jz5EPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMy45MDQ0OCwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE5LjM1MTk0NSwtNjQuMDM2ODI0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xOS4zNTE5NDUnIHk9Jy02NC4wMzY4MjQnPkE8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTkuNjY2MDgnIHk9Jy02NC4wMzY4MjQnPsOXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy4yOTY1MzQnIHk9Jy02NC4wMzY4MjQnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTAtNy4yNDMwNFYtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCwwLjAsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNDkuODMxNiwtMjkuNzAyNzQpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xOS4zNTE5NDUsLTY0LjAzNjgyNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctMTkuMzUxOTQ1JyB5PSctNjQuMDM2ODI0Jz5pZDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y2JyB4PSctMTMuNzU4MjgyJyB5PSctNjMuMDM1MDEyJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy02LjI4NDY5JyB5PSctNjQuMDM2ODI0Jz7DlzwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PScxLjc1NjE3JyB5PSctNjQuMDM2ODI0Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9JzYuNDIyNzU0JyB5PSctNjcuMDQzMzQxJz5CPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9JzExLjgyMDk4MScgeT0nLTY5LjA1MzU2NCc+4oiXPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9JzE1Ljk4NTk1JyB5PSctNjcuMDQzMzQxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9JzE4LjY4NDIwNScgeT0nLTY3LjA0MzM0MSc+QTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y3JyB4PScyMy44NDU0ODUnIHk9Jy02Ny4wNDMzNDEnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuNjI3MDMsLTIuNSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE5LjM1MTk0NSwtNjQuMDM2ODI0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xOS4zNTE5NDUnIHk9Jy02NC4wMzY4MjQnPkQ8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNTIuODYyMSwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE5LjM1MTk0NSwtNjQuMDM2ODI0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy0xOS4zNTE5NDUnIHk9Jy02NC4wMzY4MjQnPkI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTE4LjY5NTA4IDBINDcuNTcxNDknIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuODIxNDksMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgzMy4zODMyOSwyLjgxMTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtMTkuMzUxOTQ1LC02NC4wMzY4MjQpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZScvPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNNTYuOTA1NS02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDU2LjkwNTUsLTQ4LjQxMjQ2KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg2MC4xNjkzOSwtMjkuMjg2MDkpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC0xOS4zNTE5NDUsLTY0LjAzNjgyNClzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMTkuMzUxOTQ1JyB5PSctNjQuMDM2ODI0Jz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0xNC42ODUzNjEnIHk9Jy02Ny4wNDMzNDEnPkI8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTkuMjg3MTM0JyB5PSctNjkuMDUzNTY0Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNycgeD0nLTUuMTIyMTY1JyB5PSctNjcuMDQzMzQxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy0yLjQyMzkxJyB5PSctNjcuMDQzMzQxJz5BPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9JzIuNzM3MzcxJyB5PSctNjcuMDQzMzQxJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J00xOC40NjAwMi01Ni45MDU1SDQ3LjgwNjU2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ4LjA1NjU2LC01Ni45MDU1KSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgyOS4wOTM3MiwtNjIuNzMxMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTE5LjM1MTk0NSwtNjQuMDM2ODI0KXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy0xOS4zNTE5NDUnIHk9Jy02NC4wMzY4MjQnPs+APC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjcnIHg9Jy0xNC42OTMxJyB5PSctNjMuMDQwNTYnPjI8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = {A \times  D},
      nw/style = pullback,
      ne = {D},
      sw = {A \times  B},
      se = B,
      west = {\mathsf {id}_{A} \times  f^{B^{*}(A)}},
      south = {\pi _{2}},
      east = {f^{B^{*}(A)}},
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>The second half of the statement follows immediately from the first half.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1562</fr:anchor><fr:addr
type="user">ct-001F</fr:addr><fr:route>ct-001F.xml</fr:route><fr:title
text="Cartesian closed category">Cartesian closed category</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>13</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with finite products.
  <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is said to be <fr:em><fr:strong>cartesian closed</fr:strong></fr:em> if every object is <fr:link
type="local"
href="ct-001E.xml"
addr="ct-001E"
title="Exponentiable object">exponentiable</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>