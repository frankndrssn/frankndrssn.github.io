<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1681</fr:anchor><fr:addr
type="machine">#303</fr:addr><fr:route>unstable-303.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>For each object <fr:tex
display="inline"><![CDATA[f\colon X\to Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{Y}}}]]></fr:tex>, take <fr:tex
display="inline"><![CDATA[{\mathopen {}[f]\mathclose {}}_{Y} := \Sigma _{f}(1)]]></fr:tex>.
    To extend this assignment to a functor, it suffices to show that whenever there is a morphism <fr:tex
display="inline"><![CDATA[\alpha \colon f\to g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{Y}}}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[{\mathopen {}[f]\mathclose {}}_{Y} \leq  {\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[T(Y)]]></fr:tex>.</fr:p>
  <fr:p>To this end, note that <fr:tex
display="inline"><![CDATA[\alpha ^{*}(1) \leq  \alpha ^{*}g^{*}{\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[T(X)]]></fr:tex> because the unit of the adjunction <fr:tex
display="inline"><![CDATA[\Sigma _{g} \dashv  g^{*}]]></fr:tex> gives <fr:tex
display="inline"><![CDATA[1 \leq  g^{*}{\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex>.
    Since <fr:tex
display="inline"><![CDATA[\alpha ^{*}]]></fr:tex>, as a right adjoint, preserves terminal objects and <fr:tex
display="inline"><![CDATA[f^{*} \cong  \alpha ^{*}g^{*}]]></fr:tex> by the (pseudo)functoriality of <fr:tex
display="inline"><![CDATA[T]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[1 \leq  f^{*}{\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex>.
    Then, the transpose along the adjunction <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex> yields <fr:tex
display="inline"><![CDATA[{\mathopen {}[f]\mathclose {}}_{Y} \leq  {\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex>.</fr:p>
  <fr:p>Now for each <fr:tex
display="inline"><![CDATA[g\colon Z\to Y]]></fr:tex>, form the following pullback:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="4a9867a690f06965f87762f6492d4727"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNy40MDc2NTZwdCcgaGVpZ2h0PScxMTguMjM5NDA3cHQnIHZpZXdCb3g9Jy03MiAtNzIgNzguMjcxNzcxIDc4LjgyNjI3MSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUMwQUFBQTJLSnFkZkdob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0bU52c29MaitXMitNakN6TUlEQTR3aGRld1Q5bjVIcE1qT0l5OEhBQktJQUhka0pTQUFBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVJQUFvQUFBQUFCZXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjB1bU50WVhBQUFBRTRBQUFBTWdBQUFEd0FnZ0RBWjJ4NVpnQUFBV3dBQUFJN0FBQUN0SWtwajR0b1pXRmtBQUFEcUFBQUFDOEFBQUEyS0kyZGVXaG9aV0VBQUFQWUFBQUFJQUFBQUNRRm1RR2JhRzEwZUFBQUEvZ0FBQUFRQUFBQUVBbW9BTVJzYjJOaEFBQUVDQUFBQUFvQUFBQUtBY0FBMUcxaGVIQUFBQVFVQUFBQUdBQUFBQ0FBQndCWWJtRnRaUUFBQkN3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRS9BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXltS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTVdRek0vd0g4cGtoMGtocS9nT0ZBZFRIRFNzQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS3BqTmsvLzhQNUtlQjZQK3ovODhBcXdJQ0FKbHJDVHdBQUhqYVJaTExidE5BRkliOXovZ1NPNDNIanUxeG02UnBIRHZqb0taSmFScWJSbFhhTk8yaU4wb1hVSW9RckFDSkZSSWJ4RE1naEJBTHR1eDRCZmFWV1BNd0lMRkpHVk1KNXV6T09Zdi9POThvVUk2dkIrUWwrYUhzS2dvb2cyN1lNTm9pbldESVE2NGJmQVVUN05CWUYxazRuQ0NYL1EwZTJvaEZLckpjREdBVGhtSEc5UlJmeG83cTFNenA3ZTRZU0FKQndWWVlZMGxFbC92c3BFazhkczRDbSsvRnQ3YUJtTXU1MDJTc1dtMWFwZHJUWW94UDg2c2pkM2ZUbjFFUk4xc2swZE95U2FBZUI1OS9YdEMyZ1l2TGVpbzZ5ZjhSbHNUYWU3VmRnaUlmVVhyWGE2U0RLNld2ekFvYVNhTC9KWkdKZmQwSStaQm5FbUJIUXZhUlpubFJUWVNTU2k3UUhXU3BoTktONGdRODNDaFdTZlRLZlAxbThFU1ZlVjBPdTlwd0kzODdibkFqekErbmw0Uk9tWHQ0MlIxVmFLMWFDZkJ4UU9FSG03VlpLM0JjaUxTNTExZ3c4SFkrSFR5aUpPZ3RSNTVYYmxvYVFibXh0TjU2UEZSeGNlL1pYWS90VXlUYzRYRGMrZTl2ck55SlZYUkhZcnA3bHFQVFloWEpCdVgwK2hjNUlOK1ZCd1Zaa1cyREIvODB5TVNGT21sTWxzK296OE1iVjBYREtKQ2tVcEZucWVSbXNORVdvOXliUU1RM3B2T01HNWcrWDNtWW50OFhNb3BVRTdac2YvVXNGZUZpYTVPeGRaVlFEY3dYcXhZMUxGTUhITXR2YktVekFvMENSM2RpcG9iQzFUNm9oQ1dtQTlqR2ZxOEQ4blgrd2o3cGpIcjFLQ0tKblpSc1lDd2lYMGJRVEw1bG1aVzZKeitZZXBvd2l4Qkw2OWNiZlhXWTJWVmI3NmJhdTNGMTBhdHdzbDlobG1xeGtxSFNCWG1LUHpEZ1dJd0FlTnBqWUdSZ1lBQmlYYi9IbCtQNWJiNHlNTE13Z01EakNGMTdCUDFmbCtrWTAwVWdsNE9CQ1NRS0FCdTdDZmtBZU5wallHUmdZR2I0ejhEQXdIU01RZWYvQmFZc0JxQUlDbUFCQUdVY0JEZ0N4Z0FBQWpvQVN3STZBQ3dDYmdCTkFBQUFBQUJtQU5RQldnQUFlTnBqWUdSZ1lHQmhDR2RnWWdBQlJnWTBBQUFKYVFCZ2VOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5rQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDd0FBQUEyS2h1ZFYyaG9aV0VBQUFJOEFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFsd0FBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNaQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUpzQUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9RQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFZBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaW1sWHFyZkg4Tmw4Wm1Ga1lRT0J4aEs0OU1zMFN5bmdIU0hFd01JRjRBUFRaQ0FsNDJtTmdaR0JnMXZwanljREFFc3JReDlEUGxNd0FGRUVCVEFCU2dBTkNBQVJWQUFBQzhnQ09BQUFBQUFCVUFBQjQybU5nWkdCZ1lHSXdaUURSREZBU0NRQUFCY29BT3dCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUNVbFlXQmlaV3BDMkNETXNSQmRvZ1VxZXJJNys3aGV1Z05wK2Y5dUFOS2ZzaDRUc1pyM00vSktVVDljY0VMYjRtbm9oYUpTejVZTWlITForTE0yU1RPSmZsS1hQRE9KZkZVL08vRUpaODh0bDE3dS9mV3EzMW5ySGZuTm96cmcvV2g2WnhhNlNycW5YWFdIM3RyMUdsVVptakNjRzFWclN0ZHM2V2o1Y2FkSG90SHNSZkhSSGFjSlF1TXJEbEVKOUJJNnFTMVFsUDl5M2VTdTlnNXhrOUdPaWRKbE5BZ1YwSDJWZHFLT2w1cTZsL3Y2VEJIQUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVk1BQW9BQUFBQUJtd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUFtTnRZWEFBQUFFNEFBQUFOUUFBQUR3QWd3Q0haMng1WmdBQUFYQUFBQUp5QUFBREtLb3hZRHRvWldGa0FBQUQ1QUFBQUM4QUFBQTJLUzZlVm1ob1pXRUFBQVFVQUFBQUhnQUFBQ1FHaGdHY2FHMTBlQUFBQkRRQUFBQVVBQUFBRkEzU0FKNXNiMk5oQUFBRVNBQUFBQXdBQUFBTUFhZ0NlbTFoZUhBQUFBUlVBQUFBR0FBQUFDQUFDQUJoYm1GdFpRQUFCR3dBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGUUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtT3N3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSWhpWnZnUDVETkRwSkhVL0FjS0F3RHV0QTFPZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pKRS9mOFA1RHN5UlB6Ly8vL0EvMVZnVlVBQUFKTFZDUVFBQUFCNDJsV1N6V3NUUVJqRzkzMW5aMlozTTdPYk5QdEJUYkpwVE0xU3NJa203YTRXbWh4VUJFRkZLU0lvS0VvL2hDSlN2L0Npc1hyekwvQXM2bEh4b0NLS0Z3LytDUjcwMEpPQ0lDaDRiT0xzcG43TmFkNW5abDZlMy9PT2h0cmtjSWdiK0VscmFXMU5TeUJPMm41UWRQMU83TE1XOEtnUnpjU0JIeWN0cUhIbStrRWMyS0QwVk81MEllbVFGN0RJWE1tZzYwOTdJT2lWdmtGQjVvb3p4T1NENFJGWkxrb0NraTZmRkNETTdkMzdYMnZYOEVRZVRHZXo3enVrd29FUVFNUGhBQ0pZT25EWG5jd0RPalpMWmN0aFVIOFB4elcxUUNzUGgyUVpYMnRuVkpIRVNST2pMbFFoOGF2Z3Nyb05uRG1nOWlGMEF0L0xMRVpiSG1kYjRJQzZrQjF0dVc5QmR0UkQwb1E2RzNVS1FrZ2JlZkQ5VVo1Z3RRaks5dHBaRTFGWXpaNDNucXdYSm85YWxkMkNvMkJydDAwS3dnaER1bko2SmFjc1Z3MnVLd1I2ZWZRZ090U1FIMjdROGs0UFUzRjBlNklNRDUvWmdTdkFzak51bmRtTWhLNC9mNis1OENwMEFLME1ITUdVWEIvanpzL0ZpN2xBdWpsRTQvY0RoK0ZFSkw1QW1DOFFleVNpeDNXUFpobXBXUktoTXRxdkNtSXJiT2F4S3NSLzQxQ1Q3R0gwTDdRZnVLekJlRWxsMm9Tb01adXA3VkdrZUg3QUtKbW1HRFlxSU5pZEZNTzI1NnE4SnZXYmRGc0tKMGR3MHR0RnJuOXpjbEFxTUpCc2FVRUtvelB2NDhIQlJ5YnM1eTVYY1A4TjI1MWEzMXVBWThYOEh3cUZpR1poOEJZS3JsT3gwanJOWXB6UnFmR01iVzQ0d00vNFJ0dWhhU1owMm5FUDRvN3ZjUnVpR3VzQjFMY3p6ckxCOXFBTFFTM211TEg1N3NtdFN4VkRaL0t3Ym8wTjlwVkF4L25IVjFkTDZpc0MwZmNvRVo2V0NUN1k3SzllY0NtYVA1UVh6Qld4Zis0VVQ5T20xc3RNMFg0QmVJUnZKQUFBZU5wallHUmdZQURpS1E4VzE4ZnoyM3hsWUdaaEFJSEhFYnIyQ1ByL1ArWjBwcnRBTGdjREUwZ1VBRGJKQ3QwQWVOcGpZR1JnWUdiNHp3QWtBeGhrL3JzeHB6TUFSVkFBS3dCTXlnTW9BQUFDZGdBQUF3QUFKQU5RQUJ3Q1VnQWtBcm9BT2dBQUFBQUFWQURtQVZRQmxIamFZMkJrWUdCZ1pVaGdZR0lBQVVZR05BQUFDbVVBYW5qYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNTkuNTc4ODEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC01OS41Nzg4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuMzQyMDM1JyB5PSctNTkuNTc4ODEnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzcwODMsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTU5LjU3ODgxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02MS4zNDIwMzUnIHk9Jy01OS41Nzg4MSc+WjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03LjY4NDA1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNTkuNTc4ODEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjM0MjAzNScgeT0nLTU5LjU3ODgxJz5rPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjM3MDc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTU5LjU3ODgxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02MS4zNDIwMzUnIHk9Jy01OS41Nzg4MSc+WDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44OTE2MiwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNTkuNTc4ODEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjM0MjAzNScgeT0nLTU5LjU3ODgxJz5ZPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0IDBINDcuMzE1MjUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuNTY1MjUsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxOC40MjY4Miw0LjU2MTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC01OS41Nzg4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuMzQyMDM1JyB5PSctNTkuNTc4ODEnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU2LjY3NTQ1JyB5PSctNjIuNTg1MzI4Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUyLjUxMDQ4MScgeT0nLTU5LjU3ODgxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00OS4zOTcxMzgnIHk9Jy01OS41Nzg4MSc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDUuMjYwMTg4JyB5PSctNTkuNTc4ODEnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC01OS41Nzg4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuMzQyMDM1JyB5PSctNTkuNTc4ODEnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzI2MzctNTYuOTA1NUg0Ny44MzYwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wODYwNywtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjYuMjU1LC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC01OS41Nzg4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuMzQyMDM1JyB5PSctNTkuNTc4ODEnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = A,
      nw/style = {pullback},
      ne = X,
      sw = Z,
      se = Y,
      north = {f^{*}(g)},
      south = g,
      west = k,
      east = f,
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Then by Beck-Chevalley, we have</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {aligned}       T(f){\mathopen {}[g]\mathclose {}}_{Y} &:= T(f)\Sigma _{g}(1)\\                          &\cong  \Sigma _{f^{*}(g)}k^{*}(1) && \text {right adjoint preserves terminal object}\\                          &\cong  \Sigma _{f^{*}(g)}(1)\\                          &=: {\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{X}f^{*}(g)     \end {aligned}   ]]></fr:tex>
  <fr:p>These isomorphisms assemble into a natural isomorphism <fr:tex
display="inline"><![CDATA[f^{*}{\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{Y} \cong  {\mathopen {}[f^{*}(\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]\mathclose {}}_{X}]]></fr:tex> since any two parallel morphisms in the preorder <fr:tex
display="inline"><![CDATA[T(X)]]></fr:tex> are equal.</fr:p>
</fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1682</fr:anchor><fr:addr
type="user">log-000H</fr:addr><fr:route>log-000H.xml</fr:route><fr:title
text="Naming fucntor">Naming fucntor</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with finite limits and <fr:tex
display="inline"><![CDATA[T\colon \mathcal {C}^\mathrm {op}\to \mathsf {Lat}]]></fr:tex> be a <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>-indexed (pre-)lattice such that</fr:p><fr:ul><fr:li>For each object <fr:tex
display="inline"><![CDATA[X \in  \mathcal {C}]]></fr:tex>, the fiber <fr:tex
display="inline"><![CDATA[T(X)]]></fr:tex> is cartesian.</fr:li>
  <fr:li>For each morphism <fr:tex
display="inline"><![CDATA[f\colon X\to Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[f^{*}]]></fr:tex> admits a left adjoint <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex>.</fr:li>
  <fr:li>Each left adjoint <fr:tex
display="inline"><![CDATA[\Sigma _{f}]]></fr:tex> satisfies the <fr:link
type="local"
href="log-000E.xml"
addr="log-000E"
title="Beck-Chevalley condition">Beck-Chevalley</fr:link> condition.</fr:li></fr:ul><fr:p>Then we can define a <fr:em><fr:strong>naming functor</fr:strong></fr:em> <fr:tex
display="inline"><![CDATA[{\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{X}\colon {{\mathcal {C}}_{/{X}}}\to T(X)]]></fr:tex> for each object <fr:tex
display="inline"><![CDATA[X \in  \mathcal {C}]]></fr:tex>.
  Moreover, for each morphism <fr:tex
display="inline"><![CDATA[f\colon X\to Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, the following square commutes up to isomorphism.</fr:p>
    
      
      <fr:figure><fr:resource
hash="4c641583e2600d77ef1428a3c5660fa9"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzE0Mi4wNTY0NzhwdCcgaGVpZ2h0PScxMjMuNTE1OTU1cHQnIHZpZXdCb3g9Jy03MiAtNzIgOTQuNzA0MzE5IDgyLjM0Mzk3Jz4KPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4KPCFbQ0RBVEFbQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXI3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFQc0FBb0FBQUFBQkhRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVjQUFBQmdoVVFUMkdOdFlYQUFBQUU4QUFBQVBBQUFBRXhBY2VFVloyeDVaZ0FBQVhnQUFBRU1BQUFCSk1HV3UyOW9aV0ZrQUFBQ2hBQUFBQzBBQUFBMktKcWRaMmhvWldFQUFBSzBBQUFBSHdBQUFDUUZSd0hrYUcxMGVBQUFBdFFBQUFBWUFBQUFHQXRDQVhCc2IyTmhBQUFDN0FBQUFBNEFBQUFPQVRRQTVHMWhlSEFBQUFMOEFBQUFGd0FBQUNBQUNBQWNibUZ0WlFBQUF4UUFBQURLQUFBQk11MEtrZXB3YjNOMEFBQUQ0QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm1mTUE0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0lBR0JnWkdCaVNRVWx5V0RwVFVVQkJtWnZnUDVETkRwSkhVL0FjS0F3QU1uQTJxQUhqYVkyQmdZR0pnWUdBR1loRWd5UWltV1Jnc2dEUVhBd2RRam9sQmt5R2FJVlpCK1A5L29KZ0dqUDMvNXY4Vi81ZmYvd1RXQVFVQVFwWU5ubmphSmN3OVM4TlFHQVhnOTl4YjdqV1I1b1BXRkJUUldKcVNRWWUwTjhGQ3JTN2k0RmdjcEE1YWNXa1FLcTRGOFdNUy80RVcra2M2aVl1L3c5bFpxTVFidzh1Qjk4RGhJZEJ0QnR4eG9sVWkxTHlxRkRhRUZKNStiUVJOZlVuUVE0eTBMT1ZCUis1eW5GeVpzdnlrck9VR1k5dFd6QW5NRWUzVUdYKzgvSndaRHNQRnhOK2NERzhlR3ZlYXBDUHQ5d3Uvb3RXYUo2dENXZ2lTZGc5N1NIYlFERlNjREI3akhBeTM0dXMxY0xzL0FCOGZHaENjQ3UxMHRuOCtaQ1l2dWNmZnMvZXZqaWtNUnBUN3p4a2gxTDdVcGU2MlZuUVFUcWRwbWxHSm9zVmx2dkV6b25teHFiaDExZEtadjQxR25CWVU4ZGZvMzFrQ1kxMXNrSjdCVno3ci9uNHlCYlpPZnpjaE1tSjQybU5nWkdCZ0FHSVBsUk92NC9sdHZqSXdzekNBd09NSVhWTUUvWitCNlRJemlNdkJ3QVNpQUF2aUNPTUFBQUI0Mm1OZ1pHQmdadmpQd01EQWRKbUJnNEdMeVpZQktJSUMyQUE1cUFJeEFBTFRBQUFCeVFCMEFja0FTQUZMQUlzQlN3QWhBa2NBQ0FBQUFBQUFNQUJnQUhJQWhBQ1NBQUI0Mm1OZ1pHQmdZR09RWmdEUkRGQVNDUUFBQTZ3QUpRQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdac0FMQUFCOUFBUT0pIGZvcm1hdCgnd29mZicpO30KQGZvbnQtZmFjZXtmb250LWZhbWlseTpjbXIxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTmdBQW9BQUFBQUE5UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFVOejdHTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUNnQUFBQXJLQUNIYVJvWldGa0FBQUNCQUFBQUMwQUFBQTJLRWVkWjJob1pXRUFBQUkwQUFBQUh3QUFBQ1FFandHOGFHMTBlQUFBQWxRQUFBQUtBQUFBQ2dSR0FHUnNiMk5oQUFBQ1lBQUFBQWdBQUFBSUFDd0FWbTFoZUhBQUFBSm9BQUFBRndBQUFDQUFCUUFaYm1GdFpRQUFBb0FBQUFETkFBQUJPSUxoS3Fsd2IzTjBBQUFEVUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtdk1jNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwVFVZTkJrWnZnUDVETkRwSkhVL0FjS0F3RHZrUTBlZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pFajV6OEFZd3N6QUlNN0F3Q3FpcEthdXgyaXVabVp1eDJqRXo4akhLTTRtSk04b3hoZ3NsbXlvS2NQSUtLTm1tQ2JHeUJQbndjamtFcy9QL0kwcktUNWlsYTNUd3REa1ZCNkJ4RC90bGYvK3BRaXlNQUFCSTRNbDBGeE5pTG1NWW16c2ZJeEtwa0JUMVUzVTlCblZ6TTJNeE1UbEdCazF3Q2FLOHNaNk1RWDdDREV6TW9xQzdXR0FtcGowdDNYaEIxOGhGaWF3UFFBVkpDRk1lTnBqWUdSZ1lBRGlUeFB2MU1mejIzeGxZR1poQUlISEVicW1DUG8vQTFNRE00akx3Y0FFb2dBcXJBbFBBQUFBZU5wallHUmdZR2I0ejhEQXdOVEFZTWxneVJqQ0FCUkJBVXdBTzJ3Q1VBQUNnQUFBQVkwQVpBQTVBQUFBQUFBQUFDd0FWbmphWTJCa1lHQmdacEJnQU5FTVVCSUpBQUFERUFBZkFIamFSWXd4YjhJd0VJVy9pQVNKZE9oU2RXQUFEOHhXb2pCM1lXQmlaV0lCYktJTWNaQVRJaUdoanYzZFBZd2xibmo2N3IxM0IrVDhrdkNjaE0rZ3owbkpaSHR4eGdkZmthZXlMU1BuekZreElVbG40aXo0aVp4S2NvaWM4YzBsOGxUOFIrU2NOWCticnIzZUJ1dlZyalBXdTNQcnkySnZmZDkwVHBXNkNQdldPdXVQZ3pYcWRGZG1iUHF4YmxXbEMxMnhvYVBseW8wQmkwZXhFOGNFZHB3bDg1UVU3SVBUMDBqcXBGV2l4WDNuVzhsZDZCekRKeU9kRTNkUnd5aFh2V2d0YlVVVkxqWFZQMk05THc4QUFBQjQybU5nWmtBR2pBeG9BQUFBamdBRikgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVDhBQW9BQUFBQUJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFc5MDJXTnRZWEFBQUFFNEFBQUFOUUFBQUR3QWJ3Q3RaMng1WmdBQUFYQUFBQUluQUFBQ3dONmlqRlpvWldGa0FBQURtQUFBQUM4QUFBQTJLUzZlSW1ob1pXRUFBQVBJQUFBQUhnQUFBQ1FHZ3dHYmFHMTBlQUFBQStnQUFBQVFBQUFBRUFwdUFGbHNiMk5oQUFBRCtBQUFBQW9BQUFBS0FjQUE4bTFoZUhBQUFBUUVBQUFBRndBQUFDQUFCZ0JoYm1GdFpRQUFCQndBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFFOEFBQUFBd0FBQUFnQUFNQUFIamFZMkJtbXMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUU1ZWWhrWnZnUDVETkRwSkhVL0FjS0F3RGlYQTA0ZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLaGpCRS92OFA1SWN3UlB6Ly8zL3QvMVZnVlVBQUFKVUxDUllBQUFCNDJrMlJQV3NVVVJTRzV6MTM1dDZaMlR0M2RyTHp3V1ozWnhOM001TmdzdEY4ekJveFdRUWhLRWdRVWdxS29rbVZJaFppSXhnYnhkK2hqV0FoS2lLQ2pYL0F6c0xDMGtxd3NEVHJuUjM4NERibm52ZWN3M25lWThCb2pzZjBpZDRhNXd3RFRJUnhGNFVJK1RKRW51VlprYXdVdzBZeExMS1R5QVF2WDVhUHNJVmt0a2gwUEdKcm1lZ0pCYngrWk5iajh4bFQ5b3ZuMGdLbXBuZm0yV01HT09IOGpVWHA5azlZQ2ZpbUtRTTYwMEtLRmhpbmk1Zm5XbzVMQjcrK3h0SW1ZcjRTWUl6ZytCeFJtM3EyeHdWckNtZHVMeWEzOGFwVTFjZUVhdUhTM0VhSEdQa0dqUFo0elBib3ZYRk43ejhzaGdQS3Q5REZVSE9FdktjZ3VBOGRwMWhONGtpaDRsb3JWcmV3dmd3ZnVtQWlKUk1wVzhaRUdoRWJvTWVyU1VtS2NsQ0VIOC9xakxvTndMTU9yenRFMGgyTW91YndLT2p2dUozVFVwRGtodzhjQzlKT1Uydi82bjZ0RHVyYXdnU2tkYWRxeUM5bDN1ZDdWbnN4b2pKWlZjKzA4ZlNsU2tJSmQ4SVBreXZPMGpEZWZETFlmWmY2SUZmeHloZFBtRlBDLzNucm9KWjRZWTNJL3RQZ2M1cko1VGVrOVlDcEtrbVJNQ1BMMExZWWZlMlIxQjVkS0crc05EYVB1TDd6UHp1U3VCaFIvajkwbklRODQ2S2xQUjBnejlZbjJaWEtVcnA1ekMyMlpGR2FkU0Q1d3hKRHFiTmRNZXVaOTYzcEVzNnI0THpvRkx2NzNhK2hGWEI0L1BhdUorM1Z6Wmkyajc5d3FkNkVRc094VHJXdTdRc2dYRGphQ0hDbFVmOUxvUkhKQ1k0L0lBajlqbHYrU3krYTNGcG9Hc1p2Z2VsV0pRQjQybU5nWkdCZ0FHS2pSVUVyNC9sdHZqSXdzekNBd09NSVhWTUUvZjgvY3pyVEhpQ1hnNEVKSkFvQUVFRUo0Z0I0Mm1OZ1pHQmdadmpQQUNRREdDVC91ekduTXdCRlVBQUxBRXlFQXlRQUFBSjJBQUFDVmdBWkExQUFIQUpTQUNRQUFBQUFBR0FBOGdGZ0FBQjQybU5nWkdCZ1lHRklZQURSREZBU0NRQUFDak1BYUFCNDJrMk9zV3JETUJDR1AxUEhVS2ZRcVIwNkZFMFpoWTM3QUlFTW1iSm1MQ1NSQ0E1SUNySmp5Qkw2QUgzb1hoUU5QY0h4M1hlL2hJQ2FHd1gzS25oTi9WNGxsVXdQbmpIbkxYTWxSMld1K1dEQkUwWDVMT2FUWmVhU0Y3NHp6M2pubExrUy81TzU1b3ZmVlhEbnkyaWoyZ1Jqb3o4NDE3Zk4xc2FoRDE2MXVubUl0ZlUyN2tacjFQNnF6TlFQMDlHcFRqZTZZMFhBY2ViQ2lDWEt6elppVEdMUFFYYU9ucGFHYlhLRFRFRTJTcHdXK3oreGxvUlBxVjE2elVocXoxVzZZWkxNSVAwb2FVV1g3bXE2UDkvME1Mc0FBSGphWTJCbXdBc0FBSDBBQkE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk3O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFYMEFBb0FBQUFBQjBBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoVXAxQ1dOdFlYQUFBQUU0QUFBQVBnQUFBRXdCQndETVoyeDVaZ0FBQVhnQUFBTVFBQUFEN0JMVko1dG9aV0ZrQUFBRWlBQUFBQzBBQUFBMktZS2RaMmhvWldFQUFBUzRBQUFBSGdBQUFDUUc2Z0lMYUcxMGVBQUFCTmdBQUFBWUFBQUFHQkIyQVROc2IyTmhBQUFFOEFBQUFBNEFBQUFPQXpJQ0dHMWhlSEFBQUFVQUFBQUFGd0FBQUNBQUNBQm1ibUZ0WlFBQUJSZ0FBQUROQUFBQk9QTmZLcU53YjNOMEFBQUY2QUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0yc2M0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBUVVowaGpadmdQNURORHBKSFUvQWNLQXdEc0VRMURlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQ3lBTkJjREIxQ09pVUdmSVlRaGtpSHQvMytnR0lnZEFXTC92L1IvM2YvVi8rZURkVUFCQUVwc0Rjb0FBSGphVFpMUGo5dEVGTWY5ZldQUHhEL2ljZXpFM2szU3BMV0R2U1UwV3phN3RuYTdKTHRMQlNvdGxTcFFxMEpGa2FoVXRZSWpjT1BRQXkwU2dnc0hUa2djdUhPcVFPMnhGOFFGQlA4QUY4NElpUnRrZVk2NmJlWERlTjZ6Ui9QNXZLOEI0K0toUWJZd0RNOHdiRWlWRm5tRkdaS1lzTGhqcnJSTktIeGlqVTJpMy81OU5SRmRFWWdmNjhVd0RCZ3ZIQjZLay9TRGNjQWJvU0hqSVRiaWpvOTFVaE5zNVdVU2wxVlU1bVBrU3ZMamc2dnordlFUWmFMYXNxaktPY3E4eU5mQlBmeDlUd0ROMWQwa1FxQXVYL3ZlVmVoMFgxOFRuOE9OeCsrZDlyMjFrZG5vU0d2ZjlFTDZhSUQrQ0NRQnRJNUhLeCtzQmk2OS85K2Z2bU0zaUV5bnBTQmd3aEg4Z2s2ZlRpc2gyc3BOYi9rT0Y4UDdXc0VNSDYxQXUwV3IxMy9lcmMrQlZ6Tk5tZWtCUFRSdThDWWFZSG9FeEplY1lUckRsbUFTcmlkeGNnUzZXVTVMUmlFeFFaYm1Xek1NcVdJVlBnb2Z2TTZwckNhMC9EMnBOdUtrTFRQSnNoUnRmMmQxeDE2SXdLcGV1dXVSZ0s5Ni9UdS9aRUJzMXpmUzFwbmQ2N2JVN2w2NWVmWHk5cGZ5bWE4RndaZTlQcXliNTI0R050Q05pTkNVSDc4ckhHaG52bUZQMzhMZHhRTmZQM0VoVmFCRXk0THg4ekRXRGdrbk9ISVVLQ3FLdDkvY1JrOEg1bEZaS3QyQWFQbnlwM00zSXM4TkhLNzREZE9VdHE5RXB2SnI3T29NdTdyRnJsNVpaa2NMT1VUSlVxQ1JMb2MveHhNbGpENEF6enlYS3VjQnM2K3FaS1Y1d2JiQUxabHlRdWorNGk5RlVkZ1czU0pEeS9yMDdGeFQyTnc1cGliZnlOV3gyMkxtRHovekxBVGhLVUgyUFJoMnd3UHNqcmUwZGZ1Tkp2eG9jNWpTL3VJUFpSMWM0RDJaR1k4YVlzZzVpUEtIZUNkZ3hKb0RMakczYWlKYy9BN1hidnBOaTZVS20vRk5rM3JLYTY4c00zNytjSjF1MDYvRzN1T01jMUpWV2w5N0dpZXhWRHpmR2VZaWt3ek02YWhtZFdJNEdSbkh1cXlZMENlTmFSbkxBdC91QkdiUXRmZGZYTnNCUnAxY1FBKzExcU1UNHRoRVh4aFFwQy9wamg4ZlpDZDNnU3ptZmpEUU9nd0hUcU43dlc3anE4V2oxMXA3bSsyWFJaNE5qdE5JRnE1Tk1NOTN2djduaWtnVnJsenRGZmx6bzZjdHJPYW52akRUQmhqbGY0Y3pmRTk0Mm1OZ1pHQmdBR0lXM3lYbThmdzJYeG1ZV1JoQTRIR0VyaW1DL3MvQXZKc1p4T1ZnWUFKUkFPRTZCOWtBQUFCNDJtTmdaR0JnWnZqUEFDVDNNZWo4ZDJQZXpRQVVRUUZzQUY4MUEvc0FBQUxHQUFBQ1Z3Qk9BcklBTEFPK0FETUNyd0E3QWpvQVN3QUFBQUFBSGdDSUFSNEJrQUgyQUFCNDJtTmdaR0JnWUdOSVpRRFJERkFTQ1FBQUN1WUFid0I0MmsyTVBXL0NNQlJGVDlRRXFXRmdRUjBZV2crZHJhQWdzWFZoWUdKbDZnTFlSUmxzSXlkRVFxbzY5bmYzWVR6MERWZm5mdGhBelE4Rjl5dVlKYjFmU1NYdXdSVlQ1cGtuNHQ0eTF5eDQ1NG1pZkpia2xZL01wVFNmbVN0ZStNbzhrZnc3YzgySzMwMXdsK3RnbzlvRlk2TS9PZGV0OXpiMlhmQnFxWnZrdDliYmVCaXNVY2ViTW1QWGoyZW5XdDNvbGcwQng0VXJBNWFJWWllSlNldzVTZWZvV0xOUFNTOGNKRmNzMFRULytxMzBQbTBPNlNjam15TTNVY01vaTE3MExGdEZtMTVxMmovTG9TLzNBQUFBZU5wallHYkFDd0FBZlFBRSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWk1O3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUFSc0FBb0FBQUFBQlNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJQVXk4eUFBQUE5QUFBQUVRQUFBQmdoWE4xNzJOdFlYQUFBQUU0QUFBQUxBQUFBRFFBREFDc1oyeDVaZ0FBQVdRQUFBR3ZBQUFCK0wxcWpZSm9aV0ZrQUFBREZBQUFBQzhBQUFBMktnS2VJbWhvWldFQUFBTkVBQUFBSHdBQUFDUUhvUUxPYUcxMGVBQUFBMlFBQUFBTUFBQUFEQXNUQU05c2IyTmhBQUFEY0FBQUFBZ0FBQUFJQUlnQS9HMWhlSEFBQUFONEFBQUFGd0FBQUNBQUJRQmFibUZ0WlFBQUE1QUFBQUROQUFBQk9QTmJLcDl3YjNOMEFBQUVZQUFBQUF3QUFBQWdBQU1BQUhqYVkyQm0zc2c0Z1lHVmdZRnBGdFBaZnlJTS9TQ2E4UTNqR3daalJrNEdJR0JqZ0FOR0JpU1FVbHlXRHBTTVlJaGtadmdQNURORHBKSFUvQWNLQXdEck5BMVRlTnBqWUdCZ1ltQmdZQVppRVNESkNLWlpHQlNBTkFzUWd2aVIvLzhEeVlqLy8vK3ZCUE1aQUZTTEJyVjQyaTJRd1c3VFFCQ0c5NTkxZG12SFhpZnJ6Wm9tSmxFVFpCY0oyVkdoTmxKUlFpTlVJWVRVRTRJelBiYmN1WEJCZ2lzQ2NlczVKMTRoY09BRktoNEFpUmZnaU1RcFlWTnhtL2xuL3RGOFB3TTcyNnk5STFxeEY0d2hHZUp1Ylh0V1ZwRGpZb1owaHJ4Q1RFSUtPNEpOUlVWT2IrcG1oam54RWhPUkgrWk4ydFNwUWpHV3FkTkxDR2NjVVdOVEkrUllTTHI4MXJvNVZRYjloNHVQWFlKdVpYMjBQcng3NVFzZ01xRUVic3dYNTRwenJrNU9oNTIveTFaMm9CTHN2djBVYzNSRk5uanpaYmNMTS9CY016KytpQ2tJeW1jbDNxKy9od29pSEJDSDF6VUJLQXJrNzljdlE5OFhFUkVQUjllRE9DUytQMmovZ21uSEVGR2ZQQTg2YVVQL3VPejFlajRaNDhQdFVieGprTzB6c0l2Tmh2K2hyK3d4WXo2a2NDYUg3a0pScUNoR1h0eXJVMXZQOForK2RxVFg5RkxJQkk2L0dPZUZFK2M0MkFZd1VaQjh1cjY2N1lQZzZ6c2REUzFPbmo1NXBHRjFNOW9wVnpLcmxDYTdPUDdzYUhXVVdWcENtZENiaUJCazd6K1lsbDRJM1Q1Y0dEcGEvMXp1K1VwNDdwWUllOXUvNFVKekJlSzlGWjUzSWdjNDNGSkRiL01nZjMwRmJsUktzcjJWd1dXUUJONHR6ZGcvY2JGQkNRQjQybU5nWkdCZ0FPSjlEYzh2eC9QYmZHVmdabUVBZ2NjUnVxWUkrdjgvRm11bXZVQXVCd01UU0JRQVFlY0s0QUI0Mm1OZ1pHQmdadmpQd01EQVVzeVEvRCtjeFpvQktJSUNtQUZVNHdOM0FBTlVBQUFFY3dCakEwd0FiQUFBQUFBQWlBRDhlTnBqWUdSZ1lHQm1pR1FBMFF4UUVna0FBQWxwQUdBQWVOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnd05xRmdZbVZxUXRnRjJXd2pad1FDYW5xMk4vZGgvSFFOMXlkKzJFRE5UOFUzSzlnbHZSK0paVzRCMWRNbVdlZWlIdkxYTFBnblNlSzhsbVNWejR5bDlKOFpxNTQ0U3Z6UlBMdnpEVXJmamZCWGE2RGpXb1hqSTMrNUZ5MzN0dllkOEdycFc2UzMxcHY0Mkd3UmgxdnlveGRQNTZkYW5Xald6WUVIQmV1REZnaWlwMGtKckhuSkoyalk4MCtKYjF3a0Z5eFJOUDg2N2ZTKzdRNXBKK01iSTdjUkEyakxIclJzMndWYlhxcGFmOEF5QkV2N3dBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5rQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDd0FBQUEyS2h1ZFEyaG9aV0VBQUFJOEFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFsd0FBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNaQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUpzQUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9RQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFZBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaW1sWHFhK1A1YmI0eU1MTXdnTURqQ0YxVFpKb2xsUEVPa09KZ1lBTHhBUG5GQ0IxNDJtTmdaR0JnMXZwanljREFFc3JReDlEUGxNd0FGRUVCVEFCU2dBTkNBQVJWQUFBQzhnQ09BQUFBQUFCVUFBQjQybU5nWkdCZ1lHSXdaUURSREZBU0NRQUFCY29BT3dCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUNVbFlXQmlaV3BDMkNETXNSQmRvZ1VxZXJJNys3aGV1Z05wK2Y5dUFOS2ZzaDRUc1pyM00vSktVVDljY0VMYjRtbm9oYUpTejVZTWlITForTE0yU1RPSmZsS1hQRE9KZkZVL08vRUpaODh0bDE3dS9mV3EzMW5ySGZuTm96cmcvV2g2WnhhNlNycW5YWFdIM3RyMUdsVVptakNjRzFWclN0ZHM2V2o1Y2FkSG90SHNSZkhSSGFjSlF1TXJEbEVKOUJJNnFTMVFsUDl5M2VTdTlnNXhrOUdPaWRKbE5BZ1YwSDJWZHFLT2w1cTZsL3Y2VEJIQUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtc3kxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFY0FBQUJnaUU5eUJtTnRZWEFBQUFFOEFBQUFLUUFBQURRQURBQ1daMng1WmdBQUFXZ0FBQUN5QUFBQXVMVzFUNVZvWldGa0FBQUNIQUFBQUM4QUFBQTJLT09lSVdob1pXRUFBQUpNQUFBQUhnQUFBQ1FGU1A5QWFHMTBlQUFBQW13QUFBQUlBQUFBQ0FVM0FBbHNiMk5oQUFBQ2RBQUFBQVlBQUFBR0FGd0FBRzFoZUhBQUFBSjhBQUFBRndBQUFDQUFCQUE1Ym1GdFpRQUFBcFFBQUFEVEFBQUJQcTgzZGVGd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtbXMwNGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBabkJtbHZxanljREFMTVY4SFZYTi8vOE1EQUQyZnc1RUFIamFZMkJnWUdKZ1lHQUdZaEVneVFpbVdSZ1VnRFFMRUlMNHp2Ly9ROGovKzhCOEJnQlN3UWFmQUFBQWVOcGpZR1RnL1ArY1NabnBNb001QTRNcUd6c0lLcW1wcTlrem1wbWJnUWt4Y1RaK1JqNUdkaloxY3p0R2N6VjJJQk9JNUJpQlBLQThXQW5qSDBZVEJYMnYrS2dNUm1aeEZzbFFsVUQyNEh3NVl5Wm1jUlV1SFFGdVJuWnVWU1ltTzc5NFJRMGpScVkwZDJOWENYNTJmbjVlZnM2RndpWUtzb2FzRllWYThYekp1WG9tekVZc2pKS2E2Z2F1ZkJLTVRKejh3b0d5NWt5TUxrYjJDenlLc3hnWmRWVkZPTGc0MkJnWkdSZ0E1VXdiUEFBQWVOcGpZR1JnWUFEaTVLcFhndkg4Tmw4Wm1Ga1lRT0J4aEs0cGd2Ny9uRm1HNlRLUXk4SEFCQklGQUE1bENaOEFlTnBqWUdSZ1lKYjZvd2trWlJnNC8vOWdVbVlBaXFBQUpnQlc2UU9MQUFBREhBQUFBaHNBQ1FBQUFBQUFYQUFBZU5wallHUmdZR0Jpc0dBQTBReFFFZ2tBQUFZVkFENEFlTnBOanJGcXd6QVFoajlUeDFBbmtLa2RPaFJOR1lXTjh3Q0ZESm15Wml3a2tRZ09XQTZTWS9CUzhnQjk2RjRVRFQzQjhlbS83NFNBa2g4eUhwV3hqUDFST1lYY25qeGp6bHZpUW81S1hQTEJpaGV5L0ZXU1Q3NFM1eXo0VGp6am5VdmlRdko3NHBJMXY1dSt1OTRHNjlXdU45YTdVeGVtdXRwYkg5cmVxVnBYejJCcm5mV0h3UnAxbkpRWjJ6Q2VPOVhvU2pkczZPbTRjbVBBNHVWbk8wbE1aTWRKWm9HSm1vcDl6QUt0ekoxNE5WclMvOFpXREJldFEzek5pSFdVbVJJYVpTOUlQNHV2YU9LdXB2a0RDVkV4RXdCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3kxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYxIHtmb250LWZhbWlseTpjbXN5NTtmb250LXNpemU6NC45ODEzMnB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pMTA7Zm9udC1zaXplOjkuOTYyNjRweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21taTc7Zm9udC1zaXplOjYuOTczODQ4cHh9CnRleHQuZjQge2ZvbnQtZmFtaWx5OmNtbWk1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjUge2ZvbnQtZmFtaWx5OmNtcjEwO2ZvbnQtc2l6ZTo5Ljk2MjY0cHh9CnRleHQuZjYge2ZvbnQtZmFtaWx5OmNtcjc7Zm9udC1zaXplOjYuOTczODQ4cHh9Cl1dPgo8L3N0eWxlPgo8ZyBpZD0ncGFnZTEnPgo8ZyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01Ni45MTQxNTEsLTU5LjE3NDQ3MylzY2FsZSgwLjk5NjI2NCwtMC45OTYyNjQpJz4KPGcgZmlsbD0nIzAwMCcgc3Ryb2tlPScjMDAwJz4KPGcgc3Ryb2tlLXdpZHRoPScwLjQnPgo8ZyBzdHJva2Utd2lkdGg9JzAuNSc+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04LjM1ODAyLC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ni45MTQxNTEsLTU5LjE3NDQ3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YwJyB4PSctNTYuOTE0MTUxJyB5PSctNTkuMTc0NDczJz5DPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01MS42Njg1MjknIHk9Jy01Ny4zNzU2NDYnPi88dHNwYW4geD0nLTQ3LjE1NzY0NCc+WTwvdHNwYW4+PC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC04LjQ4MjMyLC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTYuOTE0MTUxLC01OS4xNzQ0NzMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU2LjkxNDE1MScgeT0nLTU5LjE3NDQ3Myc+QzwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNTEuNjY4NTI5JyB5PSctNTcuMzc1NjQ2Jz4vWDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC05Ljk2NTNWLTQ4LjE2MjQ2JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsMC4wLC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTEyLjEyODU0LC0zMS4wNjM4NyknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNTkuMTc0NDczKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01Ni45MTQxNTEnIHk9Jy01OS4xNzQ0NzMnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTUyLjI0NzU2NicgeT0nLTYyLjE4MDk5MSc+4oiXPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ1LjM4NjM4LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ni45MTQxNTEsLTU5LjE3NDQ3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNTYuOTE0MTUxJyB5PSctNTkuMTc0NDczJz5UPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjUnIHg9Jy00OS43MDg1MDgnIHk9Jy01OS4xNzQ0NzMnPig8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTQ1LjgzNDEzNCcgeT0nLTU5LjE3NDQ3Myc+WTwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctMzcuODM2MzI4JyB5PSctNTkuMTc0NDczJz4pPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQ0Ljg2NTU3LC01OS40MDU1KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNTYuOTE0MTUxLC01OS4xNzQ0NzMpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTU2LjkxNDE1MScgeT0nLTU5LjE3NDQ3Myc+VDwvdGV4dD4KPHRleHQgY2xhc3M9J2Y1JyB4PSctNDkuNzA4NTA4JyB5PSctNTkuMTc0NDczJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00NS44MzQxMzQnIHk9Jy01OS4xNzQ0NzMnPlg8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNScgeD0nLTM2Ljc5ODU3OCcgeT0nLTU5LjE3NDQ3Myc+KTwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMTIuOTEzNTYgMEg0MC4zMzA4NCcgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0MC41ODA4NCwwLjApJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE4LjYwOTk5LDUuMDYxODEpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC01Ni45MTQxNTEsLTU5LjE3NDQ3MylzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2Y2JyB4PSctNTYuOTE0MTUxJyB5PSctNTkuMTc0NDczJz5bPHRzcGFuIHg9Jy01My42NjI0NDEnPuKAkzwvdHNwYW4+PHRzcGFuIHg9Jy00OC42OTQ5MzknPl08L3RzcGFuPjwvdGV4dD4KPHRleHQgY2xhc3M9J2Y0JyB4PSctNDYuNDM5NDk5JyB5PSctNTYuOTMyODc5Jz5ZPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J001Ni45MDU1LTguOTA5NzNWLTQ3LjQ5NTc3JyBmaWxsPSdub25lJy8+CjxnIHRyYW5zZm9ybT0nbWF0cml4KDAuMCwtMS4wLDEuMCwwLjAsNTYuOTA1NSwtNDcuNzQ1NzcpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDYwLjE2OTM5LC0zMC4yMDI3NCknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNTkuMTc0NDczKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjMnIHg9Jy01Ni45MTQxNTEnIHk9Jy01OS4xNzQ0NzMnPlQ8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmNicgeD0nLTUxLjEzNjE1NCcgeT0nLTU5LjE3NDQ3Myc+KDwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDguMDIyODExJyB5PSctNTkuMTc0NDczJz5mPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy00My4zNTYyMjYnIHk9Jy01OS4xNzQ0NzMnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTEzLjAzNzg2LTU2LjkwNTVIMzkuODEwMDMnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDAuMDYwMDMsLTU2LjkwNTUpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDE4LjE5Mjk4LC02NC45NjczMiknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTU2LjkxNDE1MSwtNTkuMTc0NDczKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjYnIHg9Jy01Ni45MTQxNTEnIHk9Jy01OS4xNzQ0NzMnPls8dHNwYW4geD0nLTUzLjY2MjQ0MSc+4oCTPC90c3Bhbj48dHNwYW4geD0nLTQ4LjY5NDkzOSc+XTwvdHNwYW4+PC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjQnIHg9Jy00Ni40Mzk0OTknIHk9Jy01Ni45MzI4NzknPlg8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
  \DiagramSquare {
    nw = {{{\mathcal {C}}_{/{Y}}}},
    ne = {T(Y)},
    sw = {{{\mathcal {C}}_{/{X}}}},
    se = {T(X)},
    north = {{\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{Y}},
    south = {{\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{X}},
    west = {f^{*}},
    east = {T(f)},
  }
]]></fr:resource-source></fr:resource></fr:figure>
    
  
    
      
      <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1327</fr:anchor><fr:addr
type="machine">#303</fr:addr><fr:route>unstable-303.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>6</fr:month><fr:day>24</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>For each object <fr:tex
display="inline"><![CDATA[f\colon X\to Y]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{Y}}}]]></fr:tex>, take <fr:tex
display="inline"><![CDATA[{\mathopen {}[f]\mathclose {}}_{Y} := \Sigma _{f}(1)]]></fr:tex>.
    To extend this assignment to a functor, it suffices to show that whenever there is a morphism <fr:tex
display="inline"><![CDATA[\alpha \colon f\to g]]></fr:tex> in <fr:tex
display="inline"><![CDATA[{{\mathcal {C}}_{/{Y}}}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[{\mathopen {}[f]\mathclose {}}_{Y} \leq  {\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[T(Y)]]></fr:tex>.</fr:p>
  <fr:p>To this end, note that <fr:tex
display="inline"><![CDATA[\alpha ^{*}(1) \leq  \alpha ^{*}g^{*}{\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex> in <fr:tex
display="inline"><![CDATA[T(X)]]></fr:tex> because the unit of the adjunction <fr:tex
display="inline"><![CDATA[\Sigma _{g} \dashv  g^{*}]]></fr:tex> gives <fr:tex
display="inline"><![CDATA[1 \leq  g^{*}{\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex>.
    Since <fr:tex
display="inline"><![CDATA[\alpha ^{*}]]></fr:tex>, as a right adjoint, preserves terminal objects and <fr:tex
display="inline"><![CDATA[f^{*} \cong  \alpha ^{*}g^{*}]]></fr:tex> by the (pseudo)functoriality of <fr:tex
display="inline"><![CDATA[T]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[1 \leq  f^{*}{\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex>.
    Then, the transpose along the adjunction <fr:tex
display="inline"><![CDATA[\Sigma _{f} \dashv  f^{*}]]></fr:tex> yields <fr:tex
display="inline"><![CDATA[{\mathopen {}[f]\mathclose {}}_{Y} \leq  {\mathopen {}[g]\mathclose {}}_{Y}]]></fr:tex>.</fr:p>
  <fr:p>Now for each <fr:tex
display="inline"><![CDATA[g\colon Z\to Y]]></fr:tex>, form the following pullback:</fr:p>
  
    
      
      <fr:figure><fr:resource
hash="4a9867a690f06965f87762f6492d4727"><fr:resource-content><fr:img
src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnPz4KPCEtLSBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBkdmlzdmdtIDMuMC4zIC0tPgo8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgd2lkdGg9JzExNy40MDc2NTZwdCcgaGVpZ2h0PScxMTguMjM5NDA3cHQnIHZpZXdCb3g9Jy03MiAtNzIgNzguMjcxNzcxIDc4LjgyNjI3MSc+CjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+CjwhW0NEQVRBW0Bmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21yNztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBTjRBQW9BQUFBQUErUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFTUFBQUJnaFVOMEwyTnRZWEFBQUFFNEFBQUFMQUFBQURRQURBQjhaMng1WmdBQUFXUUFBQUM2QUFBQXdFcDdibFpvWldGa0FBQUNJQUFBQUMwQUFBQTJLSnFkZkdob1pXRUFBQUpRQUFBQUh3QUFBQ1FFeWdJZmFHMTBlQUFBQW5BQUFBQUtBQUFBQ2dUa0FIUnNiMk5oQUFBQ2ZBQUFBQWdBQUFBSUFEQUFZRzFoZUhBQUFBS0VBQUFBRndBQUFDQUFCUUFjYm1GdFpRQUFBcHdBQUFES0FBQUJNdTBLa2Vwd2IzTjBBQUFEYUFBQUFCQUFBQUFnQUFNQUFYamFZMkJtVW1TY3dNREt3TUEwaStuc1B4R0dmaEROK0lieERZTXhJeWNERUxBeHdBRWpBeEpJS1M1TEIwcHFNR2d5TS93SDhwa2gwa2hxL2dPRkFhdEdER0lBZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0JTQU5Bc1FndmlhLy84RFNZMy8vLy9mQlBNWkFGQ2JCb1Y0Mm1OZ1pDajV6OGpZd016QUlNWEF3Q2d1SnNMT3hzL0l4czRtQm1UeU02cXBBNkc1bWoyakdXTU9MenU3b3hXN0pUTmpXQm9YTzIrcktSKzNLaE9UTHA4Wk13TWprd0NiU1k1QTRiSGVuN0djQWt5TVNiV0tDclhKUmMycVRVQWpHVHlBNW9kQXpCY0dtaW91eGk3Q3hzN0hxR1p1WXM5b3gyaXV4Nml1Wm1wbUh0TmlCakpRVThrc1Q1cVJtVDhraHBHNTBJMlRrWTJaQVdKYTFFS0h4R1FtTG1ZV1FaLzNDNDg4dGVKaTQyUmlZR0FBQU43SUlIUUFBSGphWTJCa1lHQUE0bU52c29MaitXMitNakN6TUlEQTR3aGRld1Q5bjVIcE1qT0l5OEhBQktJQUhka0pTQUFBQUhqYVkyQmtZR0JtK00vQXdNQjBtY0dEd1pPeGdRRW9nZ0tZQUVsMEF1NEFBdE1BQUFISkFIUUFTQUFBQUFBQUFBQXdBR0I0Mm1OZ1pHQmdZR2FRWmdEUkRGQVNDUUFBQTFzQUlnQjQyajJNTWF2Q01CU0Z2MklWN1JzY0JJYzNTUEFIaEVvZnVMZzVPTGs2dk0yYUlCMmFTbHFMTHVKUDl6WUViK0R3M1hQT0RaRHhJbUdZaEhuUVlWSjU4OGhqZmxoRW5vaS9pcHp4eTVvUlNUb1RaOFV1Y3NxVS84aGpscFNSSitJL0ltZjg4ZDQzOWUzZVdhK09qYkhlWFdxL1BWbmZWbzFURzUwUDY4RTY2OCtkTmFwOEt0TlhiWCt0VmFGelhiQ25vZWJHblE2TFIzRVV4d1IyWENUemJEbUZ2YVdTekVsbmd5Yi9wZ2RKWFdpY3d5OUdHaVZQVVVNdk42M29WYnFLSXR4cGlnOVlyQzVMQUFCNDJtTmdaa0FHakF4b0FBQUFqZ0FGKSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21taTc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQVVJQUFvQUFBQUFCZXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRU1BQUFCZ2hZRjB1bU50WVhBQUFBRTRBQUFBTWdBQUFEd0FnZ0RBWjJ4NVpnQUFBV3dBQUFJN0FBQUN0SWtwajR0b1pXRmtBQUFEcUFBQUFDOEFBQUEyS0kyZGVXaG9aV0VBQUFQWUFBQUFJQUFBQUNRRm1RR2JhRzEwZUFBQUEvZ0FBQUFRQUFBQUVBbW9BTVJzYjJOaEFBQUVDQUFBQUFvQUFBQUtBY0FBMUcxaGVIQUFBQVFVQUFBQUdBQUFBQ0FBQndCWWJtRnRaUUFBQkN3QUFBRE5BQUFCT1BOZktxTndiM04wQUFBRS9BQUFBQXdBQUFBZ0FBTUFBSGphWTJCbXltS2N3TURLd01BMGkrbnNQeEdHZmhETitJYnhEWU14SXljREVMQXh3QUVqQXhKSUtTNUxCMHFtTVdRek0vd0g4cGtoMGtocS9nT0ZBZFRIRFNzQWVOcGpZR0JnWW1CZ1lBWmlFU0RKQ0taWkdEU0FOQnVRWmdUS3BqTmsvLzhQNUtlQjZQK3ovODhBcXdJQ0FKbHJDVHdBQUhqYVJaTExidE5BRkliOXovZ1NPNDNIanUxeG02UnBIRHZqb0taSmFScWJSbFhhTk8yaU4wb1hVSW9RckFDSkZSSWJ4RE1naEJBTHR1eDRCZmFWV1BNd0lMRkpHVk1KNXV6T09Zdi9POThvVUk2dkIrUWwrYUhzS2dvb2cyN1lNTm9pbldESVE2NGJmQVVUN05CWUYxazRuQ0NYL1EwZTJvaEZLckpjREdBVGhtSEc5UlJmeG83cTFNenA3ZTRZU0FKQndWWVlZMGxFbC92c3BFazhkczRDbSsvRnQ3YUJtTXU1MDJTc1dtMWFwZHJUWW94UDg2c2pkM2ZUbjFFUk4xc2swZE95U2FBZUI1OS9YdEMyZ1l2TGVpbzZ5ZjhSbHNUYWU3VmRnaUlmVVhyWGE2U0RLNld2ekFvYVNhTC9KWkdKZmQwSStaQm5FbUJIUXZhUlpubFJUWVNTU2k3UUhXU3BoTktONGdRODNDaFdTZlRLZlAxbThFU1ZlVjBPdTlwd0kzODdibkFqekErbmw0Uk9tWHQ0MlIxVmFLMWFDZkJ4UU9FSG03VlpLM0JjaUxTNTExZ3c4SFkrSFR5aUpPZ3RSNTVYYmxvYVFibXh0TjU2UEZSeGNlL1pYWS90VXlUYzRYRGMrZTl2ck55SlZYUkhZcnA3bHFQVFloWEpCdVgwK2hjNUlOK1ZCd1Zaa1cyREIvODB5TVNGT21sTWxzK296OE1iVjBYREtKQ2tVcEZucWVSbXNORVdvOXliUU1RM3B2T01HNWcrWDNtWW50OFhNb3BVRTdac2YvVXNGZUZpYTVPeGRaVlFEY3dYcXhZMUxGTUhITXR2YktVekFvMENSM2RpcG9iQzFUNm9oQ1dtQTlqR2ZxOEQ4blgrd2o3cGpIcjFLQ0tKblpSc1lDd2lYMGJRVEw1bG1aVzZKeitZZXBvd2l4Qkw2OWNiZlhXWTJWVmI3NmJhdTNGMTBhdHdzbDlobG1xeGtxSFNCWG1LUHpEZ1dJd0FlTnBqWUdSZ1lBQmlYYi9IbCtQNWJiNHlNTE13Z01EakNGMTdCUDFmbCtrWTAwVWdsNE9CQ1NRS0FCdTdDZmtBZU5wallHUmdZR2I0ejhEQXdIU01RZWYvQmFZc0JxQUlDbUFCQUdVY0JEZ0N4Z0FBQWpvQVN3STZBQ3dDYmdCTkFBQUFBQUJtQU5RQldnQUFlTnBqWUdSZ1lHQmhDR2RnWWdBQlJnWTBBQUFKYVFCZ2VOcE5qRDF2d2pBVVJVL1VCS2xoWUVFZEdGb1BuYTJnSUxGMVlXQmlaZW9DMkVVWmJDTW5SRUtxT3ZaMzkyRTg5QTFYNTM3WVFNMFBCZmNybUNXOVgwa2w3c0VWVSthWkorTGVNdGNzZU9lSm9ueVc1SldQektVMG41a3JYdmpLUEpIOE8zUE5pdDlOY0pmcllLUGFCV09qUHpuWHJmYzI5bDN3YXFtYjVMZlcyM2dZckZISG16SmoxNDlucDFyZDZKWU5BY2VGS3dPV2lHSW5pVW5zT1VubjZGaXpUMGt2SENSWExORTAvL3F0OUQ1dER1a25JNXNqTjFIREtJdGU5Q3hiUlp0ZWF0by95NkV2OXdBQUFIamFZMkJtd0FzQUFIMEFCQT09KSBmb3JtYXQoJ3dvZmYnKTt9CkBmb250LWZhY2V7Zm9udC1mYW1pbHk6Y21zeTU7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQU5rQUFvQUFBQUFBOHdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQTlBQUFBRW9BQUFCZ3FtS1ZBbU50WVhBQUFBRkFBQUFBS2dBQUFEUUFEQ0pxWjJ4NVpnQUFBV3dBQUFDa0FBQUFxQjZ5dGVSb1pXRmtBQUFDRUFBQUFDd0FBQUEyS2h1ZFYyaG9aV0VBQUFJOEFBQUFId0FBQUNRR0hRRWdhRzEwZUFBQUFsd0FBQUFJQUFBQUNBZEhBSTVzYjJOaEFBQUNaQUFBQUFZQUFBQUdBRlFBQUcxaGVIQUFBQUpzQUFBQUZ3QUFBQ0FBQkFBMmJtRnRaUUFBQW9RQUFBRE5BQUFCT0JON0tyZHdiM04wQUFBRFZBQUFBQkFBQUFBZ0FBTUFBWGphWTJCbVhzdzRnWUdWZ1lGcEZ0UFpmeUlNL1NDYThRM2pHd1pqUms0R0lHQmpRQUVPTUVaS2NWazZBNXVTdUpJNHM5WWZTd1lHWmkzbTQwQmhSb1RTLy84WkdBQUdyUTZZQUFCNDJtTmdZR0JpWUdCZ0JtSVJJTWtJcGxrWUZJQTBDeEFDK1VyaS8vOUR5THV2d1BJTUFGSVJCcFVBQUhqYUxjbEJDb0pBR0liaCtTYjRCMHN0ZFJ5VktHbWljVmNvcHREQ0xsRzBTeUx3TUFVZG9hQmRkK293dVdqMXd2TXlzQWRiOGl1K3JHUU1kVlVvU1dPb1NFVXV6QVlwU0t4UjdpRW8wNmF2eVV6V29FaVJtVzFaMVNvU3VMM3NSSHIwT1IwRERwbFliNGU0OWdLeTd5dHl3cmgzeVJIR3p0T213Tk44aEdsclNlM3lacllRc1M5QmwyNDNIOENQOHU0UVF1ckpmMWh0bHc4ZEh6dzlzeDlWT3haYmVOcGpZR1JnWUFEaW1sWHFyZkg4Tmw4Wm1Ga1lRT0J4aEs0OU1zMFN5bmdIU0hFd01JRjRBUFRaQ0FsNDJtTmdaR0JnMXZwanljREFFc3JReDlEUGxNd0FGRUVCVEFCU2dBTkNBQVJWQUFBQzhnQ09BQUFBQUFCVUFBQjQybU5nWkdCZ1lHSXdaUURSREZBU0NRQUFCY29BT3dCNDJrMk1QVy9DTUJDR240Z0VpWFRvVW5Yb0FCNllyYUNVbFlXQmlaV3BDMkNETXNSQmRvZ1VxZXJJNys3aGV1Z05wK2Y5dUFOS2ZzaDRUc1pyM00vSktVVDljY0VMYjRtbm9oYUpTejVZTWlITForTE0yU1RPSmZsS1hQRE9KZkZVL08vRUpaODh0bDE3dS9mV3EzMW5ySGZuTm96cmcvV2g2WnhhNlNycW5YWFdIM3RyMUdsVVptakNjRzFWclN0ZHM2V2o1Y2FkSG90SHNSZkhSSGFjSlF1TXJEbEVKOUJJNnFTMVFsUDl5M2VTdTlnNXhrOUdPaWRKbE5BZ1YwSDJWZHFLT2w1cTZsL3Y2VEJIQUFBQWVOcGpZR1pBQm93TWFBQUFBSTRBQlE9PSkgZm9ybWF0KCd3b2ZmJyk7fQpAZm9udC1mYWNle2ZvbnQtZmFtaWx5OmNtbWkxMDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVk1BQW9BQUFBQUJtd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUFV5OHlBQUFBOUFBQUFFUUFBQUJnaFZ4MUFtTnRZWEFBQUFFNEFBQUFOUUFBQUR3QWd3Q0haMng1WmdBQUFYQUFBQUp5QUFBREtLb3hZRHRvWldGa0FBQUQ1QUFBQUM4QUFBQTJLUzZlVm1ob1pXRUFBQVFVQUFBQUhnQUFBQ1FHaGdHY2FHMTBlQUFBQkRRQUFBQVVBQUFBRkEzU0FKNXNiMk5oQUFBRVNBQUFBQXdBQUFBTUFhZ0NlbTFoZUhBQUFBUlVBQUFBR0FBQUFDQUFDQUJoYm1GdFpRQUFCR3dBQUFEU0FBQUJQcGtSZGNWd2IzTjBBQUFGUUFBQUFBd0FBQUFnQUFNQUFIamFZMkJtT3N3NGdZR1ZnWUZwRnRQWmZ5SU0vU0NhOFEzakd3WmpSazRHSUdCamdBTkdCaVNRVWx5V0RwUjBaSWhpWnZnUDVETkRwSkhVL0FjS0F3RHV0QTFPZU5wallHQmdZbUJnWUFaaUVTREpDS1paR0RTQU5CdVFaZ1RLT2pKRS9mOFA1RHN5UlB6Ly8vL0EvMVZnVlVBQUFKTFZDUVFBQUFCNDJsV1N6V3NUUVJqRzkzMW5aMlozTTdPYk5QdEJUYkpwVE0xU3NJa203YTRXbWh4VUJFRkZLU0lvS0VvL2hDSlN2L0Npc1hyekwvQXM2bEh4b0NLS0Z3LytDUjcwMEpPQ0lDaDRiT0xzcG43TmFkNW5abDZlMy9PT2h0cmtjSWdiK0VscmFXMU5TeUJPMm41UWRQMU83TE1XOEtnUnpjU0JIeWN0cUhIbStrRWMyS0QwVk81MEllbVFGN0RJWE1tZzYwOTdJT2lWdmtGQjVvb3p4T1NENFJGWkxrb0NraTZmRkNETTdkMzdYMnZYOEVRZVRHZXo3enVrd29FUVFNUGhBQ0pZT25EWG5jd0RPalpMWmN0aFVIOFB4elcxUUNzUGgyUVpYMnRuVkpIRVNST2pMbFFoOGF2Z3Nyb05uRG1nOWlGMEF0L0xMRVpiSG1kYjRJQzZrQjF0dVc5QmR0UkQwb1E2RzNVS1FrZ2JlZkQ5VVo1Z3RRaks5dHBaRTFGWXpaNDNucXdYSm85YWxkMkNvMkJydDAwS3dnaER1bko2SmFjc1Z3MnVLd1I2ZWZRZ090U1FIMjdROGs0UFUzRjBlNklNRDUvWmdTdkFzak51bmRtTWhLNC9mNis1OENwMEFLME1ITUdVWEIvanpzL0ZpN2xBdWpsRTQvY0RoK0ZFSkw1QW1DOFFleVNpeDNXUFpobXBXUktoTXRxdkNtSXJiT2F4S3NSLzQxQ1Q3R0gwTDdRZnVLekJlRWxsMm9Tb01adXA3VkdrZUg3QUtKbW1HRFlxSU5pZEZNTzI1NnE4SnZXYmRGc0tKMGR3MHR0RnJuOXpjbEFxTUpCc2FVRUtvelB2NDhIQlJ5YnM1eTVYY1A4TjI1MWEzMXVBWThYOEh3cUZpR1poOEJZS3JsT3gwanJOWXB6UnFmR01iVzQ0d00vNFJ0dWhhU1owMm5FUDRvN3ZjUnVpR3VzQjFMY3p6ckxCOXFBTFFTM211TEg1N3NtdFN4VkRaL0t3Ym8wTjlwVkF4L25IVjFkTDZpc0MwZmNvRVo2V0NUN1k3SzllY0NtYVA1UVh6Qld4Zis0VVQ5T20xc3RNMFg0QmVJUnZKQUFBZU5wallHUmdZQURpS1E4VzE4ZnoyM3hsWUdaaEFJSEhFYnIyQ1ByL1ArWjBwcnRBTGdjREUwZ1VBRGJKQ3QwQWVOcGpZR1JnWUdiNHp3QWtBeGhrL3JzeHB6TUFSVkFBS3dCTXlnTW9BQUFDZGdBQUF3QUFKQU5RQUJ3Q1VnQWtBcm9BT2dBQUFBQUFWQURtQVZRQmxIamFZMkJrWUdCZ1pVaGdZR0lBQVVZR05BQUFDbVVBYW5qYVRZNnhhc013RUlZL1U4ZFFwOUNwSFRvVVRSbUZqZnNBZ1F5WnNtWXNKSkVJRGtnS3NtUElFdm9BZmVoZUZBMDl3ZkhkZDcrRWdKb2JCZmNxZUUzOVhpV1ZUQStlTWVjdGN5VkhaYTc1WU1FVFJma3M1cE5sNXBJWHZqUFBlT2VVdVJML2s3bm1pOTlWY09mTGFLUGFCR09qUHpqWHQ4M1d4cUVQWHJXNmVZaTE5VGJ1Um12VS9xck0xQS9UMGFsT043cGpSY0J4NXNLSUpjclBObUpNWXM5QmRvNmVsb1p0Y29OTVFUWktuQmI3UDdHV2hFK3BYWHJOU0dyUFZicGhrc3dnL1NocFJaZnVhcm8vMy9Rd3V3QUFlTnBqWUdiQUN3QUFmUUFFKSBmb3JtYXQoJ3dvZmYnKTt9CnRleHQuZjAge2ZvbnQtZmFtaWx5OmNtc3k1O2ZvbnQtc2l6ZTo0Ljk4MTMycHh9CnRleHQuZjEge2ZvbnQtZmFtaWx5OmNtbWkxMDtmb250LXNpemU6OS45NjI2NHB4fQp0ZXh0LmYyIHtmb250LWZhbWlseTpjbW1pNztmb250LXNpemU6Ni45NzM4NDhweH0KdGV4dC5mMyB7Zm9udC1mYW1pbHk6Y21yNztmb250LXNpemU6Ni45NzM4NDhweH0KXV0+Cjwvc3R5bGU+CjxnIGlkPSdwYWdlMSc+CjxnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNTkuNTc4ODEpc2NhbGUoMC45OTYyNjQsLTAuOTk2MjY0KSc+CjxnIGZpbGw9JyMwMDAnIHN0cm9rZT0nIzAwMCc+CjxnIHN0cm9rZS13aWR0aD0nMC40Jz4KPGcgc3Ryb2tlLXdpZHRoPScwLjUnPgo8cGF0aCBkPSdNNS42OTA0Ni0xNC4yMjYzNkgxNC4yMjYzNlYtNS42OTA0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMy43NSwtMi41KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC01OS41Nzg4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YxJyB4PSctNjEuMzQyMDM1JyB5PSctNTkuNTc4ODEnPkE8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTMuNzcwODMsLTU5LjQwNTUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTU5LjU3ODgxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02MS4zNDIwMzUnIHk9Jy01OS41Nzg4MSc+WjwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8cGF0aCBkPSdNMC02LjQwOTczVi00OC4xNjI0NicgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J21hdHJpeCgwLjAsLTEuMCwxLjAsMC4wLDAuMCwtNDguNDEyNDYpJz4KPGcgc3Ryb2tlLWRhc2hhcnJheT0nbm9uZScgc3Ryb2tlLWRhc2hvZmZzZXQ9JzAuMCc+CiA8ZyBzdHJva2UtbGluZWNhcD0ncm91bmQnPgogPGcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCc+CiA8cGF0aCBkPSdNLTIuMiAyLjU4MDYzQy0xLjc5ODA3IDEuMDMyMjMtLjkwMjQgLjMwMTA3IDAgMEMtLjkwMjQtLjMwMTA3LTEuNzk4MDctMS4wMzIyMy0yLjItMi41ODA2MycgZmlsbD0nbm9uZScvPgogPC9nPgogPC9nPgogPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03LjY4NDA1LC0yOS4yODYwOSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNTkuNTc4ODEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMicgeD0nLTYxLjM0MjAzNScgeT0nLTU5LjU3ODgxJz5rPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDUyLjM3MDc5LC0yLjUpJz4KPGcgc3Ryb2tlPSdub25lJyB0cmFuc2Zvcm09J3NjYWxlKC0xLjAwMzc1LDEuMDAzNzUpdHJhbnNsYXRlKC02MS4zNDIwMzUsLTU5LjU3ODgxKXNjYWxlKC0xLC0xKSc+CjxnIGZpbGw9JyMwMDAnPgo8ZyBzdHJva2U9J25vbmUnPgo8dGV4dCBjbGFzcz0nZjEnIHg9Jy02MS4zNDIwMzUnIHk9Jy01OS41Nzg4MSc+WDwvdGV4dD4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1Mi44OTE2MiwtNTkuNDA1NSknPgo8ZyBzdHJva2U9J25vbmUnIHRyYW5zZm9ybT0nc2NhbGUoLTEuMDAzNzUsMS4wMDM3NSl0cmFuc2xhdGUoLTYxLjM0MjAzNSwtNTkuNTc4ODEpc2NhbGUoLTEsLTEpJz4KPGcgZmlsbD0nIzAwMCc+CjxnIHN0cm9rZT0nbm9uZSc+Cjx0ZXh0IGNsYXNzPSdmMScgeD0nLTYxLjM0MjAzNScgeT0nLTU5LjU3ODgxJz5ZPC90ZXh0Pgo8L2c+CjwvZz4KPC9nPgo8L2c+CjxwYXRoIGQ9J004LjMwNTU0IDBINDcuMzE1MjUnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNDcuNTY1MjUsMC4wKSc+CjxnIHN0cm9rZS1kYXNoYXJyYXk9J25vbmUnIHN0cm9rZS1kYXNob2Zmc2V0PScwLjAnPgogPGcgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJz4KIDxnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnPgogPHBhdGggZD0nTS0yLjIgMi41ODA2M0MtMS43OTgwNyAxLjAzMjIzLS45MDI0IC4zMDEwNyAwIDBDLS45MDI0LS4zMDEwNy0xLjc5ODA3LTEuMDMyMjMtMi4yLTIuNTgwNjMnIGZpbGw9J25vbmUnLz4KIDwvZz4KIDwvZz4KIDwvZz4KPC9nPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgxOC40MjY4Miw0LjU2MTgxKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC01OS41Nzg4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuMzQyMDM1JyB5PSctNTkuNTc4ODEnPmY8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMCcgeD0nLTU2LjY3NTQ1JyB5PSctNjIuNTg1MzI4Jz7iiJc8L3RleHQ+Cjx0ZXh0IGNsYXNzPSdmMycgeD0nLTUyLjUxMDQ4MScgeT0nLTU5LjU3ODgxJz4oPC90ZXh0Pgo8dGV4dCBjbGFzcz0nZjInIHg9Jy00OS4zOTcxMzgnIHk9Jy01OS41Nzg4MSc+ZzwvdGV4dD4KPHRleHQgY2xhc3M9J2YzJyB4PSctNDUuMjYwMTg4JyB5PSctNTkuNTc4ODEnPik8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTU2LjkwNTUtNi40MDk3M1YtNDguMTYyNDYnIGZpbGw9J25vbmUnLz4KPGcgdHJhbnNmb3JtPSdtYXRyaXgoMC4wLC0xLjAsMS4wLDAuMCw1Ni45MDU1LC00OC40MTI0NiknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNjAuMTY5MzksLTI5LjI4NjA5KSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC01OS41Nzg4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuMzQyMDM1JyB5PSctNTkuNTc4ODEnPmY8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPHBhdGggZD0nTTguMzI2MzctNTYuOTA1NUg0Ny44MzYwNycgZmlsbD0nbm9uZScvPgo8ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg0OC4wODYwNywtNTYuOTA1NSknPgo8ZyBzdHJva2UtZGFzaGFycmF5PSdub25lJyBzdHJva2UtZGFzaG9mZnNldD0nMC4wJz4KIDxnIHN0cm9rZS1saW5lY2FwPSdyb3VuZCc+CiA8ZyBzdHJva2UtbGluZWpvaW49J3JvdW5kJz4KIDxwYXRoIGQ9J00tMi4yIDIuNTgwNjNDLTEuNzk4MDcgMS4wMzIyMy0uOTAyNCAuMzAxMDcgMCAwQy0uOTAyNC0uMzAxMDctMS43OTgwNy0xLjAzMjIzLTIuMi0yLjU4MDYzJyBmaWxsPSdub25lJy8+CiA8L2c+CiA8L2c+CiA8L2c+CjwvZz4KPGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoMjYuMjU1LC02Mi43MzEyKSc+CjxnIHN0cm9rZT0nbm9uZScgdHJhbnNmb3JtPSdzY2FsZSgtMS4wMDM3NSwxLjAwMzc1KXRyYW5zbGF0ZSgtNjEuMzQyMDM1LC01OS41Nzg4MSlzY2FsZSgtMSwtMSknPgo8ZyBmaWxsPScjMDAwJz4KPGcgc3Ryb2tlPSdub25lJz4KPHRleHQgY2xhc3M9J2YyJyB4PSctNjEuMzQyMDM1JyB5PSctNTkuNTc4ODEnPmc8L3RleHQ+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+CjwvZz4KPC9nPgo8L2c+Cjwvc3ZnPg==" /></fr:resource-content><fr:resource-source
type="latex"
part="preamble"><![CDATA[
        
  \RequirePackage {tikz}
  \RequirePackage {amsmath}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}

  \definecolor {catccolor}{RGB}{255,244,138}
  \tikzstyle {dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
  \tikzstyle {catc}=[catccolor!60]
  \tikzstyle {catd}=[orange!40]
  \tikzstyle {cate}=[red!40]
  \tikzstyle {catf}=[blue!10]
  \tikzstyle {catg}=[green!25]


  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]

  \NewDocumentCommand \CreateRect {D<>{} m m}{
    \path 
      coordinate (#1nw)
      ++(#2,-#3) coordinate (#1se)
      coordinate (#1sw) at (#1se -| #1nw)
      coordinate (#1ne) at (#1nw -| #1se)
    ;

    \path [spath/save = #1north] (#1nw) to (#1ne);
    \path [spath/save = #1west] (#1nw) to (#1sw);
    \path [spath/save = #1east] (#1ne) to (#1se);
    \path [spath/save = #1south] (#1sw) to (#1se);
  }

        
   % appears to be necessary
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
  \usetikzlibrary{matrix,arrows}
  \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.markings}

  % basic settings
  \tikzset{
    diagram/.style = {
      on grid,
      node distance=2cm,
      commutative diagrams/every diagram,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
      },
    },
    morphism/.style = {
      auto=left,
      node font=\scriptsize,
    },
    phantom/.style = {
      commutative diagrams/phantom,
      node font=\scriptsize,
      sloped,
    },
    between/.style args = {#1 and #2}{
      at = ($(#1)!0.5!(#2)$)
    },
    desc/.style = {anchor=center,fill=white,inner sep=3pt},
    offset/.style args = {#1} {commutative diagrams/shift right={#1}},
    cross over/.style = {
      commutative diagrams/crossing over
    },
    adjoint/.style = {
      phantom,
      every to/.append style = {
        edge node = {node [sloped,allow upside down,auto=false] {$\dashv$}}
      }
    },
  }

  % pullback and pushout
  \tikzset{
    pullback/.style = {
      append after command = {
        \pgfextra{
          \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
        }
      }
    },
    pushout/.style = {
      append after command={
        \pgfextra{
          \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
        }
      }
    },
  }

  % arrow styles
  \tikzset{
    exists/.style = {
      densely dashed
    },
    embedding/.style = {
      {right hook}->
    },
    into/.style = {
      {right hook}->
    },
    cover/.style = {
      -{Triangle[open]}
    },
    twocell/.style = {
      double, -{implies}
    }
  }

  \newlength{\dontworryaboutit} % no idea what it does

  \tikzset{
    inline diagram/.style = {
      commutative diagrams/every diagram,
      commutative diagrams/cramped,
      line width = .5pt,
      every node/.append style = {
        commutative diagrams/every cell,
        anchor = base,
        inner sep = 0pt
      },
      every path/.append style = {
        outer xsep = 2pt
      }
    }
  }
  
  % macros for drawing commutative squares
  % adapted from Jon Sterling's macros (https://git.sr.ht/~jonsterling/article-template/tree/main/item/local-tikz.sty)
  \tikzset{
    square/nw/.style = {},
    square/ne/.style = {},
    square/se/.style = {},
    square/sw/.style = {},
    square/north/.style = {->},
    square/south/.style = {->},
    square/west/.style = {->},
    square/east/.style = {->},
    square/north/node/.style = {above},
    square/south/node/.style = {below},
    square/west/node/.style = {left},
    square/east/node/.style = {right},
  }

  \ExplSyntaxOn
  \keys_define:nn { jon-tikz/diagram } {
    nw .tl_set:N = \l_jon_tikz_diagram_nw,
    sw .tl_set:N = \l_jon_tikz_diagram_sw,
    ne .tl_set:N = \l_jon_tikz_diagram_ne,
    se .tl_set:N = \l_jon_tikz_diagram_se,

    width .tl_set:N = \l_jon_tikz_diagram_width,
    height .tl_set:N = \l_jon_tikz_diagram_height,

    north .tl_set:N = \l_jon_tikz_diagram_north,
    south .tl_set:N = \l_jon_tikz_diagram_south,
    west .tl_set:N = \l_jon_tikz_diagram_west,
    east .tl_set:N = \l_jon_tikz_diagram_east,

    nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
    sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
    ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
    se/style .code:n = {\tikzset{square/se/.style = {#1}}},

    north/style .code:n = {\tikzset{square/north/.style = {#1}}},
    north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
    south/style .code:n = {\tikzset{square/south/.style = {#1}}},
    south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
    west/style .code:n = {\tikzset{square/west/.style = {#1}}},
    west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
    east/style .code:n = {\tikzset{square/east/.style = {#1}}},
    east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

    draft .meta:n = {
      nw = {nw},
      sw = {sw},
      se = {se},
      ne = {ne},
      north = {north},
      south = {south},
      west = {west},
      east = {east},
    }
  }

  \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
  \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


  \cs_new:Nn \__jon_tikz_render_square:nn {
    \group_begin:
    \keys_set:nn {jon-tikz/diagram} {#2} {
      \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
      \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
      \draw[morphism,square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

      \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
      \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
      \draw[morphism,square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
      \draw[morphism,square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
      \draw[morphism,square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
    }
    \group_end:
  }

  % the optional argument allows one to specify a prefix to positions
  \NewDocumentCommand\SpliceDiagramSquare{O{}m}{
    \__jon_tikz_render_square:nn {#1} {#2}
  }

  \NewDocumentCommand\DiagramSquare{O{}O{}m}{
    \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
      \__jon_tikz_render_square:nn {#1} {#3}
    \end{tikzpicture}
  }
  \ExplSyntaxOff

      ]]></fr:resource-source><fr:resource-source
type="latex"
part="body"><![CDATA[
    \DiagramSquare {
      nw = A,
      nw/style = {pullback},
      ne = X,
      sw = Z,
      se = Y,
      north = {f^{*}(g)},
      south = g,
      west = k,
      east = f,
    }
  ]]></fr:resource-source></fr:resource></fr:figure>
    
  
  <fr:p>Then by Beck-Chevalley, we have</fr:p>
  <fr:tex
display="block"><![CDATA[     \begin {aligned}       T(f){\mathopen {}[g]\mathclose {}}_{Y} &:= T(f)\Sigma _{g}(1)\\                          &\cong  \Sigma _{f^{*}(g)}k^{*}(1) && \text {right adjoint preserves terminal object}\\                          &\cong  \Sigma _{f^{*}(g)}(1)\\                          &=: {\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{X}f^{*}(g)     \end {aligned}   ]]></fr:tex>
  <fr:p>These isomorphisms assemble into a natural isomorphism <fr:tex
display="inline"><![CDATA[f^{*}{\mathopen {}[\mathord {\hspace {1pt}\text {--}\hspace {1pt}}]\mathclose {}}_{Y} \cong  {\mathopen {}[f^{*}(\mathord {\hspace {1pt}\text {--}\hspace {1pt}})]\mathclose {}}_{X}]]></fr:tex> since any two parallel morphisms in the preorder <fr:tex
display="inline"><![CDATA[T(X)]]></fr:tex> are equal.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
    
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>